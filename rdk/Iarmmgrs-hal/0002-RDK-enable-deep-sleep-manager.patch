From bc6ddfbad368c29da6f8f3ed0ceeb4b64627a373 Mon Sep 17 00:00:00 2001
From: Xueling Li <xueling.li@amlogic.com>
Date: Mon, 10 May 2021 08:33:54 +0000
Subject: [PATCH] RDK: enable deep sleep manager [1/1]

PD#SWPL-47766

Problem:
  deep sleep manager not handled

Solution:
  add related code to handle it

Verify: check deep sleep function
Signed-off-by: Xueling Li <xueling.li@amlogic.com>
Change-Id: I598fef55ce6bbfd710c48628fe18b026d4de6953
---
 Makefile.am                |   2 +-
 configure.ac               |   7 +-
 deepsleep/Makefile.am      |   8 ++
 deepsleep/plat-deepsleep.c | 238 +++++++++++++++++++++++++++++++++++++
 power/plat-power.c         |   8 +-
 5 files changed, 257 insertions(+), 6 deletions(-)
 create mode 100644 deepsleep/Makefile.am
 create mode 100644 deepsleep/plat-deepsleep.c

diff --git a/Makefile.am b/Makefile.am
index bf1179c..755735a 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1 +1 @@
-SUBDIRS = ir power
+SUBDIRS = ir power deepsleep
diff --git a/configure.ac b/configure.ac
index a7561fd..a0bbe17 100644
--- a/configure.ac
+++ b/configure.ac
@@ -16,16 +16,21 @@ LT_INIT
 # Libs and cflags
 IARMMGRS_HAL_IR_LIBS=""
 IARMMGRS_HAL_POWER_LIBS=""
+IARMMGRS_HAL_DEEPSLEEP_LIBS=""
 AC_SUBST(IARMMGRS_HAL_IR_LIBS)
 AC_SUBST(IARMMGRS_HAL_POWER_LIBS)
+AC_SUBST(IARMMGRS_HAL_DEEPSLEEP_LIBS)
 
 # More libs and cflags should using pkg-config later.
 # now we just temperary hard coded here.
 IARMMGRS_HAL_IR_CFLAGS="-I$PKG_CONFIG_SYSROOT_DIR/usr/include/rdk/iarmmgrs-hal"
 IARMMGRS_HAL_POWER_CFLAGS="-I$PKG_CONFIG_SYSROOT_DIR/usr/include/rdk/iarmmgrs-hal \
                            -I$PKG_CONFIG_SYSROOT_DIR/usr/include/rdk/iarmbus"
+IARMMGRS_HAL_DEEPSLEEP_CFLAGS="-I$PKG_CONFIG_SYSROOT_DIR/usr/include/rdk/iarmmgrs-hal \
+                           -I$PKG_CONFIG_SYSROOT_DIR/usr/include/rdk/iarmbus"
 AC_SUBST(IARMMGRS_HAL_IR_CFLAGS)
 AC_SUBST(IARMMGRS_HAL_POWER_CFLAGS)
+AC_SUBST(IARMMGRS_HAL_DEEPSLEEP_CFLAGS)
 
 # Checks for header files.
 AC_CHECK_HEADERS([limits.h stdlib.h string.h sys/time.h unistd.h])
@@ -35,5 +40,5 @@ AC_CHECK_HEADERS([limits.h stdlib.h string.h sys/time.h unistd.h])
 # Checks for library functions.
 AC_FUNC_MALLOC
 
-AC_CONFIG_FILES([Makefile ir/Makefile power/Makefile])
+AC_CONFIG_FILES([Makefile ir/Makefile power/Makefile deepsleep/Makefile])
 AC_OUTPUT
diff --git a/deepsleep/Makefile.am b/deepsleep/Makefile.am
new file mode 100644
index 0000000..94638cc
--- /dev/null
+++ b/deepsleep/Makefile.am
@@ -0,0 +1,8 @@
+lib_LTLIBRARIES = libiarmmgrs-deepsleep-hal.la
+
+libiarmmgrs_deepsleep_hal_la_SOURCES=plat-deepsleep.c
+
+libiarmmgrs_deepsleep_hal_la_CFLAGS=$(IARMMGRS_HAL_DEEPSLEEP_CFLAGS)
+libiarmmgrs_deepsleep_hal_la_LIBADD=$(IARMMGRS_HAL_DEEPSLEEP_LIBS)
+
+
diff --git a/deepsleep/plat-deepsleep.c b/deepsleep/plat-deepsleep.c
new file mode 100644
index 0000000..3caadf6
--- /dev/null
+++ b/deepsleep/plat-deepsleep.c
@@ -0,0 +1,238 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "plat_power.h"
+#include <errno.h>
+#include <fcntl.h>
+#include "irMgrInternal.h"
+#include "libIARM.h"
+#include "deepSleepMgr.h"
+
+#define FILE_NAME_SIZE   64
+#define LOGE printf
+
+/* Platform wake up reason*/
+typedef enum _plat_wakeup_reason {
+    UDEFINED_WAKEUP = 0,
+    REMOTE_WAKEUP   = 2,
+    RTC_WAKEUP      = 3,
+    BT_WAKEUP       = 4,
+    WIFI_WAKEUP     = 5,
+    POWER_KEY_WAKEUP = 6,
+    CEC_WAKEUP       = 8,
+    LAN_WAKEUP  = 9,
+    PRESENCE_WAKEUP  = 13,
+    VOICE_WAKEUP     = 14,
+    GPIO_WAKEUP,
+    MAX_WAKEUP
+} plat_wakeup_reason;
+
+/* RDK Wakeup Reason  */
+typedef enum _DeepSleep_WakeupReason_t
+{
+  DEEPSLEEP_WAKEUPREASON_IR = 0,
+  DEEPSLEEP_WAKEUPREASON_RCU_BT,
+  DEEPSLEEP_WAKEUPREASON_RCU_RF4CE,
+  DEEPSLEEP_WAKEUPREASON_GPIO,
+  DEEPSLEEP_WAKEUPREASON_LAN,
+  DEEPSLEEP_WAKEUPREASON_WLAN,
+  DEEPSLEEP_WAKEUPREASON_TIMER,
+  DEEPSLEEP_WAKEUPREASON_FRONT_PANEL,
+  DEEPSLEEP_WAKEUPREASON_WATCHDOG,
+  DEEPSLEEP_WAKEUPREASON_SOFTWARE_RESET,
+  DEEPSLEEP_WAKEUPREASON_THERMAL_RESET,
+  DEEPSLEEP_WAKEUPREASON_WARM_RESET,
+  DEEPSLEEP_WAKEUPREASON_COLDBOOT,
+  DEEPSLEEP_WAKEUPREASON_STR_AUTH_FAILURE,
+  DEEPSLEEP_WAKEUPREASON_CEC,
+  DEEPSLEEP_WAKEUPREASON_PRESENCE,
+  DEEPSLEEP_WAKEUPREASON_VOICE,
+  DEEPSLEEP_WAKEUPREASON_UNKNOWN
+}DeepSleep_WakeupReason_t;
+
+bool g_IsNetworkStandby_modeset = false;
+
+int PLAT_DS_INIT(void)
+{
+    printf("Inside DeepSleep  Hal %s :%d\n",__FUNCTION__,__LINE__);
+
+    LOG("INIT DONE\r\n");
+    return 0;
+}
+
+static int amsysfs_get_sysfs_int(const char *path)
+{
+    int fd;
+    int val = 0;
+    char  bcmd[16];
+    fd = open(path, O_RDONLY);
+    if (fd >= 0) {
+        read(fd, bcmd, sizeof(bcmd));
+        val = strtol(bcmd, NULL, 10);
+        close(fd);
+    } else {
+        LOGE("unable to open file %s,err: %s\n", path, strerror(errno));
+    }
+    return val;
+}
+
+static int amsysfs_set_sysfs_str(const char *path, const char *val)
+{
+    int fd;
+    int bytes;
+    fd = open(path, O_CREAT | O_RDWR | O_TRUNC, 0644);
+    if (fd >= 0) {
+        bytes = write(fd, val, strlen(val));
+        close(fd);
+        return 0;
+    } else {
+        LOGE("unable to open file %s,err: %s\n", path, strerror(errno));
+    }
+    return -1;
+}
+
+static int amsysfs_set_sysfs_int(const char *path, int val)
+{
+    int fd;
+    int bytes;
+    char  bcmd[16];
+    fd = open(path, O_CREAT | O_RDWR | O_TRUNC, 0644);
+    if (fd >= 0) {
+        sprintf(bcmd, "%d", val);
+        bytes = write(fd, bcmd, strlen(bcmd));
+        close(fd);
+        return 0;
+    } else {
+        LOGE("unable to open file %s,err: %s\n", path, strerror(errno));
+    }
+    return -1;
+}
+
+int PLAT_DS_SetNetworkStandby(uint32_t deep_sleep_timeout, bool *isGPIOWakeup,bool  isNetworkStandby)
+{
+    printf("PLAT_DS_DeepSleepWakeup: putting to sleep..\n");
+    printf("Inside Power Hal %s :%d deep_sleep_timeout is %d\n",__FUNCTION__,__LINE__,deep_sleep_timeout);
+    int wakeup_reason=0;
+    *isGPIOWakeup = 0;
+    const char SYS_POWER_EARLY_SUSPEND_TRIGGER[] = "/sys/power/early_suspend_trigger";
+    const char SYS_POWER_TIMER[] = "/sys/devices/platform/aml_pm/time_out";
+    const char sysfs[] = "/sys/power/state";
+    const char SYS_POWER_WAKE_CAUSE[] = "/sys/devices/platform/aml_pm/suspend_reason";
+        amsysfs_set_sysfs_str("/proc/sys/vm/drop_caches", "3");
+        printf("cleared page cache. \n");
+
+    if (deep_sleep_timeout != 0)
+    {
+        amsysfs_set_sysfs_int(SYS_POWER_TIMER, deep_sleep_timeout);
+    }
+
+    amsysfs_set_sysfs_str(SYS_POWER_EARLY_SUSPEND_TRIGGER, "1");
+    amsysfs_set_sysfs_str(sysfs,"mem");
+
+    printf("Waking up from STR mode\n");
+
+    wakeup_reason = amsysfs_get_sysfs_int(SYS_POWER_WAKE_CAUSE);
+    if(wakeup_reason <0)
+    {
+        printf("In %s at %d  Get wakeup reason failed \n",__FUNCTION__,__LINE__);
+        return -1;
+    }
+    printf("In %s at %d Wakeup reason is %x\n",__FUNCTION__,__LINE__,wakeup_reason);
+
+    if(wakeup_reason!=RTC_WAKEUP)
+    {
+        printf("DeepSleep: wakeup due to user action!\n");
+        *isGPIOWakeup = 1;
+    }
+    else {
+        printf("DeepSleep: wakeup due to non-user event!\n");
+    }
+    return 0;
+
+}
+
+void PLAT_DS_DeepSleepWakeup(void)
+{
+    printf("PLAT_DS_DeepSleepWakeup: Waking up from Deepsleep mode \n");
+    printf("Inside DeepSleep  Hal %s :%d\n",__FUNCTION__,__LINE__);
+    char sysfs[FILE_NAME_SIZE];
+    uint32_t deep_sleep_timeout = 0;
+    const char SYS_POWER_TIMER[] = "/sys/devices/platform/aml_pm/time_out";
+    if (g_IsNetworkStandby_modeset) g_IsNetworkStandby_modeset = false;
+    //Clearing the Deepsleep timeout set after Resuming from DeepSleep
+    amsysfs_set_sysfs_int(SYS_POWER_TIMER, deep_sleep_timeout);
+   
+    const char SYS_POWER_EARLY_SUSPEND_TRIGGER[] = "/sys/power/early_suspend_trigger";
+    amsysfs_set_sysfs_str(SYS_POWER_EARLY_SUSPEND_TRIGGER, "0");
+
+}
+
+int PLAT_DS_GetLastWakeupReason(DeepSleep_WakeupReason_t *wakeupReason)
+{
+
+    printf("%s : Enter\n",__FUNCTION__);
+    int wakeup_reason, result =0;
+    const char SYS_POWER_WAKE_CAUSE[] = "/sys/devices/platform/aml_pm/suspend_reason";
+
+    if (wakeupReason != NULL) {
+        printf("Fetching wakeup reason: \n");
+        wakeup_reason = amsysfs_get_sysfs_int(SYS_POWER_WAKE_CAUSE);
+        if (!wakeup_reason)
+        {
+           printf("Platform Reset Reason not implemented");
+        }
+        else
+        {
+            printf("Platform Wakeup Reason is :%d \n",wakeup_reason);
+            switch(wakeup_reason)
+            {
+                case REMOTE_WAKEUP:
+                    *wakeupReason = DEEPSLEEP_WAKEUPREASON_IR;
+                    break;
+
+                case GPIO_WAKEUP:
+                    *wakeupReason = DEEPSLEEP_WAKEUPREASON_GPIO;
+                    break;
+
+                case RTC_WAKEUP:
+                    *wakeupReason = DEEPSLEEP_WAKEUPREASON_TIMER;
+                    break;
+
+                case BT_WAKEUP:
+                    *wakeupReason = DEEPSLEEP_WAKEUPREASON_RCU_BT;
+                    break;
+
+                case WIFI_WAKEUP:
+                    *wakeupReason = DEEPSLEEP_WAKEUPREASON_WLAN;
+                    break;
+
+                case LAN_WAKEUP:
+                    *wakeupReason = DEEPSLEEP_WAKEUPREASON_LAN;
+                    break;
+
+                case POWER_KEY_WAKEUP:
+                    *wakeupReason = DEEPSLEEP_WAKEUPREASON_FRONT_PANEL;
+                    break;
+
+                case CEC_WAKEUP:
+                    *wakeupReason = DEEPSLEEP_WAKEUPREASON_CEC;
+                    break;
+
+                default:
+                    *wakeupReason = DEEPSLEEP_WAKEUPREASON_UNKNOWN;
+            }
+        }
+        printf("Wakeup reason value:-[%d]\n",*wakeupReason);
+    } else {
+        printf("Function argument NULL\n");
+        result = -1;
+    }
+
+    return result;
+}
+
+void PLAT_DS_TERM(void)
+{
+//Stub
+
+}
+
diff --git a/power/plat-power.c b/power/plat-power.c
index b8e8c7f..ae6e720 100644
--- a/power/plat-power.c
+++ b/power/plat-power.c
@@ -54,12 +54,12 @@ int PLAT_API_SetPowerState(IARM_Bus_PWRMgr_PowerState_t newState)
 			break;
 		case IARM_BUS_PWRMGR_POWERSTATE_STANDBY:
 			printf("Inside case standby\n");
-			system("systemctl stop wifi.service");
-			/* set wake lock to prevent system from entering real standby */
-			amsysfs_set_sysfs_str(SYS_POWER_WAKE_LOCK, wake_lock_name);
-			amsysfs_set_sysfs_str(sysfs,"mem");
 			power_state = IARM_BUS_PWRMGR_POWERSTATE_STANDBY;
 			break;
+                case IARM_BUS_PWRMGR_POWERSTATE_STANDBY_LIGHT_SLEEP:
+                        printf("Inside case lightsleep\n");
+                        power_state = IARM_BUS_PWRMGR_POWERSTATE_STANDBY_LIGHT_SLEEP;
+                        break;
 		case IARM_BUS_PWRMGR_POWERSTATE_ON:
 			printf("Inside case poweron\n");
 			amsysfs_set_sysfs_str(sysfs,"wake");
-- 
2.29.2

