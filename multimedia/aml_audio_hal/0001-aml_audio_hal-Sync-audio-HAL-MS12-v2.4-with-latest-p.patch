From b02b5918765ba3133cd9fb4b25ef87e36d2dfac6 Mon Sep 17 00:00:00 2001
From: Tim Yao <tim.yao@amlogic.com>
Date: Mon, 20 Jul 2020 01:56:44 -0700
Subject: [PATCH] aml_audio_hal: Sync audio HAL MS12 v2.4 with latest project
 code base [1/1]

PD#SWPL-27948

Problem:
Need sync up Linux audio HAL with MS12 to latest
code base from customer project.

Solution:
Merge code from customer tree.

Verify:
Verified PCM/DD/AUTO (DD+/MAT) output
with audio_client_test_ac3 test.

Change-Id: I69c04a7bf3811a8b5e5a536b616bdb93dad3826b
---
 CMakeLists.txt                               |   12 +-
 audio_hal/alsa_config_parameters.c           |   60 +-
 audio_hal/alsa_config_parameters.h           |    3 +-
 audio_hal/alsa_manager.c                     |  168 +-
 audio_hal/alsa_manager.h                     |    7 +-
 audio_hal/amlAudioMixer.c                    | 1284 ++----
 audio_hal/amlAudioMixer.h                    |   29 +-
 audio_hal/aml_ac3_parser.c                   |   22 +
 audio_hal/aml_audio_ac3parser.c              |  603 +++
 audio_hal/aml_audio_ac3parser.h              |   37 +
 audio_hal/aml_audio_ac4parser.c              |  480 +++
 audio_hal/aml_audio_ac4parser.h              |   33 +
 audio_hal/aml_audio_avsync_table.h           |   97 +
 audio_hal/aml_audio_bitsparser.c             |  147 +
 audio_hal/aml_audio_bitsparser.h             |   41 +
 audio_hal/aml_audio_delay.c                  |  207 +-
 audio_hal/aml_audio_delay.h                  |   20 +-
 audio_hal/aml_audio_ease.c                   |    9 +-
 audio_hal/aml_audio_ms12_bypass.c            |  288 ++
 audio_hal/aml_audio_ms12_bypass.h            |   34 +
 audio_hal/aml_audio_resample_manager.c       |   30 +
 audio_hal/aml_audio_resample_manager.h       |    1 +
 audio_hal/aml_audio_spdif_output.c           |  232 +
 audio_hal/aml_audio_spdif_output.h           |   27 +
 audio_hal/aml_audio_stream.c                 |  320 +-
 audio_hal/aml_audio_stream.h                 |  123 +-
 audio_hal/aml_audio_timer.c                  |    1 -
 audio_hal/aml_audio_timer.h                  |    4 +
 audio_hal/aml_avsync_tuning.c                |  253 +-
 audio_hal/aml_avsync_tuning.h                |    9 +-
 audio_hal/aml_dca_dec_api.c                  |  371 +-
 audio_hal/aml_dca_dec_api.h                  |    4 +
 audio_hal/aml_dcv_dec_api.c                  |   60 +-
 audio_hal/aml_hw_mixer.c                     |   20 +-
 audio_hal/aml_mmap_audio.c                   |  382 ++
 audio_hal/aml_mmap_audio.h                   |   47 +
 audio_hal/aml_resample_wrap.cpp              |    3 +-
 audio_hal/audio_a2dp_hw.c                    | 1528 +++++++
 audio_hal/audio_a2dp_hw.h                    |  176 +
 audio_hal/audio_android_resample_api.c       |    5 +-
 audio_hal/audio_data_process.c               |    4 +-
 audio_hal/audio_dtv_ad.c                     |   10 +-
 audio_hal/audio_format_parse.c               |  284 +-
 audio_hal/audio_format_parse.h               |   10 +-
 audio_hal/audio_hw.c                         | 3984 ++++++++++++------
 audio_hal/audio_hw.h                         |  160 +-
 audio_hal/audio_hw_dtv.c                     | 1235 ++++--
 audio_hal/audio_hw_insert_silence_data.c     |  166 +
 audio_hal/audio_hw_insert_silence_data.h     |   42 +
 audio_hal/audio_hw_ms12.c                    |  979 ++++-
 audio_hal/audio_hw_ms12.h                    |   90 +-
 audio_hal/audio_hw_profile.c                 |   79 +-
 audio_hal/audio_hw_profile.h                 |    1 +
 audio_hal/audio_hw_utils.c                   |  651 ++-
 audio_hal/audio_hw_utils.h                   |   40 +-
 audio_hal/audio_hwsync.c                     |  114 +-
 audio_hal/audio_hwsync.h                     |   16 +-
 audio_hal/audio_port.c                       |  179 +-
 audio_hal/audio_port.h                       |   56 +-
 audio_hal/audio_virtual_buf.c                |   24 +-
 audio_hal/audio_virtual_buf.h                |    1 +
 audio_hal/dolby_lib_api.c                    |   85 +-
 audio_hal/hw_avsync.c                        |    6 +-
 audio_hal/hw_avsync.h                        |    2 +-
 audio_hal/hw_avsync_callbacks.c              |   13 +-
 audio_hal/sub_mixing_factory.c               |  395 +-
 audio_hal/sub_mixing_factory.h               |    3 +
 include/utils/ac3_parser_utils.h             |    2 +
 include/utils/aml_alsa_mixer.h               |   51 +-
 include/utils/aml_audio_parser.h             |   13 +-
 include/utils/aml_conf_parser.h              |    5 +-
 include/utils/aml_malloc_debug.h             |   45 +
 include/utils/aml_ringbuffer.h               |    2 +-
 include/utils/earc_utils.h                   |   32 +
 include/utils/spdifenc_wrap.h                |    1 +
 libms12v2/CMakeLists.txt                     |    5 +-
 libms12v2/include/DolbyMS12.h                |   28 +-
 libms12v2/include/DolbyMS12ConfigParams.h    |  152 +-
 libms12v2/include/DolbyMS12Status.h          |   12 +
 libms12v2/include/aml_audio_ms12.h           |   24 +
 libms12v2/include/dolby_ms12.h               |   47 +-
 libms12v2/include/dolby_ms12_config_params.h |  110 +-
 libms12v2/include/dolby_ms12_input_mask.h    |   46 +
 libms12v2/include/dolby_ms12_status.h        |   11 +
 libms12v2/src/DolbyMS12.cpp                  |  202 +-
 libms12v2/src/DolbyMS12ConfigParams.cpp      |  490 ++-
 libms12v2/src/DolbyMS12Status.cpp            |   33 +-
 libms12v2/src/aml_audio_ms12.c               |   35 +-
 libms12v2/src/dolby_ms12.cpp                 |   93 +-
 libms12v2/src/dolby_ms12_config_params.cpp   |  172 +-
 libms12v2/src/dolby_ms12_status.cpp          |   26 +-
 utils/SPDIFEncoderAD.cpp                     |    4 +
 utils/ac3_parser_utils.c                     |   12 +-
 utils/alsa_device_parser.c                   |   20 +-
 utils/aml_alsa_mixer.c                       |   81 +-
 utils/aml_android_utils.c                    |   15 +-
 utils/aml_audio_mixer.c                      |    2 +-
 utils/aml_configs/aml_conf_parser.c          |    8 +-
 utils/aml_data_utils.c                       |   35 +-
 utils/aml_dump_debug.c                       |   30 +-
 utils/aml_malloc_debug.c                     |  250 ++
 utils/aml_ringbuffer.c                       |   46 +-
 utils/earc_utils.c                           |  167 +
 utils/ini/IniParser.cpp                      |   27 +-
 utils/spdifenc_wrap.cpp                      |   39 +
 105 files changed, 14235 insertions(+), 3944 deletions(-)
 create mode 100644 audio_hal/aml_audio_ac3parser.c
 create mode 100644 audio_hal/aml_audio_ac3parser.h
 create mode 100644 audio_hal/aml_audio_ac4parser.c
 create mode 100644 audio_hal/aml_audio_ac4parser.h
 create mode 100644 audio_hal/aml_audio_avsync_table.h
 create mode 100644 audio_hal/aml_audio_bitsparser.c
 create mode 100644 audio_hal/aml_audio_bitsparser.h
 create mode 100644 audio_hal/aml_audio_ms12_bypass.c
 create mode 100644 audio_hal/aml_audio_ms12_bypass.h
 create mode 100644 audio_hal/aml_audio_spdif_output.c
 create mode 100644 audio_hal/aml_audio_spdif_output.h
 create mode 100644 audio_hal/aml_mmap_audio.c
 create mode 100644 audio_hal/aml_mmap_audio.h
 create mode 100644 audio_hal/audio_a2dp_hw.c
 create mode 100644 audio_hal/audio_a2dp_hw.h
 create mode 100644 audio_hal/audio_hw_insert_silence_data.c
 create mode 100644 audio_hal/audio_hw_insert_silence_data.h
 create mode 100644 include/utils/aml_malloc_debug.h
 create mode 100644 include/utils/earc_utils.h
 create mode 100644 libms12v2/include/dolby_ms12_input_mask.h
 create mode 100644 utils/aml_malloc_debug.c
 create mode 100644 utils/earc_utils.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
index fcd2ea1..573c2b0 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -20,7 +20,7 @@ target_include_directories(spdifenc PRIVATE
 
 target_compile_options(spdifenc PRIVATE -Wno-deprecated-declarations)
 
-option(USE_DTV "Compile with DTV option" ON)
+option(USE_DTV "Compile with DTV option" OFF)
 
 if(USE_DTV)
     list(APPEND DTV_FILES audio_hal/audio_dtv_ad.c)
@@ -36,11 +36,16 @@ add_library(audio_hal SHARED
 	audio_hal/alsa_config_parameters.c
 	audio_hal/alsa_manager.c
 	audio_hal/aml_ac3_parser.c
+        audio_hal/aml_audio_ac3parser.c
+        audio_hal/aml_audio_ac4parser.c
+        audio_hal/aml_audio_bitsparser.c
 	audio_hal/aml_audio_delay.c
 	audio_hal/aml_audio_ease.c
 	audio_hal/amlAudioMixer.c
+        audio_hal/aml_audio_ms12_bypass.c
 	audio_hal/aml_audio_resample_manager.c
 	audio_hal/aml_audio_stream.c
+        audio_hal/aml_audio_spdif_output.c
 	audio_hal/aml_audio_timer.c
 	audio_hal/aml_avsync_tuning.c
 	audio_hal/aml_dca_dec_api.c
@@ -51,6 +56,7 @@ add_library(audio_hal SHARED
 	audio_hal/audio_data_process.c
 	audio_hal/audio_format_parse.c
 	audio_hal/audio_hw.c
+        audio_hal/audio_hw_insert_silence_data.c
 	audio_hal/audio_hw_ms12.c
 	audio_hal/audio_hw_profile.c
 	audio_hal/audio_hwsync.c
@@ -78,14 +84,16 @@ add_library(audio_hal SHARED
 	utils/aml_buffer_provider.c
 	utils/aml_data_utils.c
 	utils/aml_dump_debug.c
+        utils/aml_malloc_debug.c
 	utils/aml_ringbuffer.c
 	utils/aml_volume_utils.c
 	utils/aml_configs/aml_conf_loader.c
 	utils/aml_configs/aml_conf_parser.c
+        utils/earc_utils.c
     ${DTV_FILES}
 )
 
-add_definitions(-DREPLACE_OUTPUT_BUFFER_WITH_CALLBACK)
+add_definitions(-DNDEBUG -DREPLACE_OUTPUT_BUFFER_WITH_CALLBACK)
 
 set(PREBUILD_STATIC_LIBS
 	${CMAKE_SOURCE_DIR}/amlogic_AQ_tools/lib_aml_ng.a
diff --git a/audio_hal/alsa_config_parameters.c b/audio_hal/alsa_config_parameters.c
index d32f7ad..dfd2c99 100644
--- a/audio_hal/alsa_config_parameters.c
+++ b/audio_hal/alsa_config_parameters.c
@@ -52,7 +52,7 @@ static void get_dts_hd_hardware_config_parameters(
 }
 
 /*
- *@brief get the hardware config parameters when the output format is DDP
+ *@brief get the hardware config parameters when the output format is MAT
 */
 static void get_mat_hardware_config_parameters(
     struct pcm_config *hardware_config
@@ -61,12 +61,11 @@ static void get_mat_hardware_config_parameters(
 {
     hardware_config->channels = 2;
     hardware_config->format = PCM_FORMAT_S16_LE;
-    //hardware_config->rate = rate * 4;
     // for android P, p212 platform found that the rate should not muliply by 4
     hardware_config->rate = rate * 4 /* * 4 */;
     hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
     //hardware_config->period_size = PERIOD_SIZE /* * 4 */;
-    hardware_config->period_size = 61440 / 4;   /* period_size in frame unit, MAT IEC61937 frame size (61440) bytes */
+    hardware_config->period_size = 61440 / 4; /* period_size in frame unit, MAT IEC61937 frame size (61440) bytes */
     hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count/2;
 #ifndef TINYALSA_VERSION
     hardware_config->avail_min = 0;
@@ -81,17 +80,21 @@ static void get_mat_hardware_config_parameters(
 static void get_ddp_hardware_config_parameters(
     struct pcm_config *hardware_config
     , unsigned int channels __unused
-    , unsigned int rate)
+    , unsigned int rate
+    , bool continuous_mode)
 {
     hardware_config->channels = 2;
     hardware_config->format = PCM_FORMAT_S16_LE;
-    //hardware_config->rate = rate * 4;
     // for android P, p212 platform found that the rate should not muliply by 4
     hardware_config->rate = rate /* * 4 */;
     hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
-    //hardware_config->period_size = PERIOD_SIZE /* * 4 */;
-    hardware_config->period_size = PERIOD_SIZE * 4 * 2;
-    hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count/2;
+    if (continuous_mode) {
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT * 2 *4;
+        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 4;
+    } else {
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT *4;
+        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
+    }
 #ifndef TINYALSA_VERSION
     hardware_config->avail_min = 0;
 #endif
@@ -105,14 +108,20 @@ static void get_ddp_hardware_config_parameters(
 static void get_dd_hardware_config_parameters(
     struct pcm_config *hardware_config
     , unsigned int channels __unused
-    , unsigned int rate)
+    , unsigned int rate
+    , bool continuous_mode)
 {
     hardware_config->channels = 2;
     hardware_config->format = PCM_FORMAT_S16_LE;
     hardware_config->rate = rate;
-    hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
     hardware_config->period_size = PERIOD_SIZE;
-    hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count;
+    if (continuous_mode) {
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT * 2;
+        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 4;
+    } else {
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
+        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
+    }
 #ifndef TINYALSA_VERSION
     hardware_config->avail_min = 0;
 #endif
@@ -127,7 +136,8 @@ static void get_pcm_hardware_config_parameters(
     struct pcm_config *hardware_config
     , unsigned int channels
     , unsigned int rate
-    , bool platform_is_tv)
+    , bool platform_is_tv
+    , bool continuous_mode)
 {
     if (platform_is_tv == false) {
         if (channels <= 2) {
@@ -136,7 +146,7 @@ static void get_pcm_hardware_config_parameters(
         }
         else {
             hardware_config->channels = HARDWARE_CHANNEL_7_1_MULTI;
-            hardware_config->format = PCM_FORMAT_S32_LE;
+            hardware_config->format = PCM_FORMAT_S16_LE;
         }
     }
     else {
@@ -144,9 +154,14 @@ static void get_pcm_hardware_config_parameters(
         hardware_config->format = PCM_FORMAT_S32_LE;
     }
     hardware_config->rate = rate;//defualt sample rate = 48KHz
-    hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
     hardware_config->period_size = PERIOD_SIZE;
-    hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count;
+    if (continuous_mode) {
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT * 2;
+        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 4;
+    } else {
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
+        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
+    }
 #ifndef TINYALSA_VERSION
     hardware_config->avail_min = 0;
 #endif
@@ -162,16 +177,17 @@ int get_hardware_config_parameters(
     , audio_format_t output_format
     , unsigned int channels
     , unsigned int rate
-    , bool platform_is_tv)
+    , bool platform_is_tv
+    , bool continuous_mode)
 {
     ALOGI("%s()\n", __FUNCTION__);
     //DD+
     if (output_format == AUDIO_FORMAT_E_AC3) {
-        get_ddp_hardware_config_parameters(final_config, channels, rate);
+        get_ddp_hardware_config_parameters(final_config, channels, rate,continuous_mode);
     }
-    //DD
-    else if (output_format == AUDIO_FORMAT_AC3) {
-        get_dd_hardware_config_parameters(final_config, channels, rate);
+    //DD or DTS
+    else if ((output_format == AUDIO_FORMAT_AC3) || (output_format == AUDIO_FORMAT_DTS)){
+        get_dd_hardware_config_parameters(final_config, channels, rate,continuous_mode);
     }
     //MAT
     else if (output_format == AUDIO_FORMAT_MAT) {
@@ -179,11 +195,11 @@ int get_hardware_config_parameters(
     }
     //DTS-HD/TRUE-HD
     else if ((output_format == AUDIO_FORMAT_DTS_HD) || (output_format == AUDIO_FORMAT_DOLBY_TRUEHD)) {
-        get_dd_hardware_config_parameters(final_config, channels, rate);
+        get_dts_hd_hardware_config_parameters(final_config, channels, rate);
     }
     //PCM
     else {
-        get_pcm_hardware_config_parameters(final_config, channels, rate, platform_is_tv);
+        get_pcm_hardware_config_parameters(final_config, channels, rate, platform_is_tv, continuous_mode);
     }
     ALOGI("%s() channels %d format %d period_count %d period_size %d rate %d\n",
             __FUNCTION__, final_config->channels, final_config->format, final_config->period_count,
diff --git a/audio_hal/alsa_config_parameters.h b/audio_hal/alsa_config_parameters.h
index dde3e16..e3c0403 100644
--- a/audio_hal/alsa_config_parameters.h
+++ b/audio_hal/alsa_config_parameters.h
@@ -38,7 +38,8 @@ int get_hardware_config_parameters(
     , audio_format_t output_format
     , unsigned int channels
     , unsigned int rate
-    , bool platform_is_tv);
+    , bool platform_is_tv
+    , bool continuous_mode);
 
 #endif // _ALSA_MANAGER_H_
 
diff --git a/audio_hal/alsa_manager.c b/audio_hal/alsa_manager.c
index da86ee8..1021b48 100644
--- a/audio_hal/alsa_manager.c
+++ b/audio_hal/alsa_manager.c
@@ -30,6 +30,7 @@
 #include "dolby_lib_api.h"
 #include "aml_audio_stream.h"
 #include "audio_virtual_buf.h"
+#include "alsa_config_parameters.h"
 #define AML_ZERO_ADD_MIN_SIZE 1024
 
 #define AUDIO_EAC3_FRAME_SIZE 16
@@ -41,8 +42,11 @@
 #define MAX_AVSYNC_GAP (10*90000)
 #define MAX_AVSYNC_WAIT_TIME (3*1000*1000)
 
-#define ALSA_OUT_BUF_NS (10000000000LL)   //10s
-#define ALSA_PREFILL_BUF_NS (10000000000LL)   //10s
+#define ALSA_OUT_BUF_NS (64000000LL)
+#define ALSA_DELAY_UP_THRESHOLD_MS (48)  /*the start threshold is 42ms, so we assume it as 48ms*/
+#define VIRTUAL_BUF_DELAY_PERIOD_MS (4)
+#define MS_TO_NANO_SEC  (1000000LL)
+
 
 
 /*
@@ -86,8 +90,9 @@ int aml_alsa_output_open(struct audio_stream_out *stream)
     unsigned int device = aml_out->device;
     struct dolby_ms12_desc *ms12 = &(adev->ms12);
     ALOGI("\n+%s stream %p,device %d", __func__, stream,device);
+
     if (eDolbyMS12Lib == adev->dolby_lib_type) {
-        if (adev->ms12.dolby_ms12_enable) {
+        if ((adev->ms12.dolby_ms12_enable) && !is_bypass_dolbyms12(stream)) {
             config = &(adev->ms12_config);
             device = ms12->device;
             ALOGI("%s indeed choose ms12 [config and device(%d)]", __func__, ms12->device);
@@ -96,6 +101,14 @@ int aml_alsa_output_open(struct audio_stream_out *stream)
                 aml_out->is_device_differ_with_ms12 = true;
             }
         }
+        else {
+            ALOGI("%s hal_format %#x is_bypass_dolbyms12 %d\n",
+                __func__, aml_out->hal_format, is_bypass_dolbyms12(stream));
+            get_hardware_config_parameters(config, aml_out->hal_format
+                , audio_channel_count_from_out_mask(aml_out->hal_channel_mask)
+                , aml_out->config.rate, aml_out->is_tv_platform, continous_mode(adev));
+            device =  audio_is_linear_pcm(aml_out->hal_format) ? I2S_DEVICE : DIGITAL_DEVICE;
+        }
     } else if (eDolbyDcvLib == adev->dolby_lib_type) {
         if (is_dual_output_stream(stream) && adev->optical_format != AUDIO_FORMAT_PCM_16_BIT) {
             device = I2S_DEVICE;
@@ -111,7 +124,22 @@ int aml_alsa_output_open(struct audio_stream_out *stream)
             config_raw.start_threshold = DEFAULT_PLAYBACK_PERIOD_SIZE * PLAYBACK_PERIOD_COUNT;
             config_raw.format = PCM_FORMAT_S16_LE;
             config = &config_raw;
-            device = DIGITAL_DEVICE;
+        }
+        /*
+         *none-license dts decoder, TV platform
+         *when conneted the ARC, output dts bitstream
+         *when only speaker, output zero pcm
+         */
+        if (is_dts_format(aml_out->hal_format)) {
+            get_hardware_config_parameters(config, aml_out->hal_format
+                , audio_channel_count_from_out_mask(aml_out->hal_channel_mask)
+                , aml_out->config.rate, aml_out->is_tv_platform, continous_mode(adev));
+            if (adev->is_TV) {
+                if (adev->active_outport == OUTPORT_HDMI_ARC)
+                    device = DIGITAL_DEVICE;
+                else if (adev->active_outport == OUTPORT_SPEAKER)
+                    device = I2S_DEVICE;
+            }
         }
     }
     int card = aml_out->card;
@@ -174,8 +202,8 @@ int aml_alsa_output_open(struct audio_stream_out *stream)
                 return -ENOENT;
             }
             aml_out->earc_pcm = earc_pcm;
-            adev->pcm_refs[EARC_DEVICE]++;
             adev->pcm_handle[EARC_DEVICE] = earc_pcm;
+            adev->pcm_refs[EARC_DEVICE]++;
         }
     }
     aml_out->pcm = pcm;
@@ -299,10 +327,12 @@ static int aml_alsa_add_zero(struct aml_stream_out *stream, int size)
 
 size_t aml_alsa_output_write(struct audio_stream_out *stream,
                              void *buffer,
-                             size_t bytes)
+                             size_t bytes,
+                             audio_format_t out_format)
 {
     struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
     struct aml_audio_device *adev = aml_out->dev;
+    struct aml_audio_patch *patch = adev->audio_patch;
     int ret = 0;
     struct pcm_config *config = &aml_out->config;
     size_t frame_size = audio_stream_out_frame_size(stream);
@@ -320,7 +350,7 @@ size_t aml_alsa_output_write(struct audio_stream_out *stream,
     int64_t pretime = 0;
     unsigned char*audio_data = (unsigned char*)buffer;
 
-    switch (adev->sink_format) {
+    switch (out_format) {
     case AUDIO_FORMAT_E_AC3:
         frame_size = AUDIO_EAC3_FRAME_SIZE;
         break;
@@ -406,7 +436,7 @@ size_t aml_alsa_output_write(struct audio_stream_out *stream,
             return bytes;
         } else {
             //emset(audio_data, 0, need_drop_inject);
-            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm && adev->bHDMIARCon) {
+            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm) {
                 ret = pcm_write(aml_out->earc_pcm, audio_data + need_drop_inject, bytes - need_drop_inject);
             } else {
                 ret = pcm_write(aml_out->pcm, audio_data + need_drop_inject, bytes - need_drop_inject);
@@ -465,25 +495,68 @@ write:
     if (adev->patch_src == SRC_DTV && adev->parental_control_av_mute) {
         memset(buffer,0x0,bytes);
     }
+
+    if (aml_out->pcm == NULL) {
+        ALOGE("%s: pcm is null", __func__);
+        return bytes;
+    }
+
+    /*+[SE][BUG][SWPL-14811][zhizhong] add drop ac3 pcm function*/
+    if (adev->patch_src ==  SRC_DTV && aml_out->need_drop_size > 0) {
+        if (aml_out->need_drop_size >= (int)bytes) {
+            aml_out->need_drop_size -= bytes;
+            ALOGI("av sync drop %d pcm, need drop:%d more,apts:0x%x,pcr:0x%x\n",
+                (int)bytes, aml_out->need_drop_size, patch->last_apts, patch->last_pcrpts);
+            if (patch->last_apts >= patch->last_pcrpts) {
+                ALOGI("pts already ok, drop finish\n");
+                aml_out->need_drop_size = 0;
+            } else
+                return bytes;
+        } else {
+            ALOGI("bytes:%d, need_drop_size=%d\n", bytes, aml_out->need_drop_size);
+            ret = pcm_write(aml_out->pcm, audio_data + aml_out->need_drop_size,
+                    bytes - aml_out->need_drop_size);
+            aml_out->need_drop_size = 0;
+            ALOGI("drop finish\n");
+            return bytes;
+        }
+    }
+
     if (getprop_bool("media.audiohal.outdump")) {
         aml_audio_dump_audio_bitstreams("/data/audio/pcm_write.raw",
             buffer, bytes);
     }
-    if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm && adev->bHDMIARCon) {
+    {
+        struct snd_pcm_status status;
+
+        pcm_ioctl(aml_out->pcm, SNDRV_PCM_IOCTL_STATUS, &status);
+        if (status.state == PCM_STATE_XRUN) {
+            ALOGW("%s alsa underrun",__func__);
+        }
+    }
+
+    if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm) {
         ret = pcm_write(aml_out->earc_pcm, buffer, bytes);
         if (ret < 0) {
             ALOGE("%s write failed,aml_out->earc_pcm handle:%p, ret:%#x, err info:%s",
                     __func__, aml_out->earc_pcm, ret, strerror(errno));
         }
     } else {
+        if (adev->raw_to_pcm_flag) {
+            pcm_stop(aml_out->pcm);
+            adev->raw_to_pcm_flag = false;
+            ALOGI("raw to lpcm switch %s\n",__func__);
+        }
         ret = pcm_write(aml_out->pcm, buffer, bytes);
         if (ret < 0) {
-            ALOGE("%s write failed,pcm handle:%p, ret:%#x, err info:%s", __func__,
-                    aml_out->pcm, ret, strerror(errno));
+        ALOGE("%s write failed,pcm handle %p %s, stream %p, %s",
+            __func__, aml_out->pcm, pcm_get_error(aml_out->pcm),
+            aml_out, usecase2Str(aml_out->usecase));
         }
     }
 
-    if ((adev->continuous_audio_mode == 1) && (eDolbyMS12Lib == adev->dolby_lib_type) && (bytes != 0)) {
+    if ((adev->continuous_audio_mode == 1) && (eDolbyMS12Lib == adev->dolby_lib_type) && (bytes != 0)  && \
+        (adev->ms12.main_input_fmt != AUDIO_FORMAT_AC4)) {
         uint64_t input_ns = 0;
         int mutex_lock_success = 0;
         int sample_rate = 48000;
@@ -499,11 +572,30 @@ write:
         if (aml_out->alsa_vir_buf_handle == NULL) {
             /*set the buf to 10s, and then fill the buff, we will use this to make the data consuming to stable*/
             audio_virtual_buf_open(&aml_out->alsa_vir_buf_handle, "alsa out", ALSA_OUT_BUF_NS, ALSA_OUT_BUF_NS, 0);
-            audio_virtual_buf_process(aml_out->alsa_vir_buf_handle, ALSA_OUT_BUF_NS - input_ns/2);
+            audio_virtual_buf_process(aml_out->alsa_vir_buf_handle, ALSA_OUT_BUF_NS);
         }
 
-
         audio_virtual_buf_process(aml_out->alsa_vir_buf_handle, input_ns);
+
+        /* alsa output rate is not exactly with system time, we need check whether
+         * the delay is too big, if it is too big, we should delay the virtual buf
+         */
+        {
+            int rate_multiply = 1;
+            uint64_t frame_ms = 0;
+            snd_pcm_sframes_t frames = 0;
+            ret = pcm_ioctl(aml_out->pcm, SNDRV_PCM_IOCTL_DELAY, &frames);
+            if (out_format == AUDIO_FORMAT_E_AC3) {
+                rate_multiply = 4;
+            }
+            frame_ms = (uint64_t)frames * 1000LL/ (sample_rate * rate_multiply);
+            ALOGV("alsa frame delay=%ld ms=%lld", frames, frame_ms);
+            if (frame_ms > ALSA_DELAY_UP_THRESHOLD_MS) {
+                ALOGI("alsa delay is =%lld catch up =%d", frame_ms, VIRTUAL_BUF_DELAY_PERIOD_MS);
+                audio_virtual_buf_process(aml_out->alsa_vir_buf_handle, VIRTUAL_BUF_DELAY_PERIOD_MS * MS_TO_NANO_SEC);
+            }
+        }
+
         if(mutex_lock_success) {
             pthread_mutex_lock(&adev->alsa_pcm_lock);
         }
@@ -580,8 +672,9 @@ int alsa_depop(int card)
     return 0;
 }
 
+#define WAIT_COUNT_MAX 30
 size_t aml_alsa_input_read(struct audio_stream_in *stream,
-                        void *buffer,
+                        const void *buffer,
                         size_t bytes)
 {
     struct aml_stream_in *in = (struct aml_stream_in *)stream;
@@ -590,26 +683,53 @@ size_t aml_alsa_input_read(struct audio_stream_in *stream,
     char  *read_buf = (char *)buffer;
     int ret = 0;
     size_t  read_bytes = 0;
+    int nodata_count = 0;
     struct pcm *pcm_handle = in->pcm;
     size_t frame_size = in->config.channels * pcm_format_to_bits(in->config.format) / 8;
-    while (read_bytes < bytes) {
-        size_t remaining = bytes - read_bytes;
-        ret = pcm_read(pcm_handle, (unsigned char *)buffer + read_bytes, remaining);
 
+    while (read_bytes < bytes) {
         if (patch && patch->input_thread_exit) {
-            memset(buffer,0,bytes);
+            memset((void*)buffer,0,bytes);
             return 0;
         }
-        if (!ret) {
-            read_bytes += remaining;
-            ALOGV("ret:%d read_bytes:%d, bytes:%d ",ret,read_bytes,bytes);
-        } else if (ret != -EAGAIN ) {
-            ALOGE("%s:%d, pcm_read fail, ret:%#x, error info:%s", __func__, __LINE__, ret, strerror(errno));
+
+        ret = pcm_read(pcm_handle, (unsigned char *)buffer + read_bytes, bytes - read_bytes);
+        if (ret >= 0) {
+            nodata_count = 0;
+            read_bytes += ret*frame_size;
+            ALOGV("pcm_handle:%p, ret:%d read_bytes:%d, bytes:%d ",
+                pcm_handle,ret,read_bytes,bytes);
+        } else if (ret != -EAGAIN) {
+            ALOGD("%s:%d, pcm_read fail, ret:%#x, error info:%s",
+                __func__, __LINE__, ret, strerror(errno));
             return ret;
         } else {
              usleep( (bytes - read_bytes) * 1000000 / audio_stream_in_frame_size(stream) /
                 in->requested_rate / 2);
+             nodata_count++;
+             if (nodata_count >= WAIT_COUNT_MAX) {
+                 nodata_count = 0;
+                 ALOGV("aml_alsa_input_read immediate return");
+                 memset((void*)buffer,0,bytes);
+                 return 0;
+             }
         }
     }
     return 0;
 }
+
+int aml_alsa_input_flush(struct audio_stream_in *stream)
+{
+    struct aml_stream_in *in = (struct aml_stream_in *)stream;
+    struct pcm *pcm_handle = in->pcm;
+    int ret = 0;
+
+    ret = pcm_ioctl(pcm_handle, SNDRV_PCM_IOCTL_RESET, 0);
+    if (ret < 0) {
+        ALOGE("cannot reset pcm!");
+        return ret;
+    }
+
+    return 0;
+}
+
diff --git a/audio_hal/alsa_manager.h b/audio_hal/alsa_manager.h
index 94ddac9..2ac348b 100644
--- a/audio_hal/alsa_manager.h
+++ b/audio_hal/alsa_manager.h
@@ -34,7 +34,8 @@ void aml_alsa_output_close(struct audio_stream_out *stream);
  */
 size_t aml_alsa_output_write(struct audio_stream_out *stream,
                         void *buffer,
-                        size_t bytes);
+                        size_t bytes,
+                        audio_format_t out_format);
 /**
  * get the stream latency.
  */
@@ -48,9 +49,11 @@ void aml_close_continuous_audio_device(struct aml_audio_device *adev);
  * pcm_read to the pcm handle saved in stream instance.
  */
 size_t aml_alsa_input_read(struct audio_stream_in *stream,
-                        void *buffer,
+                        const void *buffer,
                         size_t bytes);
 
 
 int alsa_depop(int card);
+int aml_alsa_input_flush(struct audio_stream_in *stream);
+
 #endif // _ALSA_MANAGER_H_
diff --git a/audio_hal/amlAudioMixer.c b/audio_hal/amlAudioMixer.c
index 05f5d99..87423a5 100644
--- a/audio_hal/amlAudioMixer.c
+++ b/audio_hal/amlAudioMixer.c
@@ -21,11 +21,9 @@
 #define __USE_GNU
 #include <cutils/log.h>
 #include <errno.h>
-#include <sched.h>
 #include <pthread.h>
 #include <sys/prctl.h>
 #include <stdlib.h>
-#include <string.h>
 #include <system/audio.h>
 #include <aml_volume_utils.h>
 
@@ -34,15 +32,16 @@
 #include "hw_avsync.h"
 #include "audio_hwsync.h"
 #include "audio_data_process.h"
+#include "audio_virtual_buf.h"
 
 #include "audio_hw.h"
+#include "audio_a2dp_hw.h"
 
-#define MIXER_IN_BUFFER_SIZE (512*4)
-#define MIXER_OUT_BUFFER_SIZE MIXER_IN_BUFFER_SIZE
-/* in/out frame count should be same */
-#define MIXER_IN_FRAME_COUNT 512
-#define MIXER_OUT_FRAME_COUNT 512
-#define STANDBY_TIME_US 1000000
+#define MIXER_FRAME_COUNT                   (384)
+#define MIXER_OUT_FRAME_SIZE                (8)
+#define MIXER_WRITE_PERIOD_TIME_NANO        (MIXER_FRAME_COUNT * 1000000000LL / 48000)
+
+#define SILENCE_FRAME_MAX                   (6144)
 
 struct ring_buf_desc {
     struct ring_buffer *buffer;
@@ -61,31 +60,22 @@ enum mixer_state {
 
 //simple mixer support: 2 in , 1 out
 struct amlAudioMixer {
-    struct input_port *in_ports[MIXER_INPUT_PORT_NUM];
+    struct input_port *in_ports[AML_MIXER_INPUT_PORT_BUTT];
     struct output_port *out_ports[MIXER_OUTPUT_PORT_NUM];
-
-    /* protect inports */
     pthread_mutex_t inport_lock;
-
     ssize_t (*write)(struct amlAudioMixer *mixer, void *buffer, int bytes);
     //int period_time;
-    void *tmp_buffer;
-    size_t buf_frames;
+    void *tmp_buffer;       /* mixer temp output buffer. */
     int idle_sleep_time_us;
     size_t frame_size_tmp;
     uint32_t hwsync_frame_size;
     pthread_t out_mixer_tid;
-
-    /* condition and lock pair */
     pthread_mutex_t lock;
-    pthread_cond_t cond;
-
     int exit_thread : 1;
     int mixing_enable : 1;
     enum mixer_state state;
     struct timespec tval_last_write;
     struct timespec tval_last_run;
-    void *adev_data;
     struct aml_audio_device *adev;
     bool continuous_output;
     //int init_ok : 1;
@@ -126,99 +116,71 @@ int init_mixer_input_port(struct amlAudioMixer *audio_mixer,
         void *meta_data,
         float volume)
 {
-    size_t buf_frames = MIXER_IN_FRAME_COUNT;
     struct input_port *port = NULL;
-    enum MIXER_INPUT_PORT port_index;
+    aml_mixer_input_port_type_e port_index;
     struct aml_stream_out *aml_out = notify_data;
     bool direct_on = false;
 
     if (audio_mixer == NULL || config == NULL || notify_data == NULL) {
-        ALOGE("%s(), NULL pointer", __func__);
+        ALOGE("[%s:%d] NULL pointer", __func__, __LINE__);
         return -EINVAL;
     }
 
     /* if direct on, ie. the ALSA buffer is full, no need padding data anymore  */
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    direct_on = (audio_mixer->in_ports[MIXER_INPUT_PORT_PCM_DIRECT] != NULL);
-    port = new_input_port(buf_frames, config, flags, volume, direct_on);
-    port_index = port->port_index;
-    if (audio_mixer->in_ports[port_index] == NULL) {
-        ALOGI("++%s port index %d, size %d frames", __func__, port_index, buf_frames);
-        audio_mixer->in_ports[port_index] = port;
-    } else {
-        ALOGE("%s(), fatal error, inport index %d already exists!", __func__, port_index);
+    direct_on = (audio_mixer->in_ports[AML_MIXER_INPUT_PORT_PCM_DIRECT] != NULL);
+    port = new_input_port(MIXER_FRAME_COUNT, config, flags, volume, direct_on);
+    port_index = port->enInPortType;
+    if (audio_mixer->in_ports[port_index] != NULL) {
+        ALOGW("[%s:%d] inport index:%s already exists! recreate", __func__, __LINE__, inportType2Str(port_index));
+        free_input_port(audio_mixer->in_ports[port_index]);
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
+    ALOGI("[%s:%d] input port:%s, size %d frames, frame_write_sum:%lld", __func__, __LINE__,
+        inportType2Str(port_index), MIXER_FRAME_COUNT, aml_out->frame_write_sum);
+    audio_mixer->in_ports[port_index] = port;
+
     set_port_notify_cbk(port, on_notify_cbk, notify_data);
     set_port_input_avail_cbk(port, on_input_avail_cbk, input_avail_data);
     if (on_meta_data_cbk && meta_data) {
-        //mixer_set_hwsync_input_port(audio_mixer, port_index);
-        set_inport_hwsync(port);
+        port->is_hwsync = true;
         set_port_meta_data_cbk(port, on_meta_data_cbk, meta_data);
     }
-
     port->initial_frames = aml_out->frame_write_sum;
-    ALOGI("%s(), port->initial_frames: %lld", __func__, port->initial_frames);
-
     return 0;
 }
 
 int delete_mixer_input_port(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index)
+        aml_mixer_input_port_type_e port_index)
 {
-    ALOGI("++%s port ID: %d", __func__, port_index);
-    pthread_mutex_lock(&audio_mixer->inport_lock);
+    ALOGI("[%s:%d] input port:%s", __func__, __LINE__, inportType2Str(port_index));
     if (audio_mixer->in_ports[port_index]) {
         free_input_port(audio_mixer->in_ports[port_index]);
         audio_mixer->in_ports[port_index] = NULL;
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
     return 0;
 }
 
 int send_mixer_inport_message(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index , enum PORT_MSG msg)
+        aml_mixer_input_port_type_e port_index , enum PORT_MSG msg)
 {
-    struct input_port *port;
-    int ret;
-
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    port = audio_mixer->in_ports[port_index];
+    struct input_port *port = audio_mixer->in_ports[port_index];
 
     if (port == NULL) {
         ALOGE("%s(), port index %d, inval", __func__, port_index);
-        ret = -EINVAL;
-    } else {
-        ret = send_inport_message(port, msg);
+        return -EINVAL;
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return ret;
-}
-
-void mixer_set_hwsync_input_port(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index)
-{
-    struct input_port *port;
-    ALOGI("++%s port ID: %d", __func__, port_index);
-    pthread_mutex_lock(&audio_mixer->inport_lock);
 
-    port = audio_mixer->in_ports[port_index];
-    if (port)
-        set_inport_hwsync(port);
-
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
+    return send_inport_message(port, msg);
 }
 
 void set_mixer_hwsync_frame_size(struct amlAudioMixer *audio_mixer,
         uint32_t frame_size)
 {
-#if 0
-    enum MIXER_INPUT_PORT port_index = 0;
+    aml_mixer_input_port_type_e port_index = AML_MIXER_INPUT_PORT_PCM_SYSTEM;
     enum MIXER_OUTPUT_PORT out_port_index = MIXER_OUTPUT_PORT_PCM;
     struct input_port *in_port = NULL;
     struct output_port *out_port = audio_mixer->out_ports[out_port_index];
     int port_cnt = 0;
-    for (port_index = 0; port_index < MIXER_INPUT_PORT_NUM; port_index++) {
+    for (; port_index < AML_MIXER_INPUT_PORT_BUTT; port_index++) {
         struct input_port *in_port = audio_mixer->in_ports[port_index];
         if (in_port) {
             //resize_input_port_buffer(in_port, MIXER_IN_BUFFER_SIZE);
@@ -226,8 +188,7 @@ void set_mixer_hwsync_frame_size(struct amlAudioMixer *audio_mixer,
     }
 
     //resize_output_port_buffer(out_port, MIXER_IN_BUFFER_SIZE);
-#endif
-    ALOGV("%s framesize %d", __func__, frame_size);
+    ALOGI("%s framesize %d", __func__, frame_size);
     audio_mixer->hwsync_frame_size = frame_size;
 }
 
@@ -237,141 +198,89 @@ uint32_t get_mixer_hwsync_frame_size(struct amlAudioMixer *audio_mixer)
 }
 
 uint32_t get_mixer_inport_consumed_frames(
-        struct amlAudioMixer *audio_mixer, enum MIXER_INPUT_PORT port_index)
+        struct amlAudioMixer *audio_mixer, aml_mixer_input_port_type_e port_index)
 {
-    struct input_port *port;
-    uint32_t ret = 0;
-
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    port = audio_mixer->in_ports[port_index];
+    struct input_port *port = audio_mixer->in_ports[port_index];
 
     if (!port) {
         ALOGE("%s(), NULL pointer", __func__);
-    } else {
-        if (port->frame_size)
-            ret = get_inport_consumed_size(port) / port->frame_size;
+        return -EINVAL;
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return ret;
+    return get_inport_consumed_size(port) / port->cfg.frame_size;
 }
 
 int set_mixer_inport_volume(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index, float vol)
+        aml_mixer_input_port_type_e port_index, float vol)
 {
-    struct input_port *port;
-    int ret = 0;
+    struct input_port *port = audio_mixer->in_ports[port_index];
 
-    if (vol > 1.0 || vol < 0) {
-        ALOGE("%s(), invalid vol %f", __func__, vol);
+    if (!port) {
+        ALOGE("%s(), NULL pointer", __func__);
         return -EINVAL;
     }
 
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-
-    port = audio_mixer->in_ports[port_index];
-    if (!port) {
-        ALOGE("%s(), NULL pointer", __func__);
-        ret = -EINVAL;
-    } else {
-        set_inport_volume(port, vol);
+    if (vol > 1.0 || vol < 0) {
+        ALOGE("%s(), invalid vol %f", __func__, vol);
+        return -EINVAL;
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return ret;
+    set_inport_volume(port, vol);
+    return 0;
 }
 
 float get_mixer_inport_volume(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index)
+        aml_mixer_input_port_type_e port_index)
 {
-    struct input_port *port;
-    float vol = 0;
-
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    port = audio_mixer->in_ports[port_index];
+    struct input_port *port = audio_mixer->in_ports[port_index];
 
     if (!port) {
         ALOGE("%s(), NULL pointer", __func__);
-    } else {
-        vol = get_inport_volume(port);
+        return 0;
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return vol;
-}
-
-int mixer_broadcast(struct amlAudioMixer *audio_mixer)
-{
-    pthread_cond_signal(&audio_mixer->cond);
-    return 0;
+    return get_inport_volume(port);
 }
 
 int mixer_write_inport(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index, const void *buffer, int bytes)
+        aml_mixer_input_port_type_e port_index, const void *buffer, int bytes)
 {
-    struct input_port *port;
+    struct input_port *port = audio_mixer->in_ports[port_index];
     int written = 0;
 
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    port = audio_mixer->in_ports[port_index];
-
     if (!port) {
         ALOGE("%s(), NULL pointer", __func__);
-        pthread_mutex_unlock(&audio_mixer->inport_lock);
         return -EINVAL;
     }
-    //if (get_inport_state(port) == RESUMING) {
-    //    ALOGI("resuming port index %d", port_index);
-        //audio_fade_func(buffer, bytes, 1);
-        //aml_hwsync_set_tsync_resume();
-    //}
+
     written = port->write(port, buffer, bytes);
-    if (/*port_index == MIXER_INPUT_PORT_PCM_SYSTEM && */get_inport_state(port) != ACTIVE) {
-        ALOGI("port index %d is active now", port_index);
+    if (get_inport_state(port) != ACTIVE) {
+        ALOGI("[%s:%d] input port:%s is active now", __func__, __LINE__, inportType2Str(port_index));
         set_inport_state(port, ACTIVE);
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-
-    ALOGV("%s(), signal line %d portIndex %d",
-            __func__, __LINE__, port_index);
-    mixer_broadcast(audio_mixer);
+    ALOGV("%s(), signal line %d portIndex %d", __func__, __LINE__, port_index);
     return written;
 }
 
-static int mixer_read_inport_l(struct input_port *port)
+int mixer_read_inport(struct amlAudioMixer *audio_mixer,
+        aml_mixer_input_port_type_e port_index, void *buffer, int bytes)
 {
-    if (!port) {
-        ALOGE("%s(), NULL pointer", __func__);
-        return 0;
-    }
-    return port->read(port, port->data, port->data_len_bytes);
+    struct input_port *port = audio_mixer->in_ports[port_index];
+
+    return port->read(port, buffer, bytes);
 }
 
 int mixer_set_inport_state(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index, enum port_state state)
+        aml_mixer_input_port_type_e port_index, enum port_state state)
 {
-    struct input_port *port;
-    int ret = 0;
+    struct input_port *port = audio_mixer->in_ports[port_index];
 
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    port = audio_mixer->in_ports[port_index];
-    if (port)
-        ret = set_inport_state(port, state);
-    else
-        ret = -EINVAL;
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return ret;
+    return set_inport_state(port, state);
 }
 
 enum port_state mixer_get_inport_state(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index)
+        aml_mixer_input_port_type_e port_index)
 {
-    struct input_port *port;
-    enum port_state st = IDLE;
-
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    port = audio_mixer->in_ports[port_index];
-    if (port)
-        st = get_inport_state(port);
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return st;
+    struct input_port *port = audio_mixer->in_ports[port_index];
+
+    return get_inport_state(port);
 }
 //TODO: handle message queue
 static void mixer_procs_msg_queue(struct amlAudioMixer *audio_mixer __unused)
@@ -422,11 +331,10 @@ int init_mixer_output_port(struct amlAudioMixer *audio_mixer,
 {
     struct output_port *port = new_output_port(MIXER_OUTPUT_PORT_PCM,
             cfg, buf_frames);
-    enum MIXER_OUTPUT_PORT port_index = port->port_index;
+    enum MIXER_OUTPUT_PORT port_index = port->enOutPortType;
 
-    audio_mixer->standby = 1;
     audio_mixer->out_ports[port_index] = port;
-    audio_mixer->idle_sleep_time_us = (((audio_mixer->buf_frames * 1000) / cfg.sampleRate) * 1000) / 2;
+    audio_mixer->idle_sleep_time_us = (((MIXER_FRAME_COUNT * 1000) / cfg.sampleRate) * 1000) / 2;
     return 0;
 }
 
@@ -440,43 +348,68 @@ int delete_mixer_output_port(struct amlAudioMixer *audio_mixer,
 
 static int mixer_output_startup(struct amlAudioMixer *audio_mixer)
 {
-    //enum MIXER_OUTPUT_PORT port_index = 0;
-    struct output_port *out_port = audio_mixer->out_ports[0];
+    enum MIXER_OUTPUT_PORT port_index = 0;
+    struct output_port *out_port = audio_mixer->out_ports[port_index];
 
     ALOGI("++%s start open", __func__);
-    return  out_port->start(out_port);
+    out_port->start(out_port);
+    audio_mixer->standby = 0;
+
+    return 0;
 }
 
-static int mixer_output_standby(struct amlAudioMixer *audio_mixer)
+int mixer_output_standby(struct amlAudioMixer *audio_mixer)
 {
-    //enum MIXER_OUTPUT_PORT port_index = 0;
-    struct output_port *out_port = audio_mixer->out_ports[0];
+    enum MIXER_OUTPUT_PORT port_index = 0;
+    struct output_port *out_port = audio_mixer->out_ports[port_index];
 
-    ALOGI("++%s standby", __func__);
-    return out_port->standby(out_port);
+    if (!audio_mixer->standby) {
+        ALOGI("++%s()", __func__);
+        out_port->standby(out_port);
+    }
+    audio_mixer->standby = 1;
+
+    return 0;
 }
 
-static int mixer_output_write(struct amlAudioMixer *audio_mixer)
+int mixer_output_dummy(struct amlAudioMixer *audio_mixer, bool en)
 {
-    int ret = 0;
     enum MIXER_OUTPUT_PORT port_index = 0;
     struct output_port *out_port = audio_mixer->out_ports[port_index];
 
-    if (audio_mixer->standby) {
-        ret = mixer_output_startup(audio_mixer);
-    }
-    if (ret) {
-        ALOGE("%s cat not start output port", __func__);
-        return ret;
-    } else {
-        audio_mixer->standby = 0;
-    }
+    ALOGI("++%s(), en = %d", __func__, en);
+    outport_set_dummy(out_port, en);
+
+    return 0;
+}
+
+static int mixer_output_write(struct amlAudioMixer *audio_mixer)
+{
+    enum MIXER_OUTPUT_PORT port_index = MIXER_OUTPUT_PORT_PCM;
+    struct output_port *out_port = audio_mixer->out_ports[port_index];
+    struct input_port *in_port_direct = audio_mixer->in_ports[AML_MIXER_INPUT_PORT_PCM_DIRECT];
+    struct input_port *in_port_system = audio_mixer->in_ports[AML_MIXER_INPUT_PORT_PCM_SYSTEM];
+    struct aml_stream_out *out = NULL;
 
+    if (audio_mixer->standby)
+        mixer_output_startup(audio_mixer);
+
+    if (in_port_direct && in_port_direct->notify_cbk_data) {
+        out = (struct aml_stream_out *)in_port_direct->notify_cbk_data;
+    } else if (in_port_system && in_port_system->notify_cbk_data) {
+        out = (struct aml_stream_out *)in_port_system->notify_cbk_data;
+    }
     out_port->sound_track_mode = audio_mixer->adev->sound_track_mode;
+
     while (is_output_data_avail(audio_mixer, port_index)) {
         // out_write_callbacks();
         ALOGV("++%s start", __func__);
-        out_port->write(out_port, out_port->data_buf, out_port->bytes_avail);
+#ifdef ENABLE_BT_A2DP
+        if (out && (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP))
+            a2dp_out_write(&out->stream, out_port->data_buf, out_port->bytes_avail);
+        else
+#endif
+            out_port->write(out_port, out_port->data_buf, out_port->bytes_avail);
         set_outport_data_avail(out_port, 0);
     };
     return 0;
@@ -487,48 +420,41 @@ static int mixer_output_write(struct amlAudioMixer *audio_mixer)
 static int mixer_update_tstamp(struct amlAudioMixer *audio_mixer)
 {
     struct output_port *out_port = audio_mixer->out_ports[MIXER_OUTPUT_PORT_PCM];
-    struct input_port *in_port;
+    struct input_port *in_port = audio_mixer->in_ports[AML_MIXER_INPUT_PORT_PCM_SYSTEM];
     unsigned int avail;
     //struct timespec *timestamp;
 
     /*only deal with system audio */
-    if (out_port == NULL)
+    if (in_port == NULL || out_port == NULL)
         return 0;
 
-    if (audio_mixer->standby)
+    if (!out_port->pcm_handle)
         return 0;
 
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    in_port = audio_mixer->in_ports[MIXER_INPUT_PORT_PCM_SYSTEM];
-    if (in_port != NULL) {
-        if (pcm_get_htimestamp(out_port->pcm_handle, &avail, &in_port->timestamp) == 0) {
-            size_t kernel_buf_size = DEFAULT_KERNEL_FRAMES;
-            int64_t signed_frames = in_port->mix_consumed_frames - kernel_buf_size + avail;
-            if (signed_frames < 0) {
-                signed_frames = 0;
-            }
-            in_port->presentation_frames = in_port->initial_frames + signed_frames;
-            ALOGV("%s() present frames:%lld, initial %lld, consumed %lld, sec:%ld, nanosec:%ld",
-                    __func__,
-                    in_port->presentation_frames,
-                    in_port->initial_frames,
-                    in_port->mix_consumed_frames,
-                    in_port->timestamp.tv_sec,
-                    in_port->timestamp.tv_nsec);
+    if (pcm_get_htimestamp(out_port->pcm_handle, &avail, &in_port->timestamp) == 0) {
+        size_t kernel_buf_size = DEFAULT_KERNEL_FRAMES;
+        int64_t signed_frames = in_port->mix_consumed_frames - kernel_buf_size + avail;
+        if (signed_frames < 0) {
+            signed_frames = 0;
         }
+        in_port->presentation_frames = in_port->initial_frames + signed_frames;
+        ALOGV("%s() present frames:%lld, initial %lld, consumed %lld, sec:%ld, nanosec:%ld",
+                __func__,
+                in_port->presentation_frames,
+                in_port->initial_frames,
+                in_port->mix_consumed_frames,
+                in_port->timestamp.tv_sec,
+                in_port->timestamp.tv_nsec);
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
 
     return 0;
 }
 
 static bool is_mixer_inports_ready(struct amlAudioMixer *audio_mixer)
 {
-    enum MIXER_INPUT_PORT port_index = 0;
+    aml_mixer_input_port_type_e port_index = 0;
     int port_cnt = 0, ready = 0;
-
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    for (port_index = 0; port_index < MIXER_INPUT_PORT_NUM; port_index++) {
+    for (port_index = 0; port_index < AML_MIXER_INPUT_PORT_BUTT; port_index++) {
         struct input_port *in_port = audio_mixer->in_ports[port_index];
         ALOGV("%s() port index %d, port ptr %p", __func__, port_index, in_port);
         if (in_port) {
@@ -541,12 +467,11 @@ static bool is_mixer_inports_ready(struct amlAudioMixer *audio_mixer)
             }
         }
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
 
     return (port_cnt == ready);
 }
 
-static inline float get_fade_step_by_size(int fade_size, int frame_size)
+inline float get_fade_step_by_size(int fade_size, int frame_size)
 {
     return 1.0/(fade_size/frame_size);
 }
@@ -586,7 +511,7 @@ int process_fade_out(void *buf, int bytes, struct fade_out *fout)
     return 0;
 }
 
-static int update_inport_avail_l(struct input_port *in_port)
+static int update_inport_avail(struct input_port *in_port)
 {
     // first throw away the padding frames
     if (in_port->padding_frames > 0) {
@@ -604,7 +529,7 @@ static void process_port_msg(struct input_port *port)
 {
     struct port_message *msg = get_inport_message(port);
     if (msg) {
-        ALOGD("%s(), msg: %s", __func__, port_msg_to_str(msg->msg_what));
+        ALOGI("%s(), msg: %s", __func__, port_msg_to_str(msg->msg_what));
         switch (msg->msg_what) {
         case MSG_PAUSE:
             set_inport_state(port, PAUSING);
@@ -623,138 +548,105 @@ static void process_port_msg(struct input_port *port)
     }
 }
 
-static int mixer_flush_inport_l(struct input_port *in_port)
+int mixer_flush_inport(struct amlAudioMixer *audio_mixer,
+        aml_mixer_input_port_type_e port_index)
 {
-    if (in_port) {
-        return reset_input_port(in_port);
-    }
-    return -EINVAL;
-}
+    struct input_port *in_port = audio_mixer->in_ports[port_index];
 
-static int notify_mixer_input_avail_l(struct amlAudioMixer *audio_mixer)
-{
-    enum MIXER_INPUT_PORT port_index = 0;
-    for (port_index = 0; port_index < MIXER_INPUT_PORT_NUM; port_index++) {
-        struct input_port *in_port = audio_mixer->in_ports[port_index];
-        if (in_port && in_port->on_input_avail_cbk)
-            in_port->on_input_avail_cbk(in_port->input_avail_cbk_data);
+    if (!in_port) {
+        return -EINVAL;
     }
 
-    return 0;
+    return reset_input_port(in_port);
 }
 
 static int mixer_inports_read(struct amlAudioMixer *audio_mixer)
 {
-    enum MIXER_INPUT_PORT port_index = 0;
-    bool ready = false;
-    bool direct_ready = false;
-    bool is_direct_alive = false;
+    aml_mixer_input_port_type_e port_index = AML_MIXER_INPUT_PORT_PCM_SYSTEM;
+    struct aml_audio_device     *adev = audio_mixer->adev;
 
     ALOGV("++%s(), line %d", __func__, __LINE__);
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    for (port_index = 0; port_index < MIXER_INPUT_PORT_NUM; port_index++) {
+    for (; port_index < AML_MIXER_INPUT_PORT_BUTT; port_index++) {
         struct input_port *in_port = audio_mixer->in_ports[port_index];
-        int ret = 0, fade_out = 0, fade_in = 0;
-        //enum port_state state = ACTIVE;
-        if (!in_port)
-            continue;
 
-        process_port_msg(in_port);
-        enum port_state state = get_inport_state(in_port);
-
-        if (port_index == MIXER_INPUT_PORT_PCM_DIRECT) {
-            //if in pausing states, don't retrieve data
-            if (state == PAUSING) {
-                fade_out = 1;
-            } else if (state == RESUMING) {
-                fade_in = 1;
-                ALOGI("%s(), tsync resume", __func__);
-                aml_hwsync_set_tsync_resume();
-                set_inport_state(in_port, ACTIVE);
-            } else if (state == STOPPED || state == PAUSED || state == FLUSHED) {
-                ALOGV("%s(), stopped, paused or flushed", __func__);
-                //in_port->data_valid = 1;
-                //memset(in_port->data, 0, in_port->data_len_bytes);
-                continue;
-            } else if (state == FLUSHING) {
-                mixer_flush_inport_l(in_port);
-                ALOGI("%s(), flushing->flushed", __func__);
-                set_inport_state(in_port, FLUSHED);
-                //in_port->data_valid = 1;
-                //memset(in_port->data, 0, in_port->data_len_bytes);
-                continue;
-            }
-        }
-        // we are inserting frames
-        if (in_port->data_valid) {
-            ALOGV("%s() portIndex %d already valid", __func__, port_index);
-            if (port_index == MIXER_INPUT_PORT_PCM_DIRECT && get_inport_state(in_port) == ACTIVE) {
-                is_direct_alive = true;
-                direct_ready = true;
-                ready = true;
-            } else if (port_index == MIXER_INPUT_PORT_PCM_SYSTEM) {
-                ready = true;
-            }
-            continue;
-        }
-        if (port_index == MIXER_INPUT_PORT_PCM_DIRECT && get_inport_state(in_port) == ACTIVE)
-            is_direct_alive = true;
-        if (in_port->rbuf_ready(in_port)) {
-            int read_cnt;
-            read_cnt = mixer_read_inport_l(in_port);
-
-            ALOGV("%s() read_cnt %d, portIndex %d", __func__, read_cnt, port_index);
-            if (read_cnt == (int)in_port->data_len_bytes) {
-                if (fade_out) {
-                    ALOGI("%s(), fade out finished pausing->pausing_1", __func__);
+        if (in_port) {
+            int ret = 0, fade_out = 0, fade_in = 0;
+
+            process_port_msg(in_port);
+            enum port_state state = get_inport_state(in_port);
+
+            if (port_index == AML_MIXER_INPUT_PORT_PCM_DIRECT) {
+                //if in pausing states, don't retrieve data
+                if (state == PAUSING) {
+                    fade_out = 1;
                     ALOGI("%s(), tsync pause audio", __func__);
                     aml_hwsync_set_tsync_pause();
-                    audio_fade_func(in_port->data, read_cnt, 0);
-                    set_inport_state(in_port, PAUSED);
-                } else if (fade_in) {
-                    ALOGI("%s(), resuming port index %d", __func__, port_index);
-                    ALOGI("%s(), tsync resume audio", __func__);
-                    //aml_hwsync_set_tsync_resume();
-                    audio_fade_func(in_port->data, read_cnt, 1);
+                } else if (state == RESUMING) {
+                    fade_in = 1;
+                    ALOGI("[%s:%d] input port:%s tsync resume", __func__, __LINE__, inportType2Str(port_index));
+                    aml_hwsync_set_tsync_resume();
                     set_inport_state(in_port, ACTIVE);
+                } else if (state == STOPPED || state == PAUSED || state == FLUSHED) {
+                    ALOGV("[%s:%d] input port:%s stopped, paused or flushed", __func__, __LINE__, inportType2Str(port_index));
+                    continue;
+                } else if (state == FLUSHING) {
+                    mixer_flush_inport(audio_mixer, port_index);
+                    ALOGI("[%s:%d] input port:%s flushing->flushed", __func__, __LINE__, inportType2Str(port_index));
+                    set_inport_state(in_port, FLUSHED);
+                    continue;
                 }
-                update_inport_avail_l(in_port);
-                ready = true;
-                if (port_index == MIXER_INPUT_PORT_PCM_DIRECT)
-                    direct_ready = true;
-
-                if (getprop_bool("media.audiohal.inport") &&
-                        (in_port->port_index == MIXER_INPUT_PORT_PCM_DIRECT)) {
-                    aml_audio_dump_audio_bitstreams("/data/audio/inportDirectFade.raw",
-                            in_port->data, in_port->data_len_bytes);
+                if (get_inport_state(in_port) == ACTIVE && in_port->data_valid) {
+                    ALOGI("[%s:%d] input port:%s data already valid", __func__, __LINE__, inportType2Str(port_index));
+                    continue;
+                }
+            } else {
+                if (in_port->data_valid) {
+                    ALOGI("[%s:%d] input port:%s data already valid", __func__, __LINE__, inportType2Str(port_index));
+                    continue;
+                }
+            }
+
+            if (in_port->rbuf_ready(in_port)) {
+                ret = mixer_read_inport(audio_mixer, port_index, in_port->data, in_port->data_len_bytes);
+                if (ret == (int)in_port->data_len_bytes) {
+                    if (fade_out) {
+                        ALOGI("[%s:%d] output port:%s fade out, pausing->pausing_1, tsync pause audio",
+                            __func__, __LINE__, inportType2Str(port_index));
+                        audio_fade_func(in_port->data, ret, 0);
+                        set_inport_state(in_port, PAUSED);
+                    } else if (fade_in) {
+                        ALOGI("[%s:%d] input port:%s fade in", __func__, __LINE__, inportType2Str(port_index));
+                        audio_fade_func(in_port->data, ret, 1);
+                        set_inport_state(in_port, ACTIVE);
+                    }
+                    update_inport_avail(in_port);
+                    if (getprop_bool("media.audiohal.inport") &&
+                            (in_port->enInPortType == AML_MIXER_INPUT_PORT_PCM_DIRECT)) {
+                            aml_audio_dump_audio_bitstreams("/data/audio/inportDirectFade.raw",
+                                    in_port->data, in_port->data_len_bytes);
+                    }
+                } else {
+                    ALOGW("[%s:%d] port:%s read fail, have read:%d Byte, need %d Byte", __func__, __LINE__,
+                        inportType2Str(port_index), ret, in_port->data_len_bytes);
+                }
+            } else {
+                if (adev->debug_flag) {
+                    ALOGI("[%s:%d] port:%s ring buffer data is not enough", __func__, __LINE__, inportType2Str(port_index));
                 }
-            }else {
-                ALOGE("%s() read read_cnt = %d, portIndex %d", __func__, read_cnt, port_index);
             }
         }
     }
-    notify_mixer_input_avail_l(audio_mixer);
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
 
-    // if one port ready, propagate to do mixing out
-    if (ready) {
-        if (is_direct_alive && !direct_ready) {
-            ALOGV("%s(), -----------------direct not ready, next turn", __func__);
-            return -EAGAIN;
-        }
-        return 0;
-    } else
-        return -EAGAIN;
+    return 0;
 }
 
-#if 0
-static int check_mixer_state(struct amlAudioMixer *audio_mixer)
+int check_mixer_state(struct amlAudioMixer *audio_mixer)
 {
-    enum MIXER_INPUT_PORT port_index = 0;
+    aml_mixer_input_port_type_e port_index = 0;
     int inport_avail = 0, inport_ready = 0;
 
     ALOGV("++%s(), line %d", __func__, __LINE__);
-    for (port_index = 0; port_index < MIXER_INPUT_PORT_NUM; port_index++) {
+    for (port_index = 0; port_index < AML_MIXER_INPUT_PORT_BUTT; port_index++) {
         struct input_port *in_port = audio_mixer->in_ports[port_index];
         if (in_port) {
             inport_avail = 1;
@@ -776,56 +668,11 @@ static int check_mixer_state(struct amlAudioMixer *audio_mixer)
     return 0;
 }
 
-static int mixer_need_wait_forever(struct amlAudioMixer *audio_mixer)
+int mixer_need_wait_forever(struct amlAudioMixer *audio_mixer)
 {
     return mixer_get_state(audio_mixer) != MIXER_INPORTS_READY;
 }
 
-static int mixer_prepare_inport_data(struct amlAudioMixer *audio_mixer)
-{
-    enum MIXER_INPUT_PORT port_index = 0;
-    ALOGV("++%s(), line %d", __func__, __LINE__);
-
-    // in port data not ready
-    if (!is_mixer_inports_ready(audio_mixer)) {
-        struct timespec ts;
-        ALOGV("++%s(), line %d, inport not ready", __func__, __LINE__);
-
-        memset(&ts, 0, sizeof(struct timespec));
-        ts_wait_time_us(&ts, 5000);
-        pthread_mutex_lock(&audio_mixer->lock);
-        check_mixer_state(audio_mixer);
-        if (mixer_need_wait_forever(audio_mixer)) {
-            ALOGI("%s(), wait forever %d", __func__, __LINE__);
-            pthread_cond_wait(&audio_mixer->cond, &audio_mixer->lock);
-            ALOGI("%s(),wait wakeup line %d", __func__, __LINE__);
-        } else {
-            ALOGV("%s(),wait timed %d", __func__, __LINE__);
-            pthread_cond_timedwait(&audio_mixer->cond, &audio_mixer->lock, &ts);
-            ALOGV("%s(),wait wakeup line %d", __func__, __LINE__);
-        }
-        ALOGV("%s(),wait wakeup line %d", __func__, __LINE__);
-        pthread_mutex_unlock(&audio_mixer->lock);
-    }
-
-    if (is_mixer_inports_ready(audio_mixer)) {
-        mixer_inports_read(audio_mixer);
-    } else {
-        struct input_port *in_port = audio_mixer->in_ports[MIXER_INPUT_PORT_PCM_DIRECT];
-        if (in_port) {
-            if (!in_port->rbuf_ready(in_port) && get_inport_state(in_port) == ACTIVE) {
-                ALOGE("%s() inport data not ready, state (%d)", __func__, get_inport_state(in_port));
-                usleep(5000);
-                return -EAGAIN;
-            }
-        }
-    }
-
-    ALOGV("--%s(), line %d", __func__, __LINE__);
-    return 0;
-}
-#endif
-
 static inline int16_t CLIP16(int r)
 {
     return (r >  0x7fff) ? 0x7fff :
@@ -844,6 +691,7 @@ static int retrieve_hwsync_header(struct amlAudioMixer *audio_mixer,
     uint32_t frame_size = get_mixer_hwsync_frame_size(audio_mixer);
     uint32_t port_consumed_size = get_inport_consumed_size(in_port);
     uint32_t aligned_offset = 0;
+    int diff_ms = 0;
     struct hw_avsync_header header;
     int ret = 0;
 
@@ -859,36 +707,34 @@ static int retrieve_hwsync_header(struct amlAudioMixer *audio_mixer,
 
     aligned_offset = hwsync_align_to_frame(port_consumed_size, frame_size);
     memset(&header, 0, sizeof(struct hw_avsync_header));
-    if (1) {
-        int diff_ms = 0;
-        ALOGV("direct out port bytes before cbk %d", get_outport_data_avail(out_port));
-        if (!in_port->meta_data_cbk) {
-            ALOGE("no meta_data_cbk set!!");
-            return -EINVAL;
-        }
-        ALOGV("%s(), port %p, data %p", __func__, in_port, in_port->meta_data_cbk_data);
-        ret = in_port->meta_data_cbk(in_port->meta_data_cbk_data,
-                    aligned_offset, &header, &diff_ms);
-        if (ret < 0) {
-            if (ret != -EAGAIN)
-                ALOGE("meta_data_cbk fail err = %d!!", ret);
-            return ret;
-        }
-        ALOGV("%s(), meta data cbk, diffms = %d", __func__, diff_ms);
-        if (diff_ms > 0) {
-            in_port->bytes_to_insert = diff_ms * 48 * 4;
-        } else if (diff_ms < 0) {
-            in_port->bytes_to_skip = -diff_ms * 48 * 4;
-        }
+    ALOGV("direct out port bytes before cbk %d", get_outport_data_avail(out_port));
+    if (!in_port->meta_data_cbk) {
+        ALOGE("no meta_data_cbk set!!");
+        return -EINVAL;
+    }
+    ALOGV("%s(), port %p, data %p", __func__, in_port, in_port->meta_data_cbk_data);
+    ret = in_port->meta_data_cbk(in_port->meta_data_cbk_data,
+                aligned_offset, &header, &diff_ms);
+    if (ret < 0) {
+        if (ret != -EAGAIN)
+            ALOGE("meta_data_cbk fail err = %d!!", ret);
+        return ret;
+    }
+    ALOGV("%s(), meta data cbk, diffms = %d", __func__, diff_ms);
+    if (diff_ms > 0) {
+        in_port->bytes_to_insert = diff_ms * 48 * 4;
+    } else if (diff_ms < 0) {
+        in_port->bytes_to_skip = -diff_ms * 48 * 4;
     }
 
     return 0;
 }
 
+
 static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
 {
-    int ret;
-    struct input_port *in_port_sys,*in_port_drct;
+    struct input_port *in_port_sys = audio_mixer->in_ports[AML_MIXER_INPUT_PORT_PCM_SYSTEM];
+    struct input_port *in_port_drct = audio_mixer->in_ports[AML_MIXER_INPUT_PORT_PCM_DIRECT];
     struct output_port *out_port = audio_mixer->out_ports[MIXER_OUTPUT_PORT_PCM];
     struct aml_audio_device *adev = audio_mixer->adev;
     int16_t *data_sys, *data_drct, *data_mixed;
@@ -905,16 +751,9 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
         ALOGE("%s(), out null !!!", __func__);
         return 0;
     }
-
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-
-    in_port_sys = audio_mixer->in_ports[MIXER_INPUT_PORT_PCM_SYSTEM];
-    in_port_drct = audio_mixer->in_ports[MIXER_INPUT_PORT_PCM_DIRECT];
-
     if (!in_port_sys && !in_port_drct) {
         ALOGE("%s(), sys or direct pcm must exist!!!", __func__);
-        ret = -1;
-        goto _error;
+        return 0;
     }
 
     if (in_port_sys && in_port_sys->data_valid) {
@@ -932,12 +771,11 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
         sys_only = 1;
     } else {
         ALOGV("%s(), sys direct both not ready!", __func__);
-        ret = -EINVAL;
-        goto _error;
+        return -EINVAL;
     }
 
     data_mixed = (int16_t *)out_port->data_buf;
-    memset(audio_mixer->tmp_buffer, 0 , audio_mixer->buf_frames * 8);
+    memset(audio_mixer->tmp_buffer, 0 , MIXER_FRAME_COUNT * MIXER_OUT_FRAME_SIZE);
     if (mixing) {
         ALOGV("%s() mixing", __func__);
         data_sys = (int16_t *)in_port_sys->data;
@@ -950,18 +788,13 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
             aml_audio_dump_audio_bitstreams("/data/audio/audiosyst.raw",
                     in_port_sys->data, in_port_sys->data_len_bytes);
         }
-        if (is_inport_hwsync(in_port_drct) && in_port_drct->bytes_to_insert < mixing_len_bytes) {
+        if (in_port_drct->is_hwsync && in_port_drct->bytes_to_insert < mixing_len_bytes) {
             retrieve_hwsync_header(audio_mixer, in_port_drct, out_port);
         }
 
-        frames = mixing_len_bytes / in_port_drct->cfg.frame_size;
-        if (frames > MIXER_OUT_FRAME_COUNT) {
-            ALOGE("%s() %d too many frames %d", __func__, __LINE__, frames);
-            frames = MIXER_OUT_FRAME_COUNT;
-        }
-
         // insert data for direct hwsync case, only send system sound
         if (in_port_drct->bytes_to_insert >= mixing_len_bytes) {
+            frames = mixing_len_bytes / in_port_drct->cfg.frame_size;
             ALOGD("%s() insert mixing data, need %zu, insert length %zu",
                     __func__, in_port_drct->bytes_to_insert, mixing_len_bytes);
             //memcpy(data_mixed, data_sys, mixing_len_bytes);
@@ -972,17 +805,14 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
             }
             frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_sys,
                 frames, in_port_sys->cfg, out_port->cfg);
-
-            in_port_drct->bytes_to_insert -= mixing_len_bytes;
-            in_port_sys->data_valid = 0;
-            pthread_mutex_unlock(&audio_mixer->inport_lock);
-
             if (DEBUG_DUMP) {
                 aml_audio_dump_audio_bitstreams("/data/audio/sysAftermix.raw",
                         audio_mixer->tmp_buffer, frames * FRAMESIZE_32BIT_STEREO);
             }
-            apply_volume(gain_speaker, audio_mixer->tmp_buffer,
+            if (adev->is_TV) {
+                apply_volume(gain_speaker, audio_mixer->tmp_buffer,
                     sizeof(uint32_t), frames * FRAMESIZE_32BIT_STEREO);
+            }
 #ifdef IS_ATOM_PROJECT
             if (adev->has_dsp_lib) {
                 dsp_process_output(audio_mixer->adev,
@@ -998,8 +828,11 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
                 aml_audio_dump_audio_bitstreams("/data/audio/dataInsertMixed.raw",
                         data_mixed, frames * out_port->cfg.frame_size);
             }
+            in_port_drct->bytes_to_insert -= mixing_len_bytes;
+            in_port_sys->data_valid = 0;
             set_outport_data_avail(out_port, frames * out_port->cfg.frame_size);
         } else {
+            frames = mixing_len_bytes / in_port_drct->cfg.frame_size;
             frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_drct,
                 frames, in_port_drct->cfg, out_port->cfg);
             if (DEBUG_DUMP)
@@ -1007,16 +840,13 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
                     audio_mixer->tmp_buffer, frames * audio_mixer->frame_size_tmp);
             frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_sys,
                 frames, in_port_sys->cfg, out_port->cfg);
-
-            in_port_drct->data_valid = 0;
-            in_port_sys->data_valid = 0;
-            pthread_mutex_unlock(&audio_mixer->inport_lock);
-
             if (DEBUG_DUMP)
                 aml_audio_dump_audio_bitstreams("/data/audio/tmpMixed1.raw",
                     audio_mixer->tmp_buffer, frames * audio_mixer->frame_size_tmp);
-            apply_volume(gain_speaker, audio_mixer->tmp_buffer,
+            if (adev->is_TV) {
+                apply_volume(gain_speaker, audio_mixer->tmp_buffer,
                     sizeof(uint32_t), frames * FRAMESIZE_32BIT_STEREO);
+            }
 #ifdef IS_ATOM_PROJECT
             if (adev->has_dsp_lib) {
                 dsp_process_output(audio_mixer->adev,
@@ -1028,19 +858,18 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
                 extend_channel_2_8(data_mixed, audio_mixer->tmp_buffer,
                         frames, 2, 8);
 
+            in_port_drct->data_valid = 0;
+            in_port_sys->data_valid = 0;
             set_outport_data_avail(out_port, frames * out_port->cfg.frame_size);
         }
         if (DEBUG_DUMP) {
             aml_audio_dump_audio_bitstreams("/data/audio/data_mixed.raw",
                 out_port->data_buf, frames * out_port->cfg.frame_size);
         }
-    } else if (sys_only) {
-        frames = in_port_sys->data_buf_frame_cnt;
-        if (frames > MIXER_OUT_FRAME_COUNT) {
-            ALOGE("%s() %d too many frames %d", __func__, __LINE__, frames);
-            frames = MIXER_OUT_FRAME_COUNT;
-        }
+    }
 
+    if (sys_only) {
+        frames = in_port_sys->data_buf_frame_cnt;
         ALOGV("%s() sys_only, frames %d", __func__, frames);
         mixing_len_bytes = in_port_sys->data_len_bytes;
         data_sys = (int16_t *)in_port_sys->data;
@@ -1052,16 +881,14 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
         // processing_and_convert(data_mixed, data_sys, frames, in_port_sys->cfg, out_port->cfg);
         frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_sys,
                 frames, in_port_sys->cfg, out_port->cfg);
-
-        in_port_sys->data_valid = 0;
-        pthread_mutex_unlock(&audio_mixer->inport_lock);
-
         if (DEBUG_DUMP) {
             aml_audio_dump_audio_bitstreams("/data/audio/sysTmp.raw",
                     audio_mixer->tmp_buffer, frames * FRAMESIZE_32BIT_STEREO);
         }
-        apply_volume(gain_speaker, audio_mixer->tmp_buffer,
+        if (adev->is_TV) {
+            apply_volume(gain_speaker, audio_mixer->tmp_buffer,
                 sizeof(uint32_t), frames * FRAMESIZE_32BIT_STEREO);
+        }
         if (DEBUG_DUMP) {
             aml_audio_dump_audio_bitstreams("/data/audio/sysvol.raw",
                     audio_mixer->tmp_buffer, frames * FRAMESIZE_32BIT_STEREO);
@@ -1080,8 +907,11 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
             aml_audio_dump_audio_bitstreams("/data/audio/extandsys.raw",
                     data_mixed, frames * out_port->cfg.frame_size);
         }
+        in_port_sys->data_valid = 0;
         set_outport_data_avail(out_port, frames * out_port->cfg.frame_size);
-    } else if (direct_only) {
+    }
+
+    if (direct_only) {
         ALOGV("%s() direct_only", __func__);
         //dirct_vol = get_inport_volume(in_port_drct);
         mixing_len_bytes = in_port_drct->data_len_bytes;
@@ -1089,7 +919,7 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
         ALOGV("%s() direct_only, inport consumed %d",
                 __func__, get_inport_consumed_size(in_port_drct));
 
-        if (is_inport_hwsync(in_port_drct) && in_port_drct->bytes_to_insert < mixing_len_bytes) {
+        if (in_port_drct->is_hwsync && in_port_drct->bytes_to_insert < mixing_len_bytes) {
             retrieve_hwsync_header(audio_mixer, in_port_drct, out_port);
         }
 
@@ -1097,42 +927,33 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
             aml_audio_dump_audio_bitstreams("/data/audio/audiodrct.raw",
                     in_port_drct->data, mixing_len_bytes);
         }
-
         // insert 0 data to delay audio
-        frames = mixing_len_bytes / in_port_drct->cfg.frame_size;
-        if (frames > MIXER_OUT_FRAME_COUNT) {
-            ALOGE("%s() %d too many frames %d", __func__, __LINE__, frames);
-            frames = MIXER_OUT_FRAME_COUNT;
-        }
-
         if (in_port_drct->bytes_to_insert >= mixing_len_bytes) {
+            frames = mixing_len_bytes / in_port_drct->cfg.frame_size;
             ALOGD("%s() inserting direct_only, need %zu, insert length %zu",
                     __func__, in_port_drct->bytes_to_insert, mixing_len_bytes);
             memset(data_mixed, 0, mixing_len_bytes);
             extend_channel_2_8(data_mixed, audio_mixer->tmp_buffer,
                     frames, 2, 8);
             in_port_drct->bytes_to_insert -= mixing_len_bytes;
-
-            pthread_mutex_unlock(&audio_mixer->inport_lock);
             set_outport_data_avail(out_port, frames * out_port->cfg.frame_size);
         } else {
             ALOGV("%s() direct_only, vol %f", __func__, dirct_vol);
+            frames = mixing_len_bytes / in_port_drct->cfg.frame_size;
             //cpy_16bit_data_with_gain(data_mixed, data_drct,
             //        in_port_drct->data_len_bytes, dirct_vol);
             ALOGV("%s() direct_only, frames %d, bytes %d", __func__, frames, mixing_len_bytes);
 
             frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_drct,
                 frames, in_port_drct->cfg, out_port->cfg);
-            in_port_drct->data_valid = 0;
-            pthread_mutex_unlock(&audio_mixer->inport_lock);
-
             if (DEBUG_DUMP) {
                 aml_audio_dump_audio_bitstreams("/data/audio/dirctTmp.raw",
                         audio_mixer->tmp_buffer, frames * FRAMESIZE_32BIT_STEREO);
             }
-            apply_volume(gain_speaker, audio_mixer->tmp_buffer,
+            if (adev->is_TV) {
+                apply_volume(gain_speaker, audio_mixer->tmp_buffer,
                     sizeof(uint32_t), frames * FRAMESIZE_32BIT_STEREO);
-
+            }
 #ifdef IS_ATOM_PROJECT
             if (adev->has_dsp_lib) {
                 dsp_process_output(audio_mixer->adev,
@@ -1148,6 +969,7 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
                 aml_audio_dump_audio_bitstreams("/data/audio/exDrct.raw",
                         data_mixed, frames * out_port->cfg.frame_size);
             }
+            in_port_drct->data_valid = 0;
             set_outport_data_avail(out_port, frames * out_port->cfg.frame_size);
         }
     }
@@ -1157,237 +979,95 @@ static int mixer_do_mixing_32bit(struct amlAudioMixer *audio_mixer)
                 out_port->data_buf, mixing_len_bytes);
     }
     return 0;
+}
 
-_error:
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return ret;
+static int mixer_add_mixing_data(void *pMixedBuf, struct input_port *pInputPort, struct output_port *pOutputPort)
+{
+    if (pInputPort->data_buf_frame_cnt < MIXER_FRAME_COUNT) {
+        ALOGE("[%s:%d] input port type:%s buf frames:%d too small", __func__, __LINE__,
+            inportType2Str(pInputPort->enInPortType), pInputPort->data_buf_frame_cnt);
+        return -EINVAL;
+    }
+    do_mixing_2ch(pMixedBuf, pInputPort->data, MIXER_FRAME_COUNT, pInputPort->cfg, pOutputPort->cfg);
+    pInputPort->data_valid = 0;
+    return 0;
 }
 
 static int mixer_do_mixing_16bit(struct amlAudioMixer *audio_mixer)
 {
-    int ret;
-    struct input_port *in_port_sys, *in_port_drct;
-    struct output_port *out_port = audio_mixer->out_ports[MIXER_OUTPUT_PORT_PCM];
-    struct aml_audio_device *adev = audio_mixer->adev;
-    int16_t *data_sys, *data_drct, *data_mixed;
-    int mixing = 0, sys_only = 0, direct_only = 0;
-    int dirct_okay = 0, sys_okay = 0;
-    float dirct_vol = 1.0, sys_vol = 1.0;
-    int mixed_32 = 0;
-    size_t i = 0, mixing_len_bytes = 0;
-    size_t frames = 0;
-    size_t frames_written = 0;
-    float gain_speaker = adev->sink_gain[OUTPORT_SPEAKER];
-    float gain_outport = adev->sink_gain[adev->active_outport];
-    ALOGV("%s(), speaker gain %f, outport gain %f",
-        __func__, gain_speaker, gain_outport);
+    struct input_port           *pstInputPort = NULL;
+    struct output_port          *pstOutPort = audio_mixer->out_ports[MIXER_OUTPUT_PORT_PCM];
+    struct aml_audio_device     *adev = audio_mixer->adev;
 
-    if (!out_port) {
-        ALOGE("%s(), out null !!!", __func__);
+    if (NULL == pstOutPort) {
+        ALOGE("[%s:%d] outport is null", __func__, __LINE__);
         return 0;
     }
 
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-
-    in_port_sys = audio_mixer->in_ports[MIXER_INPUT_PORT_PCM_SYSTEM];
-    in_port_drct = audio_mixer->in_ports[MIXER_INPUT_PORT_PCM_DIRECT];
-
-    if (!in_port_sys && !in_port_drct) {
-        ALOGE("%s(), sys or direct pcm must exist!!!", __func__);
-        ret = -1;
-        goto _error;
-    }
-
-    if (in_port_sys) {
-        if (in_port_sys->data_valid)
-            sys_okay = 1;
-        else
-            ALOGV("%s(), sys port ready, but no valid data, maybe underrun", __func__);
-    }
-    if (in_port_drct) {
-        if (in_port_drct->data_valid)
-            dirct_okay = 1;
-        else {
-            ALOGW("%s(), direct port ready, but no valid data, maybe underrun, state%d",
-                __func__, get_inport_state(in_port_drct));
-        //dirct_okay = 1;
-        }
-    }
-    if (sys_okay && dirct_okay) {
-        mixing = 1;
-    } else if (dirct_okay) {
-        ALOGV("only direct okay");
-        direct_only = 1;
-    } else if (sys_okay) {
-        sys_only = 1;
-    } else {
-        ALOGV("%s(), sys direct both not ready!", __func__);
-        ret = -EINVAL;
-        goto _error;
-    }
-
-    data_mixed = (int16_t *)out_port->data_buf;
-    memset(audio_mixer->tmp_buffer, 0 , audio_mixer->buf_frames * 8);
-    if (mixing) {
-        ALOGV("%s() mixing", __func__);
-        data_sys = (int16_t *)in_port_sys->data;
-        data_drct = (int16_t *)in_port_drct->data;
-        mixing_len_bytes = in_port_drct->data_len_bytes;
-        //TODO: check if the two stream's frames are equal
-        if (DEBUG_DUMP) {
-            aml_audio_dump_audio_bitstreams("/data/audio/audiodrct.raw",
-                    in_port_drct->data, in_port_drct->data_len_bytes);
-            aml_audio_dump_audio_bitstreams("/data/audio/audiosyst.raw",
-                    in_port_sys->data, in_port_sys->data_len_bytes);
-        }
-        if (is_inport_hwsync(in_port_drct) && in_port_drct->bytes_to_insert < mixing_len_bytes) {
-            retrieve_hwsync_header(audio_mixer, in_port_drct, out_port);
-        }
-
-        frames = mixing_len_bytes / in_port_drct->cfg.frame_size;
-        if (frames > MIXER_OUT_FRAME_COUNT) {
-            ALOGE("%s() %d too many frames %d", __func__, __LINE__, frames);
-            frames = MIXER_OUT_FRAME_COUNT;
-        }
-        // insert data for direct hwsync case, only send system sound
-        if (in_port_drct->bytes_to_insert >= mixing_len_bytes) {
-            ALOGD("%s() insert mixing data, need %zu, insert length %zu",
-                    __func__, in_port_drct->bytes_to_insert, mixing_len_bytes);
-            frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_sys,
-                    frames, in_port_sys->cfg, out_port->cfg);
-
-            in_port_drct->bytes_to_insert -= mixing_len_bytes;
-            in_port_sys->data_valid = 0;
-            pthread_mutex_unlock(&audio_mixer->inport_lock);
-
-            memcpy(data_mixed, audio_mixer->tmp_buffer, frames * out_port->cfg.frame_size);
-        } else {
-            frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_drct,
-                frames, in_port_drct->cfg, out_port->cfg);
-            if (DEBUG_DUMP)
-                aml_audio_dump_audio_bitstreams("/data/audio/tmpMixed0.raw",
-                    audio_mixer->tmp_buffer, frames * audio_mixer->frame_size_tmp);
-            frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_sys,
-                frames, in_port_sys->cfg, out_port->cfg);
-
-            in_port_drct->data_valid = 0;
-            in_port_sys->data_valid = 0;
-            pthread_mutex_unlock(&audio_mixer->inport_lock);
-
-            if (DEBUG_DUMP)
-                aml_audio_dump_audio_bitstreams("/data/audio/tmpMixed1.raw",
-                    audio_mixer->tmp_buffer, frames * audio_mixer->frame_size_tmp);
-            apply_volume(gain_speaker, audio_mixer->tmp_buffer,
-                    sizeof(uint16_t), frames * out_port->cfg.frame_size);
-
-            memcpy(data_mixed, audio_mixer->tmp_buffer, frames * out_port->cfg.frame_size);
-        }
-        set_outport_data_avail(out_port, frames * out_port->cfg.frame_size);
-    } else if (sys_only) {
-        frames = in_port_sys->data_buf_frame_cnt;
-        if (frames > MIXER_OUT_FRAME_COUNT) {
-            ALOGE("%s() %d too many frames %d", __func__, __LINE__, frames);
-            frames = MIXER_OUT_FRAME_COUNT;
-        }
-        ALOGV("%s() sys_only, frames %d", __func__, frames);
-        mixing_len_bytes = in_port_sys->data_len_bytes;
-        data_sys = (int16_t *)in_port_sys->data;
-        if (DEBUG_DUMP) {
-            aml_audio_dump_audio_bitstreams("/data/audio/audiosyst.raw",
-                    in_port_sys->data, mixing_len_bytes);
-        }
-        // processing data and make convertion according to cfg
-        // processing_and_convert(data_mixed, data_sys, frames, in_port_sys->cfg, out_port->cfg);
-        frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_sys,
-                frames, in_port_sys->cfg, out_port->cfg);
-        in_port_sys->data_valid = 0;
-        pthread_mutex_unlock(&audio_mixer->inport_lock);
-
-        if (DEBUG_DUMP) {
-            aml_audio_dump_audio_bitstreams("/data/audio/sysTmp.raw",
-                    audio_mixer->tmp_buffer, frames * out_port->cfg.frame_size);
-        }
-
-        apply_volume(gain_speaker, audio_mixer->tmp_buffer,
-                sizeof(uint16_t), frames * out_port->cfg.frame_size);
-        if (DEBUG_DUMP) {
-            aml_audio_dump_audio_bitstreams("/data/audio/sysvol.raw",
-                    audio_mixer->tmp_buffer, frames * out_port->cfg.frame_size);
-        }
-
-        memcpy(data_mixed, audio_mixer->tmp_buffer, frames * out_port->cfg.frame_size);
-        set_outport_data_avail(out_port, frames * out_port->cfg.frame_size);
-    } else if (direct_only) {
-        ALOGV("%s() direct_only", __func__);
-        //dirct_vol = get_inport_volume(in_port_drct);
-        mixing_len_bytes = in_port_drct->data_len_bytes;
-        data_drct = (int16_t *)in_port_drct->data;
-        ALOGV("%s() direct_only, inport consumed %d",
-                __func__, get_inport_consumed_size(in_port_drct));
-
-        if (is_inport_hwsync(in_port_drct) && in_port_drct->bytes_to_insert < mixing_len_bytes) {
-            retrieve_hwsync_header(audio_mixer, in_port_drct, out_port);
+    memset(audio_mixer->tmp_buffer, 0, MIXER_FRAME_COUNT * MIXER_OUT_FRAME_SIZE);
+    for (int i = AML_MIXER_INPUT_PORT_PCM_SYSTEM; i < AML_MIXER_INPUT_PORT_BUTT; i++) {
+        pstInputPort = audio_mixer->in_ports[i];
+        if (NULL == pstInputPort) {
+            continue;
         }
-
-        if (DEBUG_DUMP) {
-            aml_audio_dump_audio_bitstreams("/data/audio/audiodrct.raw",
-                    in_port_drct->data, mixing_len_bytes);
+        if (0 == pstInputPort->data_valid) {
+            if (adev->debug_flag) {
+                ALOGI("[%s:%d] inport:%s, but no valid data, maybe underrun", __func__, __LINE__, inportType2Str(i));
+            }
+            continue;
         }
-        // insert 0 data to delay audio
-        frames = mixing_len_bytes / in_port_drct->cfg.frame_size;
-        if (frames > MIXER_OUT_FRAME_COUNT) {
-            ALOGE("%s() %d too many frames %d", __func__, __LINE__, frames);
-            frames = MIXER_OUT_FRAME_COUNT;
+        if (getprop_bool("media.audiohal.indump")) {
+            char acFilePathStr[ENUM_TYPE_STR_MAX_LEN];
+            sprintf(acFilePathStr, "/data/audio/%s", inportType2Str(i));
+            aml_audio_dump_audio_bitstreams(acFilePathStr, pstInputPort->data, pstInputPort->data_len_bytes);
         }
-
-        if (in_port_drct->bytes_to_insert >= mixing_len_bytes) {
-            ALOGD("%s() inserting direct_only, need %zu, insert length %zu",
-                    __func__, in_port_drct->bytes_to_insert, mixing_len_bytes);
-            in_port_drct->bytes_to_insert -= mixing_len_bytes;
-            pthread_mutex_unlock(&audio_mixer->inport_lock);
-
-            memset(data_mixed, 0, mixing_len_bytes);
-        } else {
-            ALOGV("%s() direct_only, vol %f", __func__, dirct_vol);
-            ALOGV("%s() direct_only, frames %d, bytes %d", __func__, frames, mixing_len_bytes);
-
-            frames_written = do_mixing_2ch(audio_mixer->tmp_buffer, data_drct,
-                frames, in_port_drct->cfg, out_port->cfg);
-            in_port_drct->data_valid = 0;
-            pthread_mutex_unlock(&audio_mixer->inport_lock);
-
-            if (DEBUG_DUMP) {
-                aml_audio_dump_audio_bitstreams("/data/audio/dirctTmp.raw",
-                        audio_mixer->tmp_buffer, frames * out_port->cfg.frame_size);
+        if (AML_MIXER_INPUT_PORT_PCM_DIRECT == i) {
+            if (pstInputPort->is_hwsync && pstInputPort->bytes_to_insert < pstInputPort->data_len_bytes) {
+                retrieve_hwsync_header(audio_mixer, pstInputPort, pstOutPort);
             }
-            apply_volume(gain_speaker, audio_mixer->tmp_buffer,
-                    sizeof(uint16_t), frames * out_port->cfg.frame_size);
 
-            memcpy(data_mixed, audio_mixer->tmp_buffer, frames * out_port->cfg.frame_size);
-            if (DEBUG_DUMP) {
-                aml_audio_dump_audio_bitstreams("/data/audio/volumeDirect.raw",
-                        data_mixed, frames * out_port->cfg.frame_size);
+            if (pstInputPort->bytes_to_insert >= pstInputPort->data_len_bytes) {
+                pstInputPort->bytes_to_insert -= pstInputPort->data_len_bytes;
+                ALOGD("[%s:%d] PCM_DIRECT inport insert mute data, still need %zu, inserted length %zu", __func__, __LINE__,
+                        pstInputPort->bytes_to_insert, pstInputPort->data_len_bytes);
+                continue;
             }
         }
-        set_outport_data_avail(out_port, frames * out_port->cfg.frame_size);
+        mixer_add_mixing_data(audio_mixer->tmp_buffer, pstInputPort, pstOutPort);
+    }
+    if (adev->is_TV) {
+        apply_volume(adev->sink_gain[OUTPORT_SPEAKER], audio_mixer->tmp_buffer, sizeof(uint16_t),
+            MIXER_FRAME_COUNT * pstOutPort->cfg.frame_size);
     }
+    memcpy(pstOutPort->data_buf, audio_mixer->tmp_buffer, MIXER_FRAME_COUNT * pstOutPort->cfg.frame_size);
+    if (getprop_bool("media.audiohal.outdump")) {
+        aml_audio_dump_audio_bitstreams("/data/audio/audio_mixed", pstOutPort->data_buf,
+            MIXER_FRAME_COUNT * pstOutPort->cfg.frame_size);
+    }
+    set_outport_data_avail(pstOutPort, MIXER_FRAME_COUNT * pstOutPort->cfg.frame_size);
     return 0;
+}
 
-_error:
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return ret;
+int notify_mixer_input_avail(struct amlAudioMixer *audio_mixer)
+{
+    aml_mixer_input_port_type_e port_index = 0;
+    for (port_index = 0; port_index < AML_MIXER_INPUT_PORT_BUTT; port_index++) {
+        struct input_port *in_port = audio_mixer->in_ports[port_index];
+        if (in_port && in_port->on_input_avail_cbk)
+            in_port->on_input_avail_cbk(in_port->input_avail_cbk_data);
+    }
+
+    return 0;
 }
 
 int notify_mixer_exit(struct amlAudioMixer *audio_mixer)
 {
-    enum MIXER_INPUT_PORT port_index = 0;
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    for (port_index = 0; port_index < MIXER_INPUT_PORT_NUM; port_index++) {
+    aml_mixer_input_port_type_e port_index = 0;
+    for (port_index = 0; port_index < AML_MIXER_INPUT_PORT_BUTT; port_index++) {
         struct input_port *in_port = audio_mixer->in_ports[port_index];
         if (in_port && in_port->on_notify_cbk)
             in_port->on_notify_cbk(in_port->notify_cbk_data);
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
 
     return 0;
 }
@@ -1409,40 +1089,12 @@ static int set_thread_affinity(void)
     return 0;
 }
 
-static int mixer_do_continous_output(struct amlAudioMixer *audio_mixer)
-{
-    struct output_port *out_port = audio_mixer->out_ports[MIXER_OUTPUT_PORT_PCM];
-    int16_t *data_mixed = (int16_t *)out_port->data_buf;
-    size_t frames = 4;
-    size_t bytes = frames * out_port->cfg.frame_size;
-
-    memset(data_mixed, 0 , bytes);
-    set_outport_data_avail(out_port, bytes);
-    mixer_output_write(audio_mixer);
-    return 0;
-}
-
-static bool mixer_inports_exist(struct amlAudioMixer *audio_mixer)
-{
-    enum MIXER_INPUT_PORT port_index = 0;
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    for (port_index = 0; port_index < MIXER_INPUT_PORT_NUM; port_index++) {
-        struct input_port *in_port = audio_mixer->in_ports[port_index];
-        if (in_port) {
-            pthread_mutex_unlock(&audio_mixer->inport_lock);
-            return true;
-        }
-    }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return false;
-}
-
 #define THROTTLE_TIME_US 5000
 static void *mixer_32b_threadloop(void *data)
 {
     struct amlAudioMixer *audio_mixer = data;
     enum MIXER_OUTPUT_PORT port_index = MIXER_OUTPUT_PORT_PCM;
-    enum MIXER_INPUT_PORT in_index = MIXER_INPUT_PORT_PCM_SYSTEM;
+    aml_mixer_input_port_type_e in_index = AML_MIXER_INPUT_PORT_PCM_SYSTEM;
     int ret = 0;
 
     ALOGI("++%s start", __func__);
@@ -1453,184 +1105,122 @@ static void *mixer_32b_threadloop(void *data)
     while (!audio_mixer->exit_thread) {
         //pthread_mutex_lock(&audio_mixer->lock);
         //mixer_procs_msg_queue(audio_mixer);
-#if 0
-        // TODO: throttle rate
-        if (!is_output_data_avail(audio_mixer, port_index)) {
-            ret = mixer_prepare_inport_data(audio_mixer);
-            if (ret < 0) {
-                notify_mixer_input_avail(audio_mixer);
-                continue;
-            }
-            ALOGV("%s %d mixing", __func__, __LINE__);
-            mixer_do_mixing(audio_mixer);
-            //ALOGI("%s %d", __func__, __LINE__);
-            notify_mixer_input_avail(audio_mixer);
-            //ALOGI("%s %d", __func__, __LINE__);
-        } else {
-            mixer_do_mixing(audio_mixer);
-            ALOGW("%s %d, data already avail, should not be here####", __func__, __LINE__);
-            notify_mixer_input_avail(audio_mixer);
-        }
-
-        //Retrieve buffers to "bufferout", and fill them into shared buffer
-        mixer_output_write(audio_mixer);
-#endif
         // processing throttle
         struct timespec tval_new;
         clock_gettime(CLOCK_MONOTONIC, &tval_new);
-        const uint32_t delta_us = tspec_diff_to_us(audio_mixer->tval_last_run, tval_new);
-
-        if (delta_us <= THROTTLE_TIME_US) {
-            struct timespec ts;
-            uint32_t throttle_us = THROTTLE_TIME_US - delta_us;
-
-            ALOGV("%s throttle time_us %d", __func__, throttle_us);
-            //usleep(delta_us);
-            ts_wait_time_us(&ts, throttle_us);
-            pthread_mutex_lock(&audio_mixer->lock);
-            pthread_cond_timedwait(&audio_mixer->cond, &audio_mixer->lock, &ts);
-            //pthread_cond_wait(&audio_mixer->cond, &audio_mixer->lock);
-            pthread_mutex_unlock(&audio_mixer->lock);
-            if (audio_mixer->exit_thread)
-                break;
-        }
-
+        const uint32_t delta_us = tspec_diff_to_us(audio_mixer->tval_last_write, tval_new);
         ret = mixer_inports_read(audio_mixer);
         if (ret < 0) {
-            struct timespec ts_now;
-            uint64_t delta_us;
-
+            //usleep(5000);
             ALOGV("%s %d data not enough, next turn", __func__, __LINE__);
-            if (mixer_is_continuous_enabled(audio_mixer) && !mixer_inports_exist(audio_mixer)) {
-                ALOGI("%s %d data not enough, do continue output", __func__, __LINE__);
-                mixer_do_continous_output(audio_mixer);
-                clock_gettime(CLOCK_MONOTONIC, &audio_mixer->tval_last_write);
-            } else {
-                clock_gettime(CLOCK_MONOTONIC, &tval_new);
-                delta_us = tspec_diff_to_us(audio_mixer->tval_last_write, tval_new);
-                if (delta_us >= STANDBY_TIME_US) {
-                    if (!audio_mixer->standby) {
-                        mixer_output_standby(audio_mixer);
-                        audio_mixer->standby = 1;
-                    }
-                    pthread_mutex_lock(&audio_mixer->lock);
-                    ALOGV("%s() sleep", __func__);
-                    pthread_cond_wait(&audio_mixer->cond, &audio_mixer->lock);
-                    ALOGV("%s() wakeup", __func__);
-                    pthread_mutex_unlock(&audio_mixer->lock);
-                }
-            }
-            clock_gettime(CLOCK_MONOTONIC, &audio_mixer->tval_last_run);
+            notify_mixer_input_avail(audio_mixer);
             continue;
+            //notify_mixer_input_avail(audio_mixer);
+            //continue;
         }
+        notify_mixer_input_avail(audio_mixer);
         ALOGV("%s %d do mixing", __func__, __LINE__);
         mixer_do_mixing_32bit(audio_mixer);
+        uint64_t tpast_us = 0;
+        clock_gettime(CLOCK_MONOTONIC, &tval_new);
+        tpast_us = tspec_diff_to_us(audio_mixer->tval_last_write, tval_new);
         // audio patching should not in this write
         // TODO: fix me, make compatible with source output
         if (!audio_mixer->adev->audio_patching) {
             mixer_output_write(audio_mixer);
             mixer_update_tstamp(audio_mixer);
-            clock_gettime(CLOCK_MONOTONIC, &audio_mixer->tval_last_write);
         }
-        clock_gettime(CLOCK_MONOTONIC, &audio_mixer->tval_last_run);
     }
 
     ALOGI("--%s", __func__);
     return NULL;
 }
 
+static int mixer_do_continous_output(struct amlAudioMixer *audio_mixer)
+{
+    struct output_port *out_port = audio_mixer->out_ports[MIXER_OUTPUT_PORT_PCM];
+    int16_t *data_mixed = (int16_t *)out_port->data_buf;
+    size_t frames = 4;
+    size_t bytes = frames * out_port->cfg.frame_size;
+
+    memset(data_mixed, 0 , bytes);
+    set_outport_data_avail(out_port, bytes);
+    mixer_output_write(audio_mixer);
+    return 0;
+}
+
+static uint32_t get_mixer_inport_count(struct amlAudioMixer *audio_mixer)
+{
+    aml_mixer_input_port_type_e enPortIndex = AML_MIXER_INPUT_PORT_PCM_SYSTEM;
+    uint32_t                    u32PortCnt = 0;
+    for (; enPortIndex < AML_MIXER_INPUT_PORT_BUTT; enPortIndex++) {
+        if (audio_mixer->in_ports[enPortIndex]) {
+            u32PortCnt++;
+        }
+    }
+    return u32PortCnt;
+}
+
 int mixerIdleSleepTimeUs(struct amlAudioMixer *audio_mixer)
 {
     return audio_mixer->idle_sleep_time_us;
 }
 
+#define STANDBY_TIME_US 1000000
 static void *mixer_16b_threadloop(void *data)
 {
-    struct amlAudioMixer *audio_mixer = data;
-    enum MIXER_OUTPUT_PORT port_index = MIXER_OUTPUT_PORT_PCM;
-    enum MIXER_INPUT_PORT in_index = MIXER_INPUT_PORT_PCM_SYSTEM;
-    int ret = 0;
+    struct amlAudioMixer        *audio_mixer = data;
+    struct audio_virtual_buf    *pstVirtualBuffer = NULL;
 
-    ALOGI("++%s start", __func__);
+    ALOGI("[%s:%d] began create thread", __func__, __LINE__);
+    if (audio_mixer->mixing_enable == 0) {
+        pthread_exit(0);
+        ALOGI("[%s:%d] mixing_enable is 0 exit thread", __func__, __LINE__);
+        return NULL;
+    }
     audio_mixer->exit_thread = 0;
     prctl(PR_SET_NAME, "amlAudioMixer16");
     set_thread_affinity();
+    aml_set_thread_priority("amlAudioMixer16", audio_mixer->out_mixer_tid);
     while (!audio_mixer->exit_thread) {
-        // processing throttle
-        struct timespec tval_new;
-        clock_gettime(CLOCK_MONOTONIC, &tval_new);
-        uint32_t delta_us = tspec_diff_to_us(audio_mixer->tval_last_run, tval_new);
-
-        if (delta_us <= THROTTLE_TIME_US) {
-            struct timespec ts;
-            uint32_t throttle_us = THROTTLE_TIME_US - delta_us;
-
-            ALOGV("%s throttle time_us %d", __func__, throttle_us);
-            ts_wait_time_us(&ts, throttle_us);
-            pthread_mutex_lock(&audio_mixer->lock);
-            pthread_cond_timedwait(&audio_mixer->cond, &audio_mixer->lock, &ts);
-            pthread_mutex_unlock(&audio_mixer->lock);
-            if (audio_mixer->exit_thread)
-                break;
+        if (pstVirtualBuffer == NULL) {
+            audio_virtual_buf_open((void **)&pstVirtualBuffer, "mixer_16bit_thread",
+                    MIXER_WRITE_PERIOD_TIME_NANO * 4, MIXER_WRITE_PERIOD_TIME_NANO * 4, 0);
+            audio_virtual_buf_process((void *)pstVirtualBuffer, MIXER_WRITE_PERIOD_TIME_NANO * 4);
         }
-        ret = mixer_inports_read(audio_mixer);
-        if (ret < 0) {
-            struct timespec ts_now;
-            uint64_t delta_us;
+        mixer_inports_read(audio_mixer);
+        audio_virtual_buf_process((void *)pstVirtualBuffer, MIXER_WRITE_PERIOD_TIME_NANO);
+        notify_mixer_input_avail(audio_mixer);
+        mixer_do_mixing_16bit(audio_mixer);
 
-            ALOGV("%s %d data not enough, next turn", __func__, __LINE__);
-            if (mixer_is_continuous_enabled(audio_mixer) && !mixer_inports_exist(audio_mixer)) {
-                ALOGV("%s %d data not enough, do continue output", __func__, __LINE__);
-                mixer_do_continous_output(audio_mixer);
-                clock_gettime(CLOCK_MONOTONIC, &audio_mixer->tval_last_write);
-            } else {
-                clock_gettime(CLOCK_MONOTONIC, &tval_new);
-                delta_us = tspec_diff_to_us(audio_mixer->tval_last_write, tval_new);
-                if (delta_us >= STANDBY_TIME_US) {
-                    if (!audio_mixer->standby) {
-                        mixer_output_standby(audio_mixer);
-                        audio_mixer->standby = 1;
-                    }
-                    pthread_mutex_lock(&audio_mixer->lock);
-                    ALOGV("%s() sleep", __func__);
-                    pthread_cond_wait(&audio_mixer->cond, &audio_mixer->lock);
-                    ALOGV("%s() wakeup", __func__);
-                    pthread_mutex_unlock(&audio_mixer->lock);
-                }
-            }
-            clock_gettime(CLOCK_MONOTONIC, &audio_mixer->tval_last_run);
-            continue;
+        if (audio_mixer->adev->debug_flag > 0) {
+            ALOGD("[%s:%d] audio_patching:%d", __func__, __LINE__, audio_mixer->adev->audio_patching);
         }
-        ALOGV("%s %d do mixing", __func__, __LINE__);
-        mixer_do_mixing_16bit(audio_mixer);
         if (!audio_mixer->adev->audio_patching) {
             mixer_output_write(audio_mixer);
             mixer_update_tstamp(audio_mixer);
-            clock_gettime(CLOCK_MONOTONIC, &audio_mixer->tval_last_write);
         }
-        clock_gettime(CLOCK_MONOTONIC, &audio_mixer->tval_last_run);
+    }
+    if (pstVirtualBuffer != NULL) {
+        audio_virtual_buf_close((void **)&pstVirtualBuffer);
     }
 
-    ALOGI("--%s", __func__);
+    ALOGI("[%s:%d] exit thread", __func__, __LINE__);
     return NULL;
 }
 
 uint32_t mixer_get_inport_latency_frames(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index)
+        aml_mixer_input_port_type_e port_index)
 {
-    struct input_port *port;
-    uint32_t frame = 0;
+    struct input_port *port = audio_mixer->in_ports[port_index];
+    int written = 0;
 
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    port = audio_mixer->in_ports[port_index];
     if (!port) {
         ALOGE("%s(), NULL pointer", __func__);
-    } else {
-        frame = port->get_latency_frames(port);
+        return 0;
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
 
-    return frame;
+    return port->get_latency_frames(port);
 }
 
 uint32_t mixer_get_outport_latency_frames(struct amlAudioMixer *audio_mixer)
@@ -1663,6 +1253,8 @@ int pcm_mixer_thread_run(struct amlAudioMixer *audio_mixer)
         ALOGE("%s(), out mixer thread already running", __func__);
         return -EINVAL;
     }
+    audio_mixer->mixing_enable = 1;
+    ALOGI("++%s() audio_mixer->mixing_enable %d", __func__, audio_mixer->mixing_enable);
     switch (out_pcm_port->cfg.format) {
     case AUDIO_FORMAT_PCM_32_BIT:
         ret = pthread_create(&audio_mixer->out_mixer_tid,
@@ -1680,6 +1272,7 @@ int pcm_mixer_thread_run(struct amlAudioMixer *audio_mixer)
         ALOGE("%s(), format not supported", __func__);
         break;
     }
+    ALOGI("++%s() audio_mixer->mixing_enable %d, pthread_create ret %d", __func__, audio_mixer->mixing_enable, ret);
 
     return ret;
 }
@@ -1687,9 +1280,10 @@ int pcm_mixer_thread_run(struct amlAudioMixer *audio_mixer)
 int pcm_mixer_thread_exit(struct amlAudioMixer *audio_mixer)
 {
     ALOGD("+%s()", __func__);
+    audio_mixer->mixing_enable = 0;
+    ALOGI("++%s() audio_mixer->mixing_enable %d", __func__, audio_mixer->mixing_enable);
     // block exit
     audio_mixer->exit_thread = 1;
-    pthread_cond_broadcast(&audio_mixer->cond);
     pthread_join(audio_mixer->out_mixer_tid, NULL);
     audio_mixer->out_mixer_tid = 0;
 
@@ -1711,26 +1305,23 @@ struct amlAudioMixer *newAmlAudioMixer(
     }
 
     // 2 channel  32bit
-    audio_mixer->tmp_buffer = calloc(1, MIXER_OUT_FRAME_COUNT * 8);
+    audio_mixer->tmp_buffer = calloc(1, MIXER_FRAME_COUNT * MIXER_OUT_FRAME_SIZE);
     if (audio_mixer->tmp_buffer == NULL) {
         ALOGE("%s(), no memory", __func__);
         goto err_tmp;
     }
-    audio_mixer->buf_frames = MIXER_OUT_FRAME_COUNT;
     // 2 channel X sample bytes;
     audio_mixer->frame_size_tmp = 2 * audio_bytes_per_sample(cfg.format);
 
     mixer_set_state(audio_mixer, MIXER_IDLE);
     ret = init_mixer_output_port(audio_mixer,
-            cfg, MIXER_OUT_FRAME_COUNT);
+            cfg, MIXER_FRAME_COUNT);
     if (ret < 0) {
         ALOGE("%s(), init mixer out port failed", __func__);
         goto err_state;
     }
     audio_mixer->adev = adev;
-    pthread_mutex_init(&audio_mixer->inport_lock, NULL);
     pthread_mutex_init(&audio_mixer->lock, NULL);
-    pthread_cond_init(&audio_mixer->cond, NULL);
     return audio_mixer;
 
 err_state:
@@ -1746,10 +1337,7 @@ err_tmp:
 void freeAmlAudioMixer(struct amlAudioMixer *audio_mixer)
 {
     if (audio_mixer) {
-        pthread_mutex_destroy(&audio_mixer->inport_lock);
         pthread_mutex_destroy(&audio_mixer->lock);
-        pthread_cond_destroy(&audio_mixer->cond);
-        delete_mixer_output_port(audio_mixer, MIXER_OUTPUT_PORT_PCM);
         free(audio_mixer);
     }
 }
@@ -1760,54 +1348,42 @@ int64_t mixer_latency_frames(struct amlAudioMixer *audio_mixer)
     /* TODO: calc the mixer buf latency
     * Now using estimated buffer length
     */
-    return MIXER_IN_FRAME_COUNT;
+    return MIXER_FRAME_COUNT;
 }
 
 int mixer_get_presentation_position(
         struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index,
+        aml_mixer_input_port_type_e port_index,
         uint64_t *frames,
         struct timespec *timestamp)
 {
-    struct input_port *port;
-    int ret = 0;
-
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    port = audio_mixer->in_ports[port_index];
+    struct input_port *port = audio_mixer->in_ports[port_index];
 
     if (!port) {
-        ALOGV("%s(), port not ready now", __func__);
-        ret = -EINVAL;
-    } else {
-        *frames = port->presentation_frames;
-        *timestamp = port->timestamp;
-        if (!is_inport_pts_valid(port)) {
-            ALOGV("%s(), not valid now", __func__);
-            ret = -EINVAL;
-        }
+        ALOGW("%s(), port not ready now", __func__);
+        return -EINVAL;
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return ret;
+
+    *frames = port->presentation_frames;
+    *timestamp = port->timestamp;
+    if (!is_inport_pts_valid(port)) {
+        ALOGW("%s(), not valid now", __func__);
+        return -EINVAL;
+    }
+    return 0;
 }
 
 int mixer_set_padding_size(
         struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index,
+        aml_mixer_input_port_type_e port_index,
         int padding_bytes)
 {
-    struct input_port *port;
-    int ret;
-
-    pthread_mutex_lock(&audio_mixer->inport_lock);
-    port = audio_mixer->in_ports[port_index];
+    struct input_port *port = audio_mixer->in_ports[port_index];
     if (!port) {
         ALOGE("%s(), NULL pointer", __func__);
-        ret = -EINVAL;
-    } else  {
-        ret = set_inport_padding_size(port, padding_bytes);
+        return -EINVAL;
     }
-    pthread_mutex_unlock(&audio_mixer->inport_lock);
-    return ret;
+    return set_inport_padding_size(port, padding_bytes);
 }
 
 int mixer_stop_outport_pcm(struct amlAudioMixer *audio_mixer)
@@ -1821,3 +1397,39 @@ int mixer_stop_outport_pcm(struct amlAudioMixer *audio_mixer)
 
     return outport_stop_pcm(port);
 }
+
+void mixer_dump(int s32Fd, const struct aml_audio_device *pstAmlDev)
+{
+    if (NULL == pstAmlDev || NULL == pstAmlDev->sm) {
+        dprintf(s32Fd, "[AML_HAL] [%s:%d] device or sub mixing is NULL !\n", __func__, __LINE__);
+        return;
+    }
+    struct amlAudioMixer *pstAudioMixer = (struct amlAudioMixer *)pstAmlDev->sm->mixerData;
+    if (NULL == pstAudioMixer) {
+        dprintf(s32Fd, "[AML_HAL] [%s:%d] amlAudioMixer is NULL !\n", __func__, __LINE__);
+        return;
+    }
+    dprintf(s32Fd, "[AML_HAL]---------------------input port description cnt: [%d]--------------\n",
+        get_mixer_inport_count(pstAudioMixer));
+    aml_mixer_input_port_type_e enInPort = AML_MIXER_INPUT_PORT_PCM_SYSTEM;
+    for (; enInPort < AML_MIXER_INPUT_PORT_BUTT; enInPort++) {
+        struct input_port *pstInputPort = pstAudioMixer->in_ports[enInPort];
+        if (pstInputPort) {
+            dprintf(s32Fd, "[AML_HAL]  input port type: %s\n", inportType2Str(pstInputPort->enInPortType));
+            dprintf(s32Fd, "[AML_HAL]      Channel       : %10d     | Format    : %#10x\n",
+                pstInputPort->cfg.channelCnt, pstInputPort->cfg.format);
+            dprintf(s32Fd, "[AML_HAL]      FrameCnt      : %10d     | data size : %10d Byte\n",
+                pstInputPort->data_buf_frame_cnt, pstInputPort->data_len_bytes);
+            dprintf(s32Fd, "[AML_HAL]      is_hwsync     : %10d     | rbuf size : %10d Byte\n",
+                pstInputPort->is_hwsync, pstInputPort->r_buf->size);
+        }
+    }
+    dprintf(s32Fd, "[AML_HAL]---------------------output port description----------------------\n");
+    struct output_port *pstOutPort = pstAudioMixer->out_ports[MIXER_OUTPUT_PORT_PCM];
+    if (pstOutPort) {
+        dprintf(s32Fd, "[AML_HAL]      Channel       : %10d     | Format    : %#10x\n", pstOutPort->cfg.channelCnt, pstOutPort->cfg.format);
+        dprintf(s32Fd, "[AML_HAL]      FrameCnt      : %10d     | data size : %10d Byte\n", pstOutPort->data_buf_frame_cnt, pstOutPort->data_buf_len);
+    } else {
+        dprintf(s32Fd, "[AML_HAL] not find output port description!!!\n");
+    }
+}
diff --git a/audio_hal/amlAudioMixer.h b/audio_hal/amlAudioMixer.h
index f52bba0..6297e1c 100644
--- a/audio_hal/amlAudioMixer.h
+++ b/audio_hal/amlAudioMixer.h
@@ -46,14 +46,14 @@ struct amlAudioMixer *newAmlAudioMixer(
  */
 void freeAmlAudioMixer(struct amlAudioMixer *audio_mixer);
 void mixer_set_hwsync_input_port(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index);
+        aml_mixer_input_port_type_e port_index);
 void set_mixer_hwsync_frame_size(struct amlAudioMixer *audio_mixer,
         uint32_t frame_size);
 uint32_t get_mixer_hwsync_frame_size(struct amlAudioMixer *audio_mixer);
 uint32_t get_mixer_inport_consumed_frames(
-        struct amlAudioMixer *audio_mixer, enum MIXER_INPUT_PORT port_index);
+        struct amlAudioMixer *audio_mixer, aml_mixer_input_port_type_e port_index);
 int set_mixer_inport_volume(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index, float vol);
+        aml_mixer_input_port_type_e port_index, float vol);
 
 int init_mixer_input_port(struct amlAudioMixer *audio_mixer,
         struct audio_config *config,
@@ -67,42 +67,45 @@ int init_mixer_input_port(struct amlAudioMixer *audio_mixer,
         float volume);
 
 int delete_mixer_input_port(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index);
+        aml_mixer_input_port_type_e port_index);
 int send_mixer_inport_message(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index , enum PORT_MSG msg);
+        aml_mixer_input_port_type_e port_index , enum PORT_MSG msg);
 
 int mixer_write_inport(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index, const void *buffer, int bytes);
+        aml_mixer_input_port_type_e port_index, const void *buffer, int bytes);
 
 int mixer_read_inport(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index, void *buffer, int bytes);
+        aml_mixer_input_port_type_e port_index, void *buffer, int bytes);
 int mixer_set_inport_state(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index, enum port_state state);
+        aml_mixer_input_port_type_e port_index, enum port_state state);
 
 int mixer_flush_inport(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index);
+        aml_mixer_input_port_type_e port_index);
 
 int pcm_mixer_thread_run(struct amlAudioMixer *audio_mixer);
 int pcm_mixer_thread_exit(struct amlAudioMixer *audio_mixer);
 uint32_t mixer_get_inport_latency_frames(struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index);
+        aml_mixer_input_port_type_e port_index);
 uint32_t mixer_get_outport_latency_frames(struct amlAudioMixer *audio_mixer);
 int64_t mixer_latency_frames(struct amlAudioMixer *audio_mixer);
 int mixer_get_presentation_position(
         struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index,
+        aml_mixer_input_port_type_e port_index,
         uint64_t *frames,
         struct timespec *timestamp);
 int mixer_set_padding_size(
         struct amlAudioMixer *audio_mixer,
-        enum MIXER_INPUT_PORT port_index,
+        aml_mixer_input_port_type_e port_index,
         int padding_bytes);
 
 int mixer_set_continuous_output(struct amlAudioMixer *audio_mixer,
-		bool continuous_output);
+    bool continuous_output);
 int mixer_idle_sleep_time_us(struct amlAudioMixer *audio_mixer);
 int mixer_stop_outport_pcm(struct amlAudioMixer *audio_mixer);
+int mixer_output_standby(struct amlAudioMixer *audio_mixer);
+int mixer_output_dummy(struct amlAudioMixer *audio_mixer, bool en);
 
+void mixer_dump(int s32Fd, const struct aml_audio_device *pstAmlDev);
 __END_DECLS
 
 #endif
diff --git a/audio_hal/aml_ac3_parser.c b/audio_hal/aml_ac3_parser.c
index 80e6290..2e5515a 100644
--- a/audio_hal/aml_ac3_parser.c
+++ b/audio_hal/aml_ac3_parser.c
@@ -349,6 +349,28 @@ int scan_dolby_main_frame_ext(void *input_buffer
                     ret = -1;
                 }
             }
+        } else if (pc == 0x16) {
+            payload_size = (pcpd >> 16);
+            if (bytes - sync_word_offset >= (size_t)payload_size) {
+                if (bytes - sync_word_offset >= MAT_PERIOD_SIZE) {
+                    *used_size = sync_word_offset + MAT_PERIOD_SIZE;
+                    is_iec61937_packat = 1;
+                } else {
+                    *used_size = sync_word_offset + payload_size;
+                }
+                ret = 0;
+            } else {
+                if (bytes - sync_word_offset > 0) {
+                    *used_size = bytes;
+                    *payload_deficiency = payload_size - (bytes - sync_word_offset - IEC61937_HEADER_SIZE);
+                    ret = 1;
+                } else {
+                    *used_size = bytes;
+                    ALOGV("%s useful data len %lu mat iec61937 packet size %#x payload_size %#x",
+                         __FUNCTION__, (unsigned long)(bytes - sync_word_offset), MAT_PERIOD_SIZE, payload_size);
+                    ret = -1;
+                }
+            }
         } else {
             ret = -1;
             ALOGE("%s error pc %x\n", __FUNCTION__, pc);
diff --git a/audio_hal/aml_audio_ac3parser.c b/audio_hal/aml_audio_ac3parser.c
new file mode 100644
index 0000000..bc2973f
--- /dev/null
+++ b/audio_hal/aml_audio_ac3parser.c
@@ -0,0 +1,603 @@
+/*
+ * Copyright (C) 2017 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "audio_ac3_parser"
+
+#include <cutils/log.h>
+#include "audio_hw.h"
+#include "audio_format_parse.h"
+#include "aml_audio_ac3parser.h"
+
+#define DOLBY_DDPP_MAXSIZE          (32768)
+#define DOLBY_DDP_HEADER_SIZE       (12)
+
+#define BYTE_REV(a) ((((uint16_t)a) & 0xff) << 8 | ((uint16_t)a) >> 8)
+
+/*====================*/
+/*merge from ffmpeg begin====*/
+
+/**
+ * Possible frame sizes.
+ * from ATSC A/52 Table 5.18 Frame Size Code Table.
+ */
+static const uint16_t ff_ac3_frame_size_tab[38][3] = {
+    { 64,   69,   96   },
+    { 64,   70,   96   },
+    { 80,   87,   120  },
+    { 80,   88,   120  },
+    { 96,   104,  144  },
+    { 96,   105,  144  },
+    { 112,  121,  168  },
+    { 112,  122,  168  },
+    { 128,  139,  192  },
+    { 128,  140,  192  },
+    { 160,  174,  240  },
+    { 160,  175,  240  },
+    { 192,  208,  288  },
+    { 192,  209,  288  },
+    { 224,  243,  336  },
+    { 224,  244,  336  },
+    { 256,  278,  384  },
+    { 256,  279,  384  },
+    { 320,  348,  480  },
+    { 320,  349,  480  },
+    { 384,  417,  576  },
+    { 384,  418,  576  },
+    { 448,  487,  672  },
+    { 448,  488,  672  },
+    { 512,  557,  768  },
+    { 512,  558,  768  },
+    { 640,  696,  960  },
+    { 640,  697,  960  },
+    { 768,  835,  1152 },
+    { 768,  836,  1152 },
+    { 896,  975,  1344 },
+    { 896,  976,  1344 },
+    { 1024, 1114, 1536 },
+    { 1024, 1115, 1536 },
+    { 1152, 1253, 1728 },
+    { 1152, 1254, 1728 },
+    { 1280, 1393, 1920 },
+    { 1280, 1394, 1920 },
+};
+
+/**
+ * Map audio coding mode (acmod) to number of full-bandwidth channels.
+ * from ATSC A/52 Table 5.8 Audio Coding Mode
+ */
+static const uint8_t ff_ac3_channels_tab[8] = {
+    2, 1, 2, 3, 3, 4, 4, 5
+};
+
+
+static const int fs_tab[3] = {
+    48000, 44100, 32000
+};
+
+static const int fs2_tab[3] = {
+    24000, 22050, 16000
+};
+
+
+/** Channel mode (audio coding mode) */
+typedef enum {
+    AC3_CHMODE_DUALMONO = 0,
+    AC3_CHMODE_MONO,
+    AC3_CHMODE_STEREO,
+    AC3_CHMODE_3F,
+    AC3_CHMODE_2F1R,
+    AC3_CHMODE_3F1R,
+    AC3_CHMODE_2F2R,
+    AC3_CHMODE_3F2R
+} AC3ChannelMode;
+
+
+
+enum PARSER_STATE {
+    PARSER_SYNCING,
+    PARSER_SYNCED,
+    PARSER_LACK_DATA,
+};
+
+struct aml_ac3_parser {
+    void * buf;
+    int32_t buf_size;
+    int32_t buf_remain;
+    uint32_t status;
+    int32_t framesize;
+};
+
+int aml_ac3_parser_open(void **pparser_handle)
+{
+    struct aml_ac3_parser *parser_hanlde = NULL;
+
+    parser_hanlde = (struct aml_ac3_parser *)calloc(1, sizeof(struct aml_ac3_parser));
+    if (parser_hanlde == NULL) {
+        ALOGE("%s handle error", __func__);
+        goto error;
+    }
+
+    parser_hanlde->buf_size  = DOLBY_DDPP_MAXSIZE;
+    parser_hanlde->buf  = calloc(1, DOLBY_DDPP_MAXSIZE);
+    if (parser_hanlde->buf == NULL) {
+        ALOGE("%s data buffer error", __func__);
+        free(parser_hanlde);
+        parser_hanlde = NULL;
+        goto error;
+    }
+    parser_hanlde->status = PARSER_SYNCING;
+    parser_hanlde->buf_remain = 0;
+    *pparser_handle = parser_hanlde;
+    ALOGI("%s exit =%p", __func__, parser_hanlde);
+    return 0;
+error:
+    *pparser_handle = NULL;
+    ALOGE("%s error", __func__);
+    return -1;
+}
+int aml_ac3_parser_close(void *parser_handle)
+{
+    struct aml_ac3_parser *parser_hanlde = (struct aml_ac3_parser *)parser_handle;
+
+    if (parser_hanlde) {
+        if (parser_hanlde->buf) {
+            free(parser_hanlde->buf);
+        }
+        free(parser_hanlde);
+    }
+    ALOGE("%s exit", __func__);
+    return 0;
+}
+
+int aml_ac3_parser_reset(void *parser_handle)
+{
+    struct aml_ac3_parser *parser_hanlde = (struct aml_ac3_parser *)parser_handle;
+
+    if (parser_hanlde) {
+        parser_hanlde->status = PARSER_SYNCING;
+        parser_hanlde->buf_remain = 0;
+    }
+    ALOGE("%s exit", __func__);
+    return 0;
+}
+
+
+static int seek_dolby_sync_word(char *buffer, int size)
+{
+    int i = -1;
+
+    for (i = 0; i < (size - 1); i++) {
+        if (buffer[i + 0] == 0x0b && buffer[i + 1] == 0x77) {
+            return i;
+        }
+        if (buffer[i + 0] == 0x77 && buffer[i + 1] == 0x0b) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+static int check_ac3_syncword(const unsigned char *ptr, int size)
+{
+    if (size < 2) {
+        return 0;
+    }
+    if (ptr[0] == 0x0b && ptr[1] == 0x77) {
+        return 1;
+    }
+    if (ptr[0] == 0x77 && ptr[1] == 0x0b) {
+        return 2;
+    }
+
+    return 0;
+}
+
+
+/*
+ *parse frame header[ATSC Standard,Digital Audio Compression (AC-3, E-AC-3)]
+ */
+static int parse_dolby_frame_header
+(const unsigned char *frameBuf
+ , int length
+ , int *frame_offset
+ , int *frame_size
+ , int *channel_num
+ , int *numblks
+ , int *timeslice_61937
+ , int *framevalid_flag
+ , int *frame_dependent
+ , int *sample_rate)
+{
+    int acmod = 0;
+    int lfeOn = 0;
+    int nIsEc3 = 0;
+    int frame_size_code = 0;
+    int sr_code = 0;
+    int substreamid = 0;
+    int numblk_per_frame;
+    char inheader[12] = {0};
+    int offset = 0;
+    int header = 0;
+    int sr= 48000;
+    int i = 0;
+    *channel_num = 2;
+
+    /*TODO, used to correct iec61937 packet*/
+    *timeslice_61937 = 0;
+    *framevalid_flag = 0;
+    *frame_dependent = 0;
+
+    for (i = 0; i < length; ++i) {
+        if ((header = check_ac3_syncword(&frameBuf[i], length - i)) > 0) {
+            offset = i;
+            break;
+        }
+    }
+    /*step 1, frame header 0x0b77/0x770b*/
+    if (header == 0) {
+        //ALOGE("locate frame header 0x0b77/0x770b failed\n");
+        goto error;/*no frame header, maybe need more data*/
+    }
+
+    /*step 2, copy 12bytes to inheader,  find one frame*/
+    if (length - offset < 12) {
+        /*
+         *find the sync word 0x0b77/0x770b,
+         *but we need 12bytes which will copy to inheader[12], need more data
+         */
+        ALOGE("data less than one frame!!!\n");
+        goto error;
+    } else {
+        memcpy((void *) inheader, (const void *)(frameBuf + offset), 12);
+    }
+
+    if (header == 2) {
+        int16_t *p_data = (int16_t *) inheader;
+        unsigned int idx;
+        unsigned int inheader_len = 12;
+        unsigned int top = inheader_len / 2;
+        for (idx = 0; idx < top; idx++) {
+            p_data[idx] = (int16_t) BYTE_REV(p_data[idx]);
+        }
+    }
+
+    if (length < 12) {
+        ALOGE("%s len %d\n", __FUNCTION__, length);
+        goto error;
+    } else {
+        //ALOGV("dolby head:0x%x 0x%x 0x%x 0x%x 0x%x 0x%x \n",
+        //    inheader[0],inheader[1],inheader[2], inheader[3],inheader[4],inheader[5]);
+        int bsid = (inheader[5] >> 3) & 0x1f;//bitstream_id,bit[40,44]
+        if (bsid > 16) {
+            goto error;    //invalid bitstream_id
+        }
+        if (bsid <= 8) {
+            nIsEc3 = 0;
+        } else if ((bsid <= 16) && (bsid > 10)) {
+            nIsEc3 = 1;
+        }
+
+        if (nIsEc3 == 0) {
+            int use_bits = 0;
+
+            substreamid = 0;
+            sr_code = inheader[4] >> 6;
+            if (sr_code == 3) {
+                ALOGE("%s error *sr_code %d", __FUNCTION__, sr_code);
+                goto error;
+            }
+            frame_size_code = inheader[4] & 0x3F;
+            sr = fs_tab[sr_code];
+            if (frame_size_code > 37) {
+                ALOGE("%s error frame_size_code %d", __FUNCTION__, frame_size_code);
+                goto error;
+            }
+            acmod = (inheader[6] >> 5) & 0x7;// 3bits
+            use_bits = use_bits + 3;
+            if (acmod == AC3_CHMODE_STEREO) {
+                //int dolby_surround_mode = (inheader[6] >> 3) &0x3; // 2bits
+                use_bits = use_bits + 2;
+            } else {
+                if ((acmod & 1)  && (acmod != AC3_CHMODE_MONO)) {
+                    //int center_mix_level =  center_levels[ (inheader[6] >> 3) &0x3]; // 2bits
+                    use_bits = use_bits + 2;
+                }
+                if (acmod & 4) {
+                    //int surround_mix_level = surround_levels[ (inheader[6] >> 1) &0x3]; // 2bits
+                    use_bits = use_bits + 2;
+                }
+            }
+            lfeOn = (inheader[6] >> (8 - use_bits - 1)) & 0x1; // 1bit
+            *frame_size = ff_ac3_frame_size_tab[frame_size_code][sr_code] * 2;
+            numblk_per_frame = 6;
+            *numblks = numblk_per_frame;
+            *timeslice_61937 = 1;
+            *framevalid_flag = 1;
+        } else {
+            int numblkscod = 0;
+            int strmtyp = (inheader[2] >> 6) & 0x3;
+            int substreamid = (inheader[2] >> 3) & 0x7;
+            *frame_size = ((inheader[2] & 0x7) * 0x100 + inheader[3] + 1) << 1;
+            sr_code = inheader[4] >> 6;
+            acmod = (inheader[4] >> 1) & 0x7;
+            lfeOn = inheader[4] & 0x1;
+            numblkscod = (sr_code == 0x3) ? 0x3 : ((inheader[4] >> 4) & 0x3);
+            numblk_per_frame = (numblkscod == 0x3) ? 6 : (numblkscod + 1);
+            if (sr_code < 0x3) {
+                sr = fs_tab[sr_code];
+            } else {
+                sr_code = ((inheader[4] >> 4) & 0x3);
+                if (sr_code < 0x3) {
+                    sr = fs2_tab[sr_code];
+                }
+            }
+            ALOGV("%s() ec3 numblkscod %d numblk_per_frame %d substreamid %d strmtyp %d\n",
+                  __FUNCTION__, numblkscod, numblk_per_frame, substreamid, strmtyp);
+            if (substreamid == 0 && strmtyp == 0) {
+                if (*framevalid_flag == 0) {
+                    *timeslice_61937 = 0;
+                    // *numblks += numblk_per_frame;
+                    *framevalid_flag = 1;
+                } else if (*framevalid_flag == 1) {
+                    if (*numblks  == 6) {
+                        *timeslice_61937 = 1;
+                        // *numblks = numblk_per_frame;
+                    } else if (*numblks  > 6) {
+                        *timeslice_61937 = 2;
+                        // *numblks = numblk_per_frame;
+                    } else {
+                        *timeslice_61937 = 0;
+                        // *numblks += numblk_per_frame;
+                    }
+                }
+            } else if (strmtyp == 1) {
+                *timeslice_61937 = 3;
+            }
+            *numblks = numblk_per_frame;
+            *frame_dependent = strmtyp;
+
+        }
+        // ALOGV("%s acmod %d lfeOn %d\n", nIsEc3==0?"ac3":"ec3",acmod, lfeOn);
+        *channel_num = ff_ac3_channels_tab[acmod] + lfeOn;
+    }
+    *frame_offset = offset;
+    *sample_rate  = sr;
+    ALOGV("%s frame_offset %d frame_size %d channel_num %d numblks %d timeslice_61937 %d framevalid_flag %d\n",
+          __FUNCTION__, *frame_offset, *frame_size, *channel_num, *numblks, *timeslice_61937, *framevalid_flag);
+
+    return 0;
+error:
+    *frame_offset = 0;
+    return 1;
+}
+
+
+int aml_ac3_parser_process(void *parser_handle, const void *in_buffer, int32_t numBytes, int32_t *used_size, void **output_buf, int32_t *out_size, struct ac3_parser_info * ac3_info)
+{
+    struct aml_ac3_parser *parser_hanlde = (struct aml_ac3_parser *)parser_handle;
+    size_t remain = 0;
+    uint8_t *buffer = (uint8_t *)in_buffer;
+    uint8_t * parser_buf = NULL;
+    int32_t sync_word_offset = -1;
+    int32_t buf_left = 0;
+    int32_t buf_offset = 0;
+    int32_t need_size = 0;
+
+    int32_t ret = 0;
+    int32_t data_valid = 0;
+    int32_t new_buf_size = 0;
+    int32_t loop_cnt = 0;
+    int32_t frame_size = 0;
+    int32_t frame_offset = 0;
+
+    if (parser_hanlde == NULL) {
+        goto error;
+    }
+
+    if (ac3_info == NULL) {
+        goto error;
+    }
+
+    memset(ac3_info, 0, sizeof(struct ac3_parser_info));
+
+    parser_buf = parser_hanlde->buf;
+    buf_left     = numBytes;
+
+    ALOGV("%s input buf size=%d status=%d", __func__, numBytes, parser_hanlde->status);
+
+    /*we need at least 12 bytes*/
+    if (parser_hanlde->buf_remain < DOLBY_DDP_HEADER_SIZE) {
+        need_size = DOLBY_DDP_HEADER_SIZE - parser_hanlde->buf_remain;
+        /*input data is not enough, just copy to internal buf*/
+        if (buf_left < need_size) {
+            memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+            parser_hanlde->buf_remain += buf_left;
+            goto error;
+        }
+        /*make sure the remain buf has 12 bytes*/
+        memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, need_size);
+        parser_hanlde->buf_remain += need_size;
+        buf_offset += need_size;
+        buf_left   = numBytes - buf_offset;
+
+    }
+
+    if (parser_hanlde->status == PARSER_SYNCING) {
+        sync_word_offset = -1;
+        while (sync_word_offset < 0) {
+            /*sync the header, we have at least period bytes*/
+            if (parser_hanlde->buf_remain < DOLBY_DDP_HEADER_SIZE) {
+                ALOGE("we should not get there");
+                parser_hanlde->buf_remain = 0;
+                goto error;
+            }
+            sync_word_offset = seek_dolby_sync_word((char*)parser_buf, parser_hanlde->buf_remain);
+            /*if we don't find the header in period bytes, move the last 1 bytes to header*/
+            if (sync_word_offset < 0) {
+                memmove(parser_buf, parser_buf + parser_hanlde->buf_remain - 1, 1);
+                parser_hanlde->buf_remain = 1;
+                need_size = DOLBY_DDP_HEADER_SIZE - parser_hanlde->buf_remain;
+                /*input data is not enough, just copy to internal buf*/
+                if (buf_left < need_size) {
+                    memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+                    parser_hanlde->buf_remain += buf_left;
+                    /*don't find the header, and there is no enough data*/
+                    goto error;
+                }
+                /*make the buf has 12 bytes*/
+                memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, need_size);
+                parser_hanlde->buf_remain += need_size;
+                buf_offset += need_size;
+                buf_left = numBytes - buf_offset;
+            }
+            loop_cnt++;
+        }
+        /*got here means we find the sync word*/
+        parser_hanlde->status = PARSER_SYNCED;
+
+        data_valid = parser_hanlde->buf_remain - sync_word_offset;
+        /*move the header to the beginning of buf*/
+        if (sync_word_offset != 0) {
+            memmove(parser_buf, parser_buf + sync_word_offset, data_valid);
+        }
+        parser_hanlde->buf_remain = data_valid;
+
+        need_size = DOLBY_DDP_HEADER_SIZE - data_valid;
+        /*get some bytes to make sure it is at least 12 bytes*/
+        if (need_size > 0) {
+            /*check if input has enough data*/
+            if (buf_left < need_size) {
+                memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+                parser_hanlde->buf_remain += buf_left;
+                goto error;
+            }
+            /*make sure the remain buf has 12 bytes*/
+            memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset , need_size);
+            parser_hanlde->buf_remain += need_size;
+            buf_offset += need_size;
+            buf_left = numBytes - buf_offset;
+        }
+
+
+    }
+
+    /*double check here*/
+    sync_word_offset = seek_dolby_sync_word((char*)parser_buf, parser_hanlde->buf_remain);
+    if (sync_word_offset != 0) {
+        ALOGE("we can't get here remain=%d,resync dolby header", parser_hanlde->buf_remain);
+        parser_hanlde->buf_remain = 0;
+        parser_hanlde->status = PARSER_SYNCING;
+        goto error;
+    }
+    /* we got here means we find the dolby header and
+     * it is at the beginning of  parser buf and
+     * it has at least 12 bytes, we can parse it
+     */
+    ret = parse_dolby_frame_header(parser_buf, parser_hanlde->buf_remain,  &frame_offset, &ac3_info->frame_size,
+                                   &ac3_info->channel_num, &ac3_info->numblks, &ac3_info->timeslice_61937,
+                                   &ac3_info->framevalid_flag,
+                                   &ac3_info->frame_dependent,
+                                   &ac3_info->sample_rate);
+
+
+
+    /*check whether the input data has a complete ac3 frame*/
+    if (ac3_info->frame_size == 0) {
+        ALOGE("%s wrong frame size=%d", __func__, ac3_info->frame_size);
+        parser_hanlde->buf_remain = 0;
+        parser_hanlde->status = PARSER_SYNCING;
+        goto error;
+    }
+
+    frame_size = ac3_info->frame_size;
+
+    /*we have a complete payload*/
+    if ((parser_hanlde->buf_remain + buf_left) >= frame_size) {
+        need_size = frame_size - (parser_hanlde->buf_remain);
+        if (need_size >= 0) {
+            new_buf_size = parser_hanlde->buf_remain + need_size;
+            if (new_buf_size > parser_hanlde->buf_size) {
+                parser_hanlde->buf = realloc(parser_hanlde->buf, new_buf_size);
+                if (parser_hanlde->buf == NULL) {
+                    ALOGE("%s realloc buf failed =%d", __func__, new_buf_size);
+                    parser_hanlde->buf_remain = 0;
+                    parser_hanlde->status = PARSER_SYNCING;
+                    goto error;
+                }
+                parser_hanlde->buf_size = new_buf_size;
+                parser_buf = parser_hanlde->buf;
+                ALOGI("%s realloc buf =%d", __func__, new_buf_size);
+            }
+
+            memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, need_size);
+            buf_offset += need_size;
+            buf_left = numBytes - buf_offset;
+
+            *output_buf = (void*)(parser_buf);
+            *out_size   = frame_size;
+            *used_size = buf_offset;
+            ALOGV("OK framesize =%d used size=%d loop_cnt=%d", frame_size, buf_offset, loop_cnt);
+            /*one frame has complete, need find next one*/
+            parser_hanlde->buf_remain = 0;
+            parser_hanlde->status = PARSER_SYNCING;
+        } else {
+            /*internal buf has more data than framsize, we only need part of it*/
+            *output_buf = (void*)(parser_buf);
+            *out_size   = frame_size;
+            /*move need_size bytes back to original buf*/
+            *used_size = buf_offset + need_size;
+            ALOGV("wrap frame size=%d used size=%d back size =%d loop_cnt=%d", frame_size, buf_offset, need_size, loop_cnt);
+            if (*used_size <= 0) {
+                ALOGE("%s wrong used size =%d", __func__, *used_size);
+                parser_hanlde->buf_remain = 0;
+                parser_hanlde->status = PARSER_SYNCING;
+                goto error;
+            }
+            /*one frame has complete, need find next one*/
+            parser_hanlde->buf_remain = 0;
+            parser_hanlde->status = PARSER_SYNCING;
+        }
+    } else {
+        /*check whether the input buf size is big enough*/
+        new_buf_size = parser_hanlde->buf_remain + buf_left;
+        if (new_buf_size > parser_hanlde->buf_size) {
+            parser_hanlde->buf = realloc(parser_hanlde->buf, new_buf_size);
+            if (parser_hanlde->buf == NULL) {
+                ALOGE("%s realloc buf failed =%d", __func__, new_buf_size);
+                parser_hanlde->buf_remain = 0;
+                parser_hanlde->status = PARSER_SYNCING;
+                goto error;
+            }
+            parser_hanlde->buf_size = new_buf_size;
+            parser_buf = parser_hanlde->buf;
+            ALOGI("%s realloc buf =%d", __func__, new_buf_size);
+        }
+        memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+        parser_hanlde->buf_remain += buf_left;
+        parser_hanlde->status = PARSER_LACK_DATA;
+        goto error;
+    }
+    if (parser_hanlde->framesize != frame_size) {
+        parser_hanlde->framesize = frame_size;
+        ALOGV("New frame size =%d", frame_size);
+    }
+    return 0;
+
+error:
+    *output_buf = NULL;
+    *out_size   = 0;
+    *used_size = numBytes;
+    return 0;
+}
diff --git a/audio_hal/aml_audio_ac3parser.h b/audio_hal/aml_audio_ac3parser.h
new file mode 100644
index 0000000..fa8d204
--- /dev/null
+++ b/audio_hal/aml_audio_ac3parser.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2017 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AML_AUDIO_AC3PARSER_H_
+#define _AML_AUDIO_AC3PARSER_H_
+
+struct ac3_parser_info {
+    int frame_size;
+    int channel_num;
+    int numblks;
+    int timeslice_61937;
+    int framevalid_flag;
+    int frame_dependent;
+    int sample_rate;
+};
+
+
+int aml_ac3_parser_open(void **pparser_handle);
+int aml_ac3_parser_close(void *parser_handle);
+int aml_ac3_parser_process(void *parser_handle, const void *buffer, int32_t numBytes, int32_t *used_size, void **output_buf, int32_t *out_size, struct ac3_parser_info * ac3_info);
+int aml_ac3_parser_reset(void *parser_handle);
+
+
+#endif
diff --git a/audio_hal/aml_audio_ac4parser.c b/audio_hal/aml_audio_ac4parser.c
new file mode 100644
index 0000000..e1d9090
--- /dev/null
+++ b/audio_hal/aml_audio_ac4parser.c
@@ -0,0 +1,480 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "audio_ac4_parser"
+
+#include <cutils/log.h>
+#include "audio_hw.h"
+#include "aml_audio_ac4parser.h"
+#include "aml_audio_bitsparser.h"
+
+/**
+ *
+ * This value can be used for the initialization of the AC-4 framer.
+ * The value 16 kB is determined by the maximum frame size used in broadcast applications.
+ * now we use 16kb * 2 to make sure it can always contain the frame
+ */
+#define DOLBY_AC4_MAX_FRAMESIZE     (32768)
+
+/* ETSI TS 103 190-2 V1.1.1 Annex C + ETSI TS 103 190-1 V1.2.1 AC-4 frame info */
+#define DOLBY_AC4_HEADER_SIZE       (8 + 3)
+
+#define AC4_SYNCWORD_AC40           (0xAC40)
+#define AC4_SYNCWORD_AC41           (0xAC41)
+
+#define AC4_SAMPLERATE_48K          (48000)
+#define AC4_SAMPLERATE_44K          (44100)
+
+
+enum PARSER_STATE {
+    PARSER_SYNCING,
+    PARSER_SYNCED,
+    PARSER_LACK_DATA,
+};
+
+struct aml_ac4_parser {
+    void * buf;
+    int32_t buf_size;
+    int32_t buf_remain;
+    uint32_t status;
+    struct audio_bit_parser bit_parser;
+};
+
+int aml_ac4_parser_open(void **pparser_handle)
+{
+    struct aml_ac4_parser *parser_hanlde = NULL;
+
+    parser_hanlde = (struct aml_ac4_parser *)calloc(1, sizeof(struct aml_ac4_parser));
+    if (parser_hanlde == NULL) {
+        ALOGE("%s handle error", __func__);
+        goto error;
+    }
+
+    parser_hanlde->buf_size   = DOLBY_AC4_MAX_FRAMESIZE;
+    parser_hanlde->buf        = calloc(1, DOLBY_AC4_MAX_FRAMESIZE);
+    if (parser_hanlde->buf == NULL) {
+        ALOGE("%s data buffer error", __func__);
+        free(parser_hanlde);
+        parser_hanlde = NULL;
+        goto error;
+    }
+    parser_hanlde->status     = PARSER_SYNCING;
+    parser_hanlde->buf_remain = 0;
+    *pparser_handle = parser_hanlde;
+    ALOGI("%s exit =%p", __func__, parser_hanlde);
+    return 0;
+error:
+    *pparser_handle = NULL;
+    ALOGE("%s error", __func__);
+    return -1;
+}
+int aml_ac4_parser_close(void *parser_handle)
+{
+    struct aml_ac4_parser *parser_hanlde = (struct aml_ac4_parser *)parser_handle;
+
+    if (parser_hanlde) {
+        if (parser_hanlde->buf) {
+            free(parser_hanlde->buf);
+        }
+        free(parser_hanlde);
+    }
+    ALOGI("%s exit", __func__);
+    return 0;
+}
+
+int aml_ac4_parser_reset(void *parser_handle)
+{
+    struct aml_ac4_parser *parser_hanlde = (struct aml_ac4_parser *)parser_handle;
+
+    if (parser_hanlde) {
+        parser_hanlde->status = PARSER_SYNCING;
+        parser_hanlde->buf_remain = 0;
+    }
+    ALOGI("%s exit", __func__);
+    return 0;
+}
+
+// ETSI TS 103 190 V1.1.1 Table 83
+static uint32_t frame_rate_table_48Khz[16] = {
+    23976,
+    24000,
+    25000,
+    29970,
+    30000,
+    47950,
+    48000,
+    50000,
+    59940,
+    60000,
+    100000,
+    119880,
+    120000,
+    23440,
+    0,
+    0,
+};
+
+// ETSI TS 103 190 V1.1.1 Table 84
+static uint32_t frame_rate_table_44Khz[16] = {
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    21533,  /*11025/512*/
+    0,
+    0,
+};
+
+
+static int seek_ac4_sync_word(char *buffer, int size)
+{
+    int i = -1;
+    if (size < 2) {
+        return -1;
+    }
+    /*The sync_word can be either 0xAC40 or 0xAC41*/
+    for (i = 0; i < (size - 1); i++) {
+        if (buffer[i + 0] == 0xAC && buffer[i + 1] == 0x40) {
+            return i;
+        }
+        if (buffer[i + 0] == 0xAC && buffer[i + 1] == 0x41) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+// ETSI TS 103 190 V1.1.1  4.2.2
+static int32_t readVariableBits(struct audio_bit_parser * bit_parser, int32_t nbits)
+{
+    int32_t value = 0;
+    int32_t more_bits = 1;
+    while (more_bits) {
+        value += aml_audio_bitparser_getBits(bit_parser, nbits);
+        more_bits = aml_audio_bitparser_getBits(bit_parser, 1);
+        if (!more_bits) {
+            break;
+        }
+        value++;
+        value <<= nbits;
+    }
+    return value;
+}
+
+
+static int parse_ac4_frame_header(struct audio_bit_parser * bit_parser, const unsigned char *frameBuf, int length, struct ac4_parser_info * ac4_info)
+{
+    uint32_t frame_size = 0;
+    uint32_t head_size = 0;
+    bool     crc_enable = false;
+    bool     b_wait_frames = false;
+    uint32_t fs_index = 0;
+    uint32_t frame_rate_index = 0;
+    uint32_t frame_length = 0;
+    if (length < DOLBY_AC4_HEADER_SIZE) {
+        return -1;
+    }
+
+    aml_audio_bitparser_init(bit_parser, frameBuf, length);
+
+    /* ETSI TS 103 190-2 V1.1.1 Annex C*/
+    int32_t syncWord = aml_audio_bitparser_getBits(bit_parser, 16);
+    if (syncWord == AC4_SYNCWORD_AC40) {
+        crc_enable = false;
+    } else if (syncWord == AC4_SYNCWORD_AC41) {
+        crc_enable = true;
+    } else {
+        return -1;
+    }
+    head_size  = 2;  /*sync word size*/
+    frame_size = aml_audio_bitparser_getBits(bit_parser, 16);
+    head_size += 2;
+    if (frame_size == 0xFFFF) {
+        frame_size = aml_audio_bitparser_getBits(bit_parser, 24);
+        head_size += 3;
+    }
+
+    if (frame_size == 0) {
+        ALOGE("Invalid AC4 frame size 0");
+        return -1;
+    }
+
+    frame_size += head_size;
+    if (crc_enable) {
+        frame_size += 2;
+    }
+
+
+    // ETSI TS 103 190-2 V1.1.1 6.2.1.1
+    uint32_t bitstreamVersion = aml_audio_bitparser_getBits(bit_parser, 2);
+    if (bitstreamVersion == 3) {
+        bitstreamVersion += readVariableBits(bit_parser, 2);
+    }
+
+    aml_audio_bitparser_skipBits(bit_parser, 10); // Sequence Counter
+
+    /*1 bit b_wait_frames*/
+    b_wait_frames = aml_audio_bitparser_getBits(bit_parser, 1);
+
+    if (b_wait_frames) {
+        /*3bit wait_frames*/
+        uint32_t waitFrames = aml_audio_bitparser_getBits(bit_parser, 3);
+        if (waitFrames > 0) {
+            aml_audio_bitparser_getBits(bit_parser, 2); // reserved;
+        }
+    }
+
+    // ETSI TS 103 190 V1.1.1 Table 82
+    fs_index = aml_audio_bitparser_getBits(bit_parser, 1);
+
+    frame_rate_index = aml_audio_bitparser_getBits(bit_parser, 4);
+
+    ac4_info->frame_size     = frame_size;
+    ac4_info->sample_rate    = fs_index ? AC4_SAMPLERATE_48K : AC4_SAMPLERATE_44K;
+    if (fs_index) {
+        ac4_info->frame_rate = frame_rate_table_48Khz[frame_rate_index];
+    } else {
+        ac4_info->frame_rate = frame_rate_table_44Khz[frame_rate_index];
+    }
+    if (ac4_info->frame_rate == 0) {
+        ALOGE("invalid ac4 samplerate =%d frame rate index=%d", ac4_info->sample_rate, frame_rate_index);
+        return -1;
+    }
+    ALOGV("ac4 frame size=%d frame rate =%d sample rate=%d wait frame=%d", ac4_info->frame_size, ac4_info->frame_rate, ac4_info->sample_rate, b_wait_frames);
+
+    return 0;
+}
+
+
+int aml_ac4_parser_process(void *parser_handle, const void *in_buffer, int32_t numBytes, int32_t *used_size, void **output_buf, int32_t *out_size, struct ac4_parser_info * ac4_info)
+{
+    struct aml_ac4_parser *parser_hanlde = (struct aml_ac4_parser *)parser_handle;
+    size_t remain = 0;
+    uint8_t *buffer = (uint8_t *)in_buffer;
+    uint8_t * parser_buf = NULL;
+    int32_t sync_word_offset = -1;
+    int32_t buf_left = 0;
+    int32_t buf_offset = 0;
+    int32_t need_size = 0;
+
+    int32_t ret = 0;
+    int32_t data_valid = 0;
+    int32_t new_buf_size = 0;
+    int32_t loop_cnt = 0;
+    int32_t frame_size = 0;
+    int32_t frame_offset = 0;
+
+    if (parser_hanlde == NULL) {
+        ALOGE("error parser_hanlde is NULL");
+        goto error;
+    }
+
+    if (ac4_info == NULL) {
+        ALOGE("error ac4_info is NULL");
+        goto error;
+    }
+
+    memset(ac4_info, 0, sizeof(struct ac4_parser_info));
+
+    parser_buf = parser_hanlde->buf;
+    buf_left   = numBytes;
+
+    ALOGV("%s input buf size=%d status=%d", __func__, numBytes, parser_hanlde->status);
+
+    /*we need at least DOLBY_AC4_HEADER_SIZE bytes*/
+    if (parser_hanlde->buf_remain < DOLBY_AC4_HEADER_SIZE) {
+        need_size = DOLBY_AC4_HEADER_SIZE - parser_hanlde->buf_remain;
+        /*input data is not enough, just copy to internal buf*/
+        if (buf_left < need_size) {
+            memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+            parser_hanlde->buf_remain += buf_left;
+            goto error;
+        }
+        /*make sure the remain buf has DOLBY_AC4_HEADER_SIZE bytes*/
+        memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, need_size);
+        parser_hanlde->buf_remain += need_size;
+        buf_offset += need_size;
+        buf_left   = numBytes - buf_offset;
+
+    }
+
+    if (parser_hanlde->status == PARSER_SYNCING) {
+        sync_word_offset = -1;
+        while (sync_word_offset < 0) {
+            /*sync the header, we have at least period bytes*/
+            if (parser_hanlde->buf_remain < DOLBY_AC4_HEADER_SIZE) {
+                ALOGE("we should not get there");
+                parser_hanlde->buf_remain = 0;
+                goto error;
+            }
+            sync_word_offset = seek_ac4_sync_word((char*)parser_buf, parser_hanlde->buf_remain);
+            /*if we don't find the header in period bytes, move the last 1 bytes to header*/
+            if (sync_word_offset < 0) {
+                memmove(parser_buf, parser_buf + parser_hanlde->buf_remain - 1, 1);
+                parser_hanlde->buf_remain = 1;
+                need_size = DOLBY_AC4_HEADER_SIZE - parser_hanlde->buf_remain;
+                /*input data is not enough, just copy to internal buf*/
+                if (buf_left < need_size) {
+                    memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+                    parser_hanlde->buf_remain += buf_left;
+                    /*don't find the header, and there is no enough data*/
+                    goto error;
+                }
+                /*make the buf has DOLBY_AC4_HEADER_SIZE bytes*/
+                memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, need_size);
+                parser_hanlde->buf_remain += need_size;
+                buf_offset += need_size;
+                buf_left = numBytes - buf_offset;
+            }
+            loop_cnt++;
+        }
+        /*got here means we find the sync word*/
+        parser_hanlde->status = PARSER_SYNCED;
+
+        data_valid = parser_hanlde->buf_remain - sync_word_offset;
+        /*move the header to the beginning of buf*/
+        if (sync_word_offset != 0) {
+            memmove(parser_buf, parser_buf + sync_word_offset, data_valid);
+        }
+        parser_hanlde->buf_remain = data_valid;
+
+        need_size = DOLBY_AC4_HEADER_SIZE - data_valid;
+        /*get some bytes to make sure it is at least DOLBY_AC4_HEADER_SIZE bytes*/
+        if (need_size > 0) {
+            /*check if input has enough data*/
+            if (buf_left < need_size) {
+                memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+                parser_hanlde->buf_remain += buf_left;
+                goto error;
+            }
+            /*make sure the remain buf has DOLBY_AC4_HEADER_SIZE bytes*/
+            memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset , need_size);
+            parser_hanlde->buf_remain += need_size;
+            buf_offset += need_size;
+            buf_left = numBytes - buf_offset;
+        }
+
+
+    }
+
+    /*double check here*/
+    sync_word_offset = seek_ac4_sync_word((char*)parser_buf, parser_hanlde->buf_remain);
+    if (sync_word_offset != 0) {
+        ALOGE("we can't get here remain=%d,resync dolby header", parser_hanlde->buf_remain);
+        parser_hanlde->buf_remain = 0;
+        parser_hanlde->status = PARSER_SYNCING;
+        goto error;
+    }
+    /* we got here means we find the ac4 header and
+     * it is at the beginning of  parser buf and
+     * it has at least DOLBY_AC4_HEADER_SIZE bytes, we can parse it
+     */
+    ret = parse_ac4_frame_header(&parser_hanlde->bit_parser, parser_buf, parser_hanlde->buf_remain, ac4_info);
+
+    /*check whether the input data has a complete ac4 frame*/
+    if (ret != 0 || ac4_info->frame_size == 0) {
+        ALOGE("%s wrong frame size=%d", __func__, ac4_info->frame_size);
+        parser_hanlde->buf_remain = 0;
+        parser_hanlde->status = PARSER_SYNCING;
+        goto error;
+    }
+    frame_size = ac4_info->frame_size;
+
+    /*we have a complete payload*/
+    if ((parser_hanlde->buf_remain + buf_left) >= frame_size) {
+        need_size = frame_size - (parser_hanlde->buf_remain);
+        if (need_size >= 0) {
+            new_buf_size = parser_hanlde->buf_remain + need_size;
+            if (new_buf_size > parser_hanlde->buf_size) {
+                void * new_buf = realloc(parser_hanlde->buf, new_buf_size);
+                if (new_buf == NULL) {
+                    ALOGE("%s realloc buf failed =%d", __func__, new_buf_size);
+                    parser_hanlde->buf_remain = 0;
+                    parser_hanlde->status = PARSER_SYNCING;
+                    goto error;
+                }
+                parser_hanlde->buf      = new_buf;
+                parser_hanlde->buf_size = new_buf_size;
+                parser_buf = parser_hanlde->buf;
+                ALOGI("%s realloc buf =%d", __func__, new_buf_size);
+            }
+
+            memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, need_size);
+            buf_offset += need_size;
+            buf_left = numBytes - buf_offset;
+
+            *output_buf = (void*)(parser_buf);
+            *out_size   = frame_size;
+            *used_size  = buf_offset;
+            ALOGV("OK framesize =%d used size=%d loop_cnt=%d", frame_size, buf_offset, loop_cnt);
+            /*one frame has complete, need find next one*/
+            parser_hanlde->buf_remain = 0;
+            parser_hanlde->status = PARSER_SYNCING;
+        } else {
+            /*internal buf has more data than framsize, we only need part of it*/
+            *output_buf = (void*)(parser_buf);
+            *out_size   = frame_size;
+            /*move need_size bytes back to original buf*/
+            *used_size  = buf_offset + need_size;
+            ALOGV("wrap frame size=%d used size=%d back size =%d loop_cnt=%d", frame_size, buf_offset, need_size, loop_cnt);
+            if (*used_size <= 0) {
+                ALOGE("%s wrong used size =%d", __func__, *used_size);
+                parser_hanlde->buf_remain = 0;
+                parser_hanlde->status = PARSER_SYNCING;
+                goto error;
+            }
+            /*one frame has complete, need find next one*/
+            parser_hanlde->buf_remain = 0;
+            parser_hanlde->status = PARSER_SYNCING;
+        }
+    } else {
+        /*check whether the input buf size is big enough*/
+        new_buf_size = parser_hanlde->buf_remain + buf_left;
+        if (new_buf_size > parser_hanlde->buf_size) {
+            void * new_buf = realloc(parser_hanlde->buf, new_buf_size);
+            if (new_buf == NULL) {
+                ALOGE("%s realloc buf failed =%d", __func__, new_buf_size);
+                parser_hanlde->buf_remain = 0;
+                parser_hanlde->status = PARSER_SYNCING;
+                goto error;
+            }
+            parser_hanlde->buf      = new_buf;
+            parser_hanlde->buf_size = new_buf_size;
+            parser_buf = parser_hanlde->buf;
+            ALOGI("%s realloc buf =%d", __func__, new_buf_size);
+        }
+        memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+        parser_hanlde->buf_remain += buf_left;
+        parser_hanlde->status = PARSER_LACK_DATA;
+        goto error;
+    }
+
+    return 0;
+
+error:
+    *output_buf = NULL;
+    *out_size   = 0;
+    *used_size = numBytes;
+    return 0;
+}
diff --git a/audio_hal/aml_audio_ac4parser.h b/audio_hal/aml_audio_ac4parser.h
new file mode 100644
index 0000000..52e9089
--- /dev/null
+++ b/audio_hal/aml_audio_ac4parser.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AML_AUDIO_AC4PARSER_H_
+#define _AML_AUDIO_AC4PARSER_H_
+
+struct ac4_parser_info {
+    int frame_size;     /*bitsteam size*/
+    int frame_rate;   /*ac4 frame rate*/
+    int sample_rate;    /*sample rate*/
+};
+
+
+int aml_ac4_parser_open(void **pparser_handle);
+int aml_ac4_parser_close(void *parser_handle);
+int aml_ac4_parser_process(void *parser_handle, const void *buffer, int32_t numBytes, int32_t *used_size, void **output_buf, int32_t *out_size, struct ac4_parser_info * ac4_info);
+int aml_ac4_parser_reset(void *parser_handle);
+
+
+#endif
diff --git a/audio_hal/aml_audio_avsync_table.h b/audio_hal/aml_audio_avsync_table.h
new file mode 100644
index 0000000..c83634a
--- /dev/null
+++ b/audio_hal/aml_audio_avsync_table.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+#ifndef  _AUDIO_AVSYNC_TABLE_H_
+#define _AUDIO_AVSYNC_TABLE_H_
+
+/* we use this table to tune the AV sync case for A/V playback including Tunnel
+ * and None-Tunnel mode with the PCM/RAW source to audio HAL
+ * if the value is positive (+), it can delay video as to give  smaller reported audio position (APTS)
+ * if the value is negetive(-), it can advance the video as to give larger reported audio position(APTS)
+ */
+
+/*below MS12 tunning default value for different source and tunnel/none-tunnel*/
+#define  AVSYNC_MS12_NONTUNNEL_PCM_LATENCY               (60)
+#define  AVSYNC_MS12_NONTUNNEL_RAW_LATENCY               (40)
+#define  AVSYNC_MS12_NONTUNNEL_ATMOS_LATENCY             (20)
+#define  AVSYNC_MS12_TUNNEL_PCM_LATENCY                  (80)
+#define  AVSYNC_MS12_TUNNEL_RAW_LATENCY                  (30)
+#define  AVSYNC_MS12_TUNNEL_ATMOS_LATENCY                (20)
+
+/*
+below is the default value for different output format  for  HDMITX/ARC sink
+*/
+#define  AVSYNC_HDMI_PCM_LATENCY           (-20)
+#define  AVSYNC_HDMI_DD_LATENCY            (-80)
+#define  AVSYNC_HDMI_DDP_LATENCY           (-190)
+#define  AVSYNC_HDMI_AC4_LATENCY           (-100)
+#define  AVSYNC_HDMI_MAT_LATENCY           (-100)
+/*below is the defalue value for atmos output of ARC sink  */
+#define  AUDIO_ATMOS_HDMI_AUTO_LATENCY              -60
+
+#define VENDOR_AUDIO_MS12_PASSTHROUGH_LATENCY		80
+
+#define AVSYNC_SPEAKER_PCM_LATENCY (-0)
+#define AVSYNC_SPEAKER_DD_LATENCY  (-30)
+#define AVSYNC_SPEAKER_DDP_LATENCY (-30)
+#define AVSYNC_SPEAKER_AC4_LATENCY (-30)
+#define AVSYNC_SPEAKER_MAT_LATENCY (-10)
+
+
+
+#define AUDIO_ATMOS_HDMI_LANTCY_PROPERTY "vendor.audio.hal.atmos.latency"
+#define AUDIO_ATMOS_HDMI_PASSTHROUGH_PROPERTY "vendor.audio.hal.amtms.passthrough.latency"
+
+
+/* ms12 version */
+#define  AVSYNC_MS12_NONTUNNEL_PCM_LATENCY_PROPERTY      "vendor.audio.hal.ms12.nontunnel.pcm"
+#define  AVSYNC_MS12_NONTUNNEL_RAW_LATENCY_PROPERTY      "vendor.audio.hal.ms12.nontunnel.raw"
+#define  AVSYNC_MS12_NONTUNNEL_ATMOS_LATENCY_PROPERTY    "vendor.audio.hal.ms12.nontunnel.atmos"
+#define  AVSYNC_MS12_TUNNEL_PCM_LATENCY_PROPERTY         "vendor.audio.hal.ms12.tunnel.pcm"
+#define  AVSYNC_MS12_TUNNEL_RAW_LATENCY_PROPERTY         "vendor.audio.hal.ms12.tunnel.raw"
+#define  AVSYNC_MS12_TUNNEL_ATMOS_LATENCY_PROPERTY       "vendor.audio.hal.ms12.tunnel.atmos"
+
+/*HDMITX/ARC sink format  tunning */
+#define  AVSYNC_HDMI_PCM_LATENCY_PROPERTY         "vendor.audio.hal.hdmi.pcm"
+#define  AVSYNC_HDMI_DD_LATENCY_PROPERTY          "vendor.audio.hal.hdmi.dd"
+#define  AVSYNC_HDMI_DDP_LATENCY_PROPERTY         "vendor.audio.hal.hdmi.ddp"
+#define AVSYNC_HDMI_AC4_LATENCY_PROPERTY            "vendor.audio.hal.hdmi.ac4"
+#define AVSYNC_HDMI_MAT_LATENCY_PROPERTY            "vendor.audio.hal.hdmi.mat"
+
+/*HDMITX/ARC sink format  tunning */
+#define AVSYNC_SPEAKER_PCM_LATENCY_PROPERTY "vendor.audio.hal.speaker.pcm"
+#define AVSYNC_SPEAKER_DD_LATENCY_PROPERTY "vendor.audio.hal.speaker.dd"
+#define AVSYNC_SPEAKER_DDP_LATENCY_PROPERTY "vendor.audio.hal.speaker.ddp"
+#define AVSYNC_SPEAKER_AC4_LATENCY_PROPERTY "vendor.audio.hal.speaker.ac4"
+#define AVSYNC_SPEAKER_MAT_LATENCY_PROPERTY "vendor.audio.hal.speaker.mat"
+/* DDP version */
+#define  AVSYNC_DDP_NONTUNNEL_PCM_LATENCY               (0)
+#define  AVSYNC_DDP_NONTUNNEL_RAW_LATENCY               (0)
+#define  AVSYNC_DDP_TUNNEL_PCM_LATENCY                  (0)
+#define  AVSYNC_DDP_TUNNEL_RAW_LATENCY                  (0)
+
+
+#define  AVSYNC_DDP_NONTUNNEL_PCM_LATENCY_PROPERTY      "vendor.audio.hal.ddp.nontunnel.pcm"
+#define  AVSYNC_DDP_NONTUNNEL_RAW_LATENCY_PROPERTY      "vendor.audio.hal.ddp.nontunnel.raw"
+#define  AVSYNC_DDP_TUNNEL_PCM_LATENCY_PROPERTY         "vendor.audio.hal.ddp.tunnel.pcm"
+#define  AVSYNC_DDP_TUNNEL_RAW_LATENCY_PROPERTY         "vendor.audio.hal.ddp.tunnel.raw"
+
+
+
+#endif
+
diff --git a/audio_hal/aml_audio_bitsparser.c b/audio_hal/aml_audio_bitsparser.c
new file mode 100644
index 0000000..37db9c6
--- /dev/null
+++ b/audio_hal/aml_audio_bitsparser.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "audio_bit_parser"
+
+#include <cutils/log.h>
+
+#include "aml_audio_bitsparser.h"
+
+
+bool static inline fillReservoir(struct audio_bit_parser * bit_parser)
+{
+    if (bit_parser->data_size == 0) {
+        bit_parser->is_over_read = true;
+        return false;
+    }
+
+    bit_parser->num_reservoir = 0;
+    size_t i;
+    for (i = 0; bit_parser->data_size > 0 && i < 4; ++i) {
+        bit_parser->num_reservoir = (bit_parser->num_reservoir << 8) | *bit_parser->data_buf;
+
+        ++bit_parser->data_buf;
+        --bit_parser->data_size;
+    }
+
+    bit_parser->num_bitsleft = 8 * i;
+    bit_parser->num_reservoir <<= 32 - bit_parser->num_bitsleft;
+    return true;
+}
+
+bool static inline getBitsGraceful(struct audio_bit_parser * bit_parser, size_t n, uint32_t *out)
+{
+    if (n > 32) {
+        return false;
+    }
+
+    uint32_t result = 0;
+    while (n > 0) {
+        if (bit_parser->num_bitsleft == 0) {
+            if (!fillReservoir(bit_parser)) {
+                return false;
+            }
+        }
+
+        size_t m = n;
+        if (m > bit_parser->num_bitsleft) {
+            m = bit_parser->num_bitsleft;
+        }
+
+        result = (result << m) | (bit_parser->num_reservoir >> (32 - m));
+        bit_parser->num_reservoir <<= m;
+        bit_parser->num_bitsleft -= m;
+
+        n -= m;
+    }
+
+    *out = result;
+    return true;
+}
+
+
+
+int aml_audio_bitparser_init(struct audio_bit_parser * bit_parser, const uint8_t *buf, size_t size)
+{
+    if (bit_parser == NULL ||
+        buf == NULL ||
+        size == 0) {
+        ALOGE("%s invalid parameter", __FUNCTION__);
+        return -1;
+    }
+
+    bit_parser->data_buf       = buf;
+    bit_parser->data_size      = size;
+    bit_parser->num_reservoir  = 0;
+    bit_parser->num_bitsleft   = 0;
+    bit_parser->is_over_read   = false;
+
+
+    return 0;
+}
+
+int aml_audio_bitparser_deinit(struct audio_bit_parser * bit_parser)
+{
+    bit_parser->data_buf       = NULL;
+    bit_parser->data_size      = 0;
+    bit_parser->num_reservoir  = 0;
+    bit_parser->num_bitsleft   = 0;
+    bit_parser->is_over_read   = false;
+
+    return 0;
+}
+
+int aml_audio_bitparser_getBits(struct audio_bit_parser * bit_parser, size_t n)
+{
+    uint32_t ret = 0;
+    getBitsGraceful(bit_parser, n, &ret);
+    return ret;
+}
+
+
+bool aml_audio_bitparser_skipBits(struct audio_bit_parser * bit_parser, size_t n)
+{
+    uint32_t dummy;
+    while (n > 32) {
+        if (!getBitsGraceful(bit_parser, 32, &dummy)) {
+            return false;
+        }
+        n -= 32;
+    }
+
+    if (n > 0) {
+        return getBitsGraceful(bit_parser, n, &dummy);
+    }
+    return true;
+}
+
+void aml_audio_bitparser_putBits(struct audio_bit_parser * bit_parser, uint32_t x, size_t n)
+{
+    if (bit_parser->is_over_read) {
+        return;
+    }
+
+    while (bit_parser->num_bitsleft + n > 32) {
+        bit_parser->num_bitsleft -= 8;
+        --bit_parser->data_buf;
+        ++bit_parser->data_size;
+    }
+
+    bit_parser->num_reservoir = (bit_parser->num_reservoir >> n) | (x << (32 - n));
+    bit_parser->num_bitsleft += n;
+    return;
+}
+
+
diff --git a/audio_hal/aml_audio_bitsparser.h b/audio_hal/aml_audio_bitsparser.h
new file mode 100644
index 0000000..339ef6b
--- /dev/null
+++ b/audio_hal/aml_audio_bitsparser.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AML_AUDIO_BITPARSER_H
+#define AML_AUDIO_BITPARSER_H
+
+#include <stdbool.h>
+
+struct audio_bit_parser {
+    const uint8_t *data_buf;
+    size_t data_size;
+    uint32_t num_reservoir;  // left-aligned bits
+    size_t num_bitsleft;
+    bool is_over_read;
+};
+
+
+int aml_audio_bitparser_init(struct audio_bit_parser * bit_parser, const uint8_t *buf, size_t size);
+
+int aml_audio_bitparser_deinit(struct audio_bit_parser * bit_parser);
+
+int aml_audio_bitparser_getBits(struct audio_bit_parser * bit_parser, size_t n);
+
+bool aml_audio_bitparser_skipBits(struct audio_bit_parser * bit_parser, size_t n);
+
+
+
+#endif
diff --git a/audio_hal/aml_audio_delay.c b/audio_hal/aml_audio_delay.c
index 58ea9cf..74e94fe 100644
--- a/audio_hal/aml_audio_delay.c
+++ b/audio_hal/aml_audio_delay.c
@@ -27,24 +27,39 @@
 #define ALIGN(size, align) ((size + align - 1) & (~(align - 1)))
 
 
-static aml_audio_delay_st g_stAudioOutputDelay[AML_DELAY_OUTPORT_BUTT];
-static const int g_u32OutDelayMaxDefault[AML_DELAY_OUTPORT_BUTT] = {1000, 1000, 1000};
+static aml_audio_delay_st g_stAudioDelay[AML_DELAY_BUTT];
+static int g_stAudioInputDelay[AML_DELAY_INPUT_MAX] = {0, 0, 0, 0, 0};
+static const int g_u32DelayMaxDefault[AML_DELAY_BUTT] = {1000, 1000, 1000, 1000};
 static bool g_bAudioDelayInit = false;
+static aml_audio_delay_input_type_e g_delay_input_type = AML_DELAY_INPUT_DEFAULT;
 
 int aml_audio_delay_init()
 {
-    memset(&g_stAudioOutputDelay, 0, sizeof(aml_audio_delay_st)*AML_DELAY_OUTPORT_BUTT);
-    for (unsigned int i=0; i<AML_DELAY_OUTPORT_BUTT; i++) {
+    int i;
+    memset(&g_stAudioDelay, 0, sizeof(aml_audio_delay_st)*AML_DELAY_BUTT);
+
+    for (i=0; i<AML_DELAY_BUTT; i++) {
         int s32BfferSize = 0;
         unsigned int u32ChannelCnt = 2;
         if ((AML_DELAY_OUTPORT_ALL == i) || (AML_DELAY_OUTPORT_SPEAKER == i)) {
             /*calculate the max size for 8ch */
             u32ChannelCnt = 8;
+        } else if (AML_DELAY_INPORT_ALL == i) {
+            // worst case MAT input
+            // 192k sr * 2 channel * 2 (bytes) * 16 (hbr)
+            u32ChannelCnt = 16;
         }
-        s32BfferSize = 192 * u32ChannelCnt * 4 * g_u32OutDelayMaxDefault[i];
-        ring_buffer_init(&g_stAudioOutputDelay[i].stDelayRbuffer, s32BfferSize);
+        s32BfferSize = 192 * u32ChannelCnt * 4 * g_u32DelayMaxDefault[i];
+        ring_buffer_init(&g_stAudioDelay[i].stDelayRbuffer, s32BfferSize);
+    }
+
+    for (i=0; i<AML_DELAY_INPUT_MAX; i++) {
+        g_stAudioInputDelay[i] = 0;
     }
+
+    g_delay_input_type = AML_DELAY_INPUT_DEFAULT;
     g_bAudioDelayInit = true;
+
     return 0;
 }
 
@@ -54,12 +69,10 @@ int aml_audio_delay_deinit()
         ALOGW("[%s:%d] audio delay not initialized", __func__, __LINE__);
         return -1;
     }
-
-    for (unsigned int i=0; i<AML_DELAY_OUTPORT_BUTT; i++) {
-        ring_buffer_release(&g_stAudioOutputDelay[i].stDelayRbuffer);
+    for (unsigned int i=0; i<AML_DELAY_BUTT; i++) {
+        ring_buffer_release(&g_stAudioDelay[i].stDelayRbuffer);
     }
     g_bAudioDelayInit = false;
-
     return 0;
 }
 
@@ -72,80 +85,119 @@ int aml_audio_delay_set_time(aml_audio_delay_type_e enAudioDelayType, int s32Del
         ALOGW("[%s:%d] audio delay not initialized", __func__, __LINE__);
         return -1;
     }
-    if (enAudioDelayType < AML_DELAY_OUTPORT_SPEAKER || enAudioDelayType >= AML_DELAY_OUTPORT_BUTT) {
+    if (enAudioDelayType < AML_DELAY_OUTPORT_SPEAKER || enAudioDelayType >= AML_DELAY_BUTT) {
         ALOGW("[%s:%d] delay type:%d invalid, min:%d, max:%d",
-            __func__, __LINE__, enAudioDelayType, AML_DELAY_OUTPORT_SPEAKER, AML_DELAY_OUTPORT_BUTT-1);
+            __func__, __LINE__, enAudioDelayType, AML_DELAY_OUTPORT_SPEAKER, AML_DELAY_BUTT-1);
         return -1;
     }
-    if (s32DelayTimeMs < 0 || s32DelayTimeMs > g_u32OutDelayMaxDefault[enAudioDelayType]) {
+    if (s32DelayTimeMs < 0 || s32DelayTimeMs > g_u32DelayMaxDefault[enAudioDelayType]) {
         ALOGW("[%s:%d] unsupport delay time:%dms, min:%dms, max:%dms",
-            __func__, __LINE__, s32DelayTimeMs, 0, g_u32OutDelayMaxDefault[enAudioDelayType]);
+            __func__, __LINE__, s32DelayTimeMs, 0, g_u32DelayMaxDefault[enAudioDelayType]);
         return -1;
     }
-    g_stAudioOutputDelay[enAudioDelayType].delay_time = s32DelayTimeMs;
+    g_stAudioDelay[enAudioDelayType].delay_time = s32DelayTimeMs;
     ALOGI("set audio output type:%d delay time: %dms", enAudioDelayType, s32DelayTimeMs);
     return 0;
 }
 
-int aml_audio_delay_clear(aml_audio_delay_type_e enAudioDelayType)
+int aml_audio_delay_input_set_time(aml_audio_delay_input_type_e enAudioDelayType, int s32DelayTimeMs)
 {
     if (!g_bAudioDelayInit) {
         ALOGW("[%s:%d] audio delay not initialized", __func__, __LINE__);
         return -1;
     }
-    if (enAudioDelayType < AML_DELAY_OUTPORT_SPEAKER || enAudioDelayType >= AML_DELAY_OUTPORT_BUTT) {
-        ALOGW("[%s:%d] delay type:%d invalid, min:%d, max:%d",
-            __func__, __LINE__, enAudioDelayType, AML_DELAY_OUTPORT_SPEAKER, AML_DELAY_OUTPORT_BUTT-1);
+
+    if (enAudioDelayType < AML_DELAY_INPUT_HDMI || enAudioDelayType >= AML_DELAY_INPUT_MAX) {
+        ALOGW("[%s:%d] delay input type:%d invalid, min:%d, max:%d",
+        __func__, __LINE__, enAudioDelayType, AML_DELAY_INPUT_HDMI, AML_DELAY_INPUT_MAX-1);
         return -1;
     }
 
-    ring_buffer_reset(&g_stAudioOutputDelay[enAudioDelayType].stDelayRbuffer);
+    if (s32DelayTimeMs < 0 || s32DelayTimeMs > g_u32DelayMaxDefault[AML_DELAY_INPORT_ALL]) {
+        ALOGW("[%s:%d] unsupport delay time:%dms, min:%dms, max:%dms",
+            __func__, __LINE__, s32DelayTimeMs, 0, g_u32DelayMaxDefault[AML_DELAY_INPORT_ALL]);
+        return -1;
+    }
+    g_stAudioInputDelay[enAudioDelayType] = s32DelayTimeMs;
+    ALOGI("set audio input type::%d delay time: %dms", enAudioDelayType, s32DelayTimeMs);
+
+    if (g_delay_input_type == enAudioDelayType) {
+        g_stAudioDelay[AML_DELAY_INPORT_ALL].delay_time = s32DelayTimeMs;
+    }
+
     return 0;
 }
 
-int aml_audio_delay_process(aml_audio_delay_type_e enAudioDelayType, void *pData, int s32Size, audio_format_t enFormat, int nChannel)
+int aml_audio_delay_clear(aml_audio_delay_type_e enAudioDelayType)
 {
     if (!g_bAudioDelayInit) {
         ALOGW("[%s:%d] audio delay not initialized", __func__, __LINE__);
         return -1;
     }
-    if (enAudioDelayType < AML_DELAY_OUTPORT_SPEAKER || enAudioDelayType >= AML_DELAY_OUTPORT_BUTT) {
+    if (enAudioDelayType < AML_DELAY_OUTPORT_SPEAKER || enAudioDelayType >= AML_DELAY_BUTT) {
         ALOGW("[%s:%d] delay type:%d invalid, min:%d, max:%d",
-            __func__, __LINE__, enAudioDelayType, AML_DELAY_OUTPORT_SPEAKER, AML_DELAY_OUTPORT_BUTT-1);
+            __func__, __LINE__, enAudioDelayType, AML_DELAY_OUTPORT_SPEAKER, AML_DELAY_BUTT-1);
         return -1;
     }
 
-    unsigned int    u32OneMsSize = 0;
-    int             s32CurNeedDelaySize = 0;
-    int             s32AvailDataSize = 0;
+    ring_buffer_reset(&g_stAudioDelay[enAudioDelayType].stDelayRbuffer);
+    return 0;
+}
+
+int aml_audio_delay_input_set_type(aml_audio_delay_input_type_e enAudioDelayType)
+{
+    if (enAudioDelayType < AML_DELAY_INPUT_HDMI || enAudioDelayType >= AML_DELAY_INPUT_MAX) {
+        ALOGW("[%s:%d] delay input type:%d invalid, min:%d, max:%d",
+            __func__, __LINE__, enAudioDelayType, AML_DELAY_INPUT_HDMI, AML_DELAY_INPUT_MAX-1);
+        return -1;
+    }
 
-    if (AML_DELAY_OUTPORT_ALL == enAudioDelayType) {
-        if (enFormat == AUDIO_FORMAT_E_AC3) {
-            u32OneMsSize = 192 * 4;// * abs(adev->delay_ms);
-        } else if (enFormat == AUDIO_FORMAT_AC3) {
-            u32OneMsSize = 48 * 4;// * abs(adev->delay_ms);
-        } else if (enFormat == AUDIO_FORMAT_MAT) {
-            u32OneMsSize = 192 * 4 * 4;// * abs(adev->delay_ms);
-        } else {
-            u32OneMsSize = 48 * 8 * 4; // 48k * 8ch * 4Byte
-        }
-    } else if (AML_DELAY_OUTPORT_SPEAKER == enAudioDelayType){
-        u32OneMsSize = 48 * nChannel * 2;  // 48k * 2ch * 2Byte
-    } else if (AML_DELAY_OUTPORT_SPDIF == enAudioDelayType){
-        if (AUDIO_FORMAT_IEC61937 == enFormat) {
-            u32OneMsSize = 48 * 2 * 2;  // 48k * 2ch * 2Byte
-        } else {
-            u32OneMsSize = 48 * 2 * 4;  // 48k * 2ch * 4Byte [Notes: alsa only support 32bit(4Byte)]
-        }
+    if (g_stAudioDelay[AML_DELAY_INPORT_ALL].delay_time != g_stAudioInputDelay[enAudioDelayType]) {
+        aml_audio_delay_clear(AML_DELAY_INPORT_ALL);
+        g_stAudioDelay[AML_DELAY_INPORT_ALL].delay_time = g_stAudioInputDelay[enAudioDelayType];
+        ALOGI("Set input delay to %dms", g_stAudioDelay[AML_DELAY_INPORT_ALL].delay_time);
     }
 
+    g_delay_input_type = enAudioDelayType;
+
+    return 0;
+}
+
+static int _get_delay_ms_size(audio_format_t enFormat, int nChannel,
+    int nSampleRate, int nSampleSize)
+{
+    int size;
+
+    if (enFormat == AUDIO_FORMAT_AC3) {
+        size = nSampleRate * 2 * 2;
+    } else if ((enFormat == AUDIO_FORMAT_E_AC3) ||
+        (enFormat == AUDIO_FORMAT_E_AC3_JOC)) {
+        size = nSampleRate * 2 * 2 * 4;
+    } else if (enFormat == AUDIO_FORMAT_MAT) {
+        size = nSampleRate * 2 * 2 * 16;
+    } else if (enFormat == AUDIO_FORMAT_IEC61937) {
+        size = nSampleRate * 2 * 2;
+    } else {
+        /* PCM */
+        size = nSampleRate * nChannel * nSampleSize;
+    }
+
+    return size / 1000;
+}
+
+static int _delay_process(aml_audio_delay_type_e enAudioDelayType, unsigned int u32OneMsSize,
+   void *pData, int s32Size)
+{
+    int s32CurNeedDelaySize = 0;
+    int s32AvailDataSize = 0;
+
     // calculate need delay total size
-    s32CurNeedDelaySize = ALIGN(g_stAudioOutputDelay[enAudioDelayType].delay_time * u32OneMsSize, 16);
+    s32CurNeedDelaySize = ALIGN(g_stAudioDelay[enAudioDelayType].delay_time * u32OneMsSize, 16);
     // get current ring buffer delay data size
-    s32AvailDataSize = ALIGN((get_buffer_read_space(&g_stAudioOutputDelay[enAudioDelayType].stDelayRbuffer) / u32OneMsSize) * u32OneMsSize, 16);
+    s32AvailDataSize = ALIGN((get_buffer_read_space(&g_stAudioDelay[enAudioDelayType].stDelayRbuffer) / u32OneMsSize) * u32OneMsSize, 16);
 
-    ring_buffer_write(&g_stAudioOutputDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, s32Size, UNCOVER_WRITE);
-    ALOGV("%s:%d AvailDataSize:%d, enFormat:%#x, u32OneMsSize:%d", __func__, __LINE__, s32AvailDataSize, enFormat, u32OneMsSize);
+    ring_buffer_write(&g_stAudioDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, s32Size, UNCOVER_WRITE);
+    ALOGV("%s:%d AvailDataSize:%d, u32OneMsSize:%d", __func__, __LINE__, s32AvailDataSize, u32OneMsSize);
 
     // accumulate this delay data
     if (s32CurNeedDelaySize > s32AvailDataSize) {
@@ -157,7 +209,7 @@ int aml_audio_delay_process(aml_audio_delay_type_e enAudioDelayType, void *pData
         } else {
             // splicing this pData data
             memset(pData, 0, s32NeedAddDelaySize);
-            ring_buffer_read(&g_stAudioOutputDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData+s32NeedAddDelaySize, s32Size-s32NeedAddDelaySize);
+            ring_buffer_read(&g_stAudioDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData+s32NeedAddDelaySize, s32Size-s32NeedAddDelaySize);
             ALOGD("%s:%d type:%d accumulate part pData CurNeedDelaySize:%d, need more DelaySize:%d, size:%d", __func__, __LINE__,
                 enAudioDelayType, s32CurNeedDelaySize, s32NeedAddDelaySize, s32Size);
         }
@@ -169,21 +221,70 @@ int aml_audio_delay_process(aml_audio_delay_type_e enAudioDelayType, void *pData
         for (;u32ClearedSize < u32NeedDecreaseDelaySize; ) {
             unsigned int u32ResidualClearSize = u32NeedDecreaseDelaySize - u32ClearedSize;
             if (u32ResidualClearSize > (unsigned int)s32Size) {
-                ring_buffer_read(&g_stAudioOutputDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, s32Size);
+                ring_buffer_read(&g_stAudioDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, s32Size);
                 u32ClearedSize += s32Size;
             } else {
-                ring_buffer_read(&g_stAudioOutputDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, u32ResidualClearSize);
+                ring_buffer_read(&g_stAudioDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, u32ResidualClearSize);
                 break;
             }
         }
-        ring_buffer_read(&g_stAudioOutputDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, s32Size);
+        ring_buffer_read(&g_stAudioDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, s32Size);
         ALOGD("%s:%d type:%d drop delay data, CurNeedDelaySize:%d, NeedDecreaseDelaySize:%d, size:%d", __func__, __LINE__,
             enAudioDelayType, s32CurNeedDelaySize, u32NeedDecreaseDelaySize, s32Size);
     } else {
-        ring_buffer_read(&g_stAudioOutputDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, s32Size);
+        ring_buffer_read(&g_stAudioDelay[enAudioDelayType].stDelayRbuffer, (unsigned char *)pData, s32Size);
         ALOGV("%s:%d do nothing, CurNeedDelaySize:%d, size:%d", __func__, __LINE__, s32CurNeedDelaySize, s32Size);
     }
 
     return 0;
 }
 
+int aml_audio_delay_input_process(void *pData, int s32Size,
+    audio_format_t enFormat, int nChannel, int nsampleRate, int nSampleSize)
+{
+    unsigned int u32OneMsSize;
+
+    if (!g_bAudioDelayInit) {
+        ALOGW("[%s:%d] audio delay not initialized", __func__, __LINE__);
+        return -1;
+    }
+
+    u32OneMsSize = _get_delay_ms_size(enFormat, nChannel, nsampleRate, nSampleSize);
+
+    return _delay_process(AML_DELAY_INPORT_ALL, u32OneMsSize, pData, s32Size);
+}
+
+int aml_audio_delay_input_get_ms()
+{
+    return g_stAudioInputDelay[g_delay_input_type];
+}
+
+int aml_audio_delay_process(aml_audio_delay_type_e enAudioDelayType, void *pData, int s32Size, audio_format_t enFormat, int nChannel)
+{
+    unsigned int u32OneMsSize = 0;
+
+    if (!g_bAudioDelayInit) {
+        ALOGW("[%s:%d] audio delay not initialized", __func__, __LINE__);
+        return -1;
+    }
+    if (enAudioDelayType < AML_DELAY_OUTPORT_SPEAKER || enAudioDelayType >= AML_DELAY_BUTT) {
+        ALOGW("[%s:%d] delay type:%d invalid, min:%d, max:%d",
+            __func__, __LINE__, enAudioDelayType, AML_DELAY_OUTPORT_SPEAKER, AML_DELAY_BUTT-1);
+        return -1;
+    }
+
+    if (AML_DELAY_OUTPORT_ALL == enAudioDelayType) {
+        u32OneMsSize = _get_delay_ms_size(enFormat, 8, 48000, 4);
+    } else if (AML_DELAY_OUTPORT_SPEAKER == enAudioDelayType){
+        u32OneMsSize = _get_delay_ms_size(AUDIO_FORMAT_PCM, nChannel, 48000, 2); // 48k * nChannel * 2Byte
+    } else if (AML_DELAY_OUTPORT_SPDIF == enAudioDelayType){
+        if (AUDIO_FORMAT_IEC61937 == enFormat) {
+            u32OneMsSize = _get_delay_ms_size(enFormat, 2, 48000, 2); // 48k * 2ch * 2Byte
+        } else {
+            u32OneMsSize = _get_delay_ms_size(AUDIO_FORMAT_PCM, 2, 48000, 4); // 48k * 2ch * 4Byte [Notes: alsa only support 32bit(4Byte)]
+        }
+    }
+
+    return _delay_process(enAudioDelayType, u32OneMsSize, pData, s32Size);
+}
+
diff --git a/audio_hal/aml_audio_delay.h b/audio_hal/aml_audio_delay.h
index 769a888..cdb1aee 100644
--- a/audio_hal/aml_audio_delay.h
+++ b/audio_hal/aml_audio_delay.h
@@ -27,20 +27,32 @@ typedef struct AML_AUDIO_DELAY {
 } aml_audio_delay_st;
 
 
-typedef enum AML_AUDIO_DELAY_TYPE{
+typedef enum AML_AUDIO_DELAY_TYPE {
     AML_DELAY_OUTPORT_SPEAKER           = 0,
     AML_DELAY_OUTPORT_SPDIF             = 1,
     AML_DELAY_OUTPORT_ALL               = 2,
-
-    AML_DELAY_OUTPORT_BUTT              = 3,
+    AML_DELAY_INPORT_ALL                = 3,
+    AML_DELAY_BUTT                      = 4,
 } aml_audio_delay_type_e;
 
+typedef enum AML_AUDIO_INPUT_DELAY_TYPE {
+    AML_DELAY_INPUT_HDMI                = 0,
+    AML_DELAY_INPUT_ARC                 = 1,
+    AML_DELAY_INPUT_OPT                 = 2,
+    AML_DELAY_INPUT_HDMI_BT             = 3,
+    AML_DELAY_INPUT_DEFAULT             = 4,
+    AML_DELAY_INPUT_MAX                 = 5
+}  aml_audio_delay_input_type_e;
+
 int aml_audio_delay_init();
 int aml_audio_delay_deinit();
 int aml_audio_delay_set_time(aml_audio_delay_type_e enAudioDelayType, int s32DelayTimeMs);
+int aml_audio_delay_input_set_time(aml_audio_delay_input_type_e enAudioInputDelayType, int s32DelayTimeMs);
+int aml_audio_delay_input_set_type(aml_audio_delay_input_type_e enAudioDelayType);
+int aml_audio_delay_input_get_ms();
 int aml_audio_delay_clear(aml_audio_delay_type_e enAudioDelayType);
 int aml_audio_delay_process(aml_audio_delay_type_e enAudioDelayType, void *pData, int s32Size, audio_format_t enFormat, int nChannel);
-
+int aml_audio_delay_input_process(void *pData, int s32Size, audio_format_t enFormat, int nChannel, int nsampleRate, int nSampleSize);
 
 #endif
 
diff --git a/audio_hal/aml_audio_ease.c b/audio_hal/aml_audio_ease.c
index 66f2080..c90b007 100644
--- a/audio_hal/aml_audio_ease.c
+++ b/audio_hal/aml_audio_ease.c
@@ -191,17 +191,18 @@ int aml_audio_ease_config(aml_audio_ease_t * ease_handle, ease_setting_t *settin
 
 int aml_audio_ease_process(aml_audio_ease_t * ease_handle, void * in_data, size_t size) {
 
-    audio_format_t format = ease_handle->data_format.format;
-    int ch = ease_handle->data_format.ch;
+    audio_format_t format;
+    int ch;
     int nframes = 0;
 
     int i = 0, j = 0;
     float vol_delta;
 
-    if (ease_handle == NULL || in_data == NULL || ch == 0 || size == 0 || ease_handle->ease_status == Invalid
-            || (format != AUDIO_FORMAT_PCM_16_BIT && format != AUDIO_FORMAT_PCM_32_BIT)) {
+    if (ease_handle == NULL || in_data == NULL || ease_handle->data_format.ch == 0 || size == 0 || ease_handle->ease_status == Invalid) {
          return -1;
     }
+    ch = ease_handle->data_format.ch;
+    format = ease_handle->data_format.format;
     pthread_mutex_lock(&ease_handle->ease_lock);
     nframes  = size / (audio_bytes_per_sample(format) * ch);
 
diff --git a/audio_hal/aml_audio_ms12_bypass.c b/audio_hal/aml_audio_ms12_bypass.c
new file mode 100644
index 0000000..909344a
--- /dev/null
+++ b/audio_hal/aml_audio_ms12_bypass.c
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "audio_ms12_bypass"
+
+#include <cutils/log.h>
+#include <inttypes.h>
+#include "audio_hw.h"
+#include "aml_audio_ms12_bypass.h"
+
+#define BYPASS_MS12_MAX_FRAME_SIZE (32768)
+#define DDP_FRAME_BLK_NUM          (6)
+
+
+struct bypass_frame_item {
+    struct listnode list;
+    uint32_t frame_size;
+    void *   frame_buf;
+    uint32_t frame_cnt;
+    uint64_t offset_start;
+    uint64_t offset_end;
+    uint32_t numblks;
+    struct bypass_frame_info info;
+};
+
+struct aml_ms12_bypass_handle {
+    void *  buf;
+    uint32_t buf_size;
+    uint64_t data_offset;
+    struct listnode frame_list;
+    pthread_mutex_t list_lock;
+};
+
+static void delete_bypass_frame(struct bypass_frame_item * frame)
+{
+    if (frame) {
+        if (frame->frame_buf) {
+            free(frame->frame_buf);
+        }
+        free(frame);
+    }
+    return;
+}
+
+static struct bypass_frame_item * new_bypass_frame(const void *buffer, int32_t numBytes, struct bypass_frame_info * data_info)
+{
+    struct bypass_frame_item *frame = NULL;
+    /*malloc frame item*/
+    frame = (struct bypass_frame_item *)calloc(1, sizeof(struct bypass_frame_item));
+    if (frame == NULL) {
+        goto exit;
+    }
+    memcpy(&frame->info, data_info, sizeof(struct bypass_frame_info));
+
+    /*malloc buffer*/
+    frame->frame_buf = calloc(1, numBytes);
+    memcpy(frame->frame_buf, buffer, numBytes);
+    frame->frame_size = numBytes;
+
+    frame->frame_cnt  = 1;
+
+    return frame;
+exit:
+    delete_bypass_frame(frame);
+
+    ALOGE("%s failed", __FUNCTION__);
+    return NULL;
+}
+
+static struct bypass_frame_item * modify_bypass_frame(struct bypass_frame_item * frame, const void *buffer, int32_t numBytes)
+{
+    uint32_t new_frame_size = frame->frame_size + numBytes;
+    frame->frame_buf = realloc(frame->frame_buf, new_frame_size);
+    if (frame->frame_buf == NULL) {
+        ALOGE("realloc size =%d failed", new_frame_size);
+        return NULL;
+    }
+    memcpy((char *)frame->frame_buf + frame->frame_size, buffer, numBytes);
+    frame->frame_size = new_frame_size;
+    frame->frame_cnt++;
+
+    return frame;
+}
+
+int aml_ms12_bypass_open(void **pphandle)
+{
+    struct aml_ms12_bypass_handle *bypass_hanlde = NULL;
+
+    bypass_hanlde = (struct aml_ms12_bypass_handle *)calloc(1, sizeof(struct aml_ms12_bypass_handle));
+    if (bypass_hanlde == NULL) {
+        ALOGE("%s handle error", __func__);
+        goto error;
+    }
+
+    bypass_hanlde->buf_size  = BYPASS_MS12_MAX_FRAME_SIZE;
+    bypass_hanlde->buf  = calloc(1, BYPASS_MS12_MAX_FRAME_SIZE);
+    if (bypass_hanlde->buf == NULL) {
+        ALOGE("%s data buffer error", __func__);
+        goto error;
+    }
+    bypass_hanlde->data_offset = 0;
+    list_init(&bypass_hanlde->frame_list);
+    pthread_mutex_init(&bypass_hanlde->list_lock, NULL);
+    *pphandle = bypass_hanlde;
+    ALOGI("%s exit =%p", __func__, bypass_hanlde);
+    return 0;
+error:
+    if (bypass_hanlde) {
+        free(bypass_hanlde);
+    }
+    *pphandle = NULL;
+    ALOGE("%s error", __func__);
+    return -1;
+}
+
+
+int aml_ms12_bypass_close(void *phandle)
+{
+    struct aml_ms12_bypass_handle *bypass_hanlde = (struct aml_ms12_bypass_handle *)phandle;
+    struct bypass_frame_item *frame_item = NULL;
+    struct listnode *item;
+
+    if (bypass_hanlde) {
+        pthread_mutex_lock(&bypass_hanlde->list_lock);
+        while (!list_empty(&bypass_hanlde->frame_list)) {
+            item = list_head(&bypass_hanlde->frame_list);
+            frame_item = node_to_item(item, struct bypass_frame_item, list);
+            list_remove(item);
+            delete_bypass_frame(frame_item);
+        }
+        pthread_mutex_unlock(&bypass_hanlde->list_lock);
+
+        if (bypass_hanlde->buf) {
+            free(bypass_hanlde->buf);
+        }
+        free(bypass_hanlde);
+    }
+    ALOGI("%s exit", __func__);
+    return 0;
+}
+
+int aml_ms12_bypass_reset(void *phandle)
+{
+    struct aml_ms12_bypass_handle *bypass_hanlde = (struct aml_ms12_bypass_handle *)phandle;
+    struct bypass_frame_item *frame_item = NULL;
+    struct listnode *item = NULL;
+    uint32_t frame_no = 0;
+
+    if (bypass_hanlde) {
+        pthread_mutex_lock(&bypass_hanlde->list_lock);
+        while (!list_empty(&bypass_hanlde->frame_list)) {
+            item = list_head(&bypass_hanlde->frame_list);
+            frame_item = node_to_item(item, struct bypass_frame_item, list);
+            list_remove(item);
+            delete_bypass_frame(frame_item);
+            frame_no++;
+        }
+        pthread_mutex_unlock(&bypass_hanlde->list_lock);
+        bypass_hanlde->data_offset = 0;
+    }
+    ALOGI("%s exit release frame number=%d", __FUNCTION__, frame_no);
+    return 0;
+}
+
+int aml_ms12_bypass_checkin_data(void *phandle, const void *buffer, int32_t numBytes, struct bypass_frame_info * data_info)
+{
+    int ret = 0;
+    struct bypass_frame_item * new_frame = NULL;
+    struct bypass_frame_item * last_frame = NULL;
+    struct listnode *item = NULL;
+    bool need_new_frame = true;
+    struct aml_ms12_bypass_handle *bypass_hanlde = (struct aml_ms12_bypass_handle *)phandle;
+    if ((bypass_hanlde == NULL) ||
+        (buffer == NULL)        ||
+        (numBytes == 0)         ||
+        (data_info == NULL)) {
+        ALOGE("%s Invalid parameter", __FUNCTION__);
+        return -1;
+    }
+    ALOGV("frame info rate=%d dependency=%d numblks=%d", data_info->samplerate, data_info->dependency_frame, data_info->numblks);
+    pthread_mutex_lock(&bypass_hanlde->list_lock);
+    if (!data_info->dependency_frame) {
+        if (!list_empty(&bypass_hanlde->frame_list)) {
+            item      = list_tail(&bypass_hanlde->frame_list);
+            last_frame = node_to_item(item, struct bypass_frame_item, list);
+            /*add this buffer to last frame*/
+            if (last_frame->numblks < DDP_FRAME_BLK_NUM) {
+                modify_bypass_frame(last_frame, buffer, numBytes);
+                last_frame->offset_end   = bypass_hanlde->data_offset + numBytes;
+                last_frame->numblks     += data_info->numblks;
+                bypass_hanlde->data_offset += numBytes;
+                need_new_frame = false;
+            }
+        }
+        if (need_new_frame)
+        {
+            new_frame = new_bypass_frame(buffer, numBytes, data_info);
+            if (new_frame) {
+                new_frame->offset_start = bypass_hanlde->data_offset;
+                new_frame->offset_end   = bypass_hanlde->data_offset + numBytes;
+                new_frame->numblks      = data_info->numblks;
+                list_add_tail(&bypass_hanlde->frame_list, &new_frame->list);
+                bypass_hanlde->data_offset += numBytes;
+            } else {
+                ret = -1;
+            }
+        }
+    } else {
+        if (!list_empty(&bypass_hanlde->frame_list)) {
+            item      = list_tail(&bypass_hanlde->frame_list);
+            new_frame = node_to_item(item, struct bypass_frame_item, list);
+            modify_bypass_frame(new_frame, buffer, numBytes);
+            new_frame->offset_end   = bypass_hanlde->data_offset + numBytes;
+            new_frame->numblks      = data_info->numblks;
+            bypass_hanlde->data_offset += numBytes;
+        }
+    }
+    pthread_mutex_unlock(&bypass_hanlde->list_lock);
+
+    if (new_frame) {
+        ALOGV("check in bypass frame start=%lld end=%lld size=%d depedency=%d", new_frame->offset_start, new_frame->offset_end, numBytes, new_frame->info.dependency_frame);
+    }
+    return ret;
+}
+
+
+int aml_ms12_bypass_checkout_data(void *phandle, void **output_buf, int32_t *out_size, uint64_t offset, struct bypass_frame_info *frame_info)
+{
+    struct aml_ms12_bypass_handle *bypass_hanlde = (struct aml_ms12_bypass_handle *)phandle;
+    struct bypass_frame_item *frame_item = NULL;
+    struct listnode *item = NULL;
+    uint32_t frame_size = 0;
+    bool find_frame = false;
+    if (bypass_hanlde == NULL) {
+        return -1;
+    }
+    ALOGV("check out bypass data =%lld", offset);
+    pthread_mutex_lock(&bypass_hanlde->list_lock);
+    list_for_each(item, &bypass_hanlde->frame_list) {
+        frame_item = node_to_item(item, struct bypass_frame_item, list);
+        if ((frame_item->offset_start <= offset) && (offset <= frame_item->offset_end)) {
+            /*find the offset frame*/
+            frame_size = frame_item->frame_size;
+            ALOGV("offset=%lld frame size=%d start=%lld end=%lld frame dependency=%d cnt=%d numblks=%d", offset, frame_size, frame_item->offset_start, frame_item->offset_end, frame_item->info.dependency_frame, frame_item->frame_cnt, frame_item->numblks);
+            if (frame_size > bypass_hanlde->buf_size) {
+                bypass_hanlde->buf = realloc(bypass_hanlde->buf, frame_size);
+                if (bypass_hanlde->buf == NULL) {
+                    ALOGE("%s realloc buf failed =%d", __FUNCTION__, frame_size);
+                    goto error;
+                }
+                bypass_hanlde->buf_size = frame_size;
+            }
+            memcpy(bypass_hanlde->buf, frame_item->frame_buf, frame_size);
+            memcpy(frame_info, &frame_item->info, sizeof(struct bypass_frame_info));
+
+            *output_buf = bypass_hanlde->buf;
+            *out_size   = frame_size;
+            find_frame = true;
+            list_remove(&frame_item->list);
+            delete_bypass_frame(frame_item);
+            break;
+        }
+    }
+
+    if (find_frame) {
+        pthread_mutex_unlock(&bypass_hanlde->list_lock);
+        return 0;
+    }
+error:
+    pthread_mutex_unlock(&bypass_hanlde->list_lock);
+    *output_buf = NULL;
+    *out_size   = 0;
+    return -1;
+}
+
+
diff --git a/audio_hal/aml_audio_ms12_bypass.h b/audio_hal/aml_audio_ms12_bypass.h
new file mode 100644
index 0000000..0a845a6
--- /dev/null
+++ b/audio_hal/aml_audio_ms12_bypass.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AML_AUDIO_MS12_BYPASS_H_
+#define _AML_AUDIO_MS12_BYPASS_H_
+
+struct bypass_frame_info {
+    int32_t audio_format;
+    int32_t samplerate;
+    bool dependency_frame;
+    int numblks;
+};
+
+
+int aml_ms12_bypass_open(void **pparser_handle);
+int aml_ms12_bypass_close(void *parser_handle);
+int aml_ms12_bypass_checkin_data(void *parser_handle, const void *buffer, int32_t numBytes, struct bypass_frame_info * data_info);
+int aml_ms12_bypass_checkout_data(void *phandle, void **output_buf, int32_t *out_size, uint64_t offset, struct bypass_frame_info *frame_info);
+int aml_ms12_bypass_reset(void *parser_handle);
+
+#endif
diff --git a/audio_hal/aml_audio_resample_manager.c b/audio_hal/aml_audio_resample_manager.c
index 91ed8b0..832203c 100644
--- a/audio_hal/aml_audio_resample_manager.c
+++ b/audio_hal/aml_audio_resample_manager.c
@@ -242,4 +242,34 @@ int aml_audio_resample_process(aml_audio_resample_t * aml_audio_resample, void *
     return 0;
 }
 
+int aml_audio_resample_reset(aml_audio_resample_t * aml_audio_resample)
+{
+    int ret = -1;
+
+    audio_resample_func_t * resample_func = NULL;
+
+    if (aml_audio_resample == NULL) {
+        ALOGE("resample_handle is NULL\n");
+        return -1;
+    }
+
+    resample_func = get_resample_function(aml_audio_resample->resample_type);
+    if (resample_func == NULL) {
+        ALOGE("resample_func is NULL\n");
+    }
+
+    if (resample_func && aml_audio_resample->resample_handle) {
+        resample_func->resample_close(aml_audio_resample->resample_handle);
+
+        ret = resample_func->resample_open(&aml_audio_resample->resample_handle, &aml_audio_resample->resample_config);
+        if (ret < 0) {
+            ALOGE("resample_reset failed\n");
+            return -1;
+
+        }
+    }
+    ALOGI("%s", __FUNCTION__);
+    return 0;
+}
+
 
diff --git a/audio_hal/aml_audio_resample_manager.h b/audio_hal/aml_audio_resample_manager.h
index 6736474..6b32094 100644
--- a/audio_hal/aml_audio_resample_manager.h
+++ b/audio_hal/aml_audio_resample_manager.h
@@ -62,6 +62,7 @@ int aml_audio_resample_close(aml_audio_resample_t * resample_handle);
 
 int aml_audio_resample_process(aml_audio_resample_t * resample_handle, void * in_data, size_t size);
 
+int aml_audio_resample_reset(aml_audio_resample_t * aml_audio_resample);
 
 #endif
 
diff --git a/audio_hal/aml_audio_spdif_output.c b/audio_hal/aml_audio_spdif_output.c
new file mode 100644
index 0000000..579fb17
--- /dev/null
+++ b/audio_hal/aml_audio_spdif_output.c
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "aml_spdif_output"
+
+#include <cutils/log.h>
+#include <inttypes.h>
+#include "audio_hw.h"
+#include "audio_hw_utils.h"
+#include "dolby_lib_api.h"
+#include "alsa_device_parser.h"
+#include "spdifenc_wrap.h"
+#include "alsa_config_parameters.h"
+#include "aml_audio_spdif_output.h"
+
+void  aml_audio_spdif_output_stop(struct audio_stream_out *stream)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device *aml_dev = aml_out->dev;
+    struct pcm *pcm = aml_dev->pcm_handle[DIGITAL_DEVICE];
+    if (pcm) {
+        pcm_close(pcm);
+        aml_tinymix_set_spdif_format(AUDIO_FORMAT_PCM_16_BIT, aml_out);
+        aml_dev->pcm_handle[DIGITAL_DEVICE] = NULL;
+        aml_dev->raw_to_pcm_flag = true;
+        aml_dev->spdif_out_format = 0;
+        aml_dev->spdif_out_rate   = 0;
+        aml_dev->dual_spdifenc_inited = 0;
+        ALOGI("%s done,pcm handle %p \n", __func__, pcm);
+    }
+}
+
+int  aml_audio_spdif_output_start(struct audio_stream_out *stream, audio_format_t output_format)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device *aml_dev = aml_out->dev;
+    struct pcm *pcm = aml_dev->pcm_handle[DIGITAL_DEVICE];
+    struct aml_audio_patch *patch = aml_dev->audio_patch;
+    struct pcm_config config;
+
+    if (!pcm) {
+        /* init pcm configs, no DDP case in dual output */
+        memset(&config, 0, sizeof(struct pcm_config));
+        config.channels = 2;
+        if (eDolbyDcvLib == aml_dev->dolby_lib_type) {
+            config.rate = aml_out->config.rate;
+        } else {
+            config.rate = MM_FULL_POWER_SAMPLING_RATE;
+        }
+        // reset the sample rate
+        if (patch && (patch->input_src == AUDIO_DEVICE_IN_HDMI || patch->input_src == AUDIO_DEVICE_IN_SPDIF)) {
+            if (patch->aformat == AUDIO_FORMAT_DTS ||
+                patch->aformat == AUDIO_FORMAT_DTS_HD) {
+                config.rate = aml_out->config.rate;
+                //ALOGD("rate=%d setrate=%d\n",config.rate,aml_out->config.rate);
+            }
+        }
+        /* SWPL-19631 increase spdif period_size to reduce spdifout delay when spdif/tdm dual output */
+        config.period_size = DEFAULT_PLAYBACK_PERIOD_SIZE * 2 * 2;
+        config.period_count = PLAYBACK_PERIOD_COUNT;
+        config.start_threshold = DEFAULT_PLAYBACK_PERIOD_SIZE * 2 * PLAYBACK_PERIOD_COUNT;
+        config.format = PCM_FORMAT_S16_LE;
+        if ((aml_dev->ms12.dolby_ms12_enable) && !is_bypass_dolbyms12(stream)) {
+            struct dolby_ms12_desc *ms12 = &(aml_dev->ms12);
+            get_hardware_config_parameters(
+                &(config)
+                , output_format
+                , audio_channel_count_from_out_mask(ms12->output_channelmask)
+                , ms12->output_samplerate
+                , aml_out->is_tv_platform
+                , continous_mode(aml_dev));
+        }
+        aml_tinymix_set_spdif_format(output_format, aml_out);
+        pthread_mutex_lock(&aml_dev->alsa_pcm_lock);
+        unsigned int port = PORT_SPDIF;
+        port = alsa_device_update_pcm_index(port, PLAYBACK);
+        pcm = pcm_open(aml_out->card, port, PCM_OUT, &config);
+        if (!pcm_is_ready(pcm)) {
+            ALOGE("%s() cannot open pcm_out: %s,card %d,device %d", __func__, pcm_get_error(pcm), aml_out->card, DIGITAL_DEVICE);
+            pcm_close(pcm);
+            pthread_mutex_unlock(&aml_dev->alsa_pcm_lock);
+            return -ENOENT;
+        }
+        ALOGI("%s open  output pcm handle %p,port %d", __func__, pcm, port);
+        aml_dev->pcm_handle[DIGITAL_DEVICE] = pcm;
+        aml_dev->spdif_out_format           = output_format;
+        aml_dev->spdif_out_rate             = config.rate;
+        pthread_mutex_unlock(&aml_dev->alsa_pcm_lock);
+
+    }
+
+    return 0;
+}
+
+
+ssize_t aml_audio_spdif_output_direct(struct audio_stream_out *stream,
+                                      void *buffer, size_t byte, audio_format_t output_format)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device *aml_dev = aml_out->dev;
+    struct pcm *pcm = aml_dev->pcm_handle[DIGITAL_DEVICE];
+    int ret = 0;
+    if (aml_dev->spdif_out_format != output_format) {
+        if (pcm) {
+            pcm_close(pcm);
+            aml_dev->pcm_handle[DIGITAL_DEVICE] = NULL;
+            aml_dev->spdif_out_format = 0;
+            aml_dev->spdif_out_rate   = 0;
+            pcm = NULL;
+        }
+        ALOGI("%s ,format change from 0x%x to 0x%x,need reinit alsa\n", __func__, aml_dev->spdif_out_format, output_format);
+    }
+
+    if (!pcm) {
+        ret = aml_audio_spdif_output_start(stream, output_format);
+        pcm = aml_dev->pcm_handle[DIGITAL_DEVICE];
+        if (ret != 0) {
+            return ret;
+        }
+    }
+
+    if (pcm) {
+        {
+            struct snd_pcm_status status;
+            pcm_ioctl(pcm, SNDRV_PCM_IOCTL_STATUS, &status);
+            if (status.state == PCM_STATE_XRUN) {
+                ALOGW("%s alsa underrun", __func__);
+            }
+        }
+        pthread_mutex_lock(&aml_dev->alsa_pcm_lock);
+        ret = pcm_write(pcm, buffer, byte);
+        pthread_mutex_unlock(&aml_dev->alsa_pcm_lock);
+    }
+    return 0;
+}
+
+
+ssize_t aml_audio_spdif_output(struct audio_stream_out *stream,
+                               void *buffer, size_t byte, audio_format_t output_format)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device *aml_dev = aml_out->dev;
+    struct pcm *pcm = aml_dev->pcm_handle[DIGITAL_DEVICE];
+    struct aml_audio_patch *patch = aml_dev->audio_patch;
+    int ret = 0;
+    int codec_type = 0;
+    bool need_reinit_encoder = false;
+    if (aml_dev->debug_flag) {
+        ALOGI("%s in format %x,size %d\n", __func__, output_format, byte);
+    }
+    // SWPL-412, when input source is DTV, and UI set "parental_control_av_mute" command to audio hal
+    // we need to mute SPDIF audio output here
+    if (aml_dev->patch_src == SRC_DTV && aml_dev->parental_control_av_mute) {
+        memset(buffer, 0x0, byte);
+    }
+    if (spdifenc_get_format() != output_format) {
+        need_reinit_encoder = true;
+        if (pcm) {
+            pcm_close(pcm);
+            aml_dev->pcm_handle[DIGITAL_DEVICE] = NULL;
+            pcm = NULL;
+        }
+        aml_dev->dual_spdifenc_inited = 0;
+        ALOGI("%s ,format change from 0x%x to 0x%x,need reinit spdif encoder and alsa\n", __func__, spdifenc_get_format(), output_format);
+    }
+    if (!pcm) {
+        ret = aml_audio_spdif_output_start(stream, output_format);
+        if (ret != 0) {
+            return ret;
+        }
+        pcm = aml_dev->pcm_handle[DIGITAL_DEVICE];
+    }
+
+    if (eDolbyDcvLib == aml_dev->dolby_lib_type) {
+
+#ifdef ADD_AUDIO_DELAY_INTERFACE
+        // spdif(RAW) delay process, frame size 2 ch * 2 Byte
+        aml_audio_delay_process(AML_DELAY_OUTPORT_SPDIF, buffer, byte, AUDIO_FORMAT_IEC61937, 2);
+#endif
+        pthread_mutex_lock(&aml_dev->alsa_pcm_lock);
+        ret = pcm_write(pcm, buffer, byte);
+        pthread_mutex_unlock(&aml_dev->alsa_pcm_lock);
+        if (ret < 0) {
+            ALOGE("%s write failed,pcm handle %p err num %d", __func__, pcm, ret);
+        }
+        ALOGV("%s(), aml_alsa_output_write bytes = %zu", __func__, byte);
+
+    } else {
+        if (!aml_dev->dual_spdifenc_inited) {
+            if ((eDolbyMS12Lib == aml_dev->dolby_lib_type) && (!aml_dev->is_TV)) {
+                // when use ms12 on BOX case, we also need to allow EAC3 output from SPDIF port .zzz
+                if (output_format != AUDIO_FORMAT_AC3 &&
+                    output_format != AUDIO_FORMAT_E_AC3 &&
+                    output_format != AUDIO_FORMAT_MAT) {
+                    ALOGE("%s() not support, optical format = %#x",
+                          __func__, output_format);
+                    return -EINVAL;
+                }
+            }
+
+            int init_ret = spdifenc_init(pcm, output_format);
+            if (init_ret == 0) {
+                aml_dev->dual_spdifenc_inited = 1;
+                aml_tinymix_set_spdif_format(output_format, aml_out);
+                spdifenc_set_mute(aml_out->offload_mute);
+                //ALOGI("%s tinymix AML_MIXER_ID_SPDIF_FORMAT %d\n", __FUNCTION__, AML_DOLBY_DIGITAL);
+            }
+        }
+        {
+            struct snd_pcm_status status;
+            pcm_ioctl(pcm, SNDRV_PCM_IOCTL_STATUS, &status);
+            if (status.state == PCM_STATE_XRUN) {
+                ALOGW("%s alsa underrun", __func__);
+            }
+        }
+        ret = spdifenc_write(buffer, byte);
+        ALOGV("%s(), spdif write bytes = %d", __func__, ret);
+    }
+    return ret;
+}
diff --git a/audio_hal/aml_audio_spdif_output.h b/audio_hal/aml_audio_spdif_output.h
new file mode 100644
index 0000000..46ddaa9
--- /dev/null
+++ b/audio_hal/aml_audio_spdif_output.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef _AML_AUDIO_SPDIF_OUTPUT_H_
+#define _AML_AUDIO_SPDIF_OUTPUT_H_
+
+void  aml_audio_spdif_output_stop(struct audio_stream_out *stream);
+int   aml_audio_spdif_output_start(struct audio_stream_out *stream, audio_format_t output_format);
+ssize_t aml_audio_spdif_output_direct(struct audio_stream_out *stream,
+                                      void *buffer, size_t byte, audio_format_t output_format);
+ssize_t aml_audio_spdif_output(struct audio_stream_out *stream,
+                               void *buffer, size_t byte, audio_format_t output_format);
+
+
+#endif
diff --git a/audio_hal/aml_audio_stream.c b/audio_hal/aml_audio_stream.c
index 2b8d878..37c4fa2 100644
--- a/audio_hal/aml_audio_stream.c
+++ b/audio_hal/aml_audio_stream.c
@@ -26,9 +26,7 @@
 #include "dolby_lib_api.h"
 
 #define min(a,b) (((a) < (b)) ? (a) : (b))
-#define PCM  0/*AUDIO_FORMAT_PCM_16_BIT*/
-#define DD   4/*AUDIO_FORMAT_AC3*/
-#define AUTO 5/*choose by sink capability/source format/Digital format*/
+
 
 /*
  *@brief get sink capability
@@ -42,9 +40,12 @@ static audio_format_t get_sink_capability (struct audio_stream_out *stream)
     char *cap = (char *) get_hdmi_sink_cap(AUDIO_PARAMETER_STREAM_SUP_FORMATS, 0, &(adev->hdmi_descs));
 
     if (cap) {
+#ifdef ENABLE_MAT_OUTPUT
         if (hdmi_desc->mat_fmt.is_support) {
             sink_capability = AUDIO_FORMAT_MAT;
-        } else if (hdmi_desc->ddp_fmt.is_support) {
+        } else
+#endif
+        if (hdmi_desc->ddp_fmt.is_support) {
             sink_capability = AUDIO_FORMAT_E_AC3;
         } else if (hdmi_desc->dd_fmt.is_support) {
             sink_capability = AUDIO_FORMAT_AC3;
@@ -63,7 +64,9 @@ static audio_format_t get_sink_capability (struct audio_stream_out *stream)
 
 bool is_sink_support_dolby_passthrough(audio_format_t sink_capability)
 {
-    return sink_capability == AUDIO_FORMAT_E_AC3 || sink_capability == AUDIO_FORMAT_AC3;
+    return sink_capability == AUDIO_FORMAT_MAT ||
+        sink_capability == AUDIO_FORMAT_E_AC3 ||
+        sink_capability == AUDIO_FORMAT_AC3;
 }
 
 /*
@@ -78,13 +81,29 @@ bool is_sink_support_dolby_passthrough(audio_format_t sink_capability)
 void get_sink_format (struct audio_stream_out *stream)
 {
     struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
-    struct aml_audio_device *adev = aml_out->dev;
+    struct aml_audio_device *adev;
     /*set default value for sink_audio_format/optical_audio_format*/
     audio_format_t sink_audio_format = AUDIO_FORMAT_PCM_16_BIT;
     audio_format_t optical_audio_format = AUDIO_FORMAT_PCM_16_BIT;
+    audio_format_t sink_capability, source_format;
+    int hdmi_format;
 
-    audio_format_t sink_capability = get_sink_capability(stream);
-    audio_format_t source_format = aml_out->hal_internal_format;
+    if (!stream) {
+        return;
+    }
+
+    adev = aml_out->dev;
+    hdmi_format = adev->hdmi_format;
+    sink_capability = get_sink_capability(stream);
+    source_format = aml_out->hal_internal_format;
+
+    if (aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+        ALOGD("get_sink_format: a2dp set to pcm");
+        adev->sink_format = AUDIO_FORMAT_PCM_16_BIT;
+        adev->optical_format = AUDIO_FORMAT_PCM_16_BIT;
+        aml_out->dual_output_flag = false;
+        return;
+    }
 
     /*when device is HDMI_ARC*/
     ALOGI("!!!%s() Sink devices %#x Source format %#x digital_format(hdmi_format) %#x Sink Capability %#x\n",
@@ -174,11 +193,22 @@ void get_sink_format (struct audio_stream_out *stream)
         }
     }
 #else
-    switch (adev->hdmi_format) {
+
+    if (eDolbyMS12Lib != adev->dolby_lib_type) {
+        /* if MS12 library does not exist, then output format is same as BYPASS case */
+        hdmi_format = BYPASS;
+    }
+
+    switch (hdmi_format) {
     case PCM:
         break;
     case DD:
         optical_audio_format = (source_format != AUDIO_FORMAT_DTS && source_format != AUDIO_FORMAT_DTS_HD) ? AUDIO_FORMAT_AC3 : AUDIO_FORMAT_DTS;
+        sink_audio_format = optical_audio_format;
+        break;
+    case BYPASS:
+        sink_audio_format = min(sink_capability,source_format);
+        optical_audio_format = sink_audio_format;
         break;
     case AUTO:
     default:
@@ -187,6 +217,7 @@ void get_sink_format (struct audio_stream_out *stream)
         } else {
             optical_audio_format = sink_capability;
         }
+        sink_audio_format = optical_audio_format;
         break;
     }
 #endif
@@ -194,19 +225,15 @@ void get_sink_format (struct audio_stream_out *stream)
     adev->sink_format = sink_audio_format;
     adev->optical_format = optical_audio_format;
 
+#if 0
     /* use single output for HDMI_ARC */
     if ((adev->active_outport == OUTPORT_HDMI_ARC) &&
         adev->bHDMIConnected)
         adev->sink_format = adev->optical_format;
+#endif
 
-    /* set the dual output format flag */
-    //if (adev->sink_format != adev->optical_format) {
-    //    aml_out->dual_output_flag = true;
-    //} else {
-    //    aml_out->dual_output_flag = false;
-    //}
-    ALOGI("%s sink_format %#x optical_format %#x, stream device %d\n",
-           __FUNCTION__, adev->sink_format, adev->optical_format, aml_out->device);
+    ALOGI("%s sink_format %#x optical_format %#x,soure fmt %#x stream device %d\n",
+           __FUNCTION__, adev->sink_format, adev->optical_format, source_format, aml_out->device);
     return ;
 }
 
@@ -350,7 +377,7 @@ bool is_spdif_in_stable_hw (struct audio_stream_in *stream)
 int set_audio_source(struct aml_mixer_handle *mixer_handle,
         enum input_source audio_source, bool is_auge)
 {
-    int src = audio_source;
+    int src;
 
     if (is_auge) {
         switch (audio_source) {
@@ -370,37 +397,84 @@ int set_audio_source(struct aml_mixer_handle *mixer_handle,
             src = SPDIFIN_AUGE;
             break;
         default:
-            ALOGW("%s(), src: %d not support", __func__, src);
             src = FRHDMIRX;
+            ALOGW("%s(),audio_source %d src: %d not support", __func__, audio_source, src);
             break;
         }
+    } else {
+        src = (int)audio_source;
     }
 
     return aml_mixer_ctrl_set_int(mixer_handle, AML_MIXER_ID_AUDIO_IN_SRC, src);
 }
 
+int set_resample_source(struct aml_mixer_handle *mixer_handle, enum ResampleSource source)
+{
+    return aml_mixer_ctrl_set_int(mixer_handle, AML_MIXER_ID_HW_RESAMPLE_SOURCE, source);
+}
+
 int set_spdifin_pao(struct aml_mixer_handle *mixer_handle,int enable)
 {
-    return aml_mixer_ctrl_set_int(mixer_handle,AML_MIXER_ID_SPDIFIN_PAO, enable);
+    return aml_mixer_ctrl_set_int(mixer_handle, AML_MIXER_ID_SPDIFIN_PAO, enable);
 }
 
-int get_spdifin_samplerate(struct aml_mixer_handle *mixer_handle)
+eMixerHwResample get_spdifin_samplerate(struct aml_mixer_handle *mixer_handle)
 {
     int index = aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_SPDIF_IN_SAMPLERATE);
 
-    return index;
+    if ((index > HW_RESAMPLE_DISABLE) && (index < HW_RESAMPLE_MAX)) {
+        return index;
+    }
+
+    return HW_RESAMPLE_DISABLE;
 }
 
-int get_hdmiin_samplerate(struct aml_mixer_handle *mixer_handle)
+static inline eMixerHwResample _sr_enum(int sr)
+{
+    switch (sr) {
+        case 32000:
+            return HW_RESAMPLE_32K;
+        case 44100:
+            return HW_RESAMPLE_44K;
+        case 48000:
+            return HW_RESAMPLE_48K;
+        case 88200:
+            return HW_RESAMPLE_88K;
+        case 96000:
+            return HW_RESAMPLE_96K;
+        case 176400:
+            return HW_RESAMPLE_176K;
+        case 192000:
+            return HW_RESAMPLE_192K;
+        default:
+            return HW_RESAMPLE_DISABLE;
+    }
+}
+
+eMixerHwResample get_eArcIn_samplerate(struct aml_mixer_handle *mixer_handle)
+{
+    int sr = aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_EARCRX_AUDIO_SAMPLERATE);
+
+    /* eARC mix control does not return sample rate as enum type as HDMIIN and SPDIF */
+    return _sr_enum(sr);
+}
+
+eMixerHwResample get_hdmiin_samplerate(struct aml_mixer_handle *mixer_handle)
 {
     int stable = 0;
+    int r;
 
     stable = aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_HDMI_IN_AUDIO_STABLE);
     if (!stable) {
-        return -1;
+        return HW_RESAMPLE_DISABLE;
+    }
+
+    r = aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_HDMI_IN_SAMPLERATE);
+    if ((r > HW_RESAMPLE_DISABLE) && (r < HW_RESAMPLE_MAX)) {
+        return r;
     }
 
-    return aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_HDMI_IN_SAMPLERATE);
+    return HW_RESAMPLE_DISABLE;
 }
 
 int get_hdmiin_channel(struct aml_mixer_handle *mixer_handle)
@@ -413,12 +487,75 @@ int get_hdmiin_channel(struct aml_mixer_handle *mixer_handle)
         return -1;
     }
 
-    /*hmdirx audio support: N/A, 2, 3, 4, 5, 6, 7, 8*/
+    /* hmdirx audio support: N/A, 2, 3, 4, 5, 6, 7, 8 as enum */
     channel_index = aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_HDMI_IN_CHANNELS);
-    if (channel_index != 7)
-        return 2;
-    else
-        return 8;
+    if ((channel_index > 0) && (channel_index <= 7))
+        return channel_index + 1;
+
+    return 2;
+}
+
+int get_arcin_channel(struct aml_mixer_handle *mixer_handle)
+{
+    if (aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_EARCRX_ATTENDED_TYPE) == ATTEND_TYPE_EARC) {
+        if (aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_EARCRX_AUDIO_CODING_TYPE) == AUDIO_CODING_TYPE_MULTICH_8CH_LPCM) {
+            return 8;
+        }
+    }
+
+    return 2;
+}
+
+/* return audio channel assignment, see CEA-861-D Table 20 */
+int get_arcin_ca(struct aml_mixer_handle *mixer_handle)
+{
+    if (aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_EARCRX_ATTENDED_TYPE) == ATTEND_TYPE_EARC) {
+        return aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_EARCRX_CA);
+    }
+
+    return 0;
+}
+
+audio_channel_mask_t aml_map_ca_to_mask(int ca)
+{
+    audio_channel_mask_t mask = 0;
+
+#if 0
+    /* FLC/FRC and RLC/RRC are represented by AUDIO_CHANNEL_IN_LEFT_PROCESSED/AUDIO_CHANNEL_IN_RIGHT_PROCESSED */
+    const audio_channel_mask_t mask_tab[] = {
+        AUDIO_CHANNEL_IN_STEREO,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK_LEFT | AUDIO_CHANNEL_IN_BACK_RIGHT,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK_LEFT | AUDIO_CHANNEL_IN_BACK_RIGHT | AUDIO_CHANNEL_IN_BACK,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK_LEFT | AUDIO_CHANNEL_IN_BACK_RIGHT | AUDIO_CHANNEL_IN_LEFT_PROCESSED | AUDIO_CHANNEL_IN_RIGHT_PROCESSED,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_LEFT_PROCESSED | AUDIO_CHANNEL_IN_RIGHT_PROCESSED,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK | AUDIO_CHANNEL_IN_LEFT_PROCESSED | AUDIO_CHANNEL_IN_RIGHT_PROCESSED,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK_LEFT | AUDIO_CHANNEL_IN_BACK_RIGHT | AUDIO_CHANNEL_IN_LEFT_PROCESSED | AUDIO_CHANNEL_IN_RIGHT_PROCESSED,
+    };
+#else
+    const audio_channel_mask_t mask_tab[] = {
+        AUDIO_CHANNEL_IN_STEREO,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK_LEFT | AUDIO_CHANNEL_IN_BACK_RIGHT,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK_LEFT | AUDIO_CHANNEL_IN_BACK_RIGHT | AUDIO_CHANNEL_IN_BACK,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK_LEFT | AUDIO_CHANNEL_IN_BACK_RIGHT | AUDIO_CHANNEL_IN_LEFT_PROCESSED | AUDIO_CHANNEL_IN_RIGHT_PROCESSED,
+        AUDIO_CHANNEL_IN_STEREO,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_BACK_LEFT,
+    };
+#endif
+
+    if ((ca >= 0) || (ca <= 0x1f)) {
+        mask = AUDIO_CHANNEL_IN_STEREO;
+        if (ca & 1)
+            mask |= AUDIO_CHANNEL_IN_LOW_FREQUENCY;
+        if ((ca >> 1) & 1)
+            mask |= AUDIO_CHANNEL_IN_CENTER;
+        mask |=  mask_tab[ca/4];
+        return mask;
+    }
+
+    return 0;
 }
 
 int get_HW_resample(struct aml_mixer_handle *mixer_handle)
@@ -462,19 +599,19 @@ bool signal_status_check(audio_devices_t in_device, int *mute_time,
     }
     if ((in_device & AUDIO_DEVICE_IN_TV_TUNER) &&
             !is_atv_in_stable_hw (stream)) {
-        *mute_time = 500;
+        *mute_time = 100;
         return false;
     }
     if (((in_device & AUDIO_DEVICE_IN_SPDIF) ||
             ((in_device & AUDIO_DEVICE_IN_HDMI_ARC) &&
                     (access(SYS_NODE_EARC_RX, F_OK) == -1))) &&
-           !is_spdif_in_stable_hw(stream)) {
-        *mute_time = 1000;
+            !is_spdif_in_stable_hw(stream)) {
+        *mute_time = 100;
         return false;
     }
     if ((in_device & AUDIO_DEVICE_IN_LINE) &&
             !is_av_in_stable_hw(stream)) {
-       *mute_time = 1000;
+       *mute_time = 100;
        return false;
     }
     return true;
@@ -531,3 +668,118 @@ unsigned int inport_to_device(enum IN_PORT inport)
     return device;
 }
 
+void get_audio_indicator(struct aml_audio_device *dev, char *temp_buf) {
+    struct aml_audio_device *adev = (struct aml_audio_device *) dev;
+
+    if (adev->update_type == TYPE_PCM)
+        sprintf (temp_buf, "audioindicator=");
+    else if (adev->update_type == TYPE_AC3)
+        sprintf (temp_buf, "audioindicator=Dolby AC3");
+    else if (adev->update_type == TYPE_EAC3)
+        sprintf (temp_buf, "audioindicator=Dolby EAC3");
+    else if (adev->update_type == TYPE_AC4)
+        sprintf (temp_buf, "audioindicator=Dolby AC4");
+    else if (adev->update_type == TYPE_MAT)
+        sprintf (temp_buf, "audioindicator=Dolby MAT");
+    else if (adev->update_type == TYPE_TRUE_HD)
+        sprintf (temp_buf, "audioindicator=Dolby TrueHD");
+    else if (adev->update_type == TYPE_DDP_ATMOS)
+        sprintf (temp_buf, "audioindicator=Dolby EAC3,Dolby Atmos");
+    else if (adev->update_type == TYPE_TRUE_HD_ATMOS)
+        sprintf (temp_buf, "audioindicator=Dolby TrueHD,Dolby Atmos");
+    else if (adev->update_type == TYPE_MAT_ATMOS)
+        sprintf (temp_buf, "audioindicator=Dolby MAT,Dolby Atmos");
+    else if (adev->update_type == TYPE_AC4_ATMOS)
+        sprintf (temp_buf, "audioindicator=Dolby AC4,Dolby Atmos");
+    else if (adev->update_type == TYPE_DTS)
+        sprintf (temp_buf, "audioindicator=DTS");
+    else if (adev->update_type == TYPE_DTS_HD_MA)
+        sprintf (temp_buf, "audioindicator=DTS HD");
+    ALOGI("%s(), [%s]", __func__, temp_buf);
+}
+
+
+bool is_dolby_ms12_support_compression_format(audio_format_t format)
+{
+    return (format == AUDIO_FORMAT_AC3 ||
+            format == AUDIO_FORMAT_E_AC3 ||
+            format == AUDIO_FORMAT_DOLBY_TRUEHD ||
+            format == AUDIO_FORMAT_AC4 ||
+            format == AUDIO_FORMAT_MAT);
+}
+
+
+void update_audio_format(struct aml_audio_device *adev, audio_format_t format)
+{
+    int atmos_flag = 0;
+    int update_type = TYPE_PCM;
+    bool is_dolby_active = dolby_stream_active(adev);
+    bool is_dolby_format = is_dolby_ms12_support_compression_format(format);
+    /*
+     *for dolby & pcm case or dolby case
+     *to update the dolby stream's format
+     */
+    if (is_dolby_active && is_dolby_format) {
+        if (eDolbyMS12Lib == adev->dolby_lib_type) {
+            atmos_flag = adev->ms12.is_dolby_atmos;
+        } else {
+            atmos_flag = adev->ddp.is_dolby_atmos;
+        }
+
+        if (adev->hal_internal_format != format ||
+                atmos_flag != adev->is_dolby_atmos) {
+
+            update_type = get_codec_type(format);
+
+            if (atmos_flag == 1) {
+                if (format == AUDIO_FORMAT_E_AC3)
+                    update_type = TYPE_DDP_ATMOS;
+                else if (format == AUDIO_FORMAT_DOLBY_TRUEHD)
+                    update_type = TYPE_TRUE_HD_ATMOS;
+                else if (format == AUDIO_FORMAT_MAT)
+                    update_type = TYPE_MAT_ATMOS;
+                else if (format == AUDIO_FORMAT_AC4)
+                    update_type = TYPE_AC4_ATMOS;
+            }
+
+            aml_mixer_ctrl_set_int(&adev->alsa_mixer, AML_MIXER_ID_AUDIO_HAL_FORMAT, update_type);
+
+            ALOGD("%s()audio hal format change from %x to %x, atmos flag = %d, update_type = %d\n",
+                __FUNCTION__, adev->hal_internal_format, format, atmos_flag, update_type);
+
+            adev->hal_internal_format = format;
+            adev->is_dolby_atmos = atmos_flag;
+            adev->update_type = update_type;
+        }
+    }
+    /*
+     *to update the audio format for other cases
+     *DTS-format / DTS format & Mixer-PCM
+     *only Mixer-PCM
+     */
+    else if (!is_dolby_active && !is_dolby_format) {
+        if (adev->hal_internal_format != format) {
+            adev->hal_internal_format = format;
+            adev->is_dolby_atmos = false;
+            adev->update_type = get_codec_type(format);
+            aml_mixer_ctrl_set_int(&adev->alsa_mixer, AML_MIXER_ID_AUDIO_HAL_FORMAT, adev->update_type);
+            ALOGD("%s()audio hal format change from %x to %x, atmos flag = %d, update_type = %d\n",
+                __FUNCTION__, adev->hal_internal_format, format, atmos_flag, update_type);
+        }
+    }
+    /*
+     * **Dolby stream is active, and get the Mixer-PCM case steam format,
+     * **we should ignore this Mixer-PCM update request.
+     * else if (is_dolby_active && !is_dolby_format) {
+     * }
+     * **If Dolby steam is not active, the available format is LPCM or DTS
+     * **The following case do not exit at all **
+     * else //(!is_dolby_acrive && is_dolby_format) {
+     * }
+     */
+}
+
+bool is_direct_stream_and_pcm_format(struct aml_stream_out *out)
+{
+    return audio_is_linear_pcm(out->hal_internal_format) && (out->flags & AUDIO_OUTPUT_FLAG_DIRECT);
+}
diff --git a/audio_hal/aml_audio_stream.h b/audio_hal/aml_audio_stream.h
index e3f1788..a14e16f 100644
--- a/audio_hal/aml_audio_stream.h
+++ b/audio_hal/aml_audio_stream.h
@@ -64,7 +64,8 @@ enum auge_input_source {
 enum digital_format {
     PCM = 0,
     DD = 4,
-    AUTO = 5
+    AUTO = 5,
+    BYPASS = 6
 };
 
 /**\brief Audio output mode*/
@@ -93,6 +94,19 @@ typedef enum hdmiin_audio_packet {
     AUDIO_PACKET_MAS
 } hdmiin_audio_packet_t;
 
+enum {
+    AUDIO_CODING_TYPE_UNDEFINED = 0,
+    AUDIO_CODING_TYPE_STEREO_LPCM,
+    AUDIO_CODING_TYPE_MULTICH_2CH_LPCM,
+    AUDIO_CODING_TYPE_MULTICH_8CH_LPCM
+};
+
+enum {
+    ATTEND_TYPE_NONE = 0,
+    ATTEND_TYPE_ARC,
+    ATTEND_TYPE_EARC
+};
+
 static inline bool is_main_write_usecase(stream_usecase_t usecase)
 {
     return usecase > 0;
@@ -103,8 +117,8 @@ static inline bool is_digital_raw_format(audio_format_t format)
     switch (format) {
     case AUDIO_FORMAT_AC3:
     case AUDIO_FORMAT_E_AC3:
-    case AUDIO_FORMAT_MAT:
     case AUDIO_FORMAT_AC4:
+    case AUDIO_FORMAT_MAT:
     case AUDIO_FORMAT_DTS:
     case AUDIO_FORMAT_DTS_HD:
     case AUDIO_FORMAT_DOLBY_TRUEHD:
@@ -115,6 +129,27 @@ static inline bool is_digital_raw_format(audio_format_t format)
     }
 }
 
+static inline bool is_dolby_format(audio_format_t format) {
+    switch (format) {
+    case AUDIO_FORMAT_AC3:
+    case AUDIO_FORMAT_E_AC3:
+    case AUDIO_FORMAT_DOLBY_TRUEHD:
+        return true;
+    default:
+        return false;
+    }
+}
+
+static inline bool is_dts_format(audio_format_t format) {
+    switch (format) {
+    case AUDIO_FORMAT_DTS:
+    case AUDIO_FORMAT_DTS_HD:
+        return true;
+    default:
+        return false;
+    }
+}
+
 static inline stream_usecase_t attr_to_usecase(uint32_t devices __unused,
         audio_format_t format, uint32_t flags)
 {
@@ -122,23 +157,25 @@ static inline stream_usecase_t attr_to_usecase(uint32_t devices __unused,
     if ((flags & AUDIO_OUTPUT_FLAG_HW_AV_SYNC) && (format != AUDIO_FORMAT_IEC61937)) {
         if (audio_is_linear_pcm(format)) {
             return STREAM_PCM_HWSYNC;
-        }
-
-        if (is_digital_raw_format(format)) {
+        } else if (is_digital_raw_format(format)) {
             return STREAM_RAW_HWSYNC;
+        } else {
+            return STREAM_USECASE_MAX;
         }
-
-        return STREAM_USECASE_INVAL;
     }
 
     // non hwsync cases
     if (/*devices == AUDIO_DEVICE_OUT_HDMI ||*/
         is_digital_raw_format(format)) {
         return STREAM_RAW_DIRECT;
-    }
-    //multi-channel LPCM or hi-res LPCM
-    else if ((flags & AUDIO_OUTPUT_FLAG_DIRECT) && audio_is_linear_pcm(format)) {
-        return STREAM_PCM_DIRECT;
+    } else if ((flags & AUDIO_OUTPUT_FLAG_DIRECT) && audio_is_linear_pcm(format)) {
+        if (flags & AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) {
+            // AAudio case
+            return STREAM_PCM_MMAP;
+        } else {
+            //multi-channel LPCM or hi-res LPCM
+            return STREAM_PCM_DIRECT;
+        }
     } else {
         return STREAM_PCM_NORMAL;
     }
@@ -153,7 +190,7 @@ static inline stream_usecase_t convert_usecase_mask_to_stream_usecase(usecase_ma
     }
     ALOGI("%s mask %#x i %d", __func__, mask, i);
     if (i >= STREAM_USECASE_MAX) {
-        return STREAM_USECASE_INVAL;
+        return STREAM_USECASE_MAX;
     } else {
         return (stream_usecase_t)i;
     }
@@ -182,7 +219,8 @@ static inline alsa_device_t usecase_device_adapter_with_ms12(alsa_device_t useca
     switch (usecase_device) {
     case DIGITAL_DEVICE:
     case I2S_DEVICE:
-        if ((output_format == AUDIO_FORMAT_AC3) || (output_format == AUDIO_FORMAT_E_AC3) || (output_format == AUDIO_FORMAT_MAT) ) {
+        if ((output_format == AUDIO_FORMAT_AC3) || (output_format == AUDIO_FORMAT_E_AC3)
+            || (output_format == AUDIO_FORMAT_MAT) ) {
             return DIGITAL_DEVICE;
         } else {
             return I2S_DEVICE;
@@ -218,7 +256,8 @@ struct aml_audio_patch {
     void *audio_parse_para;
     audio_devices_t input_src;
     audio_format_t  aformat;
-    int  sample_rate;
+    int input_sample_rate;
+    int sample_rate;
     audio_channel_mask_t chanmask;
     audio_channel_mask_t in_chanmask;
     int in_sample_rate;
@@ -238,14 +277,21 @@ struct aml_audio_patch {
     void *mixed_buf;
 #endif
 
+    /* for initial flushing */
+    int init_flush_count;
+
     /* for AVSYNC tuning */
-    int is_src_stable;
+    int rbuf_ltcy;
     int av_diffs;
-    int do_tune;
+    int average_av_diffs;
     int avsync_sample_accumed;
-    int avsync_sample_max_cnt;
-    int avsync_sample_interval;
+    bool need_do_avsync;
+    bool input_signal_stable;
+    bool is_avsync_start;
+    bool skip_frames;
+    int skip_avsync_cnt;
     /* end of AVSYNC tuning */
+
     /*for dtv play parameters */
     int dtv_aformat;
     int dtv_has_video;
@@ -262,6 +308,7 @@ struct aml_audio_patch {
     unsigned int decoder_offset ;
     unsigned int outlen_after_last_validpts;
     unsigned long last_valid_pts;
+    unsigned long last_out_pts;
     unsigned int first_apts_lookup_over;
     int dtv_symple_rate;
     int dtv_pcm_channel;
@@ -272,12 +319,16 @@ struct aml_audio_patch {
     int spdif_step_clk;
     int i2s_step_clk;
     int dtv_audio_mode;
+    int dtv_pcr_mode;
+    int tsync_mode;
     int dtv_apts_lookup;
     int dtv_audio_tune;
     int pll_state;
     unsigned int last_apts;
     unsigned int last_pcrpts;
     dtv_avsync_process_cb avsync_callback;
+    int dtv_faded_out;
+    int dtv_ac3_fmsize;
     pthread_mutex_t dtv_output_mutex;
     pthread_mutex_t dtv_input_mutex;
     pthread_mutex_t assoc_mutex;
@@ -288,10 +339,8 @@ struct aml_audio_patch {
     struct resample_para dtv_resample;
     unsigned char *resample_outbuf;
     AM_AOUT_OutputMode_t   mode;
-    unsigned char avsync_adelay;
-    unsigned char avsync_tuned;
-    unsigned char avsync_drop;
-    void *drop_buf;
+    bool ac3_pcm_dropping;
+    int last_audio_delay;
 };
 
 struct audio_stream_out;
@@ -317,16 +366,20 @@ bool is_hdmi_in_stable_sw(struct audio_stream_in *stream);
 /*@brief check the ATV audio stability by HW register */
 bool is_atv_in_stable_hw(struct audio_stream_in *stream);
 int set_audio_source(struct aml_mixer_handle *mixer_handle,
-		enum input_source audio_source, bool is_auge);
+                enum input_source audio_source, bool is_auge);
 int get_HW_resample(struct aml_mixer_handle *mixer_handle);
 int enable_HW_resample(struct aml_mixer_handle *mixer_handle, int enable_sr);
 bool Stop_watch(struct timespec start_ts, int64_t time);
 bool signal_status_check(audio_devices_t in_device, int *mute_time,
                          struct audio_stream_in *stream);
 int set_spdifin_pao(struct aml_mixer_handle *mixer_handle, int enable);
-int get_hdmiin_samplerate(struct aml_mixer_handle *mixer_handle);
+eMixerHwResample get_hdmiin_samplerate(struct aml_mixer_handle *mixer_handle);
 hdmiin_audio_packet_t get_hdmiin_audio_packet(struct aml_mixer_handle *mixer_handle);
 int get_hdmiin_channel(struct aml_mixer_handle *mixer_handle);
+int get_arcin_channel(struct aml_mixer_handle *mixer_handle);
+int get_arcin_ca(struct aml_mixer_handle *mixer_handle);
+eMixerHwResample get_eArcIn_samplerate(struct aml_mixer_handle *mixer_handle);
+audio_channel_mask_t aml_map_ca_to_mask(int ca);
 
 /*
  *@brief clean the tmp_buffer_8ch&audioeffect_tmp_buffer and release audio stream
@@ -339,7 +392,27 @@ int set_stream_dual_output(struct audio_stream_out *stream, bool en);
 int update_stream_dual_output(struct audio_stream_out *stream);
 bool is_dual_output_stream(struct audio_stream_out *stream);
 
-int get_spdifin_samplerate(struct aml_mixer_handle *mixer_handle);
+eMixerHwResample get_spdifin_samplerate(struct aml_mixer_handle *mixer_handle);
 unsigned int inport_to_device(enum IN_PORT inport);
+int set_resample_source(struct aml_mixer_handle *mixer_handle, enum ResampleSource source);
+void get_audio_indicator(struct aml_audio_device *dev, char *temp_buf);
+void update_audio_format(struct aml_audio_device *adev, audio_format_t format);
+/*
+ *This Dolby MultiStreamDecoder was built using the following components(only the decoder):
+ *- Dolby Digital Plus Decoder
+ *- Dolby HE-AAC Decoder
+ *- Dolby AC-4 Decoder
+ *- Dolby MAT Decoder
+ *- Dolby TrueHD Decoder
+ *
+ *means that Dolby MS12 supports DD/DDP/Dolby-TrueHD/AC4/MAT as the compression format.
+ */
+bool is_dolby_ms12_support_compression_format(audio_format_t format);
+/*
+ *if the stream's flag is direct and format is PCM
+ *    return true;
+ *otherwise, return false;
+ */
+bool is_direct_stream_and_pcm_format(struct aml_stream_out *out);
 
 #endif /* _AML_AUDIO_STREAM_H_ */
diff --git a/audio_hal/aml_audio_timer.c b/audio_hal/aml_audio_timer.c
index fb2b570..29ef693 100644
--- a/audio_hal/aml_audio_timer.c
+++ b/audio_hal/aml_audio_timer.c
@@ -25,7 +25,6 @@
 
 #include "aml_audio_timer.h"
 
-
 uint64_t aml_audio_get_systime(void)
 {
     struct timespec ts;
diff --git a/audio_hal/aml_audio_timer.h b/audio_hal/aml_audio_timer.h
index 74d7158..8d4b738 100644
--- a/audio_hal/aml_audio_timer.h
+++ b/audio_hal/aml_audio_timer.h
@@ -20,6 +20,10 @@
 
 #include <stdint.h>
 
+#define   NSPERSECOND   1000000000UL
+#define   USPERSECOND   1000000UL
+#define   MSPERSECOND   1000UL
+
 int aml_audio_sleep(uint64_t us);
 
 uint64_t aml_audio_get_systime(void);
diff --git a/audio_hal/aml_avsync_tuning.c b/audio_hal/aml_avsync_tuning.c
index e99c32e..292ef38 100644
--- a/audio_hal/aml_avsync_tuning.c
+++ b/audio_hal/aml_avsync_tuning.c
@@ -29,6 +29,7 @@
 #include "audio_hw_utils.h"
 #include "aml_audio_stream.h"
 #include "aml_avsync_tuning.h"
+#include "alsa_manager.h"
 #include "dolby_lib_api.h"
 
 
@@ -127,6 +128,71 @@ err:
     return ret;
 }
 
+static void check_skip_frames(struct aml_audio_device *aml_dev)
+{
+    struct aml_audio_patch *patch = aml_dev->audio_patch;
+    snd_pcm_sframes_t frames = 0;
+    struct pcm *pcm_handle = aml_dev->pcm_handle[I2S_DEVICE];
+
+    if (pcm_handle && patch && patch->need_do_avsync == true && patch->is_avsync_start == false) {
+        if (pcm_ioctl(pcm_handle, SNDRV_PCM_IOCTL_DELAY, &frames) >= 0) {
+            int alsa_out_i2s_ltcy = frames / SAMPLE_RATE_MS;
+
+            /* start to skip the output frames to reduce alsa out latency */
+            if (alsa_out_i2s_ltcy >= AVSYNC_ALSA_OUT_MAX_LATENCY) {
+                patch->skip_frames = 1;
+            } else {
+                patch->skip_frames = 0;
+            }
+        }
+    }
+}
+
+static int calc_frame_to_latency(int frames, audio_format_t format)
+{
+    int latency = frames / SAMPLE_RATE_MS;
+
+    if (format == AUDIO_FORMAT_E_AC3) {
+        latency /= EAC3_MULTIPLIER;
+    } else if (format == AUDIO_FORMAT_MAT ||
+            (format == AUDIO_FORMAT_DOLBY_TRUEHD)) {
+        latency /= MAT_MULTIPLIER;
+    }
+    return latency;
+}
+
+static int calc_latency_to_frame(int latency, audio_format_t format)
+{
+    int frames = 0;
+#if 0
+    if (format == AUDIO_FORMAT_E_AC3) {
+        frames *= EAC3_MULTIPLIER;
+    } else if (format == AUDIO_FORMAT_MAT ||
+            (format == AUDIO_FORMAT_DOLBY_TRUEHD)) {
+        frames *= MAT_MULTIPLIER;
+    }
+#endif
+    frames = latency * SAMPLE_RATE_MS;
+    ALOGV("%s(), %d", __func__, format);
+    return frames;
+}
+
+static int ringbuffer_seek(struct aml_audio_patch *patch, int tune_val)
+{
+    int space = 0, seek_space = 0;
+
+    space = calc_latency_to_frame(tune_val, patch->aformat);
+    space *= CHANNEL_CNT * audio_bytes_per_sample(AUDIO_FORMAT_PCM_16_BIT);
+    seek_space = ring_buffer_seek(&patch->aml_ringbuffer, space);
+
+    if (seek_space == space)
+        ALOGV("  --tunning audio ringbuffer %dms sucessfully!", tune_val);
+    else
+        ALOGV("  not enough space to seek!");
+
+    return seek_space;
+}
+
 static int aml_dev_sample_audio_path_latency(struct aml_audio_device *aml_dev)
 {
     struct aml_stream_in *in = aml_dev->active_input;
@@ -144,7 +210,9 @@ static int aml_dev_sample_audio_path_latency(struct aml_audio_device *aml_dev)
 
         rbuf_avail = get_buffer_read_space(&patch->aml_ringbuffer);
         frames = rbuf_avail / frame_size;
-        rbuf_ltcy = frames / SAMPLE_RATE_MS;
+        rbuf_ltcy = calc_frame_to_latency(frames, patch->aformat);
+        patch->rbuf_ltcy = rbuf_ltcy;
+
         ALOGV("  audio ringbuf latency = %d", rbuf_ltcy);
     }
 
@@ -154,17 +222,38 @@ static int aml_dev_sample_audio_path_latency(struct aml_audio_device *aml_dev)
         rbuf_avail = get_buffer_read_space(&aml_dev->spk_tuning_rbuf);
         frames = rbuf_avail / frame_size;
         spk_tuning_ltcy = frames / SAMPLE_RATE_MS;
+
         ALOGV("  audio spk tuning latency = %d", spk_tuning_ltcy);
     }
 
-    if (eDolbyMS12Lib == aml_dev->dolby_lib_type) {
-        if (aml_dev->ms12.dolby_ms12_enable == true) {
-            int dolby_main_avail = dolby_ms12_get_main_buffer_avail(NULL);
-            if (dolby_main_avail > 0) {
-                ms12_ltcy = dolby_main_avail / frame_size / SAMPLE_RATE_MS;
-            }
-            ALOGV("  audio ms12 latency = %d", ms12_ltcy);
+    if ((eDolbyMS12Lib == aml_dev->dolby_lib_type) &&
+        aml_dev->ms12.dolby_ms12_enable &&
+        aml_dev->ms12_out) {
+
+        audio_format_t format = aml_dev->ms12_out->hal_internal_format;
+        int dolby_main_avail = dolby_ms12_get_main_buffer_avail(NULL);
+        int ms12_latency_decoder = MS12_DECODER_LATENCY;
+        int ms12_latency_pipeline = MS12_PIPELINE_LATENCY;
+        int ms12_latency_dap = MS12_DAP_LATENCY;
+        int ms12_latency_encoder = MS12_ENCODER_LATENCY;
+
+        if (dolby_main_avail > 0) {
+            ms12_ltcy = calc_frame_to_latency((dolby_main_avail / frame_size), format);
+            ALOGV("  audio ms12 buffer latency = %d, format = %x", ms12_ltcy, format);
         }
+
+        ms12_ltcy += ms12_latency_pipeline;
+
+        if ((format & AUDIO_FORMAT_MAIN_MASK) != AUDIO_FORMAT_PCM)
+            ms12_ltcy += ms12_latency_decoder;
+        if (aml_dev->sink_format == AUDIO_FORMAT_PCM_16_BIT) {
+            ms12_ltcy += ms12_latency_dap;
+        } else if ((aml_dev->optical_format == AUDIO_FORMAT_AC3) ||
+                   (aml_dev->optical_format == AUDIO_FORMAT_E_AC3)) {
+            ms12_ltcy += ms12_latency_encoder;
+        }
+
+        ALOGV("  audio ms12 latency = %d, format = %x", ms12_ltcy, format);
     }
 
     if (aml_dev->pcm_handle[I2S_DEVICE]) {
@@ -172,13 +261,14 @@ static int aml_dev_sample_audio_path_latency(struct aml_audio_device *aml_dev)
         if (ret >= 0) {
             alsa_out_i2s_ltcy = frames / SAMPLE_RATE_MS;
         }
-        ALOGV("  audio i2s latency = %d", alsa_out_i2s_ltcy);
+
+        ALOGV("  audio_hw_primary audio i2s latency = %d", alsa_out_i2s_ltcy);
     }
 
     if (aml_dev->pcm_handle[DIGITAL_DEVICE]) {
         ret = pcm_ioctl(aml_dev->pcm_handle[DIGITAL_DEVICE], SNDRV_PCM_IOCTL_DELAY, &frames);
         if (ret >= 0) {
-            alsa_out_spdif_ltcy = frames / SAMPLE_RATE_MS;
+            alsa_out_spdif_ltcy = calc_frame_to_latency(frames, aml_dev->sink_format);
         }
         ALOGV("  audio spdif latency = %d", alsa_out_spdif_ltcy);
     }
@@ -187,7 +277,10 @@ static int aml_dev_sample_audio_path_latency(struct aml_audio_device *aml_dev)
         if (in->pcm != NULL) {
             ret = pcm_ioctl(in->pcm, SNDRV_PCM_IOCTL_DELAY, &frames);
             if (ret >= 0) {
-                alsa_in_ltcy = frames / SAMPLE_RATE_MS;
+                frames = frames%(in->config.period_size*in->config.period_count);
+                if (patch) {
+                    alsa_in_ltcy = calc_frame_to_latency(frames, patch->aformat);
+                }
             }
             ALOGV("  audio alsa in latency = %d", alsa_in_ltcy);
         }
@@ -198,20 +291,12 @@ static int aml_dev_sample_audio_path_latency(struct aml_audio_device *aml_dev)
         int in_path_ltcy = alsa_in_ltcy + rbuf_ltcy + ms12_ltcy;
         int out_path_ltcy = 0;
 
-        if (patch->aformat == AUDIO_FORMAT_E_AC3) {
-            in_path_ltcy /= EAC3_MULTIPLIER;
-        } else if (patch->aformat == AUDIO_FORMAT_MAT) {
-            in_path_ltcy /= MAT_MULTIPLIER;
-        }
-
         if (aml_dev->sink_format == AUDIO_FORMAT_PCM_16_BIT) {
             out_path_ltcy = alsa_out_i2s_ltcy + spk_tuning_ltcy;
-        } else if (aml_dev->sink_format == AUDIO_FORMAT_AC3) {
+        } else if (aml_dev->sink_format == AUDIO_FORMAT_AC3 ||
+                   aml_dev->sink_format == AUDIO_FORMAT_E_AC3 ||
+                   aml_dev->sink_format == AUDIO_FORMAT_MAT) {
             out_path_ltcy = alsa_out_spdif_ltcy;
-        } else if (aml_dev->sink_format == AUDIO_FORMAT_E_AC3) {
-            out_path_ltcy = alsa_out_spdif_ltcy / EAC3_MULTIPLIER;
-        } else if (aml_dev->sink_format == AUDIO_FORMAT_MAT) {
-            out_path_ltcy = alsa_out_spdif_ltcy / MAT_MULTIPLIER;
         }
 
         whole_path_ltcy = in_path_ltcy + out_path_ltcy;
@@ -220,19 +305,16 @@ static int aml_dev_sample_audio_path_latency(struct aml_audio_device *aml_dev)
     return whole_path_ltcy;
 }
 
-static int aml_dev_sample_video_path_latency(int *vlatency)
+static int aml_dev_sample_video_path_latency(void)
 {
     int vltcy = 0;
 
     vltcy = aml_sysfs_get_int("/sys/class/video/vframe_walk_delay");
-    if (vltcy >= 250 || vltcy <= 0) {
-        ALOGV("%s(), invalid video latency: %d", __func__, vltcy);
-        *vlatency = 0;
+    if (vltcy >= MAX_VEDIO_LATENCY || vltcy <= 0) {
         return -EINVAL;
     }
 
-    *vlatency = vltcy;
-    return 0;
+    return vltcy;
 }
 
 static inline int calc_diff(int altcy, int vltcy)
@@ -242,7 +324,7 @@ static inline int calc_diff(int altcy, int vltcy)
 
 static int aml_dev_avsync_diff_in_path(struct aml_audio_patch *patch, int *av_diff)
 {
-    struct aml_audio_device *aml_dev = NULL;
+    struct aml_audio_device *aml_dev;
     int altcy = 0, vltcy = 0;
     int src_diff_err = 0;
     int ret = 0;
@@ -251,20 +333,24 @@ static int aml_dev_avsync_diff_in_path(struct aml_audio_patch *patch, int *av_di
         ret = -EINVAL;
         goto err;
     }
-
     aml_dev = (struct aml_audio_device *)patch->dev;
 
-    altcy = aml_dev_sample_audio_path_latency(aml_dev);
-    ret = aml_dev_sample_video_path_latency(&vltcy);
-    if (ret < 0) {
+    check_skip_frames(aml_dev);
+
+    vltcy = aml_dev_sample_video_path_latency();
+    if (vltcy < 0) {
         ret = -EINVAL;
+        goto err;
     }
 
+    altcy = aml_dev_sample_audio_path_latency(aml_dev);
+
     if (patch->input_src == AUDIO_DEVICE_IN_LINE) {
         src_diff_err = -30;
     }
-    ALOGV("%s(), altcy: %dms, vltcy: %dms", __func__, altcy, vltcy);
-    *av_diff = altcy - vltcy + src_diff_err ;
+    *av_diff = altcy - vltcy + src_diff_err;
+
+    ALOGV("  altcy: %dms, vltcy: %dms, av_diff: %dms\n\n", altcy, vltcy, *av_diff);
 
     return 0;
 
@@ -274,10 +360,12 @@ err:
 
 static inline void aml_dev_accumulate_avsync_diff(struct aml_audio_patch *patch, int av_diff)
 {
-    if (patch->avsync_sample_accumed > 5) {
-        patch->av_diffs += av_diff;
-    }
+    patch->av_diffs += av_diff;
     patch->avsync_sample_accumed++;
+    patch->average_av_diffs = patch->av_diffs / patch->avsync_sample_accumed;
+
+    ALOGV("  latency status[%d]: average av_diff = %dms\n\n",
+            patch->avsync_sample_accumed, patch->average_av_diffs);
 }
 
 static int aml_dev_tune_video_path_latency(int tune_val)
@@ -285,7 +373,6 @@ static int aml_dev_tune_video_path_latency(int tune_val)
     char tmp[32];
     int ret = 0;
 
-    ALOGV("%s(): tuning video total latency: value %dms", __func__, tune_val);
     if (tune_val > 200 || tune_val < -200) {
         ALOGE("%s():  unsupport tuning value: %dms", __func__, tune_val);
         ret = -EINVAL;
@@ -309,6 +396,7 @@ static int aml_dev_tune_video_path_latency(int tune_val)
         goto err;
     }
 
+    ALOGD("  --tuning video total latency: value %dms", tune_val);
     return 0;
 err:
     return ret;
@@ -318,65 +406,78 @@ static inline void aml_dev_avsync_reset(struct aml_audio_patch *patch)
 {
     patch->avsync_sample_accumed = 0;
     patch->av_diffs = 0;
-    patch->do_tune = 0;
+    patch->average_av_diffs = 0;
+    patch->need_do_avsync = false;
+    patch->is_avsync_start = false;
+    patch->skip_avsync_cnt = 0;
 }
 
 int aml_dev_try_avsync(struct aml_audio_patch *patch)
 {
-    int av_diff = 0;
-    struct aml_audio_device *aml_dev = (struct aml_audio_device *)patch->dev;
+    int av_diff = 0, factor;
+    struct aml_audio_device *aml_dev;
+    struct audio_stream_in *in;
     int ret = 0;
 
     if (!patch) {
         return 0;
     }
-    if (patch->avsync_tuned == 1) {
-        patch->avsync_adelay = 0;
-        patch->avsync_drop = 0;
-        return 0;
-    }
+    aml_dev = (struct aml_audio_device *)patch->dev;
+    in = (struct audio_stream_in *)aml_dev->active_input;
+    factor = (patch->aformat == AUDIO_FORMAT_E_AC3) ? 2 : 1;
 
     ret = aml_dev_avsync_diff_in_path(patch, &av_diff);
     if (ret < 0) {
-        patch->avsync_adelay = 0;
-        patch->avsync_drop = 0;
         return 0;
     }
 
-    /* To tune immediately */
-    //if (av_diff > 16)
-    //    patch->do_tune = 1;
+    /* skip some frames to wait video stability*/
+    if (patch->skip_avsync_cnt < AVSYNC_SKIP_CNT) {
+        patch->skip_avsync_cnt++;
+        return 0;
+    }
 
-    aml_dev_accumulate_avsync_diff(patch, av_diff);
-    if (patch->avsync_sample_accumed >= patch->avsync_sample_max_cnt) {
-        patch->do_tune = 1;
+    if (patch->is_avsync_start == false) {
+        patch->is_avsync_start = true;
+        /*flush the alsa input buffer*/
+        aml_alsa_input_flush(in);
+        ALOGV("  /* start calc the average latency of audio & video */");
     }
 
-    if (patch->do_tune) {
-        int tune_val = patch->av_diffs / (patch->avsync_sample_accumed - 5);
-        int user_tune_val = aml_audio_get_src_tune_latency(aml_dev->patch_src);
-        ALOGV("%s(), av user tuning latency = %dms",
-              __func__, user_tune_val);
+    aml_dev_accumulate_avsync_diff(patch, av_diff);
+
+    if (patch->avsync_sample_accumed >= AVSYNC_SAMPLE_MAX_CNT) {
+        int tune_val = patch->average_av_diffs;
+        int user_tune_val = aml_audio_get_tvsrc_tune_latency(aml_dev->patch_src);
+
         tune_val += user_tune_val;
-        patch->avsync_tuned = 1;
-        aml_dev_avsync_reset(patch);
-        if (tune_val < 0) {
-            patch->avsync_adelay = -tune_val;
-            patch->avsync_drop = 0;
-        } else {
-            if (patch->input_src == AUDIO_DEVICE_IN_LINE) {
-                patch->avsync_drop = tune_val;
+
+        ALOGD("  --start avsync, user tuning latency = %dms, total tuning latency = %dms",
+                user_tune_val, tune_val);
+
+        if (tune_val > 0) {
+            /* if it need reduce audio latency, first do ringbuffer seek*/
+            if (patch->rbuf_ltcy > AVSYNC_RINGBUFFER_MIN_LATENCY) {
+                int seek_space = patch->rbuf_ltcy - AVSYNC_RINGBUFFER_MIN_LATENCY;
+
+                if (seek_space > tune_val)
+                    seek_space = tune_val;
+
+                ringbuffer_seek(patch, seek_space);
+                tune_val -= seek_space;
+            }
+            /* then delay video*/
+            if (tune_val > 0) {
+                ret = aml_dev_tune_video_path_latency(tune_val);
             } else {
-                patch->avsync_drop = tune_val;
+                ret = aml_dev_tune_video_path_latency(0);
             }
-            patch->avsync_adelay = 0;
-        }
-        if (tune_val > 0) {
-            ret = aml_dev_tune_video_path_latency(tune_val);
-        }
-        if (ret < 0) {
-            ALOGE("%s() fail, err = %d", __func__, ret);
+        } else {
+            /* if it need add more audio latency, direct do ringbuffer seek*/
+            ringbuffer_seek(patch, tune_val);
         }
+
+        aml_dev_avsync_reset(patch);
     }
     return 0;
 }
diff --git a/audio_hal/aml_avsync_tuning.h b/audio_hal/aml_avsync_tuning.h
index 9aa3cd5..9a6255a 100644
--- a/audio_hal/aml_avsync_tuning.h
+++ b/audio_hal/aml_avsync_tuning.h
@@ -20,9 +20,16 @@
 /* FIXME: add more SAMPLERATE and CHANNEL COUNT support */
 #define SAMPLE_RATE_MS (48)
 #define CHANNEL_CNT (2)
-/* 16 bits */
 #define FRAME_SIZE (2)
 
+/* check avsync latency times*/
+#define AVSYNC_SAMPLE_MAX_CNT (3)
+#define AVSYNC_ALSA_OUT_MAX_LATENCY (60)
+#define AVSYNC_RINGBUFFER_MIN_LATENCY (20)
+#define AVSYNC_SKIP_CNT (0)
+
+#define MAX_VEDIO_LATENCY (300)
+
 struct aml_audio_patch;
 struct aml_audio_device;
 
diff --git a/audio_hal/aml_dca_dec_api.c b/audio_hal/aml_dca_dec_api.c
index 1f78347..a1d5b63 100644
--- a/audio_hal/aml_dca_dec_api.c
+++ b/audio_hal/aml_dca_dec_api.c
@@ -48,6 +48,7 @@ enum {
 #define DTS_TYPE_II    0xC
 #define DTS_TYPE_III   0xD
 #define DTS_TYPE_IV    0x11
+
 #define IEC61937_HEADER_LENGTH  8
 #define IEC_DTS_HD_APPEND_LNGTH 12
 #define IEC61937_PA_OFFSET  0
@@ -59,6 +60,16 @@ enum {
 #define IEC61937_PD_OFFSET  6
 #define IEC61937_PD_SIZE    2
 
+#define AML_DCA_INPUT_DATA_LEN_PTIME               (10*1024)
+#define AML_DCA_SW_CORE_16M          0x7ffe8001
+#define AML_DCA_SW_CORE_14M          0x1fffe800
+#define AML_DCA_SW_CORE_24M          0xfe80007f
+#define AML_DCA_SW_CORE_16             0xfe7f0180
+#define AML_DCA_SW_CORE_14             0xff1f00e8
+#define AML_DCA_SW_CORE_24             0x80fe7f01
+#define AML_DCA_SW_SUBSTREAM_M    0x64582025
+#define AML_DCA_SW_SUBSTREAM         0x58642520
+
 //#define MAX_DDP_FRAME_LENGTH 2048
 
 ///static struct pcm_info pcm_out_info;
@@ -69,7 +80,7 @@ int (*dts_decoder_process)(char * , int , int *, char *, int *, struct pcm_info
 void *gDtsDecoderLibHandler = NULL;
 
 
-static  int unload_dts_decoder_lib()
+static int unload_dts_decoder_lib()
 {
     if (dts_decoder_cleanup != NULL) {
         (*dts_decoder_cleanup)();
@@ -149,9 +160,9 @@ static int dca_decode_process(unsigned char*input, int input_size, unsigned char
                                  , (char *) spdif_buf
                                  , (int *) raw_size);
     if (ret == 0) {
-        ALOGI("decode ok");
+        ALOGV("decode ok");
     }
-    ALOGV("used_size %d,lpcm out_size %d,raw out size %d", used_size, *out_size, *raw_size);
+    ALOGV("used_size %d,input_size:%d, lpcm out_size %d,raw out size %d", used_size, input_size, *out_size, *raw_size);
 
     return used_size;
 }
@@ -215,30 +226,137 @@ int dca_decoder_release_patch(struct dca_dts_dec *dts_dec)
     return 1;
 }
 
+static int AML_Match_DTS_SyncWord(unsigned char *read_pointer, unsigned int *pTemp0)
+{
+    unsigned int ui32Temp0 = 0;
+    unsigned int ui32Temp1 = 0;
+
+    ui32Temp0  = read_pointer[0];
+    ui32Temp0 <<= 8;
+    ui32Temp0 |= read_pointer[1];
+    ui32Temp0 <<= 8;
+    ui32Temp0 |= read_pointer[2];
+    ui32Temp0 <<= 8;
+    ui32Temp0 |= read_pointer[3];
+
+    ui32Temp1  = read_pointer[4];
+    ui32Temp1 <<= 8;
+    ui32Temp1 |= read_pointer[5];
+    ui32Temp1 <<= 8;
+    ui32Temp1 |= read_pointer[6];
+    ui32Temp1 <<= 8;
+    ui32Temp1 |= read_pointer[7];
+
+    /* 16-bit bit core stream*/
+    if ( ui32Temp0 == AML_DCA_SW_CORE_16  || ui32Temp0 == AML_DCA_SW_CORE_14 ||
+         ui32Temp0 == AML_DCA_SW_CORE_16M || ui32Temp0 == AML_DCA_SW_CORE_14M ||
+         ui32Temp0 == AML_DCA_SW_SUBSTREAM|| ui32Temp0 ==AML_DCA_SW_SUBSTREAM_M)
+    {
+        *pTemp0 = ui32Temp0;
+        return 1;
+    }
+
+    if ((ui32Temp0 & 0xffffff00) == (AML_DCA_SW_CORE_24 & 0xffffff00) &&
+       ((ui32Temp1 >> 16) & 0xFF)== (AML_DCA_SW_CORE_24 & 0xFF)) {
+        *pTemp0 = ui32Temp0;
+        return 1;
+    }
+
+    return 0;
+}
+
 int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer, int bytes)
 {
     int mFrame_size = 0;
     unsigned char *read_pointer = NULL;
+    unsigned char *read_pointer1 = NULL;
     int dts_type = 0;
-    //ALOGD("remain=%d bytes=%d\n",dts_dec->remain_size,bytes);
-    memcpy((char *)dts_dec->inbuf + dts_dec->remain_size, (char *)buffer, bytes);
-    dts_dec->remain_size += bytes;
-    read_pointer = dts_dec->inbuf;
     int decoder_used_bytes = 0;
     void *main_frame_buffer = NULL;
     int main_frame_size = 0;
     bool SyncFlag = false;
-    bool  little_end = false;
+    bool little_end = false;
     int data_offset = 0;
     int ret = -1;
+    int second_sync_pos=-1,first_sync_pos=-1;
+    int tmp_size = 0;
+
+    memcpy((char *)dts_dec->inbuf + dts_dec->remain_size, (char *)buffer, bytes);
+    dts_dec->remain_size += bytes;
+    read_pointer = dts_dec->inbuf;
+
     if (dts_dec->is_dtscd == 1) {
         main_frame_buffer = read_pointer;
         main_frame_size = mFrame_size = dts_dec->remain_size;
+    } else if (dts_dec->is_dtv) {
+        ALOGD("dtv dts remain=%d bytes=%d",dts_dec->remain_size,bytes);
+        if (dts_dec->remain_size >= AML_DCA_INPUT_DATA_LEN_PTIME) {
+            unsigned int ui32Sword0 = 0, ui32Sword1 = 0;
+            unsigned int ui32Sword0_save = 0;
+            while (!SyncFlag && dts_dec->remain_size > IEC61937_HEADER_LENGTH) {
+                SyncFlag = AML_Match_DTS_SyncWord(read_pointer, &ui32Sword0);
+
+                if (SyncFlag == 0) {
+                    read_pointer++;
+                    dts_dec->remain_size--;
+                } else {
+                    first_sync_pos = dts_dec->remain_size;
+                    read_pointer1 = read_pointer;
+                    read_pointer1++;
+                    tmp_size = dts_dec->remain_size;
+                    tmp_size--;
+                    ui32Sword0_save = ui32Sword0;
+                }
+            }
+
+            if (SyncFlag) {
+                while (first_sync_pos >= 0 && second_sync_pos == -1 && tmp_size > IEC61937_HEADER_LENGTH) {
+                    if (AML_Match_DTS_SyncWord(read_pointer1, &ui32Sword0) && (ui32Sword0_save == ui32Sword0)) {
+                        second_sync_pos = tmp_size;
+                        break;
+                    } else {
+                        read_pointer1++;
+                        tmp_size--;
+                    }
+                }
+
+                if (first_sync_pos != -1 && second_sync_pos != -1) {
+                    mFrame_size = first_sync_pos - second_sync_pos;
+                } else {
+                    mFrame_size = 0;
+                }
+            } else {
+                mFrame_size = 0;
+            }
+
+            if (mFrame_size <= 0) {
+                ALOGE("wrong data for DTS,skip the header remain=%d", dts_dec->remain_size);
+
+                if (dts_dec->remain_size < 0) {
+                    dts_dec->remain_size = 0;
+                    ALOGE("Carsh issue happens");
+                }
+                memmove(dts_dec->inbuf, read_pointer, dts_dec->remain_size);
+                return -1;
+            }
+
+            //to do know why
+            if (mFrame_size == 2013) {
+                mFrame_size = 2012;
+            }
 
+            main_frame_buffer = read_pointer;
+            main_frame_size = mFrame_size;
+            ALOGI("mFrame_size:%d dts_dec->remain_size:%d", mFrame_size, dts_dec->remain_size);
+            if (dts_dec->remain_size < mFrame_size) {
+                memmove(dts_dec->inbuf, read_pointer, dts_dec->remain_size);
+                mFrame_size = 0;
+            }
+        }
     } else if (dts_dec->remain_size >= MAX_DECODER_FRAME_LENGTH) {
         while (!SyncFlag && dts_dec->remain_size > IEC61937_HEADER_LENGTH) {
             //DTS_SYNCWORD_IEC61937 : 0xF8724E1F
-            if (read_pointer[0] == 0x72 && read_pointer[ 1] == 0xf8
+            if (read_pointer[0] == 0x72 && read_pointer[1] == 0xf8
                 && read_pointer[2] == 0x1f && read_pointer[3] == 0x4e) {
                 SyncFlag = true;
                 dts_type = read_pointer[4] & 0x1f;
@@ -248,6 +366,7 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
                 little_end = true;
                 dts_type = read_pointer[5] & 0x1f;
             }
+
             if (SyncFlag == 0) {
                 read_pointer++;
                 dts_dec->remain_size--;
@@ -280,7 +399,7 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
                 read_pointer = read_pointer + IEC61937_PD_SIZE;
                 if (dts_dec->remain_size < (IEC_DTS_HD_APPEND_LNGTH + IEC61937_HEADER_LENGTH)) {
                     // point to pa
-                    memcpy(dts_dec->inbuf, read_pointer - IEC61937_HEADER_LENGTH, dts_dec->remain_size);
+                    memmove(dts_dec->inbuf, read_pointer - IEC61937_HEADER_LENGTH, dts_dec->remain_size);
                     ALOGD("Not enough data for DTS HD header parsing\n");
                     return -1;
                 }
@@ -297,7 +416,6 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
                 // point to the address after 12 bytes header
                 read_pointer = read_pointer + IEC_DTS_HD_APPEND_LNGTH;
                 data_offset = IEC_DTS_HD_APPEND_LNGTH + IEC61937_HEADER_LENGTH;
-
             } else {
                 ALOGE("Unknow DTS type=0x%x\n", dts_type);
                 mFrame_size = 0;
@@ -312,7 +430,7 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
                     dts_dec->remain_size = 0;
                     ALOGE("Carsh issue happens\n");
                 }
-                memcpy(dts_dec->inbuf, read_pointer, dts_dec->remain_size);
+                memmove(dts_dec->inbuf, read_pointer, dts_dec->remain_size);
                 return -1;
             }
 
@@ -327,7 +445,7 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
             // the remain size contain the header and raw data size
             if (dts_dec->remain_size < (mFrame_size + data_offset)) {
                 // point to pa and copy these bytes
-                memcpy(dts_dec->inbuf, read_pointer - data_offset, dts_dec->remain_size);
+                memmove(dts_dec->inbuf, read_pointer - data_offset, dts_dec->remain_size);
                 mFrame_size = 0;
             } else {
                 // there is enough data, header has been used, update the remain size
@@ -336,8 +454,8 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
         } else {
             mFrame_size = 0;
         }
-
     }
+
     if (mFrame_size <= 0) {
         return -1;
     }
@@ -355,7 +473,6 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
     }
 #endif
 
-
     int used_size = dts_dec->decoder_process((unsigned char*)main_frame_buffer,
                     main_frame_size,
                     (unsigned char *)dts_dec->outbuf,
@@ -387,11 +504,10 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
             ALOGE("remain ori=%d new=%d used_size=%d main=%d\n", temp, dts_dec->remain_size, used_size, main_frame_size);
             dts_dec->remain_size = 0;
         }
-        memcpy(dts_dec->inbuf, read_pointer + used_size, dts_dec->remain_size);
+        memmove(dts_dec->inbuf, read_pointer + used_size, dts_dec->remain_size);
     }
 
     if (dts_dec->outlen_pcm > 0 && dts_dec->pcm_out_info.sample_rate > 0 && dts_dec->pcm_out_info.sample_rate != 48000) {
-
         if (dts_dec->resample_handle) {
             if (dts_dec->pcm_out_info.sample_rate != (int)dts_dec->resample_handle->resample_config.input_sr) {
                 audio_resample_config_t resample_config;
@@ -415,8 +531,6 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
             }
         }
 
-
-
         ret = aml_audio_resample_process(dts_dec->resample_handle, dts_dec->outbuf, dts_dec->outlen_pcm);
         if (ret < 0) {
             ALOGE("resample process error\n");
@@ -443,9 +557,6 @@ int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer,
 
 
     return 0;
-EXIT:
-
-    return -1;
 }
 
 static int Write_buffer(struct aml_audio_parser *parser, unsigned char *buffer, int size)
@@ -501,6 +612,8 @@ static void *decode_threadloop(void *data)
     int digital_raw = 0;
     int mute_count = 5;
     struct pcm_info  pcm_out_info;
+    int dts_type = 0;
+    int data_offset = 0;
 
     if (NULL == parser) {
         ALOGE("%s:%d parser == NULL", __func__, __LINE__);
@@ -540,7 +653,7 @@ static void *decode_threadloop(void *data)
         resampler_init(&parser->aml_resample);
     }
 
-    struct aml_stream_in *in = (struct aml_stream_in *)parser->stream;
+    struct aml_stream_in *in = parser->in;
     u32AlsaFrameSize = in->config.channels * pcm_format_to_bits(in->config.format) / 8;
     prctl(PR_SET_NAME, (unsigned long)"audio_dca_dec");
     while (parser->decode_ThreadExitFlag == 0) {
@@ -583,34 +696,112 @@ static void *decode_threadloop(void *data)
 #endif
         //find header and get paramters
         read_pointer = inbuf;
-        while (parser->decode_ThreadExitFlag == 0 && remain_size > MAX_DECODER_FRAME_LENGTH) {
-            //DTS_SYNCWORD_IEC61937 : 0xF8724E1F
-            if (read_pointer[0] == 0x72 && read_pointer[ 1] == 0xf8
-                && read_pointer[2] == 0x1f && read_pointer[3] == 0x4e) {
-                SyncFlag = true;
-                little_end = false;
-                s32DtsFramesize = (read_pointer[6] | read_pointer[7] << 8) / 8;
+        if  (remain_size > MAX_DECODER_FRAME_LENGTH)
+        {
+            while (parser->decode_ThreadExitFlag == 0 && !SyncFlag && remain_size > IEC61937_HEADER_LENGTH) {
+                //DTS_SYNCWORD_IEC61937 : 0xF8724E1F
+                if (read_pointer[0] == 0x72 && read_pointer[1] == 0xf8
+                    && read_pointer[2] == 0x1f && read_pointer[3] == 0x4e) {
+                    SyncFlag = true;
+                    dts_type = read_pointer[4] & 0x1f;
+                } else if (read_pointer[0] == 0xf8 && read_pointer[1] == 0x72
+                           && read_pointer[2] == 0x4e && read_pointer[3] == 0x1f) {
+                    SyncFlag = true;
+                    little_end = true;
+                    dts_type = read_pointer[5] & 0x1f;
+                }
+
+                if (SyncFlag == 0) {
+                    read_pointer++;
+                    remain_size--;
+                }
+            }
+            ALOGV("DTS Sync:%d little endian:%d dts type:%d, remain_size:%d",SyncFlag,little_end,dts_type, remain_size);
+            if (SyncFlag) {
+                // point to pd
+                read_pointer = read_pointer + IEC61937_PD_OFFSET;
+                //ALOGD("read_pointer[0]:0x%x read_pointer[1]:0x%x",read_pointer[0],read_pointer[1]);
+                if (!little_end) {
+                    s32DtsFramesize = (read_pointer[0] | read_pointer[1] << 8);
+                } else {
+                    s32DtsFramesize = (read_pointer[1] | read_pointer[0] << 8);
+                }
+
+                if (dts_type == DTS_TYPE_I ||
+                    dts_type == DTS_TYPE_II ||
+                    dts_type == DTS_TYPE_III) {
+                    // these DTS type use bits length for PD
+                    s32DtsFramesize = s32DtsFramesize >> 3;
+                    // point to the address after pd
+                    read_pointer = read_pointer + IEC61937_PD_SIZE;
+                    data_offset = IEC61937_HEADER_LENGTH;
+                } else if (dts_type == DTS_TYPE_IV) {
+                    /*refer kodi how to add 12 bytes header for DTS HD
+                    01 00 00 00 00 00 00 00 fe fe ** **, last 2 bytes for data size
+                    */
+                    // point to the address after pd
+                    read_pointer = read_pointer + IEC61937_PD_SIZE;
+                    if (remain_size < (IEC_DTS_HD_APPEND_LNGTH + IEC61937_HEADER_LENGTH)) {
+                        // point to pa
+                        memmove(inbuf, read_pointer - IEC61937_HEADER_LENGTH, remain_size);
+                        ALOGD("Not enough data for DTS HD header parsing\n");
+                        continue;
+                    }
+
+                    if (read_pointer[0] == 0x00 && read_pointer[1] == 0x01 && read_pointer[8] == 0xfe && read_pointer[9] == 0xfe) {
+                        s32DtsFramesize = (read_pointer[10] | read_pointer[11] << 8);
+                    } else if ((read_pointer[0] == 0x01 && read_pointer[1] == 0x00 && read_pointer[8] == 0xfe && read_pointer[9] == 0xfe)) {
+                        s32DtsFramesize = (read_pointer[11] | read_pointer[10] << 8);
+                    } else {
+                        ALOGE("DTS HD error data\n");
+                        s32DtsFramesize = 0;
+                    }
+                    //ALOGD("size data=0x%x 0x%x\n",read_pointer[10],read_pointer[11]);
+                    // point to the address after 12 bytes header
+                    read_pointer = read_pointer + IEC_DTS_HD_APPEND_LNGTH;
+                    data_offset = IEC_DTS_HD_APPEND_LNGTH + IEC61937_HEADER_LENGTH;
+                } else {
+                    ALOGW("Unknow DTS type=0x%x", dts_type);
+                    s32DtsFramesize = 0;
+                    data_offset = IEC61937_PD_OFFSET;
+                }
+
+                if (s32DtsFramesize <= 0) {
+                    ALOGW("wrong data for DTS,skip the header remain=%d data offset=%d", remain_size, data_offset);
+                    remain_size = remain_size - data_offset;
+
+                    if (remain_size < 0) {
+                        remain_size = 0;
+                        ALOGE("Carsh issue happens\n");
+                    }
+                    memmove(inbuf, read_pointer, remain_size);
+                    continue;
+                }
+
+                //to do know why
                 if (s32DtsFramesize == 2013) {
                     s32DtsFramesize = 2012;
                 }
-                //ALOGI("mFrame_size:%d dts_dec->remain_size:%d little_end:%d", mFrame_size, remain_size, little_end);
-                break;
+
+                ALOGV("mFrame_size:%d dts_dec->remain_size:%d little_end:%d", s32DtsFramesize, remain_size, little_end);
+                // the remain size contain the header and raw data size
+                if (remain_size < (s32DtsFramesize + data_offset)) {
+                    // point to pa and copy these bytes
+                    memmove(inbuf, read_pointer - data_offset, remain_size);
+                    s32DtsFramesize = 0;
+                } else {
+                    // there is enough data, header has been used, update the remain size
+                    remain_size = remain_size - data_offset;
+                }
+            } else {
+                s32DtsFramesize = 0;
             }
-            read_pointer++;
-            remain_size--;
         }
 
-        if (remain_size < (s32DtsFramesize + 8) || SyncFlag == 0) {
-            ALOGV("%s:%d remain:%d, DtsFramesize:%d, SyncFlag:%d, read more...", __func__, __LINE__,
-                remain_size, s32DtsFramesize, SyncFlag);
-            memcpy(inbuf, read_pointer, remain_size);
-            continue;
-        }
-        read_pointer += 8;   //pa pb pc pd
 #ifdef DTS_DECODER_ENABLE
+        ALOGV("%s:%d Framesize:%d, remain_size:%d, dts_type:%d", __func__, __LINE__, s32DtsFramesize, remain_size, dts_type);
         used_size = dca_decode_process(read_pointer, s32DtsFramesize, outbuf,
                                        &outlen_pcm, (char *) outbuf_raw, &outlen_raw,&pcm_out_info);
-#if 1
     if (getprop_bool("media.audiohal.dtsdump")) {
         FILE *dump_fp = NULL;
         dump_fp = fopen("/data/audio_hal/audio2dca.dts", "a+");
@@ -621,24 +812,21 @@ static void *decode_threadloop(void *data)
             ALOGW("[Error] Can't write to /data/audio_hal/audio2dca.raw");
         }
     }
-#endif
 
 #else
         used_size = s32DtsFramesize;
 #endif
         if (used_size > 0) {
-            remain_size -= 8;    //pa pb pc pd
             remain_size -= used_size;
             ALOGV("%s:%d decode success used_size:%d, outlen_pcm:%d", __func__, __LINE__, used_size, outlen_pcm);
-            memcpy(inbuf, read_pointer + used_size, remain_size);
+            memmove(inbuf, read_pointer + used_size, remain_size);
         } else {
-            ALOGW("%s:%d decode failed, used_size:%d", __func__, __LINE__, used_size);
+            ALOGV("%s:%d decode failed, used_size:%d", __func__, __LINE__, used_size);
         }
 
 #ifdef DTS_DECODER_ENABLE
         //only need pcm data
         if (outlen_pcm > 0) {
-
             // here only downresample, so no need to malloc more buffer
             if (parser->in_sample_rate != parser->out_sample_rate) {
                 int out_frame = outlen_pcm >> 2;
@@ -667,6 +855,7 @@ static void *decode_threadloop(void *data)
 #endif
             Write_buffer(parser, outbuf, outlen_pcm);
         }
+
 #endif
     }
     parser->decode_enabled = 0;
@@ -711,12 +900,98 @@ static int stop_decode_thread(struct aml_audio_parser *parser)
 
 int dca_decode_init(struct aml_audio_parser *parser)
 {
+    ring_buffer_reset(&(parser->aml_ringbuffer));
+    struct aml_stream_in *in = parser->in;
+    parser->aml_pcm = in->pcm;
+    parser->in_sample_rate = in->config.rate;
+    parser->out_sample_rate = in->requested_rate;
+    parser->decode_dev_op_mutex = &in->lock;
+    parser->data_ready = 0;
     return start_decode_thread(parser);
 }
 
 int dca_decode_release(struct aml_audio_parser *parser)
 {
-    return stop_decode_thread(parser);
+    int s32Ret = 0;
+    s32Ret = stop_decode_thread(parser);
+    ring_buffer_reset(&(parser->aml_ringbuffer));
+    return s32Ret;
+}
+
+/*dts decoder config(license and none-license)*/
+void dca_decoder_config(struct audio_stream_out *stream, bool *dtscd_flag)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+    struct aml_audio_device *adev = aml_out->dev;
+
+    /*init or close dts decoder*/
+    struct dca_dts_dec *dts_dec = & (adev->dts_hd);
+    if (aml_out->hal_format == AUDIO_FORMAT_IEC61937) {
+        switch (adev->hdmi_format) {
+        case PCM:
+            dts_dec->digital_raw = 0;
+            adev->dtslib_bypass_enable = 0;
+            break;
+        case DD:
+            dts_dec->digital_raw = 1;
+            //STB case
+            if (!adev->is_TV) {
+                set_stream_dual_output(stream, false);
+                adev->dtslib_bypass_enable = 1;
+            } else {
+                set_stream_dual_output(stream, true);
+                adev->dtslib_bypass_enable = 0;
+            }
+            adev->optical_format = AUDIO_FORMAT_AC3;
+            break;
+        case AUTO:
+        case BYPASS:
+            if (((!adev->is_TV) && (adev->active_outport == OUTPORT_HDMI)) ||
+                (adev->is_TV && (adev->active_outport == OUTPORT_HDMI_ARC))) {
+                if (adev->hdmi_descs.dtshd_fmt.is_support) {
+                    adev->dtslib_bypass_enable = 1;
+                    dts_dec->digital_raw = 2;
+                } else if (adev->hdmi_descs.dts_fmt.is_support) {
+                    if (aml_out->hal_internal_format == AUDIO_FORMAT_DTS_HD) {
+                       adev->dtslib_bypass_enable = 0;
+                } else if (aml_out->hal_internal_format == AUDIO_FORMAT_DTS) {
+                        dts_dec->digital_raw = 1;
+                        if (dts_dec->is_dtscd == 1) {
+                            adev->dtslib_bypass_enable = 0;
+                            *dtscd_flag = true;
+                        } else {
+                            adev->dtslib_bypass_enable = 1;
+                        }
+                    }
+                } else {
+                    dts_dec->digital_raw = 0;
+                    adev->dtslib_bypass_enable = 0;
+                }
+            } else if (adev->active_outport == OUTPORT_SPEAKER) {
+                dts_dec->digital_raw = 1;
+                adev->dtslib_bypass_enable = 0;
+            }
+            break;
+        default:
+            dts_dec->digital_raw = 0;
+            break;
+        }
+    }
+    else if (is_dts_format(aml_out->hal_format)) {
+        if (adev->is_TV) {
+            if (adev->active_outport == OUTPORT_HDMI_ARC) {
+            /*none-license dts decoder, TV platform*/
+                adev->dtslib_bypass_enable = 0;
+                dts_dec->digital_raw = 2;
+                *dtscd_flag = true;
+            } else if (adev->active_outport == OUTPORT_SPEAKER) {
+                dts_dec->digital_raw = 1;
+                adev->dtslib_bypass_enable = 0;
+            }
+        }
+    }
+
+    ALOGI("dts_dec->digital_raw:%d adev->dtslib_bypass_enable:%d", dts_dec->digital_raw, adev->dtslib_bypass_enable);
 }
 
 
diff --git a/audio_hal/aml_dca_dec_api.h b/audio_hal/aml_dca_dec_api.h
index 6bbbc4c..a641cdc 100644
--- a/audio_hal/aml_dca_dec_api.h
+++ b/audio_hal/aml_dca_dec_api.h
@@ -36,6 +36,7 @@ struct dca_dts_dec {
     int outlen_raw;
     int is_dtscd;
     int digital_raw;
+    bool is_dtv;
     //int (*get_parameters) (void *, int *, int *, int *);
     int (*decoder_process)(unsigned char*, int, unsigned char *, int *, char *, int *,struct pcm_info *);
     pthread_mutex_t lock;
@@ -51,4 +52,7 @@ int dca_decoder_init_patch(struct dca_dts_dec *dts_dec);
 int dca_decoder_release_patch(struct dca_dts_dec *dts_dec);
 int dca_decoder_process_patch(struct dca_dts_dec *dts_dec, unsigned char*buffer, int bytes);
 
+
+void dca_decoder_config(struct audio_stream_out *stream, bool *dtscd_flag);
+
 #endif
diff --git a/audio_hal/aml_dcv_dec_api.c b/audio_hal/aml_dcv_dec_api.c
index 2f49c32..939e28d 100644
--- a/audio_hal/aml_dcv_dec_api.c
+++ b/audio_hal/aml_dcv_dec_api.c
@@ -37,6 +37,7 @@
 #include "audio_hw_utils.h"
 #include "aml_dcv_dec_api.h"
 #include "aml_ac3_parser.h"
+#include <aml_android_utils.h>
 
 enum {
     EXITING_STATUS = -1001,
@@ -265,7 +266,7 @@ static int Get_DDP_Parameters(void *buf, int *sample_rate, int *frame_size, int
     }
     ddbs_unprj(p_bstrm, &acmod, 3);
     ddbs_unprj(p_bstrm, &lfeon, 1);
-    numch = chanary[acmod];
+    //numch = chanary[acmod];
     numch = 2;
     *ChNum = numch;
     //ALOGI("DEBUG[%s %d]:numch=%d,sr=%d,frs=%d",__FUNCTION__,__LINE__,*ChNum,*sample_rate,*frame_size);
@@ -303,40 +304,32 @@ static int Get_Parameters(void *buf, int *sample_rate, int *frame_size, int *ChN
     DDP_BSTRM *p_bstrm = &bstrm;
     DDPshort    bsid;
     int chnum = 0;
-    uint8_t ptr8[PTR_HEAD_SIZE];
+    uint8_t pdata[PTR_HEAD_SIZE];
 
-    memcpy(ptr8, buf, PTR_HEAD_SIZE);
+    memcpy(pdata, buf, PTR_HEAD_SIZE);
 
     //ALOGI("LZG->ptr_head:0x%x 0x%x 0x%x 0x%x 0x%x 0x%x \n",
     //     ptr8[0],ptr8[1],ptr8[2], ptr8[3],ptr8[4],ptr8[5] );
-    if ((ptr8[0] == 0x0b) && (ptr8[1] == 0x77)) {
+    if ((pdata[0] == 0x0b) && (pdata[1] == 0x77)) {
         int i;
         uint8_t tmp;
-#if 0
-        for (i = 0; i < PTR_HEAD_SIZE; i += 2) {
-            tmp = ptr8[i];
-            ptr8[i] = ptr8[i + 1];
-            ptr8[i + 1] = tmp;
+        for (i = 0; (i + 1) < PTR_HEAD_SIZE; i += 2) {
+            tmp = pdata[i];
+            pdata[i] = pdata[i + 1];
+            pdata[i + 1] = tmp;
         }
-#else
-        for (i = 0; i < PTR_HEAD_SIZE/2; i++) {
-           tmp = ptr8[2*i];
-           ptr8[2*i] = ptr8[2*i+1];
-           ptr8[2*i+1] = tmp;
-        }
-#endif
     }
 
-    ddbs_init((short*) ptr8, 0, p_bstrm);
+    ddbs_init((short*) pdata, 0, p_bstrm);
     int ret = ddbs_getbsid(p_bstrm, &bsid);
     if (ret < 0) {
         return -1;
     }
     if (ISDDP(bsid)) {
-        Get_DDP_Parameters(ptr8, sample_rate, frame_size, ChNum);
+        Get_DDP_Parameters(pdata, sample_rate, frame_size, ChNum);
         *is_eac3 = 1;
     } else if (ISDD(bsid)) {
-        Get_DD_Parameters(ptr8, sample_rate, frame_size, ChNum);
+        Get_DD_Parameters(pdata, sample_rate, frame_size, ChNum);
         *is_eac3 = 0;
     }
     return 0;
@@ -502,7 +495,7 @@ int Write_buffer(struct aml_audio_parser *parser, unsigned char *buffer, int siz
 
 #define MAX_DECODER_FRAME_LENGTH 6144 * 3
 #define READ_PERIOD_LENGTH 2048
-#define MAX_DDP_FRAME_LENGTH 2560
+#define MAX_DDP_FRAME_LENGTH 4096
 #define MAX_DDP_BUFFER_SIZE (MAX_DECODER_FRAME_LENGTH * 4 / 3 + 2 * MAX_DECODER_FRAME_LENGTH + 8)
 
 void *decode_threadloop(void *data)
@@ -562,7 +555,7 @@ void *decode_threadloop(void *data)
         resampler_init(&parser->aml_resample);
     }
 
-    struct aml_stream_in *in = (struct aml_stream_in *)parser->stream;
+    struct aml_stream_in *in = parser->in;
     u32AlsaFrameSize = in->config.channels * pcm_format_to_bits(in->config.format) / 8;
     prctl(PR_SET_NAME, (unsigned long)"audio_dcv_dec");
     while (parser->decode_ThreadExitFlag == 0) {
@@ -583,6 +576,14 @@ void *decode_threadloop(void *data)
                 usleep(1000);
                 continue;
             }
+            if (aml_getprop_bool("media.audiohal.dumpdcvin")) {
+                FILE *fp1 = fopen("/data/vendor/audiohal/dcv.raw", "a+");
+                if (fp1) {
+                    int flen = fwrite((char *)inbuf + remain_size, 1, s32AlsaReadFrames * u32AlsaFrameSize, fp1);
+                    fclose(fp1);
+                }
+            }
+
             remain_size += s32AlsaReadFrames * u32AlsaFrameSize;
         }
 
@@ -595,6 +596,11 @@ void *decode_threadloop(void *data)
         while (parser->decode_ThreadExitFlag == 0 && remain_size > 16) {
             if ((read_pointer[0] == 0x0b && read_pointer[1] == 0x77) || \
                 (read_pointer[0] == 0x77 && read_pointer[1] == 0x0b)) {
+                /*if the data is 0x0b 0x77 0x0b, we should use 0x77 0x0b as the sync word*/
+                if (read_pointer[0] == 0x0b && read_pointer[1] == 0x77 && read_pointer[2] == 0x0b) {
+                    remain_size--;
+                    read_pointer++;
+                }
                 Get_Parameters(read_pointer, &mSample_rate, &s32DolbyFrameSize, &mChNum, &is_eac3);
                 if ((s32DolbyFrameSize == 0) || (s32DolbyFrameSize < PTR_HEAD_SIZE) || \
                     (mChNum == 0) || (mSample_rate == 0)) {
@@ -690,12 +696,22 @@ static int stop_decode_thread(struct aml_audio_parser *parser)
 
 int dcv_decode_init(struct aml_audio_parser *parser)
 {
+    ring_buffer_reset(&(parser->aml_ringbuffer));
+    struct aml_stream_in *in = parser->in;
+    parser->aml_pcm = in->pcm;
+    parser->in_sample_rate = in->config.rate;
+    parser->out_sample_rate = in->requested_rate;
+    parser->decode_dev_op_mutex = &in->lock;
+    parser->data_ready = 0;
     return start_decode_thread(parser);
 }
 
 int dcv_decode_release(struct aml_audio_parser *parser)
 {
-    return stop_decode_thread(parser);
+    int s32Ret = 0;
+    s32Ret = stop_decode_thread(parser);
+    ring_buffer_reset(&(parser->aml_ringbuffer));
+    return s32Ret;
 }
 
 int dcv_decoder_init_patch(struct dolby_ddp_dec *ddp_dec)
diff --git a/audio_hal/aml_hw_mixer.c b/audio_hal/aml_hw_mixer.c
index 45eb9cb..e884c83 100644
--- a/audio_hal/aml_hw_mixer.c
+++ b/audio_hal/aml_hw_mixer.c
@@ -22,7 +22,6 @@
 #include <cutils/log.h>
 
 #include "aml_hw_mixer.h"
-#include "audio_hw_utils.h"
 
 //code here for audio hw mixer when hwsync with af mixer output stream output
 //at the same,need do a software mixer in audio hw c.
@@ -99,6 +98,7 @@ int aml_hw_mixer_get_content_l(struct aml_hw_mixer *mixer)
 int aml_hw_mixer_write(struct aml_hw_mixer *mixer, const void *buffer, size_t bytes)
 {
     int retry = 5;
+    int mutexed = 0;
     unsigned tail, space, write_bytes = bytes;
 
     if (!mixer || !mixer->start_buf) {
@@ -108,17 +108,23 @@ int aml_hw_mixer_write(struct aml_hw_mixer *mixer, const void *buffer, size_t by
 
     while (retry--) {
         pthread_mutex_lock(&mixer->lock);
+        mutexed = 1;
         space = aml_hw_mixer_get_space(mixer);
         if (space < bytes) {
             pthread_mutex_unlock(&mixer->lock);
+            mutexed = 0;
             usleep(10 * 1000);
-        } else
+        } else {
             break;
+        }
     }
 
+    if (mutexed == 0) {
+        pthread_mutex_lock(&mixer->lock);
+    }
     if (retry < 0) {
-        ALOGE("%s: write data no space,space %d,bytes %zu,rp %d,wp %d, reset all ptr",
-            __func__, space, bytes, mixer->rp, mixer->wp);
+        ALOGE("%s: write data no space, bytes %zu,rp %d,wp %d, reset all ptr",
+            __func__, bytes, mixer->rp, mixer->wp);
         mixer->wp = 0;
         mixer->rp = 0;
         pthread_mutex_unlock(&mixer->lock);
@@ -164,9 +170,6 @@ int aml_hw_mixer_mixing(struct aml_hw_mixer *mixer, void *buffer, int bytes, aud
     int32_t i, tail;
     int32_t cached_bytes, read_bytes = bytes;
 
-    if (getprop_bool("media.audiohal.mixer"))
-        aml_audio_dump_audio_bitstreams("/data/audio/beforemix.raw", buffer, bytes);
-
     pthread_mutex_lock(&mixer->lock);
     cached_bytes = aml_hw_mixer_get_content_l(mixer);
     if (cached_bytes < bytes) {
@@ -230,9 +233,6 @@ int aml_hw_mixer_mixing(struct aml_hw_mixer *mixer, void *buffer, int bytes, aud
     }
     pthread_mutex_unlock(&mixer->lock);
 
-    if (getprop_bool("media.audiohal.mixer"))
-        aml_audio_dump_audio_bitstreams("/data/audio/mixed.raw", buffer, bytes);
-
     return 0;
 }
 
diff --git a/audio_hal/aml_mmap_audio.c b/audio_hal/aml_mmap_audio.c
new file mode 100644
index 0000000..03da2bc
--- /dev/null
+++ b/audio_hal/aml_mmap_audio.c
@@ -0,0 +1,382 @@
+/*
+ * Copyright (C) 2019 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "aml_mmap_audio"
+#define __USE_GNU
+
+#include <sys/mman.h>
+#include <sys/prctl.h>
+#include <stdlib.h>
+#include <cutils/log.h>
+
+#include "audio_virtual_buf.h"
+#include "audio_hw.h"
+#include "aml_android_utils.h"
+#include "aml_volume_utils.h"
+#include "audio_hw_utils.h"
+#include "aml_mmap_audio.h"
+#include "audio_hw_ms12.h"
+#include "aml_audio_timer.h"
+
+
+#define MMAP_FRAME_SIZE_BYTE            (4)
+#define MMAP_SAMPLE_RATE_HZ             (48000)
+
+#define MMAP_BUFFER_SIZE_BYTE           (MMAP_SAMPLE_RATE_HZ * MMAP_FRAME_SIZE_BYTE * 32 / 1000)
+#define MMAP_WRITE_SIZE_BYTE            (MMAP_SAMPLE_RATE_HZ * MMAP_FRAME_SIZE_BYTE * 8 / 1000)  // every time to write 8ms data
+#define MMAP_WRITE_SIZE_FRAME           (MMAP_WRITE_SIZE_BYTE / MMAP_FRAME_SIZE_BYTE)
+#define MMAP_SAMPLE_RATE_HZ             (48000)
+#define MMAP_WRITE_PERIOD_TIME_NANO     (MMAP_WRITE_SIZE_FRAME * 1000000000LL / MMAP_SAMPLE_RATE_HZ)
+
+enum {
+    MMAP_INIT,
+    MMAP_START,
+    MMAP_START_DONE,
+    MMAP_STOP,
+    MMAP_STOP_DONE
+};
+
+static FILE *fp1 = NULL;
+
+
+static void check_audio_level(const void *buffer, size_t bytes) {
+    int num_frame = bytes/4;
+    int i = 0;
+    short *p = (short *)buffer;
+    int silence = 0;
+    int silence_cnt = 0;
+    int max = 0;
+    int min = 0;
+    int max_pos = 0;
+
+    min = max = *p;
+    for (int i=0; i<num_frame;i++) {
+        if (max < *(p+2*i)) {
+            max = *(p+2*i);
+            max_pos = i;
+        }
+        if (min > *(p+2*i)) {
+            min = *(p+2*i);
+        }
+        if (*(p+2*i) == 0) {
+             silence_cnt ++;
+        }
+    }
+    if (max < 10) {
+        silence = 1;
+    }
+    ALOGI("mmap data detect min=%d max=%d silence=%d silence_cnt=%d pos=%d", min, max, silence, silence_cnt, max_pos);
+}
+
+static void *outMmapThread(void *pArg) {
+    struct aml_stream_out       *out = (struct aml_stream_out *) pArg;
+    aml_mmap_audio_param_st     *pstParam = (aml_mmap_audio_param_st *)out->pstMmapAudioParam;
+    struct audio_virtual_buf    *pstVirtualBuffer = NULL;
+    unsigned char               *pu8CurReadAddr = pstParam->pu8MmapAddr;
+    unsigned char               *pu8StartAddr = pstParam->pu8MmapAddr;
+    unsigned char               *pu8TempBufferAddr = NULL;
+    aml_mmap_thread_param_st    *pstThread = &pstParam->stThreadParam;
+    struct timespec timestamp;
+    cpu_set_t cpuSet;
+
+    ALOGI("[%s:%d] enter threadloop bExitThread:%d, bStopPlay:%d, mmap addr:%p, out:%p", __func__, __LINE__,
+        pstThread->bExitThread, pstThread->bStopPlay, pu8StartAddr, out);
+    if (NULL == pu8StartAddr) {
+        ALOGE("[%s:%d] pu8MmapAddr is null", __func__, __LINE__);
+        return NULL;
+    }
+    prctl(PR_SET_NAME, (unsigned long)"outMmapThread");
+    aml_set_thread_priority("outMmapThread", pstThread->threadId);
+
+    CPU_ZERO(&cpuSet);
+    CPU_SET(2, &cpuSet);
+    CPU_SET(3, &cpuSet);
+    int status = sched_setaffinity(0, sizeof(cpu_set_t), &cpuSet);
+    if (status) {
+        ALOGW("%s(), failed to set cpu affinity", __FUNCTION__);
+    }
+
+    pu8TempBufferAddr = (unsigned char *)malloc(MMAP_WRITE_SIZE_BYTE);
+    while (false == pstThread->bExitThread) {
+        if (false == pstThread->bStopPlay) {
+
+            if (pstThread->status == MMAP_START) {
+                ALOGI("MMAP status: start");
+                pu8CurReadAddr = pu8StartAddr;
+                pstParam->u32FramePosition = 0;
+                clock_gettime(CLOCK_MONOTONIC, &timestamp);
+                pstParam->time_nanoseconds = (long long)timestamp.tv_sec * 1000000000 + (long long)timestamp.tv_nsec;
+                pstThread->status = MMAP_START_DONE;
+            }
+
+            if (pstVirtualBuffer == NULL) {
+                audio_virtual_buf_open((void **)&pstVirtualBuffer, "aaudio mmap",
+                        MMAP_WRITE_PERIOD_TIME_NANO * 4, MMAP_WRITE_PERIOD_TIME_NANO * 4, 0);
+                audio_virtual_buf_process((void *)pstVirtualBuffer, MMAP_WRITE_PERIOD_TIME_NANO * 4);
+            }
+            unsigned int u32RemainSizeByte =  (MMAP_BUFFER_SIZE_BYTE + pu8StartAddr) - pu8CurReadAddr;
+            if (u32RemainSizeByte >= MMAP_WRITE_SIZE_BYTE) {
+
+                memcpy(pu8TempBufferAddr, pu8CurReadAddr, MMAP_WRITE_SIZE_BYTE);
+                memset(pu8CurReadAddr, 0, MMAP_WRITE_SIZE_BYTE);
+                pu8CurReadAddr += MMAP_WRITE_SIZE_BYTE;
+            } else {
+                memcpy(pu8TempBufferAddr, pu8CurReadAddr, u32RemainSizeByte);
+                memset(pu8CurReadAddr, 0, u32RemainSizeByte);
+
+                memcpy(pu8TempBufferAddr + u32RemainSizeByte, pu8StartAddr, MMAP_WRITE_SIZE_BYTE - u32RemainSizeByte);
+                memset(pu8StartAddr, 0, MMAP_WRITE_SIZE_BYTE - u32RemainSizeByte);
+                pu8CurReadAddr = pu8StartAddr + MMAP_WRITE_SIZE_BYTE - u32RemainSizeByte;
+            }
+            apply_volume(out->volume_l, pu8TempBufferAddr, 2, MMAP_WRITE_SIZE_BYTE);
+            //check_audio_level(pu8TempBufferAddr, MMAP_WRITE_SIZE_BYTE);
+            if (out->dev->useSubMix) {
+                out->stream.write(&out->stream, pu8TempBufferAddr, MMAP_WRITE_SIZE_BYTE);
+            } else {
+                out_write_new(&out->stream, pu8TempBufferAddr, MMAP_WRITE_SIZE_BYTE);
+            }
+            if (aml_getprop_bool("vendor.media.audiohal.outdump")) {
+                if (fp1) {
+                    fwrite(pu8TempBufferAddr, 1, MMAP_WRITE_SIZE_BYTE, fp1);
+                }
+            }
+            audio_virtual_buf_process((void *)pstVirtualBuffer, MMAP_WRITE_PERIOD_TIME_NANO);
+            if (out->dev->debug_flag >= 100) {
+                ALOGI("[%s:%d] CurReadAddr:%p, RemainSize:%d, FramePosition:%d offset=%d", __func__, __LINE__,
+                    pu8CurReadAddr, u32RemainSizeByte, pstParam->u32FramePosition, pstParam->u32FramePosition%(MMAP_BUFFER_SIZE_BYTE / MMAP_FRAME_SIZE_BYTE));
+            }
+            pstParam->u32FramePosition += MMAP_WRITE_SIZE_FRAME;
+            // Absolutet time must be used when get timestamp.
+            clock_gettime(CLOCK_MONOTONIC, &timestamp);
+            pstParam->time_nanoseconds = (long long)timestamp.tv_sec * 1000000000 + (long long)timestamp.tv_nsec;
+        } else {
+            struct timespec tv;
+            clock_gettime(CLOCK_MONOTONIC, &tv);
+            // The suspend time set to 30 sec, reduce cpu power consumption.
+            // And waitting time can be awakened by out_start func.
+            tv.tv_sec += 30;
+            pthread_mutex_lock(&pstThread->mutex);
+            pthread_cond_timedwait(&pstThread->cond, &pstThread->mutex, &tv);
+            pthread_mutex_unlock(&pstThread->mutex);
+        }
+    }
+
+    if (pstVirtualBuffer != NULL) {
+        audio_virtual_buf_close((void **)&pstVirtualBuffer);
+    }
+    free(pu8TempBufferAddr);
+    pu8TempBufferAddr = NULL;
+    ALOGI("[%s:%d]  exit threadloop, out:%p", __func__, __LINE__, out);
+    return NULL;
+}
+
+static int outMmapStart(const struct audio_stream_out *stream)
+{
+    ALOGI("[%s:%d] stream:%p", __func__, __LINE__, stream);
+    struct aml_stream_out       *out = (struct aml_stream_out *) stream;
+    aml_mmap_audio_param_st     *pstParam = (aml_mmap_audio_param_st *)out->pstMmapAudioParam;
+    if (0 == pstParam->stThreadParam.threadId) {
+        ALOGE("[%s:%d]  exit threadloop", __func__, __LINE__);
+        return -ENOSYS;
+    }
+    if (aml_getprop_bool("vendor.media.audiohal.outdump")) {
+        fp1 = fopen("/data/audio/pcm_mmap", "a+");
+    }
+    pstParam->u32FramePosition = 0;
+    pstParam->stThreadParam.bStopPlay = false;
+    pstParam->stThreadParam.status = MMAP_START;
+    //dolby_ms12_app_flush();
+    pthread_mutex_lock(&pstParam->stThreadParam.mutex);
+    pthread_cond_signal(&pstParam->stThreadParam.cond);
+    pthread_mutex_unlock(&pstParam->stThreadParam.mutex);
+    ALOGI("--[%s:%d] stream:%p", __func__, __LINE__, stream);
+    return 0;
+}
+
+static int outMmapStop(const struct audio_stream_out *stream)
+{
+    ALOGI("[%s:%d] stream:%p", __func__, __LINE__, stream);
+    struct aml_stream_out       *out = (struct aml_stream_out *) stream;
+    aml_mmap_audio_param_st     *pstParam = (aml_mmap_audio_param_st *)out->pstMmapAudioParam;
+    //dolby_ms12_app_flush();
+    if (aml_getprop_bool("vendor.media.audiohal.outdump")) {
+        if (fp1) {
+            fclose(fp1);
+            fp1 = NULL;
+        }
+    }
+    // suspend threadloop.
+    pstParam->stThreadParam.status = MMAP_STOP;
+    /*sleep some time, to make sure the read thread read all the data*/
+    aml_audio_sleep(8 * 1000);
+    pstParam->stThreadParam.bStopPlay = true;
+    pstParam->stThreadParam.status = MMAP_STOP_DONE;
+    memset(pstParam->pu8MmapAddr, 0, MMAP_BUFFER_SIZE_BYTE);
+    pstParam->u32FramePosition = 0;
+    ALOGI("[--%s:%d] stream:%p", __func__, __LINE__, stream);
+    return 0;
+}
+
+static int outMmapCreateBuffer(const struct audio_stream_out *stream,
+                                             int32_t min_size_frames,
+                                             struct audio_mmap_buffer_info *info)
+{
+    ALOGI("[%s:%d], stream:%p, min_size_frames:%d", __func__, __LINE__, stream, min_size_frames);
+    struct aml_stream_out       *out = (struct aml_stream_out *) stream;
+    aml_mmap_audio_param_st     *pstParam = (aml_mmap_audio_param_st *)out->pstMmapAudioParam;
+    int ret = 0;
+
+    if (NULL == pstParam) {
+        ALOGE("[%s:%d] uninitialized, can't create mmap buffer", __func__, __LINE__);
+        return -1;
+    }
+
+    info->shared_memory_address = pstParam->pu8MmapAddr;
+    info->shared_memory_fd = pstParam->s32IonShareFd;
+    info->buffer_size_frames = MMAP_BUFFER_SIZE_BYTE / MMAP_FRAME_SIZE_BYTE;
+    info->burst_size_frames = 384;
+
+    aml_mmap_thread_param_st *pstThread = &pstParam->stThreadParam;
+    if (pstThread->threadId != 0) {
+        ALOGW("[%s:%d] mmap thread already exist, recreate thread", __func__, __LINE__);
+        pstThread->bExitThread = true;
+        pstThread->bStopPlay = true;
+        pthread_mutex_lock(&pstThread->mutex);
+        pthread_cond_signal(&pstThread->cond);
+        pthread_mutex_unlock(&pstThread->mutex);
+        pthread_join(pstThread->threadId, NULL);
+        memset(pstThread, 0, sizeof(aml_mmap_thread_param_st));
+    } else {
+        pthread_mutex_init (&pstThread->mutex, NULL);
+    }
+    pthread_condattr_init(&pstThread->condAttr);
+    pthread_condattr_setclock(&pstThread->condAttr, CLOCK_MONOTONIC);
+    pthread_cond_init(&pstThread->cond, &pstThread->condAttr);
+    pstThread->bExitThread = false;
+    pstThread->bStopPlay = true;
+    pstThread->status = MMAP_INIT;
+    ret = pthread_create(&pstThread->threadId, NULL, &outMmapThread, out);
+    if (ret != 0) {
+        ALOGE("[%s:%d], Create thread fail!\n", __func__, __LINE__);
+        return -1;
+    }
+    ALOGI("[%s:%d], mmap_fd:%d, mmap address:%p", __func__, __LINE__, info->shared_memory_fd, pstParam->pu8MmapAddr);
+    return 0;
+}
+
+static int outMmapGetPosition(const struct audio_stream_out *stream,
+                                           struct audio_mmap_position *position)
+{
+    struct aml_stream_out       *out = (struct aml_stream_out *) stream;
+    aml_mmap_audio_param_st     *pstParam = (aml_mmap_audio_param_st *)out->pstMmapAudioParam;
+    struct timespec timestamp;
+    int64_t  curr_nanoseconds = 0;
+    int64_t  time_diff = 0;
+    int drift_frames = 0;
+
+    // Absolutet time must be used when get timestamp.
+    clock_gettime(CLOCK_MONOTONIC, &timestamp);
+    curr_nanoseconds = (long long)timestamp.tv_sec * 1000000000 + (long long)timestamp.tv_nsec;
+    time_diff = curr_nanoseconds - pstParam->time_nanoseconds;
+
+    if (time_diff <= 8*1000000) {
+        drift_frames = (time_diff / 1000000) * (48);
+        ALOGV("normal time diff=%lld drift_frames=%d", time_diff, drift_frames);
+    } else {
+        ALOGI("big time diff =%lld", time_diff);
+        time_diff = 0;
+        drift_frames = 0;
+    }
+
+    position->time_nanoseconds = pstParam->time_nanoseconds + time_diff;
+    position->position_frames = pstParam->u32FramePosition + drift_frames;
+
+    if (out->dev->debug_flag >= 100) {
+        ALOGD("[%s:%d] stream:%p, position_frames:%d, nano:%lld",__func__, __LINE__, stream,
+            position->position_frames, (long long)position->time_nanoseconds);
+    }
+    return 0;
+}
+
+int outMmapInit(struct aml_stream_out *out)
+{
+   ALOGI("[%s:%d] stream:%p", __func__, __LINE__, out);
+   aml_mmap_audio_param_st     *pstParam = NULL;
+   int ret = 0;
+   out->stream.start = outMmapStart;
+   out->stream.stop = outMmapStop;
+   out->stream.create_mmap_buffer = outMmapCreateBuffer;
+   out->stream.get_mmap_position = outMmapGetPosition;
+
+   if (out->pstMmapAudioParam) {
+       ALOGW("[%s:%d] already init, can't again init", __func__, __LINE__);
+       return 0;
+   }
+   out->pstMmapAudioParam = (aml_mmap_audio_param_st *)malloc(sizeof(aml_mmap_audio_param_st));
+   pstParam = out->pstMmapAudioParam;
+   if (pstParam == NULL) {
+       ALOGW("[%s:%d] mmap audio param memory malloc fail", __func__, __LINE__);
+       return -1;
+   }
+   memset(pstParam, 0, sizeof(aml_mmap_audio_param_st));
+
+   pstParam->s32IonFd = ion_open();
+   if (pstParam->s32IonFd < 0) {
+       ALOGE("[%s:%d] ion_open fail ret:%#x", __func__, __LINE__, ret);
+       return -1;
+   }
+   ret = ion_alloc(pstParam->s32IonFd, MMAP_BUFFER_SIZE_BYTE, 32, ION_HEAP_SYSTEM_MASK, 0,
+                    &pstParam->hIonHanndle);
+   if (ret < 0) {
+       ALOGE("[%s:%d] ion_alloc fail ret:%#x", __func__, __LINE__, ret);
+       return -1;
+   }
+   ret = ion_share(pstParam->s32IonFd, pstParam->hIonHanndle, &pstParam->s32IonShareFd);
+   if (ret < 0) {
+       ALOGE("[%s:%d] ion_share fail ret:%#x", __func__, __LINE__, ret);
+       return -1;
+   }
+
+   pstParam->pu8MmapAddr = mmap(NULL, MMAP_BUFFER_SIZE_BYTE,  PROT_WRITE | PROT_READ,
+                                   MAP_SHARED, pstParam->s32IonShareFd, 0);
+   return 0;
+}
+
+int outMmapDeInit(struct aml_stream_out *out)
+{
+    ALOGI("[%s:%d] stream:%p", __func__, __LINE__, out);
+    aml_mmap_audio_param_st     *pstParam = (aml_mmap_audio_param_st *)out->pstMmapAudioParam;
+    if (NULL == pstParam) {
+       ALOGW("[%s:%d]  uninitialized, can't deinit", __func__, __LINE__);
+       return 0;
+    }
+
+    pstParam->stThreadParam.bExitThread = true;
+    pthread_mutex_lock(&pstParam->stThreadParam.mutex);
+    pthread_cond_signal(&pstParam->stThreadParam.cond);
+    pthread_mutex_unlock(&pstParam->stThreadParam.mutex);
+    if (pstParam->stThreadParam.threadId != 0) {
+       pthread_join(pstParam->stThreadParam.threadId, NULL);
+    }
+
+    munmap(pstParam->pu8MmapAddr, MMAP_BUFFER_SIZE_BYTE);
+    ion_free(pstParam->s32IonFd, pstParam->hIonHanndle);
+    ion_close(pstParam->s32IonFd);
+    free(pstParam);
+    out->pstMmapAudioParam = NULL;
+    return 0;
+}
+
diff --git a/audio_hal/aml_mmap_audio.h b/audio_hal/aml_mmap_audio.h
new file mode 100644
index 0000000..8ce48b6
--- /dev/null
+++ b/audio_hal/aml_mmap_audio.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2019 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AML_MMAP_AUDIO_H_
+#define _AML_MMAP_AUDIO_H_
+
+#include <ion/ion.h>
+
+typedef struct AML_MMAP_THREAD_PARAM {
+    pthread_t               threadId;
+    bool                    bExitThread;
+    bool                    bStopPlay;
+    int                     status;
+    pthread_condattr_t      condAttr;
+    pthread_mutex_t         mutex;
+    pthread_cond_t          cond;
+} aml_mmap_thread_param_st;
+
+typedef struct AML_MMAP_AUDIO_PARAM {
+    unsigned char               *pu8MmapAddr;
+    ion_user_handle_t           hIonHanndle;
+    int                         s32IonFd;
+    int                         s32IonShareFd;
+    unsigned int                u32FramePosition;
+    int64_t                     time_nanoseconds;
+    aml_mmap_thread_param_st    stThreadParam;
+} aml_mmap_audio_param_st;
+
+
+
+int outMmapInit(struct aml_stream_out *out);
+int outMmapDeInit(struct aml_stream_out *out);
+
+#endif
diff --git a/audio_hal/aml_resample_wrap.cpp b/audio_hal/aml_resample_wrap.cpp
index 13ccb88..23f68e0 100755
--- a/audio_hal/aml_resample_wrap.cpp
+++ b/audio_hal/aml_resample_wrap.cpp
@@ -44,6 +44,7 @@ class Provider: public AudioBufferProvider
 public:
     Provider(size_t frameSize, read_func read, void *handle)
     : mFrameSize(frameSize),
+    mWorkBufSize(0),
     mRead(read),
     mHandle(handle) {
         mWorkBuf = (unsigned char*)malloc (8192);
@@ -58,7 +59,6 @@ public:
         size_t byte_read;
         size_t requestedFrames = buffer->frameCount;
         size_t input_size = requestedFrames * mFrameSize;
-
         if (input_size > mWorkBufSize) {
             mWorkBuf = (unsigned char *)realloc(mWorkBuf, input_size);
             if (!mWorkBuf) {
@@ -81,7 +81,6 @@ public:
         }
 
         buffer->raw = (char *)mWorkBuf;
-
         return NO_ERROR;
     }
     virtual void releaseBuffer(Buffer* buffer) {
diff --git a/audio_hal/audio_a2dp_hw.c b/audio_hal/audio_a2dp_hw.c
new file mode 100644
index 0000000..d611da8
--- /dev/null
+++ b/audio_hal/audio_a2dp_hw.c
@@ -0,0 +1,1528 @@
+/**************************************************************************
+ *
+ *  Copyright 2009-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ **************************************************************************/
+
+/**************************************************************************
+ *
+ *  Filename:      audio_a2dp_hw.c
+ *
+ *  Description:   Implements hal for bluedroid a2dp audio device
+ *
+ **************************************************************************/
+
+#define LOG_TAG "audio_a2dp_hw"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdint.h>
+#include <sys/errno.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/un.h>
+#include <unistd.h>
+
+#include <hardware/audio.h>
+#include <hardware/hardware.h>
+#include <system/audio.h>
+#if defined(AUDIO_EFFECT_EXTERN_DEVICE)
+#include <cutils/str_parms.h>
+#endif
+#include <cutils/properties.h>
+#include <cutils/log.h>
+#include <cutils/str_parms.h>
+
+#include "audio_hw.h"
+#include "audio_hw_utils.h"
+#include "audio_a2dp_hw.h"
+//#include "alsa_manager.h"
+#include <aml_android_utils.h>
+#include "audio_virtual_buf.h"
+#include "dolby_lib_api.h"
+#include "aml_audio_timer.h"
+
+/*************************************************************************
+ *  Constants & Macros
+ *************************************************************************/
+
+#define CTRL_CHAN_RETRY_COUNT 3
+#define USEC_PER_SEC 1000000L
+#define SOCK_SEND_TIMEOUT_MS 2000 /* Timeout for sending */
+#define SOCK_RECV_TIMEOUT_MS 5000 /* Timeout for receiving */
+#define SEC_TO_MS 1000
+#define SEC_TO_NS 1000000000
+#define MS_TO_NS 1000000
+#define MIN_DELAY_NS (100*MS_TO_NS)
+#define MAX_DELAY_NS (1000*MS_TO_NS)
+#define DELAY_TO_NS 100000
+#define VIR_BUFF_NS (80*MS_TO_NS)
+
+/* set WRITE_POLL_MS to 0 for blocking sockets,
+ * nonzero for polled non-blocking sockets
+ */
+#define WRITE_POLL_MS 3
+
+#define UNUSED_ATTR __attribute__((unused))
+
+// Re-run |fn| system call until the system call doesn't cause EINTR.
+#define OSI_NO_INTR(fn) \
+  do {                  \
+  } while ((fn) == -1 && errno == EINTR)
+
+uint64_t total_input_ns = 0;
+
+static void a2dp_open_ctrl_path(struct a2dp_stream_out* out);
+
+#define CASE_RETURN_STR(const) \
+    case const:                  \
+        return #const;
+
+const char* audio_a2dp_hw_dump_ctrl_event(tA2DP_CTRL_CMD event) {
+    switch (event) {
+        CASE_RETURN_STR(A2DP_CTRL_CMD_NONE)
+        CASE_RETURN_STR(A2DP_CTRL_CMD_CHECK_READY)
+        CASE_RETURN_STR(A2DP_CTRL_CMD_START)
+        CASE_RETURN_STR(A2DP_CTRL_CMD_STOP)
+        CASE_RETURN_STR(A2DP_CTRL_CMD_SUSPEND)
+        CASE_RETURN_STR(A2DP_CTRL_GET_INPUT_AUDIO_CONFIG)
+        CASE_RETURN_STR(A2DP_CTRL_GET_OUTPUT_AUDIO_CONFIG)
+        CASE_RETURN_STR(A2DP_CTRL_SET_OUTPUT_AUDIO_CONFIG)
+        CASE_RETURN_STR(A2DP_CTRL_CMD_OFFLOAD_START)
+        CASE_RETURN_STR(A2DP_CTRL_GET_PRESENTATION_POSITION)
+    }
+    return "UNKNOWN A2DP_CTRL_CMD";
+}
+
+static int calc_audiotime_usec(int bytes, unsigned int rate,
+        audio_channel_mask_t channel_mask, audio_format_t format) {
+    int chan_count = audio_channel_count_from_out_mask(channel_mask);
+    int bytes_per_sample;
+
+    if (chan_count == 0) {
+        chan_count = 2;
+    }
+    switch (format) {
+        case AUDIO_FORMAT_PCM_8_BIT:
+            bytes_per_sample = 1;
+            break;
+        case AUDIO_FORMAT_PCM_16_BIT:
+            bytes_per_sample = 2;
+            break;
+        case AUDIO_FORMAT_PCM_24_BIT_PACKED:
+            bytes_per_sample = 3;
+            break;
+        case AUDIO_FORMAT_PCM_8_24_BIT:
+            bytes_per_sample = 4;
+            break;
+        case AUDIO_FORMAT_PCM_32_BIT:
+            bytes_per_sample = 4;
+            break;
+        default:
+            ALOGE("unsupported sample format %d", format);
+            bytes_per_sample = 2;
+            break;
+        }
+    return (int)(((int64_t)bytes * (USEC_PER_SEC / (chan_count * bytes_per_sample))) / rate);
+}
+
+
+/**
+ * connect to peer named "name" on fd
+ * returns same fd or -1 on error.
+ * fd is not closed on error. that's your job.
+ *
+ * Used by AndroidSocketImpl
+ */
+int osi_socket_local_client_connect(int fd, const char* name) {
+    struct sockaddr_un addr;
+    socklen_t alen;
+    int err;
+    size_t namelen = strlen(name);
+
+    memset(&addr, 0, sizeof(struct sockaddr_un));
+    if ((namelen + 1) > sizeof(addr.sun_path)) {
+        return -1;
+    }
+    addr.sun_path[0] = 0;
+    memcpy(addr.sun_path + 1, name, namelen);
+    addr.sun_family = AF_LOCAL;
+    alen = namelen + offsetof(struct sockaddr_un, sun_path) + 1;
+
+    OSI_NO_INTR(err = connect(fd, (struct sockaddr*)&addr, alen));
+    if (err < 0) {
+        return -1;
+    }
+    return fd;
+}
+
+/*****************************************************************************
+ *
+ *   bluedroid stack adaptation
+ *
+ ****************************************************************************/
+static int skt_connect(const char* path, size_t buffer_sz) {
+    int ret;
+    int skt_fd;
+    int len;
+
+    ALOGD("connect to %s (sz %zu)", path, buffer_sz);
+    skt_fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+    if (skt_fd < 0) {
+        return -1;
+    }
+    if (osi_socket_local_client_connect(skt_fd, path) < 0) {
+        ALOGE("failed to connect (%s)", strerror(errno));
+        close(skt_fd);
+        return -1;
+    }
+
+    len = buffer_sz;
+    ret = setsockopt(skt_fd, SOL_SOCKET, SO_SNDBUF, (char*)&len, (int)sizeof(len));
+    if (ret < 0)
+        ALOGE("setsockopt failed (%s)", strerror(errno));
+
+    ret = setsockopt(skt_fd, SOL_SOCKET, SO_RCVBUF, (char*)&len, (int)sizeof(len));
+    if (ret < 0)
+        ALOGE("setsockopt failed (%s)", strerror(errno));
+
+    /* Socket send/receive timeout value */
+    struct timeval tv;
+    tv.tv_sec = SOCK_SEND_TIMEOUT_MS / 1000;
+    tv.tv_usec = (SOCK_SEND_TIMEOUT_MS % 1000) * 1000;
+    ret = setsockopt(skt_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
+    if (ret < 0)
+        ALOGE("setsockopt failed (%s)", strerror(errno));
+
+    tv.tv_sec = SOCK_RECV_TIMEOUT_MS / 1000;
+    tv.tv_usec = (SOCK_RECV_TIMEOUT_MS % 1000) * 1000;
+    ret = setsockopt(skt_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
+    if (ret < 0)
+        ALOGE("setsockopt failed (%s)", strerror(errno));
+
+    ALOGD("connected to stack fd = %d", skt_fd);
+    return skt_fd;
+}
+
+static int skt_disconnect(int fd) {
+    ALOGD("skt_disconnect fd %d", fd);
+    if (fd != AUDIO_SKT_DISCONNECTED) {
+        shutdown(fd, SHUT_RDWR);
+        close(fd);
+    }
+    return 0;
+}
+
+static int skt_write(struct audio_stream_out* stream, int fd, const void* p, size_t len) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    struct aml_audio_device *aml_dev = aml_out->dev;
+    ssize_t sent;
+
+    if (WRITE_POLL_MS == 0) {
+        // do not poll, use blocking send
+        OSI_NO_INTR(sent = send(fd, p, len, MSG_NOSIGNAL));
+        if (sent == -1)
+            ALOGE("write failed with error(%s)", strerror(errno));
+        return (int)sent;
+    }
+
+    // use non-blocking send, poll
+    int ms_timeout = SOCK_SEND_TIMEOUT_MS;
+    size_t count = 0;
+    while (count < len) {
+        OSI_NO_INTR(sent = send(fd, p, len - count, MSG_NOSIGNAL | MSG_DONTWAIT));
+        if (sent == -1) {
+            if (errno != EAGAIN && errno != EWOULDBLOCK) {
+                ALOGE("write failed with error(%s)", strerror(errno));
+                return -1;
+            }
+            if (ms_timeout >= WRITE_POLL_MS) {
+                usleep(WRITE_POLL_MS * 1000);
+                ms_timeout -= WRITE_POLL_MS;
+                continue;
+            }
+            ALOGW("write timeout exceeded, sent %zu bytes", count);
+            return -1;
+        }
+        count += sent;
+        p = (const uint8_t*)p + sent;
+    }
+    if ((aml_dev->is_TV) && (count != 0)) {
+        uint64_t input_ns = 0;
+        size_t frame_size;
+        static uint64_t begin_ns = 0;
+        uint64_t process_ns = 0;
+        int mutex_lock_success = 0;
+
+        /*if (pthread_mutex_unlock(&aml_dev->alsa_pcm_lock) == 0) {
+            mutex_lock_success = 1;
+        }*/
+        if (out->is_stereo_to_mono)
+            frame_size = 2; // mono pcm 16bit
+        else
+            frame_size = 4; // stereo pcm 16bit
+        input_ns = (uint64_t)(count) * 1000000000LL / frame_size / out->rate;
+#if 0
+        if (aml_dev->debug_flag) {
+            if (total_input_ns == 0)
+                begin_ns = aml_audio_get_systime_ns();
+            process_ns = aml_audio_get_systime_ns() - begin_ns;
+            ALOGD("skt_write: process_ns %lld input_ns %lld, diff: %ldms (%ld)",
+                process_ns, total_input_ns, (long)((total_input_ns- process_ns)/1000000),
+                (long)(total_input_ns- process_ns));
+            total_input_ns += input_ns;
+        }
+#endif
+        if (out->vir_buf_handle == NULL) {
+            audio_virtual_buf_open(&out->vir_buf_handle, "a2dp", VIR_BUFF_NS, VIR_BUFF_NS, 0);
+            audio_virtual_buf_process(out->vir_buf_handle, VIR_BUFF_NS - input_ns/2);
+        }
+        audio_virtual_buf_process(out->vir_buf_handle, input_ns);
+        /*if (mutex_lock_success) {
+            pthread_mutex_lock(&aml_dev->alsa_pcm_lock);
+        }*/
+    }
+
+    return (int)count;
+}
+
+static int a2dp_ctrl_receive(struct a2dp_stream_out* out, void* buffer, size_t length) {
+    ssize_t ret;
+    int i;
+
+    for (i = 0;; i++) {
+        OSI_NO_INTR(ret = recv(out->ctrl_fd, buffer, length, MSG_NOSIGNAL));
+        if (ret > 0)
+            break;
+        if (ret == 0) {
+            ALOGE("receive control data failed: peer closed");
+            break;
+        }
+        if (errno != EWOULDBLOCK && errno != EAGAIN) {
+            ALOGE("receive control data failed: error(%s)", strerror(errno));
+            break;
+        }
+        if (i == (CTRL_CHAN_RETRY_COUNT - 1)) {
+            ALOGE("receive control data failed: max retry count");
+            break;
+        }
+        ALOGD("receive control data failed (%s), retrying", strerror(errno));
+    }
+    if (ret <= 0) {
+        skt_disconnect(out->ctrl_fd);
+        out->ctrl_fd = AUDIO_SKT_DISCONNECTED;
+    }
+    return ret;
+}
+
+/* Sends control info for stream |out|. The data to send is stored in
+ * |buffer| and has size |length|.
+ * On success, returns the number of octets sent, otherwise -1.
+ */
+static int a2dp_ctrl_send(struct a2dp_stream_out* out, const void* buffer, size_t length) {
+    ssize_t sent;
+    size_t remaining = length;
+    int i;
+
+    if (length == 0)
+        return 0;  // Nothing to do
+
+    for (i = 0;; i++) {
+        OSI_NO_INTR(sent = send(out->ctrl_fd, buffer, remaining, MSG_NOSIGNAL));
+        if (sent == (ssize_t)(remaining)) {
+            remaining = 0;
+            break;
+        }
+        if (sent > 0) {
+            buffer = ((const char*)(buffer) + sent);
+            remaining -= sent;
+            continue;
+        }
+        if (sent < 0) {
+            if (errno != EWOULDBLOCK && errno != EAGAIN) {
+                ALOGE("send control data failed: error(%s)", strerror(errno));
+                break;
+            }
+            ALOGD("send control data failed (%s), retrying", strerror(errno));
+        }
+        if (i >= (CTRL_CHAN_RETRY_COUNT - 1)) {
+            ALOGE("send control data failed: max retry count");
+            break;
+        }
+    }
+    if (remaining > 0) {
+        skt_disconnect(out->ctrl_fd);
+        out->ctrl_fd = AUDIO_SKT_DISCONNECTED;
+        return -1;
+    }
+    return length;
+}
+
+static int a2dp_command(struct a2dp_stream_out* out, tA2DP_CTRL_CMD cmd) {
+    char ack;
+
+    if (out->ctrl_fd == AUDIO_SKT_DISCONNECTED) {
+        ALOGD("starting up or recovering from previous error: command=%s",
+                audio_a2dp_hw_dump_ctrl_event(cmd));
+        a2dp_open_ctrl_path(out);
+        if (out->ctrl_fd == AUDIO_SKT_DISCONNECTED) {
+            ALOGE("failure to open ctrl path: command=%s",
+            audio_a2dp_hw_dump_ctrl_event(cmd));
+            return -1;
+        }
+    }
+
+    /* send command */
+    ssize_t sent;
+    char command =(char)cmd;
+    OSI_NO_INTR(sent = send(out->ctrl_fd, &command, 1, MSG_NOSIGNAL));
+    if (sent == -1) {
+        ALOGE("cmd failed (%s): command=%s", strerror(errno),
+                audio_a2dp_hw_dump_ctrl_event(cmd));
+        skt_disconnect(out->ctrl_fd);
+        out->ctrl_fd = AUDIO_SKT_DISCONNECTED;
+        return -1;
+    }
+
+    /* wait for ack byte */
+    if (a2dp_ctrl_receive(out, &ack, 1) < 0) {
+        ALOGE("A2DP COMMAND %s: no ACK", audio_a2dp_hw_dump_ctrl_event(cmd));
+        return -1;
+    }
+
+    if (ack == A2DP_CTRL_ACK_INCALL_FAILURE) {
+        ALOGE("A2DP COMMAND %s error %d", audio_a2dp_hw_dump_ctrl_event(cmd), ack);
+        return ack;
+    }
+    if (ack != A2DP_CTRL_ACK_SUCCESS) {
+        ALOGE("A2DP COMMAND %s error %d", audio_a2dp_hw_dump_ctrl_event(cmd), ack);
+        return -1;
+    }
+    return A2DP_CTRL_ACK_SUCCESS;
+}
+
+static int check_a2dp_ready(struct a2dp_stream_out* out) {
+    if (a2dp_command(out, A2DP_CTRL_CMD_CHECK_READY) < 0) {
+        ALOGE("check a2dp ready failed");
+        return -1;
+    }
+    return 0;
+}
+
+static void a2dp_open_ctrl_path(struct a2dp_stream_out* out) {
+    int i;
+
+    if (out->ctrl_fd != AUDIO_SKT_DISCONNECTED)
+        return;  // already connected
+
+    /* retry logic to catch any timing variations on control channel */
+    for (i = 0; i < CTRL_CHAN_RETRY_COUNT; i++) {
+        /* connect control channel if not already connected */
+        if ((out->ctrl_fd = skt_connect(
+                A2DP_CTRL_PATH, AUDIO_STREAM_CONTROL_OUTPUT_BUFFER_SZ)) >= 0) {
+            /* success, now check if stack is ready */
+            if (check_a2dp_ready(out) == 0)
+                break;
+            ALOGE("error : a2dp not ready, wait 250 ms and retry");
+            usleep(250000);
+            skt_disconnect(out->ctrl_fd);
+            out->ctrl_fd = AUDIO_SKT_DISCONNECTED;
+        }
+        /* ctrl channel not ready, wait a bit */
+        usleep(250000);
+    }
+}
+
+size_t a2dp_hw_buffer_size(btav_a2dp_codec_config_t * config) {
+    size_t buffer_sz = AUDIO_STREAM_OUTPUT_BUFFER_SZ;  // Default value
+    const uint64_t time_period_ms = 40;                // Conservative 20ms
+    uint32_t sample_rate;
+    uint32_t bytes_per_sample;
+    uint32_t number_of_channels;
+
+    // Check the codec config sample rate
+    switch (config->sample_rate) {
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+            sample_rate = 44100;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+          sample_rate = 48000;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+            sample_rate = 88200;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+            sample_rate = 96000;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+            sample_rate = 176400;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+            sample_rate = 192000;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+        default:
+            ALOGE("Invalid sample rate: 0x%x", config->sample_rate);
+            return buffer_sz;
+    }
+
+    // Check the codec config bits per sample
+    switch (config->bits_per_sample) {
+        case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+            bytes_per_sample = 2;
+            break;
+        case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+            bytes_per_sample = 3;
+            break;
+        case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+            bytes_per_sample = 4;
+            break;
+        case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+        default:
+            ALOGE("Invalid bits per sample: 0x%x", config->bits_per_sample);
+            return buffer_sz;
+    }
+
+    // Check the codec config channel mode
+    switch (config->channel_mode) {
+        case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+            number_of_channels = 1;
+            break;
+        case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+            number_of_channels = 2;
+            break;
+        case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+        default:
+            ALOGE("Invalid channel mode: 0x%x", config->channel_mode);
+            return buffer_sz;
+    }
+
+    /*
+    * The buffer size is computed by using the following formula:
+    *
+    * AUDIO_STREAM_OUTPUT_BUFFER_SIZE =
+    *    (TIME_PERIOD_MS * AUDIO_STREAM_OUTPUT_BUFFER_PERIODS *
+    *     SAMPLE_RATE_HZ * NUMBER_OF_CHANNELS * (BITS_PER_SAMPLE / 8)) / 1000
+    *
+    * AUDIO_STREAM_OUTPUT_BUFFER_PERIODS controls how the socket buffer is
+    * divided for AudioFlinger data delivery. The AudioFlinger mixer delivers
+    * data in chunks of
+    * (AUDIO_STREAM_OUTPUT_BUFFER_SIZE / AUDIO_STREAM_OUTPUT_BUFFER_PERIODS) .
+    * If the number of periods is 2, the socket buffer represents "double
+    * buffering" of the AudioFlinger mixer buffer.
+    *
+    * Furthermore, the AudioFlinger expects the buffer size to be a multiple
+    * of 16 frames.
+    */
+    const size_t divisor = (AUDIO_STREAM_OUTPUT_BUFFER_PERIODS * 16 *
+                number_of_channels * bytes_per_sample);
+    buffer_sz = (time_period_ms * AUDIO_STREAM_OUTPUT_BUFFER_PERIODS *
+            sample_rate * number_of_channels * bytes_per_sample) / 1000;
+    // Adjust the buffer size so it can be divided by the divisor
+    const size_t remainder = buffer_sz % divisor;
+    if (remainder != 0) {
+        buffer_sz += divisor - remainder;
+    }
+    return buffer_sz;
+}
+
+static int a2dp_get_output_audio_config(
+        struct a2dp_stream_out* out,
+        btav_a2dp_codec_config_t* codec_config,
+        btav_a2dp_codec_config_t* codec_capability) {
+    if (a2dp_command(out, A2DP_CTRL_GET_OUTPUT_AUDIO_CONFIG) < 0) {
+        ALOGE("get a2dp output audio config failed");
+        return -1;
+    }
+
+    // Receive the current codec config
+    if (a2dp_ctrl_receive(out, &codec_config->sample_rate,
+            sizeof(btav_a2dp_codec_sample_rate_t)) < 0) {
+        return -1;
+    }
+    if (a2dp_ctrl_receive(out, &codec_config->bits_per_sample,
+            sizeof(btav_a2dp_codec_bits_per_sample_t)) < 0) {
+        return -1;
+    }
+    if (a2dp_ctrl_receive(out, &codec_config->channel_mode,
+            sizeof(btav_a2dp_codec_channel_mode_t)) < 0) {
+        return -1;
+    }
+
+    // Receive the current codec capability
+    if (a2dp_ctrl_receive(out, &codec_capability->sample_rate,
+            sizeof(btav_a2dp_codec_sample_rate_t)) < 0) {
+        return -1;
+    }
+    if (a2dp_ctrl_receive(out, &codec_capability->bits_per_sample,
+            sizeof(btav_a2dp_codec_bits_per_sample_t)) < 0) {
+        return -1;
+    }
+    if (a2dp_ctrl_receive(out, &codec_capability->channel_mode,
+            sizeof(btav_a2dp_codec_channel_mode_t)) < 0) {
+        return -1;
+    }
+    return 0;
+}
+
+static int a2dp_read_output_audio_config(struct audio_stream_out* stream) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    btav_a2dp_codec_config_t codec_config;
+    btav_a2dp_codec_config_t codec_capability;
+    bool is_stereo_to_mono;
+    unsigned int rate;
+    audio_format_t format;
+    audio_channel_mask_t channel_mask;
+
+    if (a2dp_get_output_audio_config(out, &codec_config, &codec_capability) < 0)
+        return -1;
+    // Check the codec config sample rate
+    switch (codec_config.sample_rate) {
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+            rate = 44100;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+            rate = 48000;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+            rate = 88200;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+            rate = 96000;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+            rate = 176400;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+            rate = 192000;
+            break;
+        case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+        default:
+            ALOGE("Invalid sample rate: 0x%x", codec_config.sample_rate);
+            return -1;
+    }
+
+    // Check the codec config bits per sample
+    switch (codec_config.bits_per_sample) {
+        case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+            format = AUDIO_FORMAT_PCM_16_BIT;
+            break;
+        case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+            format = AUDIO_FORMAT_PCM_24_BIT_PACKED;
+            break;
+        case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+            format = AUDIO_FORMAT_PCM_32_BIT;
+            break;
+        case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+        default:
+            ALOGE("Invalid bits per sample: 0x%x", codec_config.bits_per_sample);
+            return -1;
+    }
+
+    // Check the codec config channel mode
+    switch (codec_config.channel_mode) {
+        case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+            channel_mask = AUDIO_CHANNEL_OUT_MONO;
+            is_stereo_to_mono = true;
+            break;
+        case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+            channel_mask = AUDIO_CHANNEL_OUT_STEREO;
+            is_stereo_to_mono = false;
+            break;
+        case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+        default:
+            ALOGE("Invalid channel mode: 0x%x", codec_config.channel_mode);
+            return -1;
+    }
+    if (is_stereo_to_mono) {
+        channel_mask = AUDIO_CHANNEL_OUT_STEREO;
+    }
+
+    out->rate = rate;
+    out->is_stereo_to_mono = is_stereo_to_mono;
+    out->buffer_sz = a2dp_hw_buffer_size(&codec_config);
+    if (is_stereo_to_mono) {
+        // We need to fetch twice as much data from the Audio framework
+        out->buffer_sz *= 2;
+    }
+
+    ALOGD("got output codec config: sample_rate=0x%x bits_per_sample=0x%x channel_mode=0x%x",
+        codec_config.sample_rate, codec_config.bits_per_sample, codec_config.channel_mode);
+    ALOGD("got output codec capability: sample_rate=0x%x bits_per_sample=0x%x channel_mode=0x%x",
+        codec_capability.sample_rate, codec_capability.bits_per_sample, codec_capability.channel_mode);
+    return 0;
+}
+
+static int a2dp_write_output_audio_config(struct audio_stream_out* stream) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    btav_a2dp_codec_config_t config;
+
+    if (a2dp_command(out, A2DP_CTRL_SET_OUTPUT_AUDIO_CONFIG) < 0) {
+        ALOGE("set a2dp output audio config failed");
+        return -1;
+    }
+
+    switch (aml_out->hal_rate) {
+        case 44100:
+            config.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+            break;
+        case 48000:
+            config.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+            break;
+        case 88200:
+            config.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+            break;
+        case 96000:
+            config.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+            break;
+        case 176400:
+            config.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_176400;
+            break;
+        case 192000:
+            config.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+            break;
+        default:
+            ALOGE("Invalid sample rate: %" PRIu32, aml_out->hal_rate);
+            config.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+            //return -1;
+    }
+
+    switch (aml_out->hal_format) {
+        case AUDIO_FORMAT_PCM_16_BIT:
+            config.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+            break;
+        case AUDIO_FORMAT_PCM_24_BIT_PACKED:
+            config.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+            break;
+        case AUDIO_FORMAT_PCM_32_BIT:
+            config.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+            break;
+        case AUDIO_FORMAT_PCM_8_24_BIT:
+        // FALLTHROUGH
+        // All 24-bit audio is expected in AUDIO_FORMAT_PCM_24_BIT_PACKED format
+        default:
+            ALOGE("Invalid audio format: 0x%x", aml_out->hal_format);
+            config.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+            //return -1;
+    }
+
+    switch (aml_out->hal_channel_mask) {
+        case AUDIO_CHANNEL_OUT_MONO:
+            config.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
+            break;
+        case AUDIO_CHANNEL_OUT_STEREO:
+            if (out->is_stereo_to_mono) {
+                config.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
+            } else {
+                config.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+            }
+            break;
+        default:
+            ALOGE("Invalid channel mask: 0x%x", aml_out->hal_channel_mask);
+            config.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+            //return -1;
+    }
+
+    // Send the current codec config that has been selected by us
+    if (a2dp_ctrl_send(out, &config.sample_rate,
+            sizeof(btav_a2dp_codec_sample_rate_t)) < 0)
+        return -1;
+    if (a2dp_ctrl_send(out, &config.bits_per_sample,
+            sizeof(btav_a2dp_codec_bits_per_sample_t)) < 0)
+        return -1;
+    if (a2dp_ctrl_send(out, &config.channel_mode,
+            sizeof(btav_a2dp_codec_channel_mode_t)) < 0)
+        return -1;
+
+    ALOGD("sent output codec config: sample_rate=0x%x "
+        "bits_per_sample=0x%x channel_mode=0x%x",
+        config.sample_rate, config.bits_per_sample,
+        config.channel_mode);
+    return 0;
+}
+
+static int a2dp_get_presentation_position_cmd(struct a2dp_stream_out* out,
+        uint64_t* bytes, uint16_t* delay, struct timespec* timestamp) {
+    if ((out->ctrl_fd == AUDIO_SKT_DISCONNECTED) ||
+            (out->state != AUDIO_A2DP_STATE_STARTED))  // Audio is not streaming
+        return -1;
+    if (a2dp_command(out, A2DP_CTRL_GET_PRESENTATION_POSITION) < 0)
+        return -1;
+    if (a2dp_ctrl_receive(out, bytes, sizeof(*bytes)) < 0)
+        return -1;
+    if (a2dp_ctrl_receive(out, delay, sizeof(*delay)) < 0)
+        return -1;
+
+    uint32_t seconds;
+    if (a2dp_ctrl_receive(out, &seconds, sizeof(seconds)) < 0)
+        return -1;
+
+    uint32_t nsec;
+    if (a2dp_ctrl_receive(out, &nsec, sizeof(nsec)) < 0)
+        return -1;
+
+    timestamp->tv_sec = seconds;
+    timestamp->tv_nsec = nsec;
+    return 0;
+}
+
+static void a2dp_stream_common_init(struct a2dp_stream_out* out) {
+    out->ctrl_fd = AUDIO_SKT_DISCONNECTED;
+    out->audio_fd = AUDIO_SKT_DISCONNECTED;
+    out->state = AUDIO_A2DP_STATE_STOPPED;
+    /* manages max capacity of socket pipe */
+    out->buffer_sz = AUDIO_STREAM_OUTPUT_BUFFER_SZ;
+    out->rate = 44100;
+    out->vir_buf_handle = NULL;
+}
+
+static void a2dp_stream_common_destroy(struct a2dp_stream_out* out) {
+    if (out->ctrl_fd != AUDIO_SKT_DISCONNECTED) {
+        skt_disconnect(out->ctrl_fd);
+        out->ctrl_fd = AUDIO_SKT_DISCONNECTED;
+    }
+    if (out->audio_fd != AUDIO_SKT_DISCONNECTED) {
+        skt_disconnect(out->audio_fd);
+        out->audio_fd = AUDIO_SKT_DISCONNECTED;
+    }
+}
+
+static int start_audio_datapath(struct audio_stream_out* stream) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    struct aml_audio_device *adev = aml_out->dev;
+    int oldstate = out->state;
+
+    ALOGD("start_audio_datapath state %d (%p), flags=%x", out->state, aml_out, aml_out->flags);
+    out->state = AUDIO_A2DP_STATE_STARTING;
+    adev->debug_flag = aml_audio_get_debug_flag();
+
+    int a2dp_status = a2dp_command(out, A2DP_CTRL_CMD_START);
+    if (a2dp_status < 0) {
+        ALOGE("Audiopath start failed (status %d)", a2dp_status);
+        a2dp_command(out, A2DP_CTRL_CMD_SUSPEND);
+        goto error;
+    } else if (a2dp_status == A2DP_CTRL_ACK_INCALL_FAILURE) {
+        ALOGE("Audiopath start failed - in call, move to suspended");
+        goto error;
+    }
+
+    /* connect socket if not yet connected */
+    if (out->audio_fd == AUDIO_SKT_DISCONNECTED) {
+        out->audio_fd = skt_connect(A2DP_DATA_PATH, out->buffer_sz);
+        if (out->audio_fd < 0) {
+            ALOGE("Audiopath start failed - error opening data socket");
+            goto error;
+        }
+    }
+    out->state = (a2dp_state_t)AUDIO_A2DP_STATE_STARTED;
+    /* check to see if delay reporting is enabled */
+    out->enable_delay_reporting = !property_get_bool("persist.bluetooth.disabledelayreports", false);
+    if (aml_out->hal_rate != out->rate) {
+        out->aml_resample.input_sr = aml_out->hal_rate;
+        out->aml_resample.output_sr = out->rate;
+        out->aml_resample.channels = 2;
+        resampler_init(&out->aml_resample);
+    }
+    return 0;
+
+error:
+    out->state = (a2dp_state_t)oldstate;
+    return -1;
+}
+
+static int stop_audio_datapath(struct a2dp_stream_out* out) {
+    int oldstate = out->state;
+
+    ALOGD("stop_audio_datapath state %d (%p)", out->state, out);
+
+    /* prevent any stray output writes from autostarting the stream
+    * while stopping audiopath
+    */
+    out->state = AUDIO_A2DP_STATE_STOPPING;
+
+    if (a2dp_command(out, A2DP_CTRL_CMD_STOP) < 0) {
+        ALOGE("audiopath stop failed");
+        out->state = (a2dp_state_t)oldstate;
+        return -1;
+    }
+
+    out->state = (a2dp_state_t)AUDIO_A2DP_STATE_STOPPED;
+
+    /* disconnect audio path */
+    skt_disconnect(out->audio_fd);
+    out->audio_fd = AUDIO_SKT_DISCONNECTED;
+    return 0;
+}
+
+int suspend_audio_datapath(struct a2dp_stream_out* out, bool standby) {
+    ALOGD("suspend_audio_datapath state %d", out->state);
+    if (out->state == AUDIO_A2DP_STATE_STOPPING)
+        return -1;
+    if (a2dp_command(out, A2DP_CTRL_CMD_SUSPEND) < 0)
+        return -1;
+    if (standby)
+        out->state = AUDIO_A2DP_STATE_STANDBY;
+    else
+        out->state = AUDIO_A2DP_STATE_SUSPENDED;
+
+    /* disconnect audio path */
+    skt_disconnect(out->audio_fd);
+    out->audio_fd = AUDIO_SKT_DISCONNECTED;
+    return 0;
+}
+
+static size_t a2dp_out_get_buffer_size(const struct audio_stream* stream) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    // the AudioFlinger mixer buffer size.
+    return out->buffer_sz / AUDIO_STREAM_OUTPUT_BUFFER_PERIODS;
+}
+
+int a2dp_out_set_parameters(struct audio_stream* stream, const char* kvpairs) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    struct str_parms *parms;
+    char value[32];
+    int ret;
+
+    ALOGI("a2dp_out_set_parameters %s (%p)\n", kvpairs, aml_out);
+    parms = str_parms_create_str (kvpairs);
+    ret = str_parms_get_str (parms, "closing", value, sizeof (value) );
+    if (ret >= 0) {
+        pthread_mutex_lock(&out->mutex);
+        if (strncmp(value, "true", 4) == 0)
+            out->state = AUDIO_A2DP_STATE_STOPPING;
+        pthread_mutex_unlock(&out->mutex);
+    }
+    ret = str_parms_get_str (parms, "A2dpSuspended", value, sizeof (value) );
+    if (ret >= 0) {
+        pthread_mutex_lock(&out->mutex);
+        if (strncmp(value, "true", 4) == 0) {
+            if (out->state == AUDIO_A2DP_STATE_STARTED)
+                suspend_audio_datapath(out, false);
+        } else {
+            if (out->state == AUDIO_A2DP_STATE_SUSPENDED)
+                out->state = AUDIO_A2DP_STATE_STANDBY;
+        }
+        pthread_mutex_unlock(&out->mutex);
+    }
+    return 0;
+}
+static char* a2dp_out_get_parameters(const struct audio_stream* stream, const char* keys) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    char cap[1024];
+    int size = 0;
+    btav_a2dp_codec_config_t codec_config;
+    btav_a2dp_codec_config_t codec_capability;
+
+    ALOGI("a2dp_out_get_parameters %s,out %p\n", keys, aml_out);
+    if (a2dp_get_output_audio_config(out, &codec_config, &codec_capability) < 0) {
+        ALOGE("a2dp_out_get_parameters: keys=%s, a2dp_get_output_audio_config error", keys);
+        return strdup("");
+    }
+    memset(cap, 0, 1024);
+    if (strstr(keys, AUDIO_PARAMETER_STREAM_SUP_FORMATS)) {
+        bool first = true;
+        size += sprintf(cap + size, "%s=", AUDIO_PARAMETER_STREAM_SUP_FORMATS);
+        if (codec_capability.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+            /*if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else*/
+                first = false;
+            size += sprintf(cap + size, "%s", "AUDIO_FORMAT_PCM_16_BIT");
+        }
+        if (codec_capability.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+            if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else
+                first = false;
+            size += sprintf(cap + size, "%s", "AUDIO_FORMAT_PCM_24_BIT_PACKED");
+        }
+        if (codec_capability.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32) {
+            if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else
+                first = false;
+            size += sprintf(cap + size, "%s", "AUDIO_FORMAT_PCM_32_BIT");
+        }
+    }else if (strstr(keys, AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES)) {
+        bool first = true;
+        size += sprintf(cap + size, "%s=", AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES);
+        if (codec_capability.sample_rate & BTAV_A2DP_CODEC_SAMPLE_RATE_44100) {
+            /*if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else*/
+                first = false;
+            size += sprintf(cap + size, "%s", "44100");
+        }
+        if (codec_capability.sample_rate & BTAV_A2DP_CODEC_SAMPLE_RATE_48000) {
+            if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else
+                first = false;
+            size += sprintf(cap + size, "%s", "48000");
+        }
+        if (codec_capability.sample_rate & BTAV_A2DP_CODEC_SAMPLE_RATE_88200) {
+            if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else
+                first = false;
+            size += sprintf(cap + size, "%s", "88200");
+        }
+        if (codec_capability.sample_rate & BTAV_A2DP_CODEC_SAMPLE_RATE_96000) {
+            if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else
+                first = false;
+            size += sprintf(cap + size, "%s", "96000");
+        }
+        if (codec_capability.sample_rate & BTAV_A2DP_CODEC_SAMPLE_RATE_176400) {
+            if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else
+                first = false;
+            size += sprintf(cap + size, "%s", "176400");
+        }
+        if (codec_capability.sample_rate & BTAV_A2DP_CODEC_SAMPLE_RATE_192000) {
+            if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else
+                first = false;
+            size += sprintf(cap + size, "%s", "192000");
+        }
+    } else if (strstr(keys, AUDIO_PARAMETER_STREAM_SUP_CHANNELS)) {
+        bool first = true;
+        size += sprintf(cap + size, "%s=", AUDIO_PARAMETER_STREAM_SUP_CHANNELS);
+        if (codec_capability.channel_mode & BTAV_A2DP_CODEC_CHANNEL_MODE_MONO) {
+            /*if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else*/
+                first = false;
+            size += sprintf(cap + size, "%s", "AUDIO_CHANNEL_OUT_MONO");
+        }
+        if (codec_capability.channel_mode & BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO) {
+            if (!first)
+                size += sprintf(cap + size, "%s", "|");
+            else
+                first = false;
+            size += sprintf(cap + size, "%s", "AUDIO_CHANNEL_OUT_STEREO");
+        }
+    }
+    return strdup(cap);
+}
+
+uint32_t a2dp_out_get_latency(const struct audio_stream_out* stream) {
+    (void *)stream;
+    return 200;
+}
+
+
+int a2dp_out_get_presentation_position(const struct audio_stream_out* stream,
+        uint64_t* frames, struct timespec* timestamp) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out;
+
+    if (stream == NULL || frames == NULL || timestamp == NULL)
+        return -EINVAL;
+    out = aml_out->a2dp_out;
+    if (out == NULL)
+        return -EINVAL;
+    // bytes is the total number of bytes sent by the Bluetooth stack to a
+    // remote headset
+    uint64_t bytes = 0;
+    // delay_report is the audio delay from the remote headset receiving data to
+    // the headset playing sound in units of 1/10ms
+    uint16_t delay_report = 0;
+
+    // If for some reason getting a delay fails or delay reports are disabled,
+    // default to old delay
+    pthread_mutex_lock(&out->mutex);
+    if (out->enable_delay_reporting &&
+        a2dp_get_presentation_position_cmd(out, &bytes, &delay_report, timestamp) == 0) {
+        uint64_t delay_ns = (uint64_t)delay_report * DELAY_TO_NS;
+        if (delay_ns > MIN_DELAY_NS && delay_ns < MAX_DELAY_NS) {
+            *frames = bytes / audio_stream_out_frame_size(stream);
+            timestamp->tv_nsec += delay_ns;
+            if (timestamp->tv_nsec > 1 * SEC_TO_NS) {
+                timestamp->tv_sec++;
+                timestamp->tv_nsec -= SEC_TO_NS;
+            }
+            pthread_mutex_unlock(&out->mutex);
+            return 0;
+        }
+    }
+
+    uint64_t latency_frames = (uint64_t)a2dp_out_get_latency(stream) * aml_out->hal_rate / SEC_TO_MS;
+    if (out->frames_presented >= latency_frames) {
+        clock_gettime(CLOCK_MONOTONIC, timestamp);
+        *frames = out->frames_presented - latency_frames;
+        pthread_mutex_unlock(&out->mutex);
+        return 0;
+    }
+    pthread_mutex_unlock(&out->mutex);
+    return -EWOULDBLOCK;
+}
+
+static int a2dp_out_get_render_position(const struct audio_stream_out* stream,
+                                   uint32_t* dsp_frames) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out;
+
+    if (stream == NULL || dsp_frames == NULL)
+        return -EINVAL;
+    out = aml_out->a2dp_out;
+    if (out == NULL)
+        return -EINVAL;
+    pthread_mutex_lock(&out->mutex);
+    uint64_t latency_frames = (uint64_t)a2dp_out_get_latency(stream) * aml_out->hal_rate / SEC_TO_MS;
+    if (out->frames_rendered >= latency_frames) {
+        *dsp_frames = (uint32_t)(out->frames_rendered - latency_frames);
+    } else {
+        *dsp_frames = 0;
+    }
+    pthread_mutex_unlock(&out->mutex);
+    return 0;
+}
+#if 0
+static int a2dp_write_hwsync(struct audio_stream_out* stream, const void* buffer, size_t bytes,
+            const void* out_buffer, size_t* out_size) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    struct aml_audio_device *adev = aml_out->dev;
+    audio_hwsync_t *hw_sync = aml_out->hwsync;
+    int return_bytes = bytes;
+    uint64_t cur_pts = 0xffffffff;
+    int outsize = 0;
+
+    if (aml_out->hw_sync_mode == 0) {
+        out_buffer = buffer;
+        *out_size = bytes;
+        return bytes;
+    }
+
+    if (adev->debug_flag)
+        ALOGD("a2dp_write_hwsync bytes=%zu\n", bytes);
+    pthread_mutex_lock (&adev->lock);
+    pthread_mutex_lock (&out->mutex);
+    return_bytes = aml_audio_hwsync_find_frame(hw_sync, (char *)buffer, bytes, &cur_pts, &outsize);
+    if (cur_pts > 0xffffffff)
+            ALOGE ("APTS exeed the max 32bit value");
+    if (adev->debug_flag)
+        ALOGI ("after aml_audio_hwsync_find_frame bytes remain %zu,cost %zu,outsize %d,pts %"PRId64"ms\n",
+                bytes - return_bytes, return_bytes, outsize, cur_pts / 90);
+
+    if (cur_pts != 0xffffffff && outsize > 0) {
+        //TODO,skip 3 frames after flush, to tmp fix seek pts discontinue issue.need dig more
+        // to find out why seek ppint pts frame is remained after flush.WTF.
+        if (aml_out->skip_frame > 0) {
+            aml_out->skip_frame--;
+            ALOGI ("skip pts@%"PRIx64",cur frame size %d,cost size %zu\n", cur_pts, outsize, return_bytes);
+            pthread_mutex_unlock (&out->mutex);
+            pthread_mutex_unlock (&adev->lock);
+            return return_bytes;
+        }
+        *out_size = outsize;
+        out_buffer = hw_sync->hw_sync_body_buf;
+
+        // if we got the frame body,which means we get a complete frame.
+        //we take this frame pts as the first apts.
+        //this can fix the seek discontinue,we got a fake frame,which maybe cached before the seek
+        if (hw_sync->first_apts_flag == false) {
+            aml_audio_hwsync_set_first_pts(hw_sync, cur_pts);
+        } else {
+            uint64_t apts;
+            uint32_t apts32;
+            uint pcr = 0;
+            uint apts_gap = 0;
+            uint64_t latency = a2dp_out_get_latency(stream) * 90;
+            // check PTS discontinue, which may happen when audio track switching
+            // discontinue means PTS calculated based on first_apts and frame_write_sum
+            // does not match the timestamp of next audio samples
+            if (cur_pts > latency)
+                apts = cur_pts - latency;
+            else
+                apts = 0;
+            apts32 = apts & 0xffffffff;
+            if (get_sysfs_uint (TSYNC_PCRSCR, &pcr) == 0) {
+                enum hwsync_status sync_status = CONTINUATION;
+                apts_gap = get_pts_gap (pcr, apts32);
+                sync_status = check_hwsync_status (apts_gap);
+                ALOGD("%s()audio pts %dms, pcr %dms, latency %lldms, diff %dms, sync_status=%d",
+                        __func__, apts32/90, pcr/90, latency/90,
+                        (apts32 > pcr) ? (apts32 - pcr)/90 : (pcr - apts32)/90, sync_status);
+                // limit the gap handle to 0.5~5 s.
+                if (sync_status == ADJUSTMENT) {
+                    // two cases: apts leading or pcr leading
+                    // apts leading needs inserting frame and pcr leading neads discarding frame
+                    if (apts32 > pcr) {
+                        size_t once_write_size = 0;
+                        int sent = -1;
+                        char insert_buf[1024];
+                        int insert_size = apts_gap / 90 * 44 * 4;
+                        insert_size = insert_size & (~63);
+                        ALOGI ("audio gap 0x%"PRIx32" ms ,need insert data %d\n", apts_gap / 90, insert_size);
+                        memset(&insert_buf, 0, 1024);
+                        while (insert_size > 0) {
+                            once_write_size = insert_size > 1024 ? 1024 : insert_size;
+                            sent = skt_write(out->audio_fd, &insert_buf, once_write_size);
+                            insert_size -= once_write_size;
+                            if (sent < 0) {
+                                pthread_mutex_unlock (&out->mutex);
+                                pthread_mutex_unlock (&adev->lock);
+                                return -1;
+                            }
+                        }
+                    } else {
+                        //audio pts smaller than pcr,need skip frame.
+                        ALOGI ("audio slow 0x%x,skip frame @pts 0x%"PRIx64",pcr 0x%x,cur apts 0x%x\n",
+                                apts_gap, cur_pts, pcr, apts32);
+                        aml_out->frame_skip_sum += 1764; // 40ms*44100/SEC_TO_MS
+                        pthread_mutex_unlock (&out->mutex);
+                        pthread_mutex_unlock (&adev->lock);
+                        return return_bytes;
+                    }
+                } else if (sync_status == RESYNC) {
+                    char tempbuf[32];
+                    sprintf (tempbuf, "0x%x", apts32);
+                    ALOGI ("tsync -> reset pcrscr 0x%x -> 0x%x, %s big,diff %"PRIx64" ms",
+                            pcr, apts32, apts32 > pcr ? "apts" : "pcr", get_pts_gap (apts, pcr) / 90);
+                    int ret_val = sysfs_set_sysfs_str (TSYNC_APTS, tempbuf);
+                    if (ret_val == -1) {
+                        ALOGE ("unable to open file %s,err: %s", TSYNC_APTS, strerror (errno) );
+                    }
+                }
+            }
+        }
+    }
+    pthread_mutex_unlock (&out->mutex);
+    pthread_mutex_unlock (&adev->lock);
+
+    return return_bytes;
+}
+#endif
+ssize_t a2dp_out_write(struct audio_stream_out* stream, const void* buffer, size_t bytes) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    struct aml_audio_device *adev = aml_out->dev;
+    struct aml_audio_patch *patch = adev->audio_patch;
+    char* data_buffer = (char *)buffer;
+    int sent = -1;
+    const void *out_buffer;
+    size_t out_size = 0;
+    int frame_size = 4; //2ch 16bits
+    size_t in_frames = bytes / frame_size;
+    int i;
+#if defined(AUDIO_EFFECT_EXTERN_DEVICE)
+    int16_t *outbuff;
+    int32_t *outbuff1;
+    float tmp = 0;
+    int chan_num = audio_channel_count_from_out_mask(aml_out->hal_channel_mask);
+#endif
+
+    if (out == NULL)
+        return bytes;
+    if (aml_out->pause_status)
+        return bytes;
+    pthread_mutex_lock(&out->mutex);
+    if (aml_out->is_tv_platform == 1) {
+        in_frames = bytes/32; // 8ch pcm32
+    }
+
+    if (out->state == AUDIO_A2DP_STATE_SUSPENDED || out->state == AUDIO_A2DP_STATE_STOPPING) {
+        ALOGD("stream %p suspended or closing", aml_out);
+        goto finish;
+    }
+
+    /* only allow autostarting if we are in stopped or standby */
+    if (out->state == AUDIO_A2DP_STATE_STOPPED || out->state == AUDIO_A2DP_STATE_STANDBY) {
+        if (start_audio_datapath(stream) < 0) {
+            ALOGE("stream %p start_audio_datapath fail", aml_out);
+            goto finish;
+        }
+    } else if (out->state != AUDIO_A2DP_STATE_STARTED) {
+        ALOGE("stream %p not in stopped or standby", aml_out);
+        goto finish;
+    }
+
+    if (adev->debug_flag)
+        ALOGD("a2dp_out_write: out(%p), write %zu bytes flags=%x, hwsync=%d",
+                aml_out, bytes, aml_out->flags, aml_out->hw_sync_mode);
+
+    /*dtv add drop ac3 pcm function*/
+    if (adev->patch_src ==  SRC_DTV && aml_out->need_drop_size > 0) {
+        if (aml_out->need_drop_size >= (int)bytes) {
+            aml_out->need_drop_size -= bytes;
+            ALOGI("a2dp av sync drop %d pcm, need drop:%d more,apts:0x%x,pcr:0x%x\n",
+                (int)bytes, aml_out->need_drop_size, patch->last_apts, patch->last_pcrpts);
+            if (patch->last_apts >= patch->last_pcrpts) {
+                ALOGI("a2dp pts already ok, drop finish\n");
+                aml_out->need_drop_size = 0;
+            } else {
+                sent = 0;
+                in_frames = 0;
+                goto finish;
+            }
+        } else {
+            data_buffer += aml_out->need_drop_size;
+            bytes -= aml_out->need_drop_size;
+            aml_out->need_drop_size = 0;
+            if (aml_out->is_tv_platform == 1) {
+                in_frames = bytes/32; // 8ch pcm32
+            } else {
+                in_frames = bytes/frame_size;
+            }
+            ALOGI("a2dp drop finish bytes:%d, need_drop_size=%d\n", bytes, aml_out->need_drop_size);
+        }
+    }
+
+    if (aml_out->is_tv_platform == 1) {
+        int16_t *tmp_buffer = (int16_t *)data_buffer;
+        int32_t *tmp_buffer_8ch = (int32_t *)data_buffer;
+        for (int i=0; i<(int)in_frames; i++) {
+            tmp_buffer[2*i] = (tmp_buffer_8ch[8*i]>>16);
+            tmp_buffer[2*i+1] = (tmp_buffer_8ch[8*i+1]>>16);
+        }
+    }
+
+    if (aml_out->hal_rate != out->rate) {
+        size_t out_frames = 0;
+        out_frames = resample_process(&out->aml_resample, in_frames, (int16_t*) data_buffer, (int16_t*) data_buffer);
+        if (out_frames == 0) {
+            goto finish;
+        }
+        out_size = out_frames * frame_size;
+        in_frames = out_frames;
+        out_buffer = data_buffer;
+    } else {
+        out_buffer = data_buffer;
+        out_size = bytes;
+    }
+
+    // Mix the stereo into mono if necessary
+    if (out->is_stereo_to_mono) {
+        int16_t* src = (int16_t*)out_buffer;
+        int16_t* dst = (int16_t*)out_buffer;
+        for (i = 0; i < (int)in_frames; i++, dst++, src += 2) {
+            *dst = (int16_t)(((int32_t)src[0] + (int32_t)src[1]) >> 1);
+        }
+        out_size /= 2;
+    }
+    pthread_mutex_unlock(&out->mutex);
+#if defined(AUDIO_EFFECT_EXTERN_DEVICE)
+    if (aml_out->hal_format == AUDIO_FORMAT_PCM_16_BIT) {
+        outbuff = (int16_t *)out_buffer;
+        outbuff1 = NULL;
+        if (chan_num == 2) {
+            for (i = 0; i < out_size/2; i++) {
+                if (i % 2 == 0) {
+                    tmp = (float)(outbuff[i] * out->bt_gain * out->bt_unmute * out->left_gain);
+                    outbuff[i] = (int16_t)tmp;
+                } else {
+                    tmp = (float)(outbuff[i] * out->bt_gain * out->bt_unmute * out->right_gain);
+                    outbuff[i] = (int16_t)tmp;
+                }
+            }
+        } else {
+            for (i = 0; i < out_size/2; i++) {
+                tmp = (float)(outbuff[i] * out->bt_gain * out->bt_unmute);
+                outbuff[i] = (int16_t)tmp;
+            }
+        }
+    }
+
+    if (aml_out->hal_format == AUDIO_FORMAT_PCM_32_BIT) {
+        outbuff1 = (int32_t *)out_buffer;
+        outbuff = NULL;
+        if (chan_num == 2) {
+            for (i = 0; i < out_size/4; i++) {
+                if (i % 2 == 0) {
+                    tmp = (float)(outbuff1[i] * out->bt_gain * out->bt_unmute * out->left_gain);
+                    outbuff1[i] = (int32_t)tmp;
+                } else {
+                    tmp = (float)(outbuff1[i] * out->bt_gain * out->bt_unmute * out->right_gain);
+                    outbuff[i] = (int32_t)tmp;
+                }
+            }
+        } else {
+            for (i = 0; i < out_size/4; i++) {
+                tmp = (float)(outbuff1[i] * out->bt_gain * out->bt_unmute);
+                outbuff1[i] = (int32_t)tmp;
+            }
+        }
+    }
+#endif
+
+    //sent = skt_write(out->audio_fd, out_buffer, out_size);
+    if (aml_getprop_bool("media.audiohal.a2dp"))
+    {
+        FILE *fp1 = fopen("/data/audio_out/a2dp.pcm", "a+");
+        if (fp1) {
+            int flen = fwrite((char *)out_buffer, 1, out_size, fp1);
+            fclose(fp1);
+        }
+    }
+
+    int write_bytes = 0;
+    while (write_bytes < (int)out_size) {
+        sent = ((out_size-write_bytes) > out->buffer_sz)?out->buffer_sz:(out_size-write_bytes);
+        sent = skt_write(stream, out->audio_fd, (void*)((char*)out_buffer+write_bytes), sent);
+        if (sent < 0)
+            break;
+        write_bytes += sent;
+    }
+    pthread_mutex_lock(&out->mutex);
+    if (sent == -1) {
+        skt_disconnect(out->audio_fd);
+        out->audio_fd = AUDIO_SKT_DISCONNECTED;
+        if (out->state != AUDIO_A2DP_STATE_SUSPENDED && out->state != AUDIO_A2DP_STATE_STOPPING)
+            out->state = AUDIO_A2DP_STATE_STOPPED;
+        else
+            ALOGE("write failed : stream suspended, avoid resetting state");
+        goto finish;
+    }
+
+finish:
+    out->frames_rendered += in_frames;
+    out->frames_presented += in_frames;
+    pthread_mutex_unlock(&out->mutex);
+
+    // If send didn't work out, sleep to emulate write delay.
+    if (sent == -1) {
+        const int us_delay = in_frames * USEC_PER_SEC / aml_out->hal_rate;
+        ALOGD("stream %p emulate a2dp write delay (%d us)", aml_out, us_delay);
+        usleep(us_delay);
+    }
+    return bytes;
+}
+
+int a2dp_out_standby(struct audio_stream* stream) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    int retVal = 0;
+
+    ALOGD("a2dp_out_standby: %p", aml_out);
+    pthread_mutex_lock(&out->mutex);
+    // Do nothing in SUSPENDED state.
+    if (out->state != AUDIO_A2DP_STATE_SUSPENDED)
+        retVal = suspend_audio_datapath(out, true);
+    out->frames_rendered = 0;  // rendered is reset, presented is not
+    if (out->vir_buf_handle != NULL)
+        audio_virtual_buf_close(&out->vir_buf_handle);
+    pthread_mutex_unlock(&out->mutex);
+    return retVal;
+}
+
+int a2dp_output_enable(struct audio_stream_out* stream) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct aml_audio_device *aml_dev = aml_out->dev;
+    struct a2dp_stream_out* out = NULL;
+    struct audio_config* config = &aml_out->out_cfg;
+    int ret = 0;
+
+    ALOGD("a2dp_output_enable");
+    if (aml_out->a2dp_out != NULL) {
+        ALOGD("a2dp_output_enable already exist");
+        return 0;
+    }
+    out = (struct a2dp_stream_out*)malloc(sizeof(struct a2dp_stream_out));
+    if (!out) {
+        ALOGE("a2dp_output_enable a2dp_stream_out realloc error");
+        return -ENOMEM;
+    }
+    aml_out->a2dp_out = out;
+    //aml_alsa_output_close(stream);
+    pthread_mutex_init(&out->mutex, NULL);
+    pthread_mutex_lock(&out->mutex);
+
+    total_input_ns = 0;
+    /* initialize a2dp specifics */
+    a2dp_stream_common_init(out);
+
+    // Make sure we always have the feeding parameters configured
+    if (a2dp_read_output_audio_config(stream) < 0) {
+        ALOGE("a2dp_read_output_audio_config failed");
+        ret = -1;
+        //goto err_open;
+    }
+
+    a2dp_write_output_audio_config(stream);
+    a2dp_read_output_audio_config(stream);
+
+    ALOGD("Output stream config: format=0x%x sample_rate=%d channel_mask=0x%x buffer_sz=%zu",
+            config->format, config->sample_rate, config->channel_mask, out->buffer_sz);
+
+    //aml_out->stream.common.set_parameters = a2dp_out_set_parameters;
+    //aml_out->stream.common.get_parameters = a2dp_out_get_parameters;
+    //aml_out->stream.common.get_buffer_size = a2dp_out_get_buffer_size;
+    //aml_out->stream.get_render_position = a2dp_out_get_render_position;
+    //aml_out->stream.get_presentation_position = a2dp_out_get_presentation_position;
+    aml_dev->sink_format = AUDIO_FORMAT_PCM_16_BIT;
+    aml_dev->optical_format = AUDIO_FORMAT_PCM_16_BIT;
+
+#if defined(AUDIO_EFFECT_EXTERN_DEVICE)
+    out->bt_gain = 1;
+    out->bt_unmute = 1;
+    out->left_gain = 1;
+    out->right_gain = 1;
+#endif
+    pthread_mutex_unlock(&out->mutex);
+    ALOGD("a2dp_output_enable success");
+    /* Delay to ensure Headset is in proper state when START is initiated from
+    * DUT immediately after the connection due to ongoing music playback.
+    */
+    //usleep(250000);
+    return 0;
+
+/*err_open:
+    pthread_mutex_unlock(&out->mutex);
+    aml_out->a2dp_out = NULL;
+    ALOGE("a2dp_output_enable failed");
+    return ret;*/
+}
+void a2dp_output_disable(struct audio_stream_out* stream) {
+    struct aml_stream_out* aml_out = (struct aml_stream_out*)stream;
+    struct a2dp_stream_out* out = aml_out->a2dp_out;
+    /*
+    aml_out->stream.common.set_parameters = out_set_parameters;
+    aml_out->stream.common.get_parameters = out_get_parameters;
+    //aml_out->stream.common.get_buffer_size = out_get_buffer_size;
+    aml_out->stream.get_render_position = out_get_render_position;
+    aml_out->stream.get_presentation_position = out_get_presentation_position;
+    */
+    if (out == NULL)
+        return;
+    pthread_mutex_lock(&out->mutex);
+    total_input_ns = 0;
+    ALOGD("a2dp_output_disable  (state %d)", (int)out->state);
+    if ((out->state == AUDIO_A2DP_STATE_STARTED) || (out->state == AUDIO_A2DP_STATE_STOPPING)) {
+        stop_audio_datapath(out);
+    }
+    if (out->vir_buf_handle != NULL)
+        audio_virtual_buf_close(&out->vir_buf_handle);
+
+    a2dp_stream_common_destroy(out);
+    pthread_mutex_unlock(&out->mutex);
+    free(out);
+    aml_out->a2dp_out = NULL;
+    ALOGD("a2dp_output_disable done");
+}
+
diff --git a/audio_hal/audio_a2dp_hw.h b/audio_hal/audio_a2dp_hw.h
new file mode 100644
index 0000000..adfb944
--- /dev/null
+++ b/audio_hal/audio_a2dp_hw.h
@@ -0,0 +1,176 @@
+/******************************************************************************
+ *
+ *  Copyright 2009-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*****************************************************************************
+ *
+ *  Filename:      audio_a2dp_hw.h
+ *
+ *  Description:
+ *
+ *****************************************************************************/
+
+#ifndef AUDIO_A2DP_HW_H
+#define AUDIO_A2DP_HW_H
+
+#include <stdint.h>
+
+/*****************************************************************************
+ *  Constants & Macros
+ *****************************************************************************/
+
+#define A2DP_AUDIO_HARDWARE_INTERFACE "audio.a2dp"
+#define A2DP_CTRL_PATH "/data/misc/bluedroid/.a2dp_ctrl"
+#define A2DP_DATA_PATH "/data/misc/bluedroid/.a2dp_data"
+
+// AUDIO_STREAM_OUTPUT_BUFFER_SZ controls the size of the audio socket buffer.
+// If one assumes the write buffer is always full during normal BT playback,
+// then increasing this value increases our playback latency.
+//
+// FIXME: The BT HAL should consume data at a constant rate.
+// AudioFlinger assumes that the HAL draws data at a constant rate, which is
+// true for most audio devices; however, the BT engine reads data at a variable
+// rate (over the short term), which confuses both AudioFlinger as well as
+// applications which deliver data at a (generally) fixed rate.
+//
+// 20 * 512 is not sufficient to smooth the variability for some BT devices,
+// resulting in mixer sleep and throttling. We increase this to 28 * 512 to help
+// reduce the effect of variable data consumption.
+#define AUDIO_STREAM_OUTPUT_BUFFER_SZ (28 * 512)
+#define AUDIO_STREAM_CONTROL_OUTPUT_BUFFER_SZ 256
+
+// AUDIO_STREAM_OUTPUT_BUFFER_PERIODS controls how the socket buffer is divided
+// for AudioFlinger data delivery. The AudioFlinger mixer delivers data in
+// chunks of AUDIO_STREAM_OUTPUT_BUFFER_SZ / AUDIO_STREAM_OUTPUT_BUFFER_PERIODS.
+// If the number of periods is 2, the socket buffer represents "double
+// buffering" of the AudioFlinger mixer buffer.
+//
+// In general, AUDIO_STREAM_OUTPUT_BUFFER_PERIODS * 16 * 4 should be a divisor
+// of AUDIO_STREAM_OUTPUT_BUFFER_SZ.
+//
+// These values should be chosen such that
+//
+// AUDIO_STREAM_BUFFER_SIZE * 1000 / (AUDIO_STREAM_OUTPUT_BUFFER_PERIODS
+//         * AUDIO_STREAM_DEFAULT_RATE * 4) > 20 (ms)
+//
+// to avoid introducing the FastMixer in AudioFlinger. Using the FastMixer
+// results in unnecessary latency and CPU overhead for Bluetooth.
+#define AUDIO_STREAM_OUTPUT_BUFFER_PERIODS 2
+
+#define AUDIO_SKT_DISCONNECTED (-1)
+
+typedef enum {
+    A2DP_CTRL_CMD_NONE,
+    A2DP_CTRL_CMD_CHECK_READY,
+    A2DP_CTRL_CMD_START,
+    A2DP_CTRL_CMD_STOP,
+    A2DP_CTRL_CMD_SUSPEND,
+    A2DP_CTRL_GET_INPUT_AUDIO_CONFIG,
+    A2DP_CTRL_GET_OUTPUT_AUDIO_CONFIG,
+    A2DP_CTRL_SET_OUTPUT_AUDIO_CONFIG,
+    A2DP_CTRL_CMD_OFFLOAD_START,
+    A2DP_CTRL_GET_PRESENTATION_POSITION,
+} tA2DP_CTRL_CMD;
+
+typedef enum {
+    A2DP_CTRL_ACK_SUCCESS,
+    A2DP_CTRL_ACK_FAILURE,
+    A2DP_CTRL_ACK_INCALL_FAILURE, /* Failure when in Call*/
+    A2DP_CTRL_ACK_UNSUPPORTED,
+    A2DP_CTRL_ACK_PENDING,
+    A2DP_CTRL_ACK_DISCONNECT_IN_PROGRESS,
+} tA2DP_CTRL_ACK;
+
+typedef enum {
+    BTAV_A2DP_CODEC_SAMPLE_RATE_NONE = 0x0,
+    BTAV_A2DP_CODEC_SAMPLE_RATE_44100 = 0x1 << 0,
+    BTAV_A2DP_CODEC_SAMPLE_RATE_48000 = 0x1 << 1,
+    BTAV_A2DP_CODEC_SAMPLE_RATE_88200 = 0x1 << 2,
+    BTAV_A2DP_CODEC_SAMPLE_RATE_96000 = 0x1 << 3,
+    BTAV_A2DP_CODEC_SAMPLE_RATE_176400 = 0x1 << 4,
+    BTAV_A2DP_CODEC_SAMPLE_RATE_192000 = 0x1 << 5,
+    BTAV_A2DP_CODEC_SAMPLE_RATE_16000 = 0x1 << 6,
+    BTAV_A2DP_CODEC_SAMPLE_RATE_24000 = 0x1 << 7
+} btav_a2dp_codec_sample_rate_t;
+
+typedef enum {
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE = 0x0,
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 = 0x1 << 0,
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24 = 0x1 << 1,
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32 = 0x1 << 2
+} btav_a2dp_codec_bits_per_sample_t;
+
+typedef enum {
+    BTAV_A2DP_CODEC_CHANNEL_MODE_NONE = 0x0,
+    BTAV_A2DP_CODEC_CHANNEL_MODE_MONO = 0x1 << 0,
+    BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO = 0x1 << 1
+} btav_a2dp_codec_channel_mode_t;
+
+typedef struct btav_a2dp_codec_config {
+    btav_a2dp_codec_sample_rate_t sample_rate;
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+    btav_a2dp_codec_channel_mode_t channel_mode;
+} btav_a2dp_codec_config_t;
+
+typedef enum {
+    AUDIO_A2DP_STATE_STARTING,
+    AUDIO_A2DP_STATE_STARTED,
+    AUDIO_A2DP_STATE_STOPPING,
+    AUDIO_A2DP_STATE_STOPPED,
+    /* need explicit set param call to resume (suspend=false) */
+    AUDIO_A2DP_STATE_SUSPENDED,
+    AUDIO_A2DP_STATE_STANDBY /* allows write to autoresume */
+} a2dp_state_t;
+
+struct a2dp_stream_out {
+    //struct aml_stream_out aml_out;
+    pthread_mutex_t mutex;
+    int ctrl_fd;
+    int audio_fd;
+    size_t buffer_sz;
+    bool is_stereo_to_mono;  // True if fetching Stereo and mixing into Mono
+    bool enable_delay_reporting;
+    a2dp_state_t state;
+    uint64_t frames_presented;  // frames written, never reset
+    uint64_t frames_rendered;   // frames written, reset on standby
+    struct resample_para aml_resample;
+    uint32_t rate;
+    void * vir_buf_handle;
+
+#if defined(AUDIO_EFFECT_EXTERN_DEVICE)
+    float bt_gain;
+    float right_gain;
+    float left_gain;
+    int bt_unmute;
+#endif
+};
+
+
+/*****************************************************************************
+ *  Functions
+ *****************************************************************************/
+
+int a2dp_output_enable(struct audio_stream_out* stream);
+void a2dp_output_disable(struct audio_stream_out* stream);
+uint32_t a2dp_out_get_latency(const struct audio_stream_out* stream);
+ssize_t a2dp_out_write(struct audio_stream_out* stream, const void* buffer, size_t bytes);
+int a2dp_out_standby(struct audio_stream* stream);
+int a2dp_out_get_presentation_position(const struct audio_stream_out* stream,
+        uint64_t* frames, struct timespec* timestamp);
+int a2dp_out_set_parameters(struct audio_stream* stream, const char* kvpairs);
+
+#endif /* A2DP_AUDIO_HW_H */
diff --git a/audio_hal/audio_android_resample_api.c b/audio_hal/audio_android_resample_api.c
index 19c22da..a38316f 100644
--- a/audio_hal/audio_android_resample_api.c
+++ b/audio_hal/audio_android_resample_api.c
@@ -18,7 +18,6 @@
 
 #include <cutils/log.h>
 #include <stdlib.h>
-#include <string.h>
 #include "aml_audio_stream.h"
 #include "audio_android_resample_api.h"
 #include "aml_resample_wrap.h"
@@ -147,7 +146,7 @@ int android_resample_process(void *handle, void * in_buffer, size_t bytes, void
     int ret = -1;
     unsigned int input_sr;
     unsigned int output_sr;
-    size_t need_size = 0;
+    uint64_t need_size = 0;
 
     int resample_size = RESAMPLE_FRAME * 2 * 2;
     if (handle == NULL) {
@@ -158,7 +157,7 @@ int android_resample_process(void *handle, void * in_buffer, size_t bytes, void
     resample = (android_resample_handle_t *)handle;
     input_sr = resample->input_sr;
     output_sr = resample->output_sr;
-    need_size = (uint64_t)(resample_size*input_sr + (output_sr - 1))/output_sr;
+    need_size = ((uint64_t)resample_size*input_sr + (output_sr - 1))/output_sr;
 
     if (get_buffer_write_space(&resample->ring_buf) > (int)bytes) {
         ring_buffer_write(&resample->ring_buf, in_buffer, bytes, UNCOVER_WRITE);
diff --git a/audio_hal/audio_data_process.c b/audio_hal/audio_data_process.c
index 175cb69..8880273 100644
--- a/audio_hal/audio_data_process.c
+++ b/audio_hal/audio_data_process.c
@@ -105,7 +105,7 @@ int do_mixing_2ch(void *data_mixed,
 }
 // 2->8ch, 32bit, in out no overlap
 int extend_channel_2_8(void *data_out, void *data_in,
-        size_t frames, int ch_cnt_in, int ch_cnt_out)
+        size_t frames, int ch_cnt_out, int ch_cnt_in)
 {
     (void *)ch_cnt_out;
     (void *)ch_cnt_in;
@@ -126,7 +126,7 @@ int extend_channel_2_8(void *data_out, void *data_in,
 }
 
 int extend_channel_5_8(void *data_out, void *data_in,
-        size_t frames, int ch_cnt_in, int ch_cnt_out)
+        size_t frames, int ch_cnt_out, int ch_cnt_in)
 {
     (void *)ch_cnt_out;
     (void *)ch_cnt_in;
diff --git a/audio_hal/audio_dtv_ad.c b/audio_hal/audio_dtv_ad.c
index 893805a..02fb28d 100644
--- a/audio_hal/audio_dtv_ad.c
+++ b/audio_hal/audio_dtv_ad.c
@@ -243,9 +243,11 @@ int dtv_assoc_read(unsigned char *data, int size)
 
 void dtv_assoc_set_main_frame_size(int main_frame_size)
 {
+    pthread_mutex_lock(&assoc_mutex);
     dtv_assoc_audio *param = get_assoc_audio();
 
     param->main_frame_size = main_frame_size;
+    pthread_mutex_unlock(&assoc_mutex);
 }
 
 void dtv_assoc_get_main_frame_size(int* main_frame_size)
@@ -257,9 +259,11 @@ void dtv_assoc_get_main_frame_size(int* main_frame_size)
 
 void dtv_assoc_set_ad_frame_size(int ad_frame_size)
 {
+    pthread_mutex_lock(&assoc_mutex);
     dtv_assoc_audio *param = get_assoc_audio();
 
     param->ad_frame_size = ad_frame_size;
+    pthread_mutex_unlock(&assoc_mutex);
 }
 
 void dtv_assoc_get_ad_frame_size(int* ad_frame_size)
@@ -350,15 +354,17 @@ static void dtv_assoc_audio_pause(unsigned int handle)
         return;
     }
     ALOGI("%s, paused\n", __FUNCTION__);
+    pthread_mutex_lock(&assoc_mutex);
     dtv_assoc_audio *param = get_assoc_audio();
-    if (handle == 0) {
+    /*if (handle == 0) {
         return ;
-    }
+    }*/
     if (param->assoc_enable == DTV_ASSOC_STAT_ENABLE) {
         audio_ad_set_source(DTV_ASSOC_STAT_DISABLE, param->sub_apid, param->sub_afmt, NULL);
     }
     param->assoc_enable = DTV_ASSOC_STAT_DISABLE;
     param->sub_apid = 0;
+    pthread_mutex_unlock(&assoc_mutex);
     return ;
 }
 static void dtv_assoc_audio_resume(unsigned int handle, int pid)
diff --git a/audio_hal/audio_format_parse.c b/audio_hal/audio_format_parse.c
index 68677f9..2f5ffb0 100644
--- a/audio_hal/audio_format_parse.c
+++ b/audio_hal/audio_format_parse.c
@@ -122,14 +122,81 @@ static audio_channel_mask_t get_dolby_channel_mask(const unsigned char *frameBuf
     }
 }
 
-static int hw_audio_format_detection(struct aml_mixer_handle *mixer_handle)
+#if 0
+/**
+    /*  0 */ "UNDEFINED",
+    /*  1 */ "STEREO LPCM",
+    /*  2 */ "MULTICH 2CH LPCM",
+    /*  3 */ "MULTICH 8CH LPCM",
+    /*  4 */ "MULTICH 16CH LPCM",
+    /*  5 */ "MULTICH 32CH LPCM",
+    /*  6 */ "High Bit Rate LPCM",
+    /*  7 */ "AC-3 (Dolby Digital)", /* Layout A */
+    /*  8 */ "AC-3 (Dolby Digital Layout B)",
+    /*  9 */ "E-AC-3/DD+ (Dolby Digital Plus)",
+    /* 10 */ "MLP (Dolby TrueHD)",
+    /* 11 */ "DTS",
+    /* 12 */ "DTS-HD",
+    /* 13 */ "DTS-HD MA",
+    /* 14 */ "DSD (One Bit Audio 6CH)",
+    /* 15 */ "DSD (One Bit Audio 12CH)",
+    /* 16 */ "PAUSE",
+
+*/
+#endif
+
+static int eArcIn_audio_format_detection(struct aml_mixer_handle *mixer_handle)
+{
+    int type = 0;
+    int audio_code = 0;
+    type = aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_EARCRX_AUDIO_CODING_TYPE);
+
+    switch (type) {
+        case 7:
+        case 8:
+            audio_code = AC3;
+            break;
+        case 9:
+            audio_code = EAC3;
+            break;
+        case 10:
+            audio_code = MAT;
+            break;
+        case 11:
+            audio_code = DTS;
+            break;
+        case 12:
+            audio_code = DTSHD;
+            break;
+        default:
+            audio_code = LPCM;
+        /* TODO -Add multi-channel LPCM support */
+    }
+    return audio_code;
+}
+
+static int hdmiin_audio_format_detection(struct aml_mixer_handle *mixer_handle)
 {
     int type = 0;
 
     if (alsa_device_is_auge())
-        type = aml_mixer_ctrl_get_int(mixer_handle,AML_MIXER_ID_HDMIIN_AUDIO_TYPE);
+        type = aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_HDMIIN_AUDIO_TYPE);
     else
-        type = aml_mixer_ctrl_get_int(mixer_handle,AML_MIXER_ID_SPDIFIN_AUDIO_TYPE);
+        type = aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_SPDIFIN_AUDIO_TYPE);
+
+    if (type >= LPCM && type <= PAUSE) {
+        return type;
+    } else {
+        return LPCM;
+    }
+
+}
+
+static int spdifin_audio_format_detection(struct aml_mixer_handle *mixer_handle)
+{
+    int type = 0;
+
+    type = aml_mixer_ctrl_get_int(mixer_handle, AML_MIXER_ID_SPDIFIN_AUDIO_TYPE);
 
     if (type >= LPCM && type <= PAUSE) {
         return type;
@@ -197,8 +264,8 @@ int audio_type_parse(void *buffer, size_t bytes, int *package_size, audio_channe
             /*refer to IEC 61937-5 pdf, table 6*/
             *package_size = DTSHD_PERIOD_SIZE << tmp ;
             break;
-        case IEC61937_TRUEHD:
-            AudioType = TRUEHD;
+        case IEC61937_MAT:
+            AudioType = MAT;
             *package_size = THD_PERIOD_SIZE;
             break;
         case IEC61937_PAUSE:
@@ -210,7 +277,7 @@ int audio_type_parse(void *buffer, size_t bytes, int *package_size, audio_channe
             AudioType = LPCM;
             break;
         }
-        ALOGV("%s() data format: %d, *package_size %d, input size %zu\n",
+        ALOGI("%s() data format: %d, *package_size %d, input size %zu\n",
               __FUNCTION__, AudioType, *package_size, bytes);
     } else if (pos_dtscd_sync_word >= 0) {
         AudioType = DTSCD;
@@ -292,6 +359,38 @@ static int audio_type_parse_release(audio_type_parse_t *status)
     return 0;
 }
 
+static int audio_transer_samplerate (eMixerHwResample hw_sr)
+{
+    int samplerate;
+    switch (hw_sr) {
+    case HW_RESAMPLE_32K:
+        samplerate = 32000;
+        break;
+    case HW_RESAMPLE_44K:
+        samplerate = 44100;
+        break;
+    case HW_RESAMPLE_48K:
+        samplerate = 48000;
+        break;
+    case HW_RESAMPLE_88K:
+        samplerate = 88200;
+        break;
+    case HW_RESAMPLE_96K:
+        samplerate = 96000;
+        break;
+    case HW_RESAMPLE_176K:
+        samplerate = 176400;
+        break;
+    case HW_RESAMPLE_192K:
+        samplerate = 192000;
+        break;
+    default:
+        samplerate = 48000;
+        break;
+    }
+    return samplerate;
+}
+
 static int update_audio_type(audio_type_parse_t *status, int update_bytes, int sr)
 {
     audio_type_parse_t *audio_type_status = status;
@@ -326,11 +425,13 @@ void* audio_type_parse_threadloop(void *data)
 {
     audio_type_parse_t *audio_type_status = (audio_type_parse_t *)data;
     int bytes, ret = -1;
-    int cur_samplerate = HW_RESAMPLE_48K;
-    int last_cur_samplerate = HW_RESAMPLE_48K;
+    eMixerHwResample cur_samplerate = HW_RESAMPLE_48K;
     int read_bytes = 0;
     int txlx_chip = is_txlx_chip();
     int txl_chip = is_txl_chip();
+    int auge_chip = alsa_device_is_auge();
+    int last_resampler_enable = 0;
+    eMixerHwResample last_resampler_sr = HW_RESAMPLE_DISABLE;
 
     ret = audio_type_parse_init(audio_type_status);
     if (ret < 0) {
@@ -345,71 +446,141 @@ void* audio_type_parse_threadloop(void *data)
     ALOGV("Start thread loop for android audio data parse! data = %p, bytes = %d, in = %p\n",
           data, bytes, audio_type_status->in);
 
+    if (audio_type_status->input_src == AUDIO_DEVICE_IN_HDMI) {
+        set_resample_source(audio_type_status->mixer_handle, RESAMPLE_FROM_FRHDMIRX);
+    } else if (audio_type_status->input_src == AUDIO_DEVICE_IN_HDMI_ARC) {
+        set_resample_source(audio_type_status->mixer_handle, RESAMPLE_FROM_EARCRX_DMAC);
+    } else if (audio_type_status->input_src == AUDIO_DEVICE_IN_SPDIF) {
+        set_resample_source(audio_type_status->mixer_handle, RESAMPLE_FROM_SPDIFIN);
+    }
+
+    // by default disable resampler
+    enable_HW_resample(audio_type_status->mixer_handle, HW_RESAMPLE_DISABLE);
+
     while (audio_type_status->running_flag) {
         if (audio_type_status->input_src == AUDIO_DEVICE_IN_HDMI) {
             cur_samplerate = get_hdmiin_samplerate(audio_type_status->mixer_handle);
+            audio_type_status->audio_samplerate = audio_transer_samplerate(cur_samplerate);
         } else if (audio_type_status->input_src == AUDIO_DEVICE_IN_SPDIF) {
             cur_samplerate = get_spdifin_samplerate(audio_type_status->mixer_handle);
+            audio_type_status->audio_samplerate = audio_transer_samplerate(cur_samplerate);
         } else if (audio_type_status->input_src == AUDIO_DEVICE_IN_HDMI_ARC) {
-            cur_samplerate = -1;//temp code
-        }
-
-        /*check hdmiin audio input sr and reset hw resample*/
-        if (cur_samplerate != -1 && cur_samplerate != HW_RESAMPLE_DISABLE &&
-                cur_samplerate != last_cur_samplerate &&
-                audio_type_status->audio_type == LPCM) {
-            enable_HW_resample(audio_type_status->mixer_handle, cur_samplerate);
-            ALOGD("Reset hdmiin/spdifin audio resample sr from %d to %d\n",
-                last_cur_samplerate, cur_samplerate);
-            last_cur_samplerate = cur_samplerate;
+            cur_samplerate = get_eArcIn_samplerate(audio_type_status->mixer_handle);
+            audio_type_status->audio_samplerate = audio_transer_samplerate(cur_samplerate);
         }
 
+        // get input audio format
         if (txlx_chip && audio_type_status->in) {
+            //sw audio format detection.
             if (cur_samplerate == HW_RESAMPLE_192K) {
                 read_bytes = bytes * 4;
             } else {
                 read_bytes = bytes;
             }
             ret = pcm_read(audio_type_status->in, audio_type_status->parse_buffer + 3, read_bytes);
+            if (ret >= 0) {
+                audio_type_status->cur_audio_type = audio_type_parse(audio_type_status->parse_buffer,
+                                                    read_bytes, &(audio_type_status->package_size),
+                                                    &(audio_type_status->audio_ch_mask));
+                //ALOGD("cur_audio_type=%d\n", audio_type_status->cur_audio_type);
+                memcpy(audio_type_status->parse_buffer, audio_type_status->parse_buffer + read_bytes, 3);
+                update_audio_type(audio_type_status, read_bytes, cur_samplerate);
+            } else {
+                usleep(10 * 1000);
+            }
         } else {
-            ret = -1;
-        }
+            if (auge_chip) {
+                // get audio format from hw.
+                if (audio_type_status->input_src == AUDIO_DEVICE_IN_HDMI) {
+                    audio_type_status->cur_audio_type = hdmiin_audio_format_detection(audio_type_status->mixer_handle);
+                } else if (audio_type_status->input_src == AUDIO_DEVICE_IN_SPDIF) {
+                    audio_type_status->cur_audio_type = spdifin_audio_format_detection(audio_type_status->mixer_handle);
+                } else if (audio_type_status->input_src == AUDIO_DEVICE_IN_HDMI_ARC) {
+                    audio_type_status->cur_audio_type = eArcIn_audio_format_detection(audio_type_status->mixer_handle);
+                }
 
-        if (ret >= 0) {
-            audio_type_status->cur_audio_type = audio_type_parse(audio_type_status->parse_buffer,
-                                                read_bytes, &(audio_type_status->package_size),
-                                                &(audio_type_status->audio_ch_mask));
-            //ALOGD("cur_audio_type=%d\n", audio_type_status->cur_audio_type);
-            memcpy(audio_type_status->parse_buffer, audio_type_status->parse_buffer + read_bytes, 3);
-            update_audio_type(audio_type_status, read_bytes, cur_samplerate);
-        } else {
-            //for txl chip,the PAO sw audio format detection is not ready yet.
-            //we use the hw audio format detection.
-            //TODO
-            if (!txlx_chip) {
-                hdmiin_audio_packet_t audio_packet = AUDIO_PACKET_NONE;
-                if (txl_chip) {
-                    audio_packet = get_hdmiin_audio_packet(audio_type_status->mixer_handle);
-                    if (audio_packet == AUDIO_PACKET_HBR) {
-                        /* we let software detect it */
-                        enable_HW_resample(audio_type_status->mixer_handle, HW_RESAMPLE_DISABLE);
+                audio_type_status->audio_type = audio_type_status->cur_audio_type;
+
+                // set up channel mask according to channel assignment
+                if (audio_type_status->input_src == AUDIO_DEVICE_IN_HDMI) {
+                    audio_channel_mask_t mask;
+                    // TODO: use HDMI channel assignment instead of channel number
+                    switch (get_hdmiin_channel(audio_type_status->mixer_handle)) {
+                        case 2:
+                            mask = AUDIO_CHANNEL_OUT_STEREO;
+                            break;
+                        case 3:
+                            mask = AUDIO_CHANNEL_OUT_STEREO | AUDIO_CHANNEL_OUT_LOW_FREQUENCY;
+                            break;
+                        case 4:
+                            mask = AUDIO_CHANNEL_OUT_QUAD;
+                            break;
+                        case 6:
+                            mask = AUDIO_CHANNEL_OUT_5POINT1;
+                            break;
+                        case 8:
+                            mask = AUDIO_CHANNEL_OUT_7POINT1;
+                            break;
+                        default:
+                            mask = AUDIO_CHANNEL_OUT_STEREO;
+                            break;
+                    }
+                    if (audio_type_status->audio_ch_mask != mask) {
+                        ALOGI("HDMI IN audio_type_status channel mask 0x%x\n", mask);
                     }
+                    audio_type_status->audio_ch_mask = mask;
+                } else if (audio_type_status->input_src == AUDIO_DEVICE_IN_HDMI_ARC) {
+                    int ca = get_arcin_ca(audio_type_status->mixer_handle);
+                    audio_channel_mask_t mask;
+                    switch (ca/4) {
+                        case 0:
+                        case 5:
+                            mask = AUDIO_CHANNEL_OUT_STEREO;
+                            break;
+                        case 1:
+                        case 6:
+                            mask = AUDIO_CHANNEL_OUT_STEREO | AUDIO_CHANNEL_OUT_BACK_CENTER;
+                            break;
+                        case 2:
+                        case 7:
+                            mask = AUDIO_CHANNEL_OUT_QUAD;
+                            break;
+                        case 3:
+                            mask = AUDIO_CHANNEL_OUT_QUAD | AUDIO_CHANNEL_OUT_BACK_CENTER;
+                            break;
+                        case 4:
+                            mask = AUDIO_CHANNEL_OUT_QUAD | AUDIO_CHANNEL_OUT_SIDE_LEFT | AUDIO_CHANNEL_OUT_SIDE_RIGHT;
+                            break;
+                        default:
+                            mask = AUDIO_CHANNEL_OUT_STEREO;
+                    }
+                    if (ca & 1)
+                        mask |= AUDIO_CHANNEL_OUT_LOW_FREQUENCY;
+                    if (ca & 2)
+                        mask |= AUDIO_CHANNEL_OUT_FRONT_CENTER;
+                    if (audio_type_status->audio_ch_mask != mask) {
+                        ALOGI("HDMI ARC/eARC IN audio_type_status channel mask 0x%x\n", mask);
+                    }
+                    audio_type_status->audio_ch_mask = mask;
                 }
-                if (audio_packet != AUDIO_PACKET_HBR) {
-                    audio_type_status->cur_audio_type = hw_audio_format_detection(audio_type_status->mixer_handle);
-                    if (audio_type_status->audio_type != LPCM && audio_type_status->cur_audio_type == LPCM) {
+
+                // check HW resampler settings when audio type changed or sample rate changed
+                if (audio_type_status->cur_audio_type == LPCM) {
+                    if ((!last_resampler_enable) || (last_resampler_sr != cur_samplerate)) {
+                        ALOGI("Enable resample for PCM, sr = %d", cur_samplerate);
                         enable_HW_resample(audio_type_status->mixer_handle, cur_samplerate);
+                        last_resampler_enable = 1;
+                        last_resampler_sr = cur_samplerate;
                     }
-                    else if (audio_type_status->audio_type == LPCM && audio_type_status->cur_audio_type != LPCM){
-                        ALOGV("1 Raw data found: type(%d)\n", audio_type_status->cur_audio_type);
-                        enable_HW_resample(audio_type_status->mixer_handle, HW_RESAMPLE_DISABLE);
-                    }
-                    audio_type_status->audio_type = audio_type_status->cur_audio_type;
+                } else if (last_resampler_enable) {
+                    ALOGI("Disable resampler for non-PCM type %d", audio_type_status->cur_audio_type);
+                    enable_HW_resample(audio_type_status->mixer_handle, HW_RESAMPLE_DISABLE);
+                    last_resampler_enable = 0;
                 }
             }
-            usleep(10 * 1000);
-            //ALOGE("fail to read bytes = %d\n", bytes);
         }
+
+        usleep(10 * 1000);
     }
 
     audio_type_parse_release(audio_type_status);
@@ -418,6 +589,15 @@ void* audio_type_parse_threadloop(void *data)
     return ((void *) 0);
 }
 
+int audio_parse_get_audio_samplerate(audio_type_parse_t *status)
+{
+    if (!status) {
+        ALOGE("NULL pointer of audio_type_parse_t, return default samperate:48000\n");
+        return DEFAULT_SAMPLE_RATE;
+    }
+    return status->audio_samplerate;
+}
+
 int creat_pthread_for_audio_type_parse(
                      pthread_t *audio_type_parse_ThreadID,
                      void **status,
@@ -488,6 +668,8 @@ audio_format_t audio_type_convert_to_android_audio_format_t(int codec_type)
         return AUDIO_FORMAT_AC3;
     case EAC3:
         return AUDIO_FORMAT_E_AC3;
+    case MAT:
+        return AUDIO_FORMAT_MAT;
     case DTS:
     case DTSCD:
         return AUDIO_FORMAT_DTS;
@@ -512,6 +694,8 @@ int android_audio_format_t_convert_to_andio_type(audio_format_t format)
         return AC3;
     case AUDIO_FORMAT_E_AC3:
         return EAC3;
+    case AUDIO_FORMAT_MAT:
+        return MAT;
     case AUDIO_FORMAT_DTS:
         return  DTS;//DTSCD;
     case AUDIO_FORMAT_DTS_HD:
@@ -542,6 +726,8 @@ char* audio_type_convert_to_string(int s32AudioType)
         return "TRUEHD";
     case LPCM:
         return "LPCM";
+    case MAT:
+        return "MAT";
     default:
         return "UNKNOWN";
     }
diff --git a/audio_hal/audio_format_parse.h b/audio_hal/audio_format_parse.h
index 34fb10c..ca0ddf7 100644
--- a/audio_hal/audio_format_parse.h
+++ b/audio_hal/audio_format_parse.h
@@ -27,7 +27,7 @@ enum IEC61937_PC_Value {
     IEC61937_DTS3               = 0x0D,          ///< DTS type III (2048 samples)
     IEC61937_DTSHD              = 0x11,          ///< DTS HD data
     IEC61937_EAC3               = 0x15,          ///< E-AC-3 data
-    IEC61937_TRUEHD             = 0x16,          ///< TrueHD data
+    IEC61937_MAT                = 0x16,          ///< MAT data
     IEC61937_PAUSE              = 0x03,          ///< Pause
 };
 
@@ -37,8 +37,9 @@ enum audio_type {
     EAC3,
     DTS,
     DTSHD,
-    TRUEHD,
+    MAT,
     PAUSE,
+    TRUEHD,
     DTSCD,
     MUTE,
 };
@@ -57,6 +58,8 @@ enum audio_type {
 /*min DTSHD Period 2048; max DTSHD Period 65536*/
 #define DTSHD_PERIOD_SIZE (2048)
 
+#define DEFAULT_SAMPLE_RATE 48000
+
 enum parser_state {
     IEC61937_UNSYNC,
     IEC61937_SYNCING,
@@ -82,7 +85,7 @@ typedef struct audio_type_parse {
 
     int read_bytes;
     int package_size;
-
+    int audio_samplerate;
     int running_flag;
     // used for software detection
     int state;
@@ -136,5 +139,6 @@ int audio_type_parse(void *buffer, size_t bytes, int *package_size, audio_channe
  */
 void feeddata_audio_type_parse(void **status, char * input, int size);
 
+int audio_parse_get_audio_samplerate(audio_type_parse_t *status);
 
 #endif
diff --git a/audio_hal/audio_hw.c b/audio_hal/audio_hw.c
index 96c4cd1..687a9e0 100644
--- a/audio_hal/audio_hw.c
+++ b/audio_hal/audio_hw.c
@@ -38,8 +38,10 @@
 #include <hardware/hardware.h>
 #include <system/audio.h>
 #include <audio_utils/channels.h>
+#ifdef AML_EQ_DRC
 #include "aml_DRC_param_gen.h"
 #include "aml_EQ_param_gen.h"
+#endif
 #include "atomic.h"
 
 #if ANDROID_PLATFORM_SDK_VERSION >= 25 //8.0
@@ -50,9 +52,7 @@
 #include <sound/asound.h>
 #include <tinyalsa/asoundlib.h>
 #include <audio_route/audio_route.h>
-#include <aml_data_utils.h>
 #include <spdifenc_wrap.h>
-#include <aml_volume_utils.h>
 #include <aml_android_utils.h>
 #include <aml_alsa_mixer.h>
 
@@ -60,7 +60,6 @@
 #include "SPDIFEncoderAD.h"
 #include "aml_volume_utils.h"
 #include "aml_data_utils.h"
-#include "aml_dump_debug.h"
 #include "spdifenc_wrap.h"
 #include "alsa_manager.h"
 #include "aml_audio_stream.h"
@@ -84,7 +83,11 @@
 #define ENABLE_DTV_PATCH
 #define ENABLE_TUNER_IN
 #endif
-
+#include "aml_audio_spdif_output.h"
+#include "aml_audio_ac4parser.h"
+#ifdef ENABLE_MMAP
+#include "aml_mmap_audio.h"
+#endif
 // for invoke bluetooth rc hal
 //#include "audio_hal_thunks.h"
 
@@ -94,6 +97,8 @@
 #include "dolby_ms12.h"
 #include "dolby_lib_api.h"
 
+#include "earc_utils.h"
+
 //#define ENABLE_NANO_NEW_PATH 1
 #if ENABLE_NANO_NEW_PATH
 #include "jb_nano.h"
@@ -103,7 +108,7 @@
 //#define ENABLE_NOISE_GATE
 //#define ENABLE_DRC
 //#define ENABLE_EQ
-#define SUBMIXER_V1_1
+//#define SUBMIXER_V1_1
 #define HDMI_LATENCY_MS 60
 
 #ifdef ENABLE_AEC_FUNC
@@ -123,6 +128,12 @@
 #endif
 
 #include "sub_mixing_factory.h"
+#include "aml_malloc_debug.h"
+#include "audio_a2dp_hw.h"
+
+/*audio hal insert silence data!*/
+#include "audio_hw_insert_silence_data.h"
+
 #define CARD_AMLOGIC_BOARD 0
 
 /*Google Voice Assistant channel_mask */
@@ -149,30 +160,38 @@
 #define VX_NB_SAMPLING_RATE 8000
 
 #define MIXER_XML_PATH "/etc/mixer_paths.xml"
-#define DOLBY_MS12_INPUT_FORMAT_TEST
 
-#define IEC61937_PACKET_SIZE_OF_AC3     0x1800
-#define IEC61937_PACKET_SIZE_OF_EAC3    0x6000
+#define IEC61937_PACKET_SIZE_OF_AC3                     (0x1800)
+#define IEC61937_PACKET_SIZE_OF_EAC3                    (0x6000)
 
+#define MAX_INPUT_STREAM_CNT                            (3)
 #define DISABLE_CONTINUOUS_OUTPUT "persist.vendor.audio.continuous.disable"
 
-#define INPUTSOURCE_MUTE_DELAY_MS	800
+#define INPUTSOURCE_MUTE_DELAY_MS       800
 
-#define DROP_AUDIO_SIZE             (32 * 1024)
+#define DROP_AUDIO_SIZE             (64 * 1024)
 
-const char *str_usecases[STREAM_USECASE_MAX] = {
-    "STREAM_PCM_NORMAL",
-    "STREAM_PCM_DIRECT",
-    "STREAM_PCM_HWSYNC",
-    "STREAM_RAW_DIRECT",
-    "STREAM_RAW_HWSYNC",
-    "STREAM_PCM_PATCH",
-    "STREAM_RAW_PATCH"
-};
+#define ENUM_USECASE_TYPE_TO_STR(x, pStr)              ENUM_TYPE_TO_STR(x, strlen("STREAM_"), pStr)
 
-const char *usecase_to_str(stream_usecase_t usecase)
+//#define HDMI_ARC_PCM_32BIT_INPUT
+
+const char* usecase2Str(stream_usecase_t enUsecase)
 {
-    return str_usecases[usecase];
+    static char acTypeStr[ENUM_TYPE_STR_MAX_LEN];
+    char *pStr = "INVALID";
+    switch (enUsecase) {
+        ENUM_USECASE_TYPE_TO_STR(STREAM_PCM_NORMAL, pStr)
+        ENUM_USECASE_TYPE_TO_STR(STREAM_PCM_DIRECT, pStr)
+        ENUM_USECASE_TYPE_TO_STR(STREAM_PCM_HWSYNC, pStr)
+        ENUM_USECASE_TYPE_TO_STR(STREAM_RAW_DIRECT, pStr)
+        ENUM_USECASE_TYPE_TO_STR(STREAM_RAW_HWSYNC, pStr)
+        ENUM_USECASE_TYPE_TO_STR(STREAM_PCM_PATCH, pStr)
+        ENUM_USECASE_TYPE_TO_STR(STREAM_RAW_PATCH, pStr)
+        ENUM_USECASE_TYPE_TO_STR(STREAM_PCM_MMAP, pStr)
+        ENUM_USECASE_TYPE_TO_STR(STREAM_USECASE_MAX, pStr)
+    }
+    sprintf(acTypeStr, "[%d]%s", enUsecase, pStr);
+    return acTypeStr;
 }
 
 static const struct pcm_config pcm_config_out = {
@@ -237,7 +256,7 @@ int start_ease_out(struct aml_audio_device *adev) {
 }
 static void select_output_device (struct aml_audio_device *adev);
 static void select_input_device (struct aml_audio_device *adev);
-//static void select_devices (struct aml_audio_device *adev);
+static void select_devices (struct aml_audio_device *adev);
 static int adev_set_voice_volume (struct audio_hw_device *dev, float volume);
 static int do_input_standby (struct aml_stream_in *in);
 static int do_output_standby (struct aml_stream_out *out);
@@ -255,7 +274,6 @@ static int create_patch_ext(struct audio_hw_device *dev,
                             audio_patch_handle_t handle);
 static int release_patch (struct aml_audio_device *aml_dev);
 static int release_parser(struct aml_audio_device *aml_dev);
-static void aml_tinymix_set_spdif_format(audio_format_t output_format,  struct aml_stream_out *stream);
 static inline bool need_hw_mix(usecase_mask_t masks);
 //static int out_standby_new(struct audio_stream *stream);
 static int adev_open_output_stream(struct audio_hw_device *dev,
@@ -273,8 +291,12 @@ static int get_audio_patch_by_src_dev(struct audio_hw_device *dev,
 ssize_t out_write_new(struct audio_stream_out *stream,
                       const void *buffer,
                       size_t bytes);
+
+static int out_get_presentation_position (const struct audio_stream_out *stream, uint64_t *frames, struct timespec *timestamp);
+
+int calc_time_interval_us(struct timespec *ts_start, struct timespec *ts_end);
+
 static aec_timestamp get_timestamp(void);
-static void config_output(struct audio_stream_out *stream);
 static inline bool need_hw_mix(usecase_mask_t masks)
 {
     return (masks > 1);
@@ -290,7 +312,7 @@ static RECORDING_DEVICE recording_device = RECORDING_DEVICE_OTHER;
 /*[SEN5-autumn.zhao-2018-01-11] add for B06 audio support } */
 #endif
 
-static bool is_bypass_dolbyms12(struct audio_stream_out *stream);
+static bool is_high_rate_pcm(struct audio_stream_out *stream);
 
 static inline short CLIP (int r)
 {
@@ -324,7 +346,7 @@ static void continuous_stream_do_standby(struct aml_audio_device *adev)
     //normal pcm stream exit.
     if (eDolbyMS12Lib == adev->dolby_lib_type) {
         get_dolby_ms12_cleanup(&adev->ms12);
-        ALOGD("[%s:%d] get_dolby_ms12_cleanup\n", __FUNCTION__, __LINE__);
+        ALOGI("[%s:%d] get_dolby_ms12_cleanup\n", __FUNCTION__, __LINE__);
     }
     aml_normal_pcm_out = adev->active_outputs[normal_pcm_stream_usecase];
     ALOGI("%s normal_pcm_stream_usecase %#x aml_normal_pcm_out %p", __FUNCTION__, normal_pcm_stream_usecase, aml_normal_pcm_out);
@@ -367,7 +389,10 @@ static void store_stream_presentation(struct aml_audio_device *adev)
                     is_mat_61937 = true;
                 }
             } else if ((aml_out->hal_internal_format == AUDIO_FORMAT_E_AC3) || (aml_out->hal_internal_format == AUDIO_FORMAT_AC3)) {
-                write_frames = aml_out->input_bytes_size / aml_out->ddp_frame_size * 32 * 48;
+                if (aml_out->ddp_frame_size)
+                    write_frames = aml_out->input_bytes_size / aml_out->ddp_frame_size * 32 * 48;
+                else /*TODO: how to define write_frames*/
+                    ALOGE("%s line %d ddp_frame_size %d\n", __FUNCTION__, __LINE__, aml_out->ddp_frame_size);
             }
 
             /*
@@ -380,7 +405,11 @@ static void store_stream_presentation(struct aml_audio_device *adev)
                     multiple = 4;
                 else if (is_mat_61937 == true && (aml_out->hal_rate == 128000 || aml_out->hal_rate == 44100*4))
                     multiple = 16;
-                write_frames = (write_frames * MM_FULL_POWER_SAMPLING_RATE*multiple) / aml_out->hal_rate;
+
+                if (aml_out->hal_rate)
+                    write_frames = (write_frames * MM_FULL_POWER_SAMPLING_RATE*multiple) / aml_out->hal_rate;
+                else /*TODO: how to define write_frames*/
+                    ALOGE("%s line %d hal_rate %d\n", __FUNCTION__, __LINE__, aml_out->hal_rate);
             }
             aml_out->last_frames_postion = write_frames;
             aml_out->frame_write_sum = write_frames;
@@ -492,7 +521,6 @@ static int aml_hal_mixer_read (struct aml_hal_mixer *mixer, void *r_buf, uint si
 }
 // aml audio hal mixer code end
 
-#if 0
 static void select_devices (struct aml_audio_device *adev)
 {
     ALOGD ("%s(mode=%d, out_device=%#x)", __FUNCTION__, adev->mode, adev->out_device);
@@ -536,7 +564,6 @@ static void select_devices (struct aml_audio_device *adev)
     audio_route_update_mixer (adev->ar);
 
 }
-#endif
 
 static void select_mode (struct aml_audio_device *adev)
 {
@@ -554,11 +581,11 @@ static void select_mode (struct aml_audio_device *adev)
         a call. This works because we're sure that the audio policy
         manager will update the output device after the audio mode
         change, even if the device selection did not change. */
-    if ( (adev->out_device & AUDIO_DEVICE_OUT_ALL) == AUDIO_DEVICE_OUT_SPEAKER) {
+    /*if ( (adev->out_device & AUDIO_DEVICE_OUT_ALL) == AUDIO_DEVICE_OUT_SPEAKER) {
         adev->in_device = AUDIO_DEVICE_IN_BUILTIN_MIC & ~AUDIO_DEVICE_BIT_IN;
     } else {
         adev->out_device &= ~AUDIO_DEVICE_OUT_SPEAKER;
-    }
+    }*/
 
     return;
 }
@@ -574,6 +601,7 @@ bool format_is_passthrough (audio_format_t fmt)
     case AUDIO_FORMAT_DTS_HD:
     case AUDIO_FORMAT_IEC61937:
     case AUDIO_FORMAT_DOLBY_TRUEHD:
+    case AUDIO_FORMAT_AC4:
         return true;
     default:
         return false;
@@ -811,6 +839,10 @@ static int start_output_stream_direct (struct aml_stream_out *out)
     out->config.avail_min = 0;
 #endif
     set_codec_type (codec_type);
+    /* mute spdif when dd+ output */
+    if (codec_type == TYPE_EAC3) {
+        aml_mixer_ctrl_set_int(&adev->alsa_mixer, AML_MIXER_ID_SPDIF_MUTE, 1);
+    }
 
     ALOGI ("ALSA open configs: channels=%d, format=%d, period_count=%d, period_size=%d,,rate=%d",
            out->config.channels, out->config.format, out->config.period_count,
@@ -822,7 +854,7 @@ static int start_output_stream_direct (struct aml_stream_out *out)
             /*
             for a113 later chip,raw passthr goes to spsdifa or spdifb
             */
-            if (format_is_passthrough(out->hal_format)) {
+            if (format_is_passthrough(out->hal_format) || codec_type == TYPE_PCM_HIGH_SR) {
                 port = PORT_SPDIF;
             }
             else
@@ -897,8 +929,8 @@ static int check_input_parameters(uint32_t sample_rate, audio_format_t format, i
         return -EINVAL;
     }
 
-    if (channel_count < 1 || channel_count > 2) {
-        ALOGE("%s: unsupported channel count (%d) passed  Min / Max (1 / 2)", __func__, channel_count);
+    if (channel_count < 1 || channel_count > 8) {
+        ALOGE("%s: unsupported channel count (%d) passed  Min / Max (1 / 8)", __func__, channel_count);
         return -EINVAL;
     }
 
@@ -921,9 +953,7 @@ static int check_input_parameters(uint32_t sample_rate, audio_format_t format, i
     devices &= ~AUDIO_DEVICE_BIT_IN;
     if ((devices & AUDIO_DEVICE_IN_LINE) ||
         (devices & AUDIO_DEVICE_IN_SPDIF) ||
-        (devices & AUDIO_DEVICE_IN_TV_TUNER) ||
-        (devices & AUDIO_DEVICE_IN_HDMI) ||
-        (devices & AUDIO_DEVICE_IN_HDMI_ARC)) {
+        (devices & AUDIO_DEVICE_IN_TV_TUNER)) {
         if (format == AUDIO_FORMAT_PCM_16_BIT &&
             channel_count == 2 &&
             sample_rate == 48000) {
@@ -949,16 +979,28 @@ static int check_input_parameters(uint32_t sample_rate, audio_format_t format, i
     return 0;
 }
 
+static int check_mic_parameters(struct mic_in_desc *mic_desc,
+        struct audio_config *config)
+{
+    struct pcm_config *pcm_cfg = &mic_desc->config;
+    uint32_t sample_rate = config->sample_rate;
+    audio_format_t format =config->format;
+    unsigned int channel_count = audio_channel_count_from_in_mask(config->channel_mask);
+
+    ALOGD("%s(sample_rate=%d, format=%d, channel_count=%d)",
+            __func__, sample_rate, format, channel_count);
+    if (sample_rate == pcm_cfg->rate &&
+            format == AUDIO_FORMAT_PCM_16_BIT)
+        return 0;
+
+    return -EINVAL;
+}
+
 static size_t get_input_buffer_size(unsigned int period_size, uint32_t sample_rate, audio_format_t format, int channel_count)
 {
     size_t size;
 
     ALOGD("%s(sample_rate=%d, format=%d, channel_count=%d)", __FUNCTION__, sample_rate, format, channel_count);
-
-    if (check_input_parameters(sample_rate, format, channel_count, AUDIO_DEVICE_NONE) != 0) {
-        return 0;
-    }
-
     /* take resampling into account and return the closest majoring
     multiple of 16 frames, as audioflinger expects audio buffers to
     be a multiple of 16 frames */
@@ -1071,12 +1113,13 @@ static size_t out_get_buffer_size (const struct audio_stream *stream)
                 size = (8192 + 16) / 4;
             }
         }
+        break;
     default:
         if (out->config.rate == 96000)
             size = DEFAULT_PLAYBACK_PERIOD_SIZE * 2;
         else
             // bug_id - 158018, modify size value from PERIOD_SIZE to (PERIOD_SIZE * PLAYBACK_PERIOD_COUNT)
-            size = DEFAULT_PLAYBACK_PERIOD_SIZE*2/* * PLAYBACK_PERIOD_COUNT*/;
+            size = DEFAULT_PLAYBACK_PERIOD_SIZE * 2/* * PLAYBACK_PERIOD_COUNT*/;
     }
     // size = ( (size + 15) / 16) * 16;
     return size * audio_stream_out_frame_size ( (struct audio_stream_out *) stream);
@@ -1129,6 +1172,11 @@ static int do_output_standby (struct aml_stream_out *out)
 
     ALOGD ("%s(%p)", __FUNCTION__, out);
 
+#ifdef ENABLE_BT_A2DP
+    if ((out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) && out->a2dp_out)
+        a2dp_out_standby(&out->stream.common);
+#endif
+
     if (!out->standby) {
         //commit here for hwsync/mix stream hal mixer
         //pcm_close(out->pcm);
@@ -1195,6 +1243,11 @@ static int do_output_standby_direct (struct aml_stream_out *out)
     struct aml_audio_device *adev = out->dev;
     ALOGI ("%s,out %p", __FUNCTION__,  out);
 
+#ifdef ENABLE_BT_A2DP
+    if ((out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) && out->a2dp_out)
+        a2dp_out_standby(&out->stream.common);
+#endif
+
     if (!out->standby) {
         if (out->buffer) {
             free (out->buffer);
@@ -1214,12 +1267,15 @@ static int do_output_standby_direct (struct aml_stream_out *out)
             if (out->pause_status == true && out->earc_pcm) {
                 pcm_stop(out->earc_pcm);
             }
-            pcm_close (out->earc_pcm);
-            out->earc_pcm = NULL;
+            if (out->earc_pcm) {
+                pcm_close (out->earc_pcm);
+                out->earc_pcm = NULL;
+            }
         }
     }
     out->pause_status = false;
     set_codec_type (TYPE_PCM);
+    aml_mixer_ctrl_set_int(&adev->alsa_mixer, AML_MIXER_ID_SPDIF_MUTE, 0);
     /* clear the hdmitx channel config to default */
     if (out->multich == 6) {
         sysfs_set_sysfs_str ("/sys/class/amhdmitx/amhdmitx0/aud_output_chs", "0:0");
@@ -1276,6 +1332,7 @@ static int out_standby_direct (struct audio_stream *stream)
     }
     out->pause_status = false;
     set_codec_type (TYPE_PCM);
+    aml_mixer_ctrl_set_int(&adev->alsa_mixer, AML_MIXER_ID_SPDIF_MUTE, 0);
 
     if (out->need_convert) {
         ALOGI("need_convert release %d ",__LINE__);
@@ -1566,6 +1623,11 @@ static int out_set_parameters (struct audio_stream *stream, const char *kvpairs)
     }
 
     if (eDolbyMS12Lib == adev->dolby_lib_type) {
+        if (strlen(kvpairs) >= sizeof(value)) {
+            ret = -1;
+            ALOGE("ms12_runtime param size exceeds %d", sizeof(value));
+            goto exit;
+        }
         ret = str_parms_get_str(parms, "ms12_runtime", value, sizeof(value));
         if (ret >= 0) {
             char *parm = strstr(kvpairs, "=");
@@ -1611,6 +1673,8 @@ static char *out_get_parameters (const struct audio_stream *stream, const char *
         } else {
             if (out->out_device & AUDIO_DEVICE_OUT_HDMI_ARC) {
                 cap = (char *) strdup_hdmi_arc_cap_default (AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES, format);
+            } else if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+                cap = (char *) strdup_a2dp_cap_default(AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES, format);
             } else {
                 cap = (char *) get_hdmi_sink_cap (AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES,format,&(adev->hdmi_descs));
             }
@@ -1630,6 +1694,8 @@ static char *out_get_parameters (const struct audio_stream *stream, const char *
         } else {
             if (out->out_device & AUDIO_DEVICE_OUT_HDMI_ARC) {
                 cap = (char *) strdup_hdmi_arc_cap_default (AUDIO_PARAMETER_STREAM_SUP_CHANNELS, format);
+            } else if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+                cap = (char *) strdup_a2dp_cap_default(AUDIO_PARAMETER_STREAM_SUP_CHANNELS, format);
             } else {
                 cap = (char *) get_hdmi_sink_cap (AUDIO_PARAMETER_STREAM_SUP_CHANNELS,format,&(adev->hdmi_descs));
             }
@@ -1645,6 +1711,8 @@ static char *out_get_parameters (const struct audio_stream *stream, const char *
     } else if (strstr (keys, AUDIO_PARAMETER_STREAM_SUP_FORMATS) ) {
         if (out->out_device & AUDIO_DEVICE_OUT_HDMI_ARC) {
             cap = (char *) strdup_hdmi_arc_cap_default (AUDIO_PARAMETER_STREAM_SUP_FORMATS, format);
+        } else if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+            cap = (char *) strdup_a2dp_cap_default(AUDIO_PARAMETER_STREAM_SUP_FORMATS, format);
         } else {
             if (out->is_tv_platform == 1) {
                 ALOGV ("Amlogic - return hard coded sup_formats list for primary output stream.\n");
@@ -1665,6 +1733,8 @@ static char *out_get_parameters (const struct audio_stream *stream, const char *
         }
         ALOGI ("%s\n", para);
         return para;
+    } else if (!strstr(keys, "dap_")) {
+        return dolby_ms12_query_dap_parameters(keys);
     }
     return strdup ("");
 }
@@ -1692,9 +1762,17 @@ static uint32_t out_get_latency_frames (const struct audio_stream_out *stream)
 static uint32_t out_get_latency (const struct audio_stream_out *stream)
 {
     const struct aml_stream_out *out = (const struct aml_stream_out *) stream;
+    uint32_t a2dp_delay = 0;
+
+#ifdef ENABLE_BT_A2DP
+    if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+        a2dp_delay = a2dp_out_get_latency(stream);
+    }
+#endif
+
     snd_pcm_sframes_t frames = out_get_latency_frames (stream);
     //snd_pcm_sframes_t frames = DEFAULT_PLAYBACK_PERIOD_SIZE * PLAYBACK_PERIOD_COUNT;
-    return (frames * 1000) / out->config.rate;
+    return (frames * 1000) / out->config.rate + a2dp_delay;
 }
 
 #define FLOAT_ZERO 0.000001
@@ -1703,8 +1781,14 @@ static int out_set_volume (struct audio_stream_out *stream, float left, float ri
     struct aml_stream_out *out = (struct aml_stream_out *) stream;
     struct aml_audio_device *adev = out->dev;
     int ret = 0;
-    ALOGI("%s(), stream(%p), left:%f right:%f ", __func__, stream, left, right);
-    if (out->hal_internal_format == AUDIO_FORMAT_E_AC3) {
+    bool is_dolby_format = is_dolby_ms12_support_compression_format(out->hal_internal_format);
+    bool is_direct_pcm = is_direct_stream_and_pcm_format(out);
+
+    ALOGI("%s(), stream(%p), left:%f right:%f, continous_mode(%d), hal_internal_format:%x, is dolby %d is direct pcm %d\n",
+        __func__, stream, left, right, continous_mode(adev), out->hal_internal_format, is_dolby_format, is_direct_pcm);
+
+    /* for not use ms12 case, we can use spdif enc mute, other wise ms12 can handle it*/
+    if (is_dolby_format && (eDolbyDcvLib == adev->dolby_lib_type || is_bypass_dolbyms12(stream) || adev->hdmi_format == BYPASS)) {
         if (out->volume_l < FLOAT_ZERO && left > FLOAT_ZERO) {
             ALOGI("set offload mute: false");
             spdifenc_set_mute(false);
@@ -1718,33 +1802,17 @@ static int out_set_volume (struct audio_stream_out *stream, float left, float ri
     out->volume_l = left;
     out->volume_r = right;
 
-    // When MS12 input is PCM to OTT, ms12 fail to change volume.we will change volume at input side.
-    // When MS12 input is DD/DDP, we adjust main DD/DDP input volume here
-    if ((eDolbyMS12Lib == adev->dolby_lib_type) && continous_mode(adev) && !audio_is_linear_pcm(out->hal_internal_format)) {
-        int iMS12DB = -96;
-
+    /*
+     *The Dolby format(dd/ddp/ac4/true-hd/mat) and direct&UI-PCM(stereo or multi PCM)
+     *will go through dolby system mixer as main input
+     *use dolby_ms12_set_main_volume to control it.
+     *The volume about mixer-PCM is controled by AudioFlinger
+     */
+    if ((eDolbyMS12Lib == adev->dolby_lib_type) && (is_dolby_format || is_direct_pcm)) {
         if (out->volume_l != out->volume_r) {
             ALOGW("%s, left:%f right:%f NOT match", __FUNCTION__, left, right);
         }
-
-        iMS12DB = volume2Ms12DBGain(out->volume_l);
-
-        // MS12 initial DB gain is 0 when setup
-        // without "adev->ms12->curDBGain != iMS12DB" conditional filter, audio will have gap when continous changing volume
-        if (adev->ms12.curDBGain != iMS12DB) {
-            char param[16];
-            char *argv[3] = {"ms12_runtime", "-sys_prim_mixgain", param};
-            // set duration to 10 will not introduce gap
-            ret = set_dolby_ms12_primary_input_db_gain(&adev->ms12, iMS12DB , 10);
-            if (ret < 0) {
-                ALOGE("%s,set dolby primary gain failed", __FUNCTION__);
-            }
-            adev->ms12.curDBGain = iMS12DB;
-            sprintf(param, "%d,10,0", iMS12DB);
-            aml_ms12_update_runtime_params_direct(&(adev->ms12), 3, argv);
-            ALOGI("%s,out->volume_l = %f,  iMS12DB = %d", __FUNCTION__, out->volume_l, iMS12DB);
-        }
-
+        dolby_ms12_set_main_volume(out->volume_l);
     }
     return 0;
 }
@@ -1789,6 +1857,7 @@ static int out_pause (struct audio_stream_out *stream)
                 ALOGE ("out->pcm and adev->pcm are assumed same handle");
         }
     }
+
     if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected &&
             out->earc_pcm && pcm_is_ready (out->earc_pcm)) {
         r = pcm_ioctl (out->earc_pcm, SNDRV_PCM_IOCTL_PAUSE, 1);
@@ -1810,6 +1879,7 @@ exit:
     if (out->hw_sync_mode) {
         ALOGI("%s set AUDIO_PAUSE when tunnel mode\n",__func__);
         sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_PAUSE");
+        out->tsync_status = TSYNC_STATUS_PAUSED;
     }
     pthread_mutex_unlock (&adev->lock);
     pthread_mutex_unlock (&out->lock);
@@ -1847,10 +1917,10 @@ static int out_resume (struct audio_stream_out *stream)
                 r = pcm_ioctl (out->earc_pcm, SNDRV_PCM_IOCTL_PREPARE);
             }
         } else {
-            r = pcm_ioctl (out->pcm, SNDRV_PCM_IOCTL_PAUSE, 0);
+            r = pcm_ioctl (out->pcm, SNDRV_PCM_IOCTL_PREPARE);
             if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected &&
                     out->earc_pcm && pcm_is_ready (out->earc_pcm)) {
-                r = pcm_ioctl (out->earc_pcm, SNDRV_PCM_IOCTL_PAUSE, 0);
+                r = pcm_ioctl (out->earc_pcm, SNDRV_PCM_IOCTL_PREPARE);
             }
         }
         if (r < 0) {
@@ -1867,12 +1937,14 @@ static int out_resume (struct audio_stream_out *stream)
         adev->hwsync_output = out;
         aml_hal_mixer_init(&adev->hal_mixer);
         sysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_RESUME");
+        out->tsync_status = TSYNC_STATUS_RUNNING;
     }
     out->pause_status = false;
 exit:
     if (out->hw_sync_mode) {
         ALOGI("%s set AUDIO_RESUME when tunnel mode\n",__func__);
         sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_RESUME");
+        out->tsync_status = TSYNC_STATUS_RUNNING;
     }
     pthread_mutex_unlock (&adev->lock);
     pthread_mutex_unlock (&out->lock);
@@ -1885,34 +1957,33 @@ static int out_pause_new (struct audio_stream_out *stream)
     struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
     struct aml_audio_device *aml_dev = aml_out->dev;
     struct dolby_ms12_desc *ms12 = &(aml_dev->ms12);
+    bool is_standby = aml_out->standby;
     int ret = 0;
 
     ALOGI("%s(), stream(%p), pause_status = %d,dolby_lib_type = %d, conti = %d,hw_sync_mode = %d,ms12_enable = %d,ms_conti_paused = %d\n",
           __func__, stream, aml_out->pause_status, aml_dev->dolby_lib_type, aml_dev->continuous_audio_mode, aml_out->hw_sync_mode, aml_dev->ms12.dolby_ms12_enable, aml_dev->ms12.is_continuous_paused);
     pthread_mutex_lock (&aml_dev->lock);
     pthread_mutex_lock (&aml_out->lock);
-    // mark : some project have comment this out, while 8.1 keep it functioning. zz
-    //if (aml_out->pause_status == true) {
-    //    ALOGI("pause already, do nothing and exit");
-    //    goto exit1;
-    //}
-    /*
-    send audio pause cmd to  video when tunnel mode.
-    */
-    if (aml_out->hw_sync_mode) {
-        sysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_PAUSE");
+
+    /* a stream should fail to pause if not previously started */
+    if (aml_out->pause_status == true) {
+        // If output stream is standby or paused,
+        // we should return Result::INVALID_STATE (3),
+        // thus we can pass VTS test.
+        ALOGE ("%s: stream in wrong status. standby(%d) or paused(%d)",
+                __func__, aml_out->standby, aml_out->pause_status);
+        ret = INVALID_STATE;
+        goto exit;
     }
+
     if (eDolbyMS12Lib == aml_dev->dolby_lib_type) {
         if (aml_dev->continuous_audio_mode == 1) {
             if ((aml_dev->ms12.dolby_ms12_enable == true) && (aml_dev->ms12.is_continuous_paused == false)) {
-                char *argv[3] = {"ms12_runtime", "-pause", "1"};
                 aml_dev->ms12.is_continuous_paused = true;
                 pthread_mutex_lock(&ms12->lock);
-                int ms12_runtime_update_ret = 0;
                 dolby_ms12_set_pause_flag(aml_dev->ms12.is_continuous_paused);
-                ms12_runtime_update_ret = aml_ms12_update_runtime_params_direct(&(aml_dev->ms12), 3, argv);
+                set_dolby_ms12_runtime_pause(&(aml_dev->ms12), aml_dev->ms12.is_continuous_paused);
                 pthread_mutex_unlock(&ms12->lock);
-                ALOGI("%s ms12 set pause flag runtime return %d\n", __func__, ms12_runtime_update_ret);
             } else {
                 ALOGI("%s do nothing\n", __func__);
             }
@@ -1923,22 +1994,28 @@ static int out_pause_new (struct audio_stream_out *stream)
             }
         }
     } else {
-
         ret = do_output_standby_l(&stream->common);
         if (ret < 0) {
             goto exit;
         }
     }
-exit1:
+exit:
     aml_out->pause_status = true;
 
-    if (aml_out->hw_sync_mode) {
+    pthread_mutex_unlock(&aml_dev->lock);
+    pthread_mutex_unlock(&aml_out->lock);
+
+    if (aml_out->hw_sync_mode && aml_out->tsync_status != TSYNC_STATUS_PAUSED) {
+        usleep(150 * 1000);
         sysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_PAUSE");
+        aml_out->tsync_status = TSYNC_STATUS_PAUSED;
+    }
+
+    if (is_standby) {
+        ALOGD("%s(), stream(%p) already in standy, return INVALID_STATE", __func__, stream);
+        ret = INVALID_STATE;
     }
 
-exit:
-    pthread_mutex_unlock(&aml_dev->lock);
-    pthread_mutex_unlock(&aml_out->lock);
     return ret;
 }
 
@@ -1966,14 +2043,12 @@ static int out_resume_new (struct audio_stream_out *stream)
     if (eDolbyMS12Lib == aml_dev->dolby_lib_type) {
         if (aml_dev->continuous_audio_mode == 1) {
             if ((aml_dev->ms12.dolby_ms12_enable == true) && (aml_dev->ms12.is_continuous_paused == true)) {
-                char *argv[3] = {"ms12_runtime", "-pause", "0"};
                 aml_dev->ms12.is_continuous_paused = false;
                 pthread_mutex_lock(&ms12->lock);
                 int ms12_runtime_update_ret = 0;
                 dolby_ms12_set_pause_flag(aml_dev->ms12.is_continuous_paused);
-                ms12_runtime_update_ret = aml_ms12_update_runtime_params_direct(&(aml_dev->ms12), 3, argv);
+                set_dolby_ms12_runtime_pause(&(aml_dev->ms12), aml_dev->ms12.is_continuous_paused);
                 pthread_mutex_unlock(&ms12->lock);
-                ALOGI("%s ms12 set unpause flag runtime return %d\n", __func__, ms12_runtime_update_ret);
             }
         }
     }
@@ -1984,6 +2059,7 @@ static int out_resume_new (struct audio_stream_out *stream)
     aml_out->pause_status = false;
     if (aml_out->hw_sync_mode) {
         sysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_RESUME");
+        aml_out->tsync_status = TSYNC_STATUS_RUNNING;
     }
 
 exit:
@@ -2004,8 +2080,8 @@ static int out_flush_new (struct audio_stream_out *stream)
     out->spdif_enc_init_frame_write_sum =  0;
     out->frame_skip_sum = 0;
     out->skip_frame = 0;
-    out->input_bytes_size = 0;
     out->pause_status = false;
+    out->input_bytes_size = 0;
 
     if (eDolbyMS12Lib == adev->dolby_lib_type) {
         if (out->hw_sync_mode) {
@@ -2014,12 +2090,18 @@ static int out_flush_new (struct audio_stream_out *stream)
         //normal pcm(mixer thread) do not flush dolby ms12 input buffer
         if (continous_mode(adev) && (out->flags & AUDIO_OUTPUT_FLAG_DIRECT)) {
             pthread_mutex_lock(&ms12->lock);
-            dolby_ms12_flush_main_input_buffer();
+            dolby_ms12_main_flush(stream);
             pthread_mutex_unlock(&ms12->lock);
             out->continuous_audio_offset = 0;
+            adev->ms12.last_frames_postion = 0;
         }
     }
 
+    if (out->hal_format == AUDIO_FORMAT_AC4) {
+        aml_ac4_parser_reset(&out->ac4_parser_handle);
+    }
+
+
     return 0;
 }
 
@@ -2054,6 +2136,12 @@ static ssize_t out_write_legacy (struct audio_stream_out *stream, const void* bu
     ALOGV ("%s():out %p,position %zu",
              __func__, out, bytes);
 
+    if (adev->out_device != out->out_device) {
+        ALOGD("%s:%p device:%x,%x", __func__, stream, out->out_device, adev->out_device);
+        out->out_device = adev->out_device;
+        config_output(stream,true);
+    }
+
     // limit HAL mixer buffer level within 200ms
     while ( (adev->hwsync_output != NULL && adev->hwsync_output != out) &&
             (aml_hal_mixer_get_content (&adev->hal_mixer) > 200 * 48 * 4) ) {
@@ -2132,7 +2220,7 @@ static ssize_t out_write_legacy (struct audio_stream_out *stream, const void* bu
 
 #if 1
     if (enable_dump && out->hw_sync_mode == 0) {
-        FILE *fp1 = fopen ("/data/tmp/i2s_audio_out.pcm", "a+");
+        FILE *fp1 = fopen ("/data/vendor/audiohal/i2s_audio_out.pcm", "a+");
         if (fp1) {
             int flen = fwrite ( (char *) buffer, 1, bytes, fp1);
             fclose (fp1);
@@ -2219,7 +2307,7 @@ static ssize_t out_write_legacy (struct audio_stream_out *stream, const void* bu
 
 #if 0
     if (enable_dump && out->hw_sync_mode == 1) {
-        FILE *fp1 = fopen ("/data/tmp/i2s_audio_out.pcm", "a+");
+        FILE *fp1 = fopen ("/data/vendor/audiohal/i2s_audio_out.pcm", "a+");
         if (fp1) {
             int flen = fwrite ( (char *) in_buffer, 1, out_frames * frame_size, fp1);
             ALOGD ("flen = %d---outlen=%d ", flen, out_frames * frame_size);
@@ -2246,27 +2334,27 @@ static ssize_t out_write_legacy (struct audio_stream_out *stream, const void* bu
 #endif
     if (out->is_tv_platform == 1) {
         int16_t *tmp_buffer = (int16_t *) out->audioeffect_tmp_buffer;
-        if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm && adev->bHDMIARCon) {
+        if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm /* && adev->bHDMIARCon */) {
             ret = pcm_write (out->earc_pcm, tmp_buffer, out_frames * frame_size * 2);
         } else {
-        memcpy ( (void *) tmp_buffer, (void *) in_buffer, out_frames * 4);
-        ALOGV ("Amlogic - disable audio_data_process(), and replace tmp_buffer data with in_buffer data.\n");
-        // audio_effect_process() is deprecated
-        //audio_effect_process(stream, tmp_buffer, out_frames);
-        for (i = 0; i < out_frames; i ++) {
-            out->tmp_buffer_8ch[8 * i] = ( (int32_t) (in_buffer[2 * i]) ) << 16;
-            out->tmp_buffer_8ch[8 * i + 1] = ( (int32_t) (in_buffer[2 * i + 1]) ) << 16;
-            out->tmp_buffer_8ch[8 * i + 2] = ( (int32_t) (in_buffer[2 * i]) ) << 16;
-            out->tmp_buffer_8ch[8 * i + 3] = ( (int32_t) (in_buffer[2 * i + 1]) ) << 16;
-            out->tmp_buffer_8ch[8 * i + 4] = 0;
-            out->tmp_buffer_8ch[8 * i + 5] = 0;
-            out->tmp_buffer_8ch[8 * i + 6] = 0;
-            out->tmp_buffer_8ch[8 * i + 7] = 0;
-        }
-        /*if (out->frame_count < 5*1024) {
-            memset(out->tmp_buffer_8ch, 0, out_frames * frame_size * 8);
-        }*/
-        ret = pcm_write (out->pcm, out->tmp_buffer_8ch, out_frames * frame_size * 8);
+            memcpy ( (void *) tmp_buffer, (void *) in_buffer, out_frames * 4);
+            ALOGV ("Amlogic - disable audio_data_process(), and replace tmp_buffer data with in_buffer data.\n");
+            // audio_effect_process() is deprecated
+            //audio_effect_process(stream, tmp_buffer, out_frames);
+            for (i = 0; i < out_frames; i ++) {
+                out->tmp_buffer_8ch[8 * i] = ( (int32_t) (in_buffer[2 * i]) ) << 16;
+                out->tmp_buffer_8ch[8 * i + 1] = ( (int32_t) (in_buffer[2 * i + 1]) ) << 16;
+                out->tmp_buffer_8ch[8 * i + 2] = ( (int32_t) (in_buffer[2 * i]) ) << 16;
+                out->tmp_buffer_8ch[8 * i + 3] = ( (int32_t) (in_buffer[2 * i + 1]) ) << 16;
+                out->tmp_buffer_8ch[8 * i + 4] = 0;
+                out->tmp_buffer_8ch[8 * i + 5] = 0;
+                out->tmp_buffer_8ch[8 * i + 6] = 0;
+                out->tmp_buffer_8ch[8 * i + 7] = 0;
+            }
+            /*if (out->frame_count < 5*1024) {
+                memset(out->tmp_buffer_8ch, 0, out_frames * frame_size * 8);
+            }*/
+            ret = pcm_write (out->pcm, out->tmp_buffer_8ch, out_frames * frame_size * 8);
         }
         out->frame_write_sum += out_frames;
     } else {
@@ -2362,7 +2450,7 @@ static ssize_t out_write_legacy (struct audio_stream_out *stream, const void* bu
                                     }
 #if 1
                                     if (enable_dump) {
-                                        FILE *fp1 = fopen ("/data/tmp/i2s_audio_out.pcm", "a+");
+                                        FILE *fp1 = fopen ("/data/vendor/audiohal/i2s_audio_out.pcm", "a+");
                                         if (fp1) {
                                             int flen = fwrite ( (char *) insert_buf, 1, once_write_size, fp1);
                                             fclose (fp1);
@@ -2481,7 +2569,7 @@ static ssize_t out_write_legacy (struct audio_stream_out *stream, const void* bu
                             }
 #if 1
                             if (enable_dump) {
-                                FILE *fp1 = fopen ("/data/tmp/i2s_audio_out.pcm", "a+");
+                                FILE *fp1 = fopen ("/data/vendor/audiohal/i2s_audio_out.pcm", "a+");
                                 if (fp1) {
                                     int flen = fwrite ( (char *) w_buf, 1, 64, fp1);
                                     fclose (fp1);
@@ -2650,6 +2738,12 @@ static ssize_t out_write (struct audio_stream_out *stream, const void* buffer,
     short *mix_buf = NULL;
     unsigned char enable_dump = getprop_bool ("media.audiohal.outdump");
 
+    if (adev->out_device != out->out_device) {
+        ALOGD("%s:%p device:%x,%x", __func__, stream, out->out_device, adev->out_device);
+        out->out_device = adev->out_device;
+        config_output(stream,true);
+    }
+
     /* acquiring hw device mutex systematically is useful if a low priority thread is waiting
      * on the output stream mutex - e.g. executing select_mode() while holding the hw device
      * mutex
@@ -2729,13 +2823,13 @@ static ssize_t out_write (struct audio_stream_out *stream, const void* buffer,
     if (aml_hal_mixer_get_content (mixer) > 0) {
         pthread_mutex_lock (&mixer->lock);
         if (mixer->wp > mixer->rp) {
-            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm && adev->bHDMIARCon) {
+            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm/* && adev->bHDMIARCon */) {
                 pcm_write (out->earc_pcm, mixer->start_buf + mixer->rp, mixer->wp - mixer->rp);
             } else {
                 pcm_write (out->pcm, mixer->start_buf + mixer->rp, mixer->wp - mixer->rp);
             }
         } else {
-            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm && adev->bHDMIARCon) {
+            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm/* && adev->bHDMIARCon */) {
                 pcm_write (out->earc_pcm, mixer->start_buf + mixer->wp, mixer->buf_size - mixer->rp);
                 pcm_write (out->earc_pcm, mixer->start_buf, mixer->wp);
             } else {
@@ -2746,7 +2840,7 @@ static ssize_t out_write (struct audio_stream_out *stream, const void* buffer,
         mixer->rp = mixer->wp = 0;
         pthread_mutex_unlock (&mixer->lock);
     }
-    if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm && adev->bHDMIARCon) {
+    if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm/* && adev->bHDMIARCon */) {
         ret = pcm_write (out->earc_pcm, in_buffer, out_frames * frame_size);
     } else {
         ret = pcm_write (out->pcm, in_buffer, out_frames * frame_size);
@@ -2792,7 +2886,6 @@ static int insert_output_bytes (struct aml_stream_out *out, size_t size)
     size_t output_buffer_bytes = 0;
     audio_format_t output_format = get_output_format(stream);
     char *insert_buf = (char*) malloc (8192);
-
     if (insert_buf == NULL) {
         ALOGE ("malloc size failed \n");
         return -ENOMEM;
@@ -2810,7 +2903,7 @@ static int insert_output_bytes (struct aml_stream_out *out, size_t size)
     memset (insert_buf, 0, 8192);
     while (insert_size > 0) {
         once_write_size = insert_size > 8192 ? 8192 : insert_size;
-        if (eDolbyMS12Lib == adev->dolby_lib_type) {
+        if (eDolbyMS12Lib == adev->dolby_lib_type && !is_bypass_dolbyms12(stream)) {
             size_t used_size = 0;
             ret = dolby_ms12_main_process(stream, insert_buf, once_write_size, &used_size);
             if (ret) {
@@ -2876,7 +2969,7 @@ static ssize_t out_write_direct(struct audio_stream_out *stream, const void* buf
            __func__, out, bytes,
            out->hw_sync_mode, out->frame_write_sum);
 #if 0
-    FILE *fp1 = fopen ("/data/out_write_direct_passthrough.pcm", "a+");
+    FILE *fp1 = fopen("/data/vendor/audiohal/out_write_direct_passthrough.pcm", "a+");
     if (fp1) {
         int flen = fwrite ( (char *) buffer, 1, bytes, fp1);
         //ALOGD("flen = %d---outlen=%d ", flen, out_frames * frame_size);
@@ -2886,6 +2979,12 @@ static ssize_t out_write_direct(struct audio_stream_out *stream, const void* buf
     }
 #endif
 
+    if (adev->out_device != out->out_device) {
+        ALOGD("%s:%p device:%x,%x", __func__, stream, out->out_device, adev->out_device);
+        out->out_device = adev->out_device;
+        config_output(stream,true);
+    }
+
     /*when hi-pcm stopped  and switch to 2-ch , then switch to hi-pcm,hi-pcm-mode must be
      set and wait 20ms for i2s device release*/
     if (get_codec_type(out->hal_internal_format) == TYPE_PCM && !adev->hi_pcm_mode
@@ -2905,9 +3004,9 @@ static ssize_t out_write_direct(struct audio_stream_out *stream, const void* buf
     if ( (out->standby) && out->hw_sync_mode) {
         /*
         there are two types of raw data come to hdmi  audio hal
-        1) compressed audio data without IEC61937 wrapped (AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO=0)
-        2) compressed audio data  with IEC61937 wrapped (typically from amlogic amadec source, AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO=1)
-        we use the AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO to distinguish the two cases.
+        1) compressed audio data without IEC61937 wrapped
+        2) compressed audio data  with IEC61937 wrapped (typically from amlogic amadec source)
+        we use the AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO to distiguwish the two cases.
         */
         if ((codec_type == TYPE_AC3 || codec_type == TYPE_EAC3)  && !(out->flags & AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO)) {
              if (out->need_convert) {
@@ -2956,6 +3055,7 @@ rewrite:
         if (cur_pts > 0xffffffff) {
             ALOGE ("APTS exeed the max 32bit value");
         }
+
         if (adev->debug_flag)
             ALOGI ("after aml_audio_hwsync_find_frame bytes remain %zu,cost %zu,outsize %d,pts %"PRId64"ms\n",
                total_bytes - bytes_cost - hwsync_cost_bytes, hwsync_cost_bytes, outsize, cur_pts / 90);
@@ -2969,14 +3069,15 @@ rewrite:
             return hwsync_cost_bytes;
         }
         if (cur_pts != 0xffffffff && outsize > 0) {
-			int hwsync_hdmi_latency = aml_audio_get_hwsync_latency_offset();
+            int  b_raw  = audio_is_linear_pcm(out->hal_internal_format) ? 1 : 0;
+            int hwsync_tune_latency = aml_audio_get_ms12_tunnel_latency_offset(b_raw);
             // if we got the frame body,which means we get a complete frame.
             //we take this frame pts as the first apts.
             //this can fix the seek discontinue,we got a fake frame,which maybe cached before the seek
             if (hw_sync->first_apts_flag == false) {
-                if (cur_pts >= (out_get_latency(stream) + hwsync_hdmi_latency) * 90
+                if (cur_pts >= (out_get_latency(stream) + hwsync_tune_latency) * 90
                     /*&& out->last_frames_postion > 0*/) {
-                    cur_pts -= (out_get_latency(stream) + hwsync_hdmi_latency) * 90;
+                    cur_pts -= (out_get_latency(stream) + hwsync_tune_latency) * 90;
                     aml_audio_hwsync_set_first_pts(out->hwsync, cur_pts);
                 } else {
                     ALOGI("%s(), first pts not set, cur_pts %lld, last position %lld",
@@ -2987,7 +3088,7 @@ rewrite:
                 uint32_t apts32;
                 uint pcr = 0;
                 uint apts_gap = 0;
-                uint64_t latency = (out_get_latency(stream) + hwsync_hdmi_latency) * 90;
+                uint64_t latency = (out_get_latency(stream) + hwsync_tune_latency) * 90;
                 // check PTS discontinue, which may happen when audio track switching
                 // discontinue means PTS calculated based on first_apts and frame_write_sum
                 // does not match the timestamp of next audio samples
@@ -3063,7 +3164,7 @@ rewrite:
     out_frames = in_frames;
     buf = (void *) write_buf;
     if (getprop_bool("media.hdmihal.outdump")) {
-        FILE *fp1 = fopen("/data/tmp/hal_audio_out.pcm", "a+");
+        FILE *fp1 = fopen("/data/vendor/audiohal/hal_audio_out.pcm", "a+");
         if (fp1) {
             int flen = fwrite ( (char *) buffer, 1, bytes, fp1);
             //ALOGD("flen = %d---outlen=%d ", flen, out_frames * frame_size);
@@ -3086,10 +3187,22 @@ rewrite:
                      break;
                    process_bytes = 0;
                 } else {
-                    config_output(stream);
+                    config_output(stream,true);
                 }
                 if (ddp_dec->outlen_raw > 0) {
+                    /*to avoid ca noise in Sony TV*/
+                    struct snd_pcm_status status;
+                    pcm_ioctl(out->pcm, SNDRV_PCM_IOCTL_STATUS, &status);
                     if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm) {
+                        pcm_ioctl(out->earc_pcm, SNDRV_PCM_IOCTL_STATUS, &status);
+                    }
+                    if (status.state == PCM_STATE_SETUP ||
+                        status.state == PCM_STATE_PREPARED ||
+                        status.state == PCM_STATE_XRUN) {
+                        ALOGI("mute the first raw data");
+                        memset(ddp_dec->outbuf_raw, 0, ddp_dec->outlen_raw);
+                    }
+                    if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm/* && adev->bHDMIARCon */) {
                         ret = pcm_write (out->earc_pcm, ddp_dec->outbuf_raw, ddp_dec->outlen_raw);
                     } else {
                         ret = pcm_write (out->pcm, ddp_dec->outbuf_raw, ddp_dec->outlen_raw);
@@ -3132,6 +3245,7 @@ rewrite:
             write_buf = convert_audio_sample_for_output (input_frames,
                     out->hal_internal_format, out->multich, buf, &write_size);
             //volume apply here,TODO need apply that inside convert_audio_sample_for_output function.
+            if (write_buf) {
             if (out->multich == 2) {
                 short *sample = (short*) write_buf;
                 int l, r;
@@ -3150,9 +3264,8 @@ rewrite:
                 }
             }
 
-            if (write_buf) {
                 if (getprop_bool ("media.hdmihal.outdump") ) {
-                    FILE *fp1 = fopen ("/data/tmp/hdmi_audio_out8.pcm", "a+");
+                    FILE *fp1 = fopen ("/data/vendor/audiohal/hdmi_audio_out8.pcm", "a+");
                     if (fp1) {
                         int flen = fwrite ( (char *) buffer, 1, out_frames * frame_size, fp1);
                         ALOGD ("flen = %d---outlen=%zu ", flen, out_frames * frame_size);
@@ -3161,7 +3274,7 @@ rewrite:
                         ALOGD ("could not open file:/data/hdmi_audio_out.pcm");
                     }
                 }
-                if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm && adev->bHDMIARCon) {
+                if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm/* && adev->bHDMIARCon */) {
                     ret = pcm_write (out->earc_pcm, write_buf, write_size);
                 } else {
                     ret = pcm_write (out->pcm, write_buf, write_size);
@@ -3189,7 +3302,7 @@ rewrite:
                 }
             }
 #if 0
-            FILE *fp1 = fopen ("/data/pcm_write_passthrough.pcm", "a+");
+            FILE *fp1 = fopen ("/data/vendor/audiohal/pcm_write_passthrough.pcm", "a+");
             if (fp1) {
                 int flen = fwrite ( (char *) buf, 1, out_frames * frame_size, fp1);
                 //ALOGD("flen = %d---outlen=%d ", flen, out_frames * frame_size);
@@ -3198,7 +3311,7 @@ rewrite:
                 ALOGD ("could not open file:/data/pcm_write_passthrough.pcm");
             }
 #endif
-            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm && adev->bHDMIARCon) {
+            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && out->earc_pcm/* && adev->bHDMIARCon */) {
                 ret = pcm_write (out->earc_pcm, (void *) buf, out_frames * frame_size);
             } else {
                 ret = pcm_write (out->pcm, (void *) buf, out_frames * frame_size);
@@ -3215,11 +3328,8 @@ exit:
     total_frame = out->frame_write_sum + out->frame_skip_sum;
     //ALSA hw latency fames
     latency_frames = out_get_latency_frames(stream);
-    //latency_frames += HDMI_LATENCY_MS * 48;
-    //mantual tunning latency frames
-    int tuning_latency_frame = aml_audio_get_arc_latency_offset(adev->sink_format)*48;
     int total_latency_frame = 0;
-    total_latency_frame = tuning_latency_frame + latency_frames;
+    total_latency_frame = latency_frames;
     clock_gettime (CLOCK_MONOTONIC, &out->timestamp);
     out->lasttimestamp.tv_sec = out->timestamp.tv_sec;
     out->lasttimestamp.tv_nsec = out->timestamp.tv_nsec;
@@ -3229,8 +3339,8 @@ exit:
         out->last_frames_postion = total_frame - total_latency_frame;//total_frame;
     }
     if (adev->debug_flag)
-        ALOGD("out %p,out->last_frames_postion %"PRId64", total latency frame = %d, skp sum %lld , tune frames %d,alsa frame %d\n",
-            out, out->last_frames_postion, total_latency_frame, out->frame_skip_sum,tuning_latency_frame,latency_frames);
+        ALOGD("out %p,out->last_frames_postion %"PRId64", total latency frame = %d, skp sum %lld ,alsa frame %d\n",
+            out, out->last_frames_postion, total_latency_frame, out->frame_skip_sum,latency_frames);
     pthread_mutex_unlock (&out->lock);
     if (ret != 0) {
         usleep (bytes * 1000000 / audio_stream_out_frame_size (stream) /
@@ -3253,49 +3363,22 @@ exit:
 static int out_get_render_position (const struct audio_stream_out *stream,
                                     uint32_t *dsp_frames)
 {
-    struct aml_stream_out *out = (struct aml_stream_out *)stream;
+    int ret = 0;
+    uint64_t  dsp_frame_uint64 = 0;
+    struct timespec timetamp = {0};
+    struct aml_stream_out *out = (struct aml_stream_out *) stream;
     struct aml_audio_device *adev = out->dev;
-    uint64_t  dsp_frame_int64 = out->last_frames_postion;
-    *dsp_frames = (uint32_t)(dsp_frame_int64 & 0xffffffff);
-    if (out->flags & AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO) {
-        //dsp_frame_int64 = out->last_frames_postion ;
-        //*dsp_frames = (uint32_t)(dsp_frame_int64 & 0xffffffff);
-        if (out->last_dsp_frame > dsp_frame_int64) {
-            ALOGI("maybe uint32_t wraparound,print something,last %u,now %u", out->last_dsp_frame, *dsp_frames);
-            ALOGI("wraparound,out_get_render_position return %u,playback time %"PRIu64" ms,sr %d\n", *dsp_frames,
-                  out->last_frames_postion * 1000 / out->config.rate, out->config.rate);
-        }
-    }
-    if (eDolbyMS12Lib == adev->dolby_lib_type) {
-        /*
-         *1.after MS12, output(pcm/dd/dd+) samplerate is changed to 48kHz,
-         *handle the case hal_rate != 48KHz
-         *2.Bypass MS12, do not go through this process.
-         */
-        if ((out->hal_rate != MM_FULL_POWER_SAMPLING_RATE) &&
-            (!is_bypass_dolbyms12((struct audio_stream_out *)stream))) {
-            dsp_frame_int64 = (dsp_frame_int64 * out->hal_rate) / MM_FULL_POWER_SAMPLING_RATE;
-        }
-        *dsp_frames = (uint32_t)(dsp_frame_int64 & 0xffffffff);
-        if (direct_continous((struct audio_stream_out *)stream)) {
-            *dsp_frames = adev->ms12.last_frames_postion;
-        }
+    *dsp_frames = 0;
+    ret = out_get_presentation_position(stream, &dsp_frame_uint64,&timetamp);
+    if (ret == 0)
+    {
+        *dsp_frames = (uint32_t)(dsp_frame_uint64 & 0xffffffff);
     }
 
-    if (adev->active_outport == OUTPORT_HDMI_ARC && !adev->continuous_audio_mode) {
-        int arc_latency_ms = 0;
-        int frame_latency = 0;
-        arc_latency_ms = aml_audio_get_arc_latency_offset(adev->sink_format);
-        //TODO we support it is 1 48K audio
-        frame_latency = arc_latency_ms * 48;
-        *dsp_frames += frame_latency;
-    }
-    if (*dsp_frames < 0)
-        *dsp_frames = 0;
     if (adev->debug_flag) {
-        ALOGI("out_get_render_position %d \n", *dsp_frames);
+        ALOGD("%s,pos %d\n",__func__,*dsp_frames);
     }
-    return 0;
+    return ret;
 }
 
 static int out_add_audio_effect (const struct audio_stream *stream, effect_handle_t effect)
@@ -3321,11 +3404,7 @@ static int out_add_audio_effect (const struct audio_stream *stream, effect_handl
     }
 
     dev->native_postprocess.postprocessors[dev->native_postprocess.num_postprocessors++] = effect;
-    /*add for virtualx. specify effect order
-     according to dts profile2 block diagram: Trusurround:X->Truvolume->TBHDX->customer modules->MC Dynamics
-     virtualx will be called twice,first implementation for process Trusurround:X->Truvolume->TBHDX
-     final implementation for process MC Dynamics
-    */
+    /*specify effect order for virtualx.*/
     effect_descriptor_t tmpdesc;
     for ( i = 0; i < dev->native_postprocess.num_postprocessors; i++) {
         (*effect)->get_descriptor(dev->native_postprocess.postprocessors[i], &tmpdesc);
@@ -3391,6 +3470,16 @@ static int out_get_next_write_timestamp (const struct audio_stream_out *stream _
     return ESRCH;
 }
 
+
+static uint64_t internal_calc_frames(uint64_t frames,int frame_latency)
+{
+    if (frames >= (uint64_t)abs(frame_latency)) {
+        return frames + frame_latency;
+    }
+
+    return 0;
+}
+
 //actually maybe it be not useful now  except pass CTS_TEST:
 //  run cts -c android.media.cts.AudioTrackTest -m testGetTimestamp
 static int out_get_presentation_position (const struct audio_stream_out *stream, uint64_t *frames, struct timespec *timestamp)
@@ -3398,55 +3487,115 @@ static int out_get_presentation_position (const struct audio_stream_out *stream,
     struct aml_stream_out *out = (struct aml_stream_out *) stream;
     struct aml_audio_device *adev = out->dev;
     uint64_t frames_written_hw = out->last_frames_postion;
+    int frame_latency = 0;
+    int b_raw = 0;
     if (!frames || !timestamp) {
         ALOGI("%s, !frames || !timestamp\n", __FUNCTION__);
         return -EINVAL;
     }
 
-    if (eDolbyMS12Lib == adev->dolby_lib_type) {
-        /*
-         *1.after MS12, output(pcm/dd/dd+) samplerate is changed to 48kHz,
-         *handle the case hal_rate != 48KHz
-         *2.Bypass MS12, do not go through this process.
-         */
-        if ((out->hal_rate != MM_FULL_POWER_SAMPLING_RATE) &&
-            (!is_bypass_dolbyms12((struct audio_stream_out *)stream))) {
-            frames_written_hw = (frames_written_hw * out->hal_rate) / MM_FULL_POWER_SAMPLING_RATE;
-        }
-    }
-
     if (frames_written_hw == 0) {
         ALOGV("%s(), not ready yet", __func__);
         return -EINVAL;
     }
     *frames = frames_written_hw;
     *timestamp = out->lasttimestamp;
-    if (eDolbyMS12Lib == adev->dolby_lib_type) {
+    if (out->is_normal_pcm && eDolbyMS12Lib == adev->dolby_lib_type && adev->ms12.dolby_ms12_enable) {
+        *frames = adev->ms12.sys_audio_frame_pos;
+        *timestamp = adev->ms12.sys_audio_timestamp;
+    }
+
+
+    if (eDolbyMS12Lib == adev->dolby_lib_type && !is_bypass_dolbyms12((struct audio_stream_out *)stream)) {
+
         if (direct_continous((struct audio_stream_out *)stream)) {
             *frames = adev->ms12.last_frames_postion;
             *timestamp = adev->ms12.timestamp;
         }
-    }
-    if (adev->active_outport == OUTPORT_HDMI_ARC && !adev->continuous_audio_mode) {
+
+        /*when it is ddp5.1 or heaac we need use different latency control*/
+        if (audio_is_linear_pcm(out->hal_internal_format)) {
+            b_raw = 0;
+        } else {
+            b_raw = 1;
+        }
+        frame_latency = aml_audio_get_ms12_latency_offset(b_raw) * 48;
+
+        if ((adev->ms12.is_dolby_atmos && adev->ms12_main1_dolby_dummy == false) || adev->atoms_lock_flag) {
+            int tunnel = 0;
+            frame_latency -= aml_audio_get_ms12_atmos_latency_offset(tunnel) * 48;
+        }
+        *frames = internal_calc_frames(*frames,frame_latency);
+       }
+    /* here to tune the addtional  HDMITX/ARC sink latency by different output format.
+      * if we have already  tuned the HDMITX/ARC latency through the aml_audio_get_ms12_latency_offset
+      * API, we may not need to tune this  again.
+      */
+
+    *frames += aml_audio_get_video_latency()*48;
+
+    if (adev->active_outport == OUTPORT_HDMI_ARC || adev->active_outport == OUTPORT_HDMI) {
         int arc_latency_ms = 0;
-        int frame_latency = 0;
-        arc_latency_ms = aml_audio_get_arc_latency_offset(adev->sink_format);
+        arc_latency_ms = aml_audio_get_hdmi_latency_offset(adev->sink_format);
         //TODO we support it is 1 48K audio
         frame_latency = arc_latency_ms * 48;
-        *frames += frame_latency;
+        if ((adev->ms12.is_dolby_atmos && adev->ms12_main1_dolby_dummy == false) || adev->atoms_lock_flag)
+         {
+             int bypass = is_bypass_ms12((struct audio_stream_out *)stream);
+              frame_latency +=  aml_audio_get_atmos_hdmi_latency_offset(adev->sink_format,bypass)*48;
+         }
+
+        *frames = internal_calc_frames(*frames,frame_latency);
+        frame_latency = aml_audio_get_ms12_passthrough_latency((struct audio_stream_out*)stream)*48;
+        *frames = internal_calc_frames(*frames,frame_latency);
+    } else {
+        int speaker_latency_ms = 0;
+        speaker_latency_ms = aml_audio_get_speaker_latency_offset(out->hal_internal_format);
+        //TODO we support it is 1 48K audio
+        frame_latency = speaker_latency_ms * 48;
+        *frames = internal_calc_frames(*frames,frame_latency);
     }
-    if (*frames < 0)
-        *frames = 0;
-    if (adev->debug_flag) {
-        ALOGI("out_get_presentation_position out %p %"PRIu64", sec = %ld, nanosec = %ld\n", out, *frames, timestamp->tv_sec, timestamp->tv_nsec);
+
+
+    if (eDolbyMS12Lib == adev->dolby_lib_type) {
+        /*
+         *1.after MS12, output(pcm/dd/dd+) samplerate is changed to 48kHz,
+         *handle the case hal_rate != 48KHz
+         *2.Bypass MS12, do not go through this process.
+         */
+        if ((out->hal_rate != MM_FULL_POWER_SAMPLING_RATE) &&
+            (!is_bypass_dolbyms12((struct audio_stream_out *)stream))) {
+            *frames = (*frames * out->hal_rate) / MM_FULL_POWER_SAMPLING_RATE;
+        }
     }
+
+
+    if (adev->debug_flag) {
+        ALOGI("%s stream %p %"PRIu64", sec = %ld, nanosec = %ld\n",
+           __func__,out, *frames, timestamp->tv_sec, timestamp->tv_nsec);
+    }
+    int64_t  frame_diff_ms =  (*frames - out->last_frame_reported)*MSPERSECOND/out->hal_rate;
+    int64_t  system_time_ms = 0;
+    system_time_ms = calc_time_interval_us(&out->last_timestamp_reported, timestamp)/MSPERSECOND;
+    int64_t jitter_diff = llabs(frame_diff_ms - system_time_ms);
+    if  (jitter_diff > JITTER_DURATION_MS && adev->debug_flag) {
+        ALOGW("%s audio postion  jitter. stream %p %"PRIu64",last sec = %ld, last nanosec = %ld\n",
+                    __func__,out, out->last_frame_reported,
+                    out->last_timestamp_reported.tv_sec, out->last_timestamp_reported.tv_nsec);
+        ALOGW("%s  audio postion  jitter.  system time diff %"PRIu64" ms, audio position diff %"PRIu64" ms, jitter %"PRIu64" ms \n",
+                    __func__,system_time_ms,frame_diff_ms,jitter_diff);
+    }
+    out->last_frame_reported = *frames;
+    out->last_timestamp_reported = *timestamp;
+
     return 0;
 }
 
 /** audio_stream_in implementation **/
-static unsigned int select_port_by_device(audio_devices_t in_device)
+static unsigned int select_port_by_device(struct aml_audio_device *adev)
 {
     unsigned int inport = PORT_I2S;
+    audio_devices_t in_device = adev->in_device;
 
     if (in_device & AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET) {
         inport = PORT_PCM;
@@ -3465,7 +3614,22 @@ static unsigned int select_port_by_device(audio_devices_t in_device)
         }
     } else if ((in_device & AUDIO_DEVICE_IN_BACK_MIC) ||
             (in_device & AUDIO_DEVICE_IN_BUILTIN_MIC)) {
-        inport = PORT_BUILTINMIC;
+        if (adev->mic_desc) {
+            struct mic_in_desc *desc = adev->mic_desc;
+
+            switch (desc->mic) {
+            case DEV_MIC_PDM:
+                inport = PROT_PDM;
+                break;
+            case DEV_MIC_TDM:
+                inport = PORT_BUILTINMIC;
+                break;
+            default:
+                inport = PORT_BUILTINMIC;
+                break;
+            }
+        } else
+            inport = PORT_BUILTINMIC;
     } else {
         /* fix auge tv input, hdmirx, tunner */
         if (alsa_device_is_auge()
@@ -3511,15 +3675,6 @@ static int start_input_stream(struct aml_stream_in *in)
     ret = choose_stream_pcm_config(in);
     if (ret < 0)
         return -EINVAL;
-    if (in->requested_rate != in->config.rate) {
-        ret = add_in_stream_resampler(in);
-        if (ret < 0)
-            return -EINVAL;
-    }
-
-    ALOGI("%s: device(%x) channels=%d rate=%d requested_rate=%d mode= %d",
-        __func__, in->device, in->config.channels,
-        in->config.rate, in->requested_rate, adev->mode);
 
     adev->active_input = in;
     if (adev->mode != AUDIO_MODE_IN_CALL) {
@@ -3528,15 +3683,14 @@ static int start_input_stream(struct aml_stream_in *in)
     }
 
     card = alsa_device_get_card_index();
-    port = select_port_by_device(adev->in_device);
+    port = select_port_by_device(adev);
     /* check to update alsa device by port */
     alsa_device = alsa_device_update_pcm_index(port, CAPTURE);
-    ALOGI("*%s, open alsa_card(%d) alsa_device(%d), in_device:0x%x\n",
+    ALOGD("*%s, open alsa_card(%d) alsa_device(%d), in_device:0x%x\n",
         __func__, card, alsa_device, adev->in_device);
 
     /* this assumes routing is done previously */
-    //in->pcm = pcm_open(card, alsa_device, PCM_IN | PCM_NONEBLOCK, &in->config);
-    in->pcm = pcm_open(card, alsa_device, PCM_IN, &in->config);
+    in->pcm = pcm_open(card, alsa_device, PCM_IN | PCM_NONBLOCK, &in->config);
     if (!pcm_is_ready(in->pcm)) {
         ALOGE("%s: cannot open pcm_in driver: %s", __func__, pcm_get_error(in->pcm));
         pcm_close (in->pcm);
@@ -3544,6 +3698,21 @@ static int start_input_stream(struct aml_stream_in *in)
         return -ENOMEM;
     }
 
+    if (in->requested_rate != in->config.rate) {
+        ret = add_in_stream_resampler(in);
+        if (ret < 0) {
+            pcm_close (in->pcm);
+            adev->active_input = NULL;
+            return -EINVAL;
+        }
+    }
+
+    ALOGD("%s: device(%x) channels=%d rate=%d requested_rate=%d mode= %d,in->pcm=%p",
+        __func__, in->device, in->config.channels,
+        in->config.rate, in->requested_rate, adev->mode,in->pcm);
+
+
+
     /* if no supported sample rate is available, use the resampler */
     if (in->resampler) {
         in->resampler->reset(in->resampler);
@@ -3611,7 +3780,6 @@ static audio_format_t in_get_format(const struct audio_stream *stream)
     if ((in->device & AUDIO_DEVICE_IN_LINE) && in->ref_count == 1)
         return AUDIO_FORMAT_PCM_32_BIT;
 #endif
-
     return in->hal_format;
 }
 
@@ -3810,7 +3978,7 @@ static int get_next_buffer (struct resampler_buffer_provider *buffer_provider,
 
     if (in->frames_in == 0) {
         in->read_status = aml_alsa_input_read ((struct audio_stream_in *)in, (void*) in->buffer,
-                                    in->config.period_size * audio_stream_in_frame_size (&in->stream) );
+            in->config.period_size * audio_stream_in_frame_size (&in->stream) );
         if (in->read_status != 0) {
             ALOGE ("get_next_buffer() pcm_read error %d", in->read_status);
             buffer->raw = NULL;
@@ -4023,7 +4191,7 @@ static void inread_proc_aec(struct audio_stream_in *stream,
 /* here to fix pcm switch to raw nosie issue ,it is caused by hardware format detection later than output
 so we delay pcm output one frame to work around the issue,but it has a negative effect on av sync when normal
 pcm playback.abouot delay audio 21.3*BT_AND_USB_PERIOD_DELAY_BUF_CNT ms */
-static void processBtAndUsbCardData(struct aml_stream_in *in, struct aml_audio_parser *parser, void *pBuffer, size_t bytes)
+static void processBtAndUsbCardData(struct aml_stream_in *in, audio_format_t format, void *pBuffer, size_t bytes)
 {
     bool bIsBufNull = false;
     for (int i=0; i<BT_AND_USB_PERIOD_DELAY_BUF_CNT; i++) {
@@ -4042,7 +4210,7 @@ static void processBtAndUsbCardData(struct aml_stream_in *in, struct aml_audio_p
         in->delay_buffer_size = bytes;
     }
 
-    if (AUDIO_FORMAT_PCM_16_BIT == parser->aformat || AUDIO_FORMAT_PCM_32_BIT == parser->aformat) {
+    if (AUDIO_FORMAT_PCM_16_BIT == format || AUDIO_FORMAT_PCM_32_BIT == format) {
         memcpy(in->pBtUsbTempDelayBuf, pBuffer, bytes);
         memcpy(pBuffer, in->pBtUsbPeriodDelayBuf[BT_AND_USB_PERIOD_DELAY_BUF_CNT-1], bytes);
         for (int i=BT_AND_USB_PERIOD_DELAY_BUF_CNT-1; i>0; i--) {
@@ -4052,6 +4220,100 @@ static void processBtAndUsbCardData(struct aml_stream_in *in, struct aml_audio_p
     }
 }
 
+static void processHdmiInputFormatChange(struct aml_stream_in *in, struct aml_audio_parser *parser)
+{
+    audio_format_t enCurFormat = audio_parse_get_audio_type(parser->audio_parse_para);
+    if (enCurFormat != parser->aformat) {
+        ALOGI("%s:%d input format changed from %#x to %#x, PreDecType:%#x", __func__, __LINE__, parser->aformat, enCurFormat, parser->enCurDecType);
+        for (int i=0; i<BT_AND_USB_PERIOD_DELAY_BUF_CNT; i++) {
+             memset(in->pBtUsbPeriodDelayBuf[i], 0, in->delay_buffer_size);
+        }
+        parser->in = in;
+        if (AUDIO_FORMAT_PCM_16_BIT == enCurFormat) {
+            if (AUDIO_FORMAT_AC3 == parser->aformat || AUDIO_FORMAT_E_AC3 == parser->aformat) {//from dd/dd+ -> pcm
+                dcv_decode_release(parser);
+            } else if (AUDIO_FORMAT_DTS == parser->aformat || AUDIO_FORMAT_DTS_HD == parser->aformat) {//from dts -> pcm
+                dca_decode_release(parser);
+            } else if (AUDIO_FORMAT_INVALID == parser->aformat) {//from PAUSE or MUTE -> pcm
+                if (AML_AUDIO_DECODER_TYPE_DOLBY == parser->enCurDecType) {
+                    dcv_decode_release(parser);
+                } else if (AML_AUDIO_DECODER_TYPE_DTS == parser->enCurDecType){
+                    dca_decode_release(parser);
+                }
+            }
+            parser->enCurDecType = AML_AUDIO_DECODER_TYPE_NONE;
+        } else if (AUDIO_FORMAT_AC3 == enCurFormat || AUDIO_FORMAT_E_AC3 == enCurFormat) {
+            if (AUDIO_FORMAT_PCM_16_BIT == parser->aformat) {//from pcm -> dd/dd+
+                dcv_decode_init(parser);
+            } else {
+                if (AML_AUDIO_DECODER_TYPE_NONE == parser->enCurDecType) {// non-dd/dd+ decoder scene
+                    dcv_decode_init(parser);
+                } else if (AML_AUDIO_DECODER_TYPE_DTS == parser->enCurDecType) {//from dts -> dd/dd+
+                    dca_decode_release(parser);
+                    dcv_decode_init(parser);
+                } else {
+                    ALOGI("from pause or mute to continue play Dolby audio");
+                }
+            }
+            parser->enCurDecType = AML_AUDIO_DECODER_TYPE_DOLBY;
+        } else if (AUDIO_FORMAT_DTS == enCurFormat || AUDIO_FORMAT_DTS_HD == enCurFormat) {
+            if (AUDIO_FORMAT_PCM_16_BIT == parser->aformat) {//from pcm -> dts
+                dca_decode_init(parser);
+            } else {
+                if (AML_AUDIO_DECODER_TYPE_NONE == parser->enCurDecType) {// non-dts decoder scene
+                    dca_decode_init(parser);
+                } else if (AML_AUDIO_DECODER_TYPE_DOLBY == parser->enCurDecType) {//from dd/dd+ -> dts
+                    dcv_decode_release(parser);
+                    dca_decode_init(parser);
+                } else {
+                    ALOGI("from pause or mute to continue play DTS audio");
+                }
+            }
+            parser->enCurDecType = AML_AUDIO_DECODER_TYPE_DTS;
+        } else if (enCurFormat == AUDIO_FORMAT_INVALID) {
+            ALOGI("cur format invalid, do nothing");
+        } else {
+            ALOGW("This format unsupport or no need to reset decoder!");
+        }
+        parser->aformat = enCurFormat;
+    }
+}
+
+static size_t parserRingBufferDataRead(struct aml_audio_parser *parser, void* buffer, size_t bytes)
+{
+    int ret = 0;
+    /*if data is ready, read from buffer.*/
+    if (parser->data_ready == 1) {
+        ret = ring_buffer_read(&parser->aml_ringbuffer, (unsigned char*)buffer, bytes);
+        if (ret < 0) {
+            ALOGE("%s:%d parser in_read err", __func__, __LINE__);
+        } else if (ret == 0) {
+            unsigned int u32TimeoutMs = 40;
+            while (u32TimeoutMs > 0) {
+                usleep(5000);
+                ret = ring_buffer_read(&parser->aml_ringbuffer, (unsigned char*)buffer, bytes);
+                if (parser->aformat == AUDIO_FORMAT_INVALID) { // don't need to wait when the format is unavailable
+                    break;
+                }
+                if (ret > 0) {
+                    bytes = ret;
+                    break;
+                }
+                u32TimeoutMs -= 5;
+            }
+            if (u32TimeoutMs <= 0) {
+                memset (buffer, 0, bytes);
+                ALOGW("%s:%d read parser ring buffer timeout 40 ms, insert mute data", __func__, __LINE__);
+            }
+        } else {
+            bytes = ret;
+        }
+    } else {
+        memset (buffer, 0, bytes);
+    }
+    return bytes;
+}
+
 static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t bytes)
 {
     int ret = 0;
@@ -4060,6 +4322,7 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
     struct aml_audio_parser *parser = adev->aml_parser;
     int channel_count = audio_channel_count_from_in_mask(in->hal_channel_mask);
     size_t in_frames = bytes / audio_stream_in_frame_size(&in->stream);
+    struct aml_audio_patch* patch = adev->audio_patch;
     size_t cur_in_bytes, cur_in_frames;
     int in_mute = 0, parental_mute = 0;
     bool stable = true;
@@ -4072,7 +4335,6 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
      * mutex
      */
     pthread_mutex_lock(&in->lock);
-
     /* For voice communication BT & MIC switches */
     if (adev->active_inport == INPORT_BT_SCO_HEADSET_MIC) {
         int ret = 0;
@@ -4095,61 +4357,12 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
     }
     /* if audio patch type is hdmi to mixer, check audio format from hdmi*/
     if (adev->patch_src == SRC_HDMIIN && parser != NULL) {
-        audio_format_t cur_aformat = audio_parse_get_audio_type(parser->audio_parse_para);
-        if (cur_aformat != parser->aformat) {
-            ALOGI("%s: input format changed from %#x to %#x", __func__, parser->aformat, cur_aformat);
-            for (int i=0; i<BT_AND_USB_PERIOD_DELAY_BUF_CNT; i++) {
-                 memset(in->pBtUsbPeriodDelayBuf[i], 0, in->delay_buffer_size);
-            }
-            if (parser->aformat == AUDIO_FORMAT_PCM_16_BIT && //from pcm -> dd/dd+
-                (cur_aformat == AUDIO_FORMAT_AC3 || cur_aformat == AUDIO_FORMAT_E_AC3)) {
-                parser->aml_pcm = in->pcm;
-                parser->stream = stream;
-                parser->in_sample_rate = in->config.rate;
-                parser->out_sample_rate = in->requested_rate;
-                parser->decode_dev_op_mutex = &in->lock;
-                parser->data_ready = 0;
-                dcv_decode_init(parser);
-            } else if (parser->aformat == AUDIO_FORMAT_PCM_16_BIT && //from pcm -> dts
-                (cur_aformat == AUDIO_FORMAT_DTS || cur_aformat == AUDIO_FORMAT_DTS_HD)) {
-                parser->aml_pcm = in->pcm;
-                parser->stream = stream;
-                parser->in_sample_rate = in->config.rate;
-                parser->out_sample_rate = in->requested_rate;
-                parser->decode_dev_op_mutex = &in->lock;
-                parser->data_ready = 0;
-                dca_decode_init(parser);
-            } else if (cur_aformat == AUDIO_FORMAT_PCM_16_BIT && //from dd/dd+ -> pcm
-                       (parser->aformat == AUDIO_FORMAT_AC3 || parser->aformat == AUDIO_FORMAT_E_AC3)) {
-                dcv_decode_release(parser);
-                ring_buffer_reset(&(parser->aml_ringbuffer));
-            } else if (cur_aformat == AUDIO_FORMAT_PCM_16_BIT && //from dts -> pcm
-                       (parser->aformat == AUDIO_FORMAT_DTS || parser->aformat == AUDIO_FORMAT_DTS_HD)) {
-                dca_decode_release(parser);
-                ring_buffer_reset(&(parser->aml_ringbuffer));
-            } else {
-                ALOGI("This format unsupport or no need to reset decoder!\n");
-            }
-            parser->aformat = cur_aformat;
-        }
+        processHdmiInputFormatChange(in, parser);
     }
     /*if raw data from hdmi and decoder is ready read from decoder buffer*/
     if (parser != NULL && parser->decode_enabled == 1) {
-        /*if data is ready, read from buffer.*/
-        if (parser->data_ready == 1) {
-            ret = ring_buffer_read(&parser->aml_ringbuffer, (unsigned char*)buffer, bytes);
-            if (ret < 0) {
-                ALOGE("%s(), parser in_read err", __func__);
-                goto exit;
-            } else if (ret == 0) {
-                memset(buffer, 0, bytes);
-            } else {
-                bytes = ret;
-            }
-        } else
-            memset (buffer, 0, bytes);
+        bytes = parserRingBufferDataRead(parser, buffer, bytes);
     }
-
 #ifdef ENABLE_AEC_FUNC
     if (in->device & AUDIO_DEVICE_IN_BUILTIN_MIC) {
         size_t read_size = 0;
@@ -4169,7 +4382,6 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
         read_size = cur_in_bytes * 2;
         ret = aml_alsa_input_read(stream, in->tmp_buffer_8ch, read_size);
     }
-    else
 #endif
 #ifdef ENABLE_DTV_PATCH
     if (adev->patch_src == SRC_DTV && adev->tuner2mix_patch == 1)
@@ -4178,7 +4390,8 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
             ALOGD("%s:%d dtv_in_read data size:%d, src_gain:%f",__func__,__LINE__, bytes, adev->src_gain[adev->active_inport]);
         }
         ret = dtv_in_read(stream, buffer, bytes);
-        apply_volume(adev->src_gain[adev->active_inport], buffer, sizeof(uint16_t), bytes);
+        if (adev->src_gain[adev->active_inport] != 1.0)
+            apply_volume(adev->src_gain[adev->active_inport], buffer, sizeof(uint16_t), bytes);
         goto exit;
     } else
 #endif
@@ -4188,7 +4401,12 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
          * the mute time is related to hdmi audio buffer size
          */
         bool stable = signal_status_check(adev->in_device, &in->mute_mdelay, stream);
-
+        if (adev->atv_switch) {
+            stable = false;
+            adev->atv_switch = false;
+            in->mute_log_cntr = 0;
+            ALOGD("%s: switch channel force unstable", __func__);
+        }
         if (!stable) {
             if (in->mute_log_cntr == 0)
                 ALOGI("%s: audio is unstable, mute channel", __func__);
@@ -4199,15 +4417,25 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
             adev->patch_start = false;
             in->mute_flag = 1;
         }
+
         if (in->mute_flag == 1) {
             in_mute = Stop_watch(in->mute_start_ts, in->mute_mdelay);
             if (!in_mute) {
-                ALOGI("%s: unmute audio since audio signal is stable", __func__);
+                ALOGV("%s: unmute audio since audio signal is stable", __func__);
                 in->mute_log_cntr = 0;
                 in->mute_flag = 0;
                 /* fade in start */
-                ALOGI("start fade in");
+                ALOGV("start fade in");
                 start_ease_in(adev);
+                if (adev->tuner2mix_patch || (adev->patch_src == SRC_HDMIIN && parser != NULL)) {
+                    ALOGD("%s: flush", __func__);
+                    aml_alsa_input_flush(stream);
+                    for (int i=0; i<BT_AND_USB_PERIOD_DELAY_BUF_CNT; i++) {
+                        if (in->pBtUsbPeriodDelayBuf[i]) {
+                            memset(in->pBtUsbPeriodDelayBuf[i], 0, in->delay_buffer_size);
+                        }
+                    }
+                }
             }
         }
 
@@ -4221,19 +4449,32 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
             }
             memset(buffer, 0, bytes);
             unsigned int estimated_sched_time_us = 1000;
-            uint64_t frame_duration = bytes * 1000000 / audio_stream_in_frame_size(stream) /
+            uint64_t frame_duration = (uint64_t)bytes * 1000000 / audio_stream_in_frame_size(stream) /
                     in_get_sample_rate(&stream->common);
 
             if (frame_duration > estimated_sched_time_us) {
                 usleep(frame_duration - estimated_sched_time_us);
             }
+
+            /* when audio is unstable, start avaync*/
+            if (patch && in_mute) {
+                patch->need_do_avsync = true;
+                patch->input_signal_stable = false;
+            }
         } else {
             if (adev->debug_flag) {
-                ALOGD("%s:%d pcm_read data size:%d, channels:%d, pResampler:%p",__func__,__LINE__, bytes, in->config.channels, in->resampler);
+                ALOGD("%s:%d pcm_read data size:%d, channels:%d, pResampler:%p", __func__, __LINE__,
+                    bytes, in->config.channels, in->resampler);
+            }
+
+            if (patch) {
+                patch->input_signal_stable = true;
             }
+
             if (in->resampler) {
                 ret = read_frames(in, buffer, in_frames);
             } else {
+#ifdef MULTI_CHANNEL_DOWNMIX
                 //if input channel count from hdmirx is 8, do audio downmix.
                 if (in->config.channels == 8) {
                     if (in->input_tmp_buffer ||
@@ -4265,11 +4506,28 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
                         *out_ptr++ = (int32_t)(left >> 2);
                         *out_ptr++ = (int32_t)(right >> 2);
                     }
+                } else if (in->config.channels == 4 ||
+                        (in->config.channels == 2 && channel_count != 2)) {
+                    unsigned int mult = in->config.channels / channel_count;
+                    size_t read_bytes = mult * bytes;
+
+                    if (in->input_tmp_buffer ||
+                        in->input_tmp_buffer_size < read_bytes) {
+                        in->input_tmp_buffer = realloc(in->input_tmp_buffer, read_bytes);
+                        in->input_tmp_buffer_size = read_bytes;
+                    }
+                    aml_alsa_input_read(stream, in->input_tmp_buffer, read_bytes);
+                    adjust_channels(in->input_tmp_buffer, in->config.channels,
+                            buffer, channel_count, 2, read_bytes);
                 } else if (!((adev->in_device & AUDIO_DEVICE_IN_HDMI_ARC) &&
                         (access(SYS_NODE_EARC_RX, F_OK) == 0) &&
                         (aml_mixer_ctrl_get_int(&adev->alsa_mixer,
                                 AML_MIXER_ID_HDMI_EARC_AUDIO_ENABLE) == 0))) {
                     ret = aml_alsa_input_read(stream, buffer, bytes);
+                } else
+#endif
+                {
+                    ret = aml_alsa_input_read(stream, buffer, bytes);
                 }
             }
 
@@ -4277,6 +4535,7 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
                 if (adev->debug_flag) {
                     ALOGE("%s:%d pcm_read fail, ret:%s",__func__,__LINE__, strerror(errno));
                 }
+                bytes = 0;
                 goto exit;
             }
             if ((adev->in_device & AUDIO_DEVICE_IN_TV_TUNER) && in->first_buffer_discard) {
@@ -4303,6 +4562,7 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
     } else
 #endif
     if (!adev->audio_patching) {
+#ifdef AML_EQ_DRC
         /* case dev->mix, set audio gain to src and TV source gain */
         float source_gain;
         if (adev->patch_src == SRC_HDMIIN)
@@ -4312,31 +4572,36 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer, size_t byte
         else if (adev->patch_src == SRC_ATV)
             source_gain = adev->eq_data.s_gain.atv;
         else
-            source_gain = 1.0;
-
+            source_gain = adev->eq_data.s_gain.media;
+#else
+        float source_gain = 1.0;
+#endif
         source_gain *= adev->src_gain[adev->active_inport];
         apply_volume(source_gain, buffer, sizeof(int16_t), bytes);
     }
 
 exit:
     if (ret < 0) {
-        ALOGE("%s: read failed - sleeping for buffer duration", __func__);
+        //ALOGE("%s: read failed - sleeping for buffer duration", __func__);
         usleep(bytes * 1000000 / audio_stream_in_frame_size(stream) /
                 in_get_sample_rate(&stream->common));
     }
     pthread_mutex_unlock(&in->lock);
-
     if (SRC_HDMIIN == adev->patch_src && parser != NULL) {
         audio_format_t cur_aformat = audio_parse_get_audio_type(parser->audio_parse_para);
         if ((parser->aformat == AUDIO_FORMAT_PCM_16_BIT && cur_aformat != parser->aformat ) ||
-            (parser->aformat == AUDIO_FORMAT_PCM_32_BIT && cur_aformat != parser->aformat))
+            (parser->aformat == AUDIO_FORMAT_PCM_32_BIT && cur_aformat != parser->aformat) ||
+             parser->aformat == AUDIO_FORMAT_INVALID) {
             memset(buffer , 0 , bytes);
-        else
-            processBtAndUsbCardData(in, parser, buffer, bytes);
+        } else {
+            processBtAndUsbCardData(in, parser->aformat, buffer, bytes);
+        }
+    } else if (SRC_ATV == adev->patch_src && adev->tuner2mix_patch) {
+        processBtAndUsbCardData(in, AUDIO_FORMAT_PCM_16_BIT, buffer, bytes);
     }
 
     if (ret >= 0 && getprop_bool("media.audiohal.indump")) {
-        aml_audio_dump_audio_bitstreams("/data/audio/alsa_read.raw",
+        aml_audio_dump_audio_bitstreams("/data/vendor/audiohal/alsa_read.raw",
             buffer, bytes);
     }
 
@@ -4362,6 +4627,68 @@ static int adev_get_microphones (const struct audio_hw_device *dev __unused,
     return 0;
 }
 
+/****************ch_num's value ******************************
+   Virtual:x   0 : mean 2.0 ch   1 : mean 5.1 ch  param: 47
+   TruvolumeHD 0 : mean 2.0 ch   4 : mean 5.1 ch  param: 70
+   cmdCode     5 : effect setparameter   2 : effect reset
+*************************************************************/
+#define VIRTUALXINMODE   47
+#define TRUVOLUMEINMODE  70
+
+static void virtualx_setparameter(struct aml_audio_device *adev,int param,int ch_num,int cmdCode)
+{
+    effect_descriptor_t tmpdesc;
+    int32_t replyData;
+    uint32_t replySize = sizeof(int32_t);
+    uint32_t cmdSize = (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t));
+    uint32_t buf32[sizeof(effect_param_t) / sizeof(uint32_t) + 2];
+    effect_param_t *p = (effect_param_t *)buf32;
+    p->psize = sizeof(uint32_t);
+    p->vsize = sizeof(uint32_t);
+    *(int32_t *)p->data = param;
+    *((int32_t *)p->data + 1) = ch_num;
+    if (adev->native_postprocess.postprocessors[0] != NULL) {
+        (*(adev->native_postprocess.postprocessors[0]))->get_descriptor(adev->native_postprocess.postprocessors[0], &tmpdesc);
+        if (0 == strcmp(tmpdesc.name,"VirtualX")) {
+            (*adev->native_postprocess.postprocessors[0])->command(adev->native_postprocess.postprocessors[0],cmdCode,cmdSize,
+                (void *)p,&replySize,&replyData);
+        }
+    }
+}
+
+static void update_VX_format (struct aml_stream_out *stream,
+                        bool *need_reconfig_output) {
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device *adev = aml_out->dev;
+
+    char val[PROPERTY_VALUE_MAX];
+    if (property_get("media.libplayer.dtsMulChPcm", val, NULL) > 0) {
+        if (strcmp(val, "true" /*enble 5.1 ch*/) == 0) {
+            if (adev->virtualx_mulch != true) {
+                adev->virtualx_mulch = true;
+                virtualx_setparameter(adev, VIRTUALXINMODE, 1, 5);
+                virtualx_setparameter(adev, TRUVOLUMEINMODE, 4, 5);
+                adev->effect_in_ch = 6;
+                /*reconfig dts  decoder interface*/
+                if (aml_out->hal_internal_format == AUDIO_FORMAT_DTS) {
+                    *need_reconfig_output = true;
+                }
+            }
+        } else if (strcmp(val, "false"/*disable 5.1 ch*/) == 0) {
+            if (adev->virtualx_mulch != false) {
+                adev->virtualx_mulch = false;
+                virtualx_setparameter(adev, VIRTUALXINMODE, 0, 5);
+                virtualx_setparameter(adev, TRUVOLUMEINMODE, 0, 5);
+                adev->effect_in_ch = 2;
+                /*reconfig dts  decoder interface*/
+                if (aml_out->hal_internal_format == AUDIO_FORMAT_DTS) {
+                    *need_reconfig_output = true;
+                }
+            }
+        }
+    }
+}
+
 // open corresponding stream by flags, formats and others params
 static int adev_open_output_stream(struct audio_hw_device *dev,
                                 audio_io_handle_t handle __unused,
@@ -4382,7 +4709,9 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     out = (struct aml_stream_out *)calloc(1, sizeof(struct aml_stream_out));
     if (!out)
         return -ENOMEM;
-
+    virtualx_setparameter(adev,VIRTUALXINMODE,0,5);
+    virtualx_setparameter(adev,TRUVOLUMEINMODE,0,5);
+    adev->effect_in_ch = 2;
     if (flags == AUDIO_OUTPUT_FLAG_NONE)
         flags = AUDIO_OUTPUT_FLAG_PRIMARY;
     if (config->channel_mask == AUDIO_CHANNEL_NONE)
@@ -4426,7 +4755,9 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
             break;
         }
     } else if (flags & AUDIO_OUTPUT_FLAG_DIRECT) {
-        if (config->format == AUDIO_FORMAT_DEFAULT)
+        if (devices & AUDIO_DEVICE_OUT_ALL_A2DP)
+            config->format = AUDIO_FORMAT_PCM_16_BIT;
+        else if (config->format == AUDIO_FORMAT_DEFAULT)
             config->format = AUDIO_FORMAT_AC3;
 
         out->stream.common.get_channels = out_get_channels_direct;
@@ -4457,8 +4788,6 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
             out->config.format = PCM_FORMAT_S32_LE;
             break;
         case AUDIO_FORMAT_IEC61937:
-            // TODO: The internal format should be from IEC61937 Pc field
-            // TODO: Add MAT support
             if (out->config.channels == 2 && (out->config.rate == 192000 || out->config.rate == 176400 || out->config.rate == 128000)) {
                 out->config.rate /= 4;
                 out->hal_internal_format = AUDIO_FORMAT_E_AC3;
@@ -4487,6 +4816,11 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
             }
             ALOGI("convert format IEC61937 to 0x%x\n", out->hal_internal_format);
             break;
+        case AUDIO_FORMAT_DTS:
+        case AUDIO_FORMAT_DTS_HD:
+            out->hal_internal_format = out->hal_format;
+            adev->dolby_lib_type = eDolbyDcvLib;
+            break;
         default:
             break;
         }
@@ -4508,6 +4842,7 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
         case TYPE_PCM:
             if (out->config.channels >= 6 || out->config.rate > 48000)
                 adev->hi_pcm_mode = true;
+            break;
         default:
             out->raw_61937_frame_size = 1;
             break;
@@ -4520,22 +4855,28 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
             out->multich = out->config.channels;
         }
 
-        if (flags & AUDIO_OUTPUT_FLAG_HW_AV_SYNC)
+        if (flags & AUDIO_OUTPUT_FLAG_HW_AV_SYNC) {
+            ALOGI("Set out->hw_sync_mode true");
             out->hw_sync_mode = true;
+        }
     } else {
         // TODO: add other cases here
         ALOGE("%s: flags = %#x invalid", __func__, flags);
         ret = -EINVAL;
         goto err;
     }
-
-    out->hal_ch = audio_channel_count_from_out_mask(out->hal_channel_mask);
+    out->hal_ch   = audio_channel_count_from_out_mask(out->hal_channel_mask);
     out->hal_frame_size = audio_bytes_per_frame(out->hal_ch, out->hal_internal_format);
-    if (out->hal_ch == 0)
+    if (out->hal_ch == 0) {
         out->hal_ch = 2;
-    if (out->hal_frame_size == 0)
+    }
+    if (out->hal_frame_size == 0) {
         out->hal_frame_size = 1;
+    }
 
+    adev->hal_internal_format = AUDIO_FORMAT_PCM;
+    adev->is_dolby_atmos = 0;
+    adev->update_type = TYPE_PCM;
     out->stream.common.get_sample_rate = out_get_sample_rate;
     out->stream.common.set_sample_rate = out_set_sample_rate;
     out->stream.common.get_buffer_size = out_get_buffer_size;
@@ -4551,7 +4892,7 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     out->stream.get_next_write_timestamp = out_get_next_write_timestamp;
     out->stream.get_presentation_position = out_get_presentation_position;
 
-    if (eDolbyMS12Lib == adev->dolby_lib_type) {
+    if (eDolbyMS12Lib == adev->dolby_lib_type_last) {
         // BOX with ms 12 need to use new method
         out->stream.pause = out_pause_new;
         out->stream.resume = out_resume_new;
@@ -4570,6 +4911,18 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     out->standby = true;
     out->frame_write_sum = 0;
     out->need_convert = false;
+    out->need_drop_size = 0;
+    out->enInputPortType = AML_MIXER_INPUT_PORT_BUTT;
+
+#ifdef ENABLE_MMAP
+    if (flags & AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) {
+        if ((eDolbyMS12Lib == adev->dolby_lib_type) && !adev->ms12.dolby_ms12_enable) {
+           config_output((struct audio_stream_out *)out,true);
+        }
+        outMmapInit(out);
+    }
+#endif
+
     //aml_audio_hwsync_init(out->hwsync,out);
     /* FIXME: when we support multiple output devices, we will want to
      * do the following:
@@ -4621,14 +4974,43 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     if (out->hw_sync_mode) {
         //aml_audio_hwsync_init(out->hwsync, out);
     }
+
+    /*if tunnel mode pcm is not 48Khz, resample to 48K*/
+    if (flags & AUDIO_OUTPUT_FLAG_HW_AV_SYNC) {
+        ALOGD("%s format=%d rate=%d", __func__, out->hal_internal_format, out->config.rate);
+        if (audio_is_linear_pcm(out->hal_internal_format) && out->config.rate != 48000) {
+            if (out->resample_handle == NULL)
+            {
+                audio_resample_config_t resample_config;
+                ALOGI("init resampler from %d to 48000!\n", out->config.rate);
+                resample_config.aformat   = out->hal_internal_format;
+                resample_config.channels  = 2;
+                resample_config.input_sr  = out->config.rate;
+                resample_config.output_sr = 48000;
+                ret = aml_audio_resample_init((aml_audio_resample_t **)&out->resample_handle, AML_AUDIO_ANDROID_RESAMPLE, &resample_config);
+                if (ret < 0) {
+                    ALOGE("resample init error\n");
+                    return -1;
+                }
+            }
+
+        }
+    }
+
+    if (out->hal_format == AUDIO_FORMAT_AC4) {
+        aml_ac4_parser_open(&out->ac4_parser_handle);
+    }
+
     out->ddp_frame_size = aml_audio_get_ddp_frame_size();
     *stream_out = &out->stream;
     ALOGD("%s: exit", __func__);
 
     return 0;
 err:
-    free(out->audioeffect_tmp_buffer);
-    free(out->tmp_buffer_8ch);
+    if (out->audioeffect_tmp_buffer)
+        free(out->audioeffect_tmp_buffer);
+    if (out->tmp_buffer_8ch)
+        free(out->tmp_buffer_8ch);
     free(out);
     return ret;
 }
@@ -4639,8 +5021,16 @@ static void adev_close_output_stream(struct audio_hw_device *dev,
 {
     struct aml_stream_out *out = (struct aml_stream_out *)stream;
     struct aml_audio_device *adev = (struct aml_audio_device *)dev;
+    bool is_dolby_format = is_dolby_ms12_support_compression_format(out->hal_internal_format);
+    bool is_direct_pcm = is_direct_stream_and_pcm_format(out);
 
-    ALOGD("%s: enter: dev(%p) stream(%p)", __func__, dev, stream);
+    ALOGD("%s: enter: dev(%p) stream(%p) continous_mode(%d) hal_internal_format %#x is dolby %d is direct pcm %d\n",
+        __func__, dev, stream, continous_mode(adev), out->hal_internal_format, is_dolby_format, is_direct_pcm);
+
+    virtualx_setparameter(adev,0,0,2);
+    virtualx_setparameter(adev,VIRTUALXINMODE,0,5);
+    virtualx_setparameter(adev,TRUVOLUMEINMODE,0,5);
+    adev->effect_in_ch = 2;
 
     if (adev->useSubMix) {
         if (out->usecase == STREAM_PCM_NORMAL || out->usecase == STREAM_PCM_HWSYNC)
@@ -4651,23 +5041,53 @@ static void adev_close_output_stream(struct audio_hw_device *dev,
         out_standby_new(&stream->common);
     }
 
-    if (continous_mode(adev) && (eDolbyMS12Lib == adev->dolby_lib_type)) {
+    if ((eDolbyMS12Lib == adev->dolby_lib_type) && (is_dolby_format || is_direct_pcm)) {
         if (out->volume_l != 1.0) {
-            if (!audio_is_linear_pcm(out->hal_internal_format)) {
-                char *argv[3] = {"ms12_runtime", "-sys_prim_mixgain", "0,10,0"};
-                /*we change the volume in this stream, but it will be closed,
-                  we need to restore the ms12 to normal one
-                */
-                int iMS12DB = 0;//restore to full volume
-                ALOGI("restore the ms12 volume");
-                set_dolby_ms12_primary_input_db_gain(&(adev->ms12), iMS12DB , 10);
-                adev->ms12.curDBGain = iMS12DB;
-                //restore to full volume
-                aml_ms12_update_runtime_params_direct(&(adev->ms12), 3, argv);
+            /*
+             *The Dolby format(dd/ddp/ac4/true-hd/mat) and direct&UI-PCM(stereo or multi PCM)
+             *will go through dolby system mixer as main input
+             *use dolby_ms12_set_main_volume to reset the original stream volume.
+             *The volume about mixer-PCM is controled by AudioFlinger
+             */
+            dolby_ms12_set_main_volume(1.0);
+            if (out->offload_mute) {
+                out->offload_mute = false;
+                spdifenc_set_mute(false);
             }
         }
     }
 
+    /*when open dts decoder, the dolby lib is changed, so we need restore it*/
+    if (is_dts_format(out->hal_internal_format)) {
+        if (eDolbyMS12Lib == adev->dolby_lib_type_last) {
+            adev->dolby_lib_type = eDolbyMS12Lib;
+        }
+    }
+    /*TBD .to fix the AC-4 continous function in ms12 lib then remove this */
+    /*
+     * will close MS12 if the AVR DDP-ATMOS capbility is changed,
+     * such as switch from DDP-AVR to ATMOS-AVR
+     * then, next stream is new built, this setting is available.
+     */
+    bool is_atmos_supported = is_platform_supported_ddp_atmos(adev->hdmi_descs.ddp_fmt.atmos_supported, adev->active_outport);
+    if ((out->hal_internal_format == AUDIO_FORMAT_AC4) ||
+        !is_ms12_out_ddp_5_1_suitable(is_atmos_supported)) {
+        if (adev->continuous_audio_mode) {
+            adev->delay_disable_continuous = 0;
+            ALOGI("Need disable MS12 continuous");
+            get_dolby_ms12_cleanup(&adev->ms12);
+            adev->continuous_audio_mode = 0;
+            adev->exiting_ms12 = 1;
+            out->restore_continuous = true;
+            clock_gettime(CLOCK_MONOTONIC, &adev->ms12_exiting_start);
+        }
+    }
+    if (out->restore_continuous == true) {
+        ALOGI("restore ms12 continuous mode");
+        adev->continuous_audio_mode = 1;
+
+    }
+
     pthread_mutex_lock(&out->lock);
     free(out->audioeffect_tmp_buffer);
     free(out->tmp_buffer_8ch);
@@ -4676,34 +5096,102 @@ static void adev_close_output_stream(struct audio_hw_device *dev,
         aml_audio_hwsync_release(out->hwsync);
         free(out->hwsync);
     }
+
+    if (out->resample_handle) {
+        aml_audio_resample_close(out->resample_handle);
+        out->resample_handle = NULL;
+    }
+
+#ifdef ENABLE_MMAP
+    if (out->flags & AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) {
+        outMmapDeInit(out);
+    }
+#endif
+
+    if (out->hal_format == AUDIO_FORMAT_AC4) {
+        aml_ac4_parser_close(out->ac4_parser_handle);
+        out->ac4_parser_handle = NULL;
+    }
+
     pthread_mutex_unlock(&out->lock);
     free(stream);
     ALOGD("%s: exit", __func__);
 }
 
-static int set_arc_hdmi (struct audio_hw_device *dev, char *value, size_t len)
+/* default_edid = 1, restore default edid
+ * default_edid = 0, update AVR ARC capability to edid.
+ */
+static void update_edid(struct aml_audio_device *adev, bool default_edid)
+{
+    struct aml_arc_hdmi_desc *hdmi_desc = &adev->hdmi_descs;
+
+    if (default_edid == true) {
+        aml_mixer_ctrl_set_array(&adev->alsa_mixer, AML_MIXER_ID_HDMIIN_AUDIO_EDID,
+            &hdmi_desc->SAD[0], TLV_HEADER_SIZE);
+        hdmi_desc->default_edid = true;
+    } else {
+        aml_mixer_ctrl_set_array(&adev->alsa_mixer, AML_MIXER_ID_HDMIIN_AUDIO_EDID,
+            &hdmi_desc->SAD[0], (hdmi_desc->EDID_length + TLV_HEADER_SIZE));
+        hdmi_desc->default_edid = false;
+    }
+}
+
+static int set_arc_hdmi(struct audio_hw_device *dev, char *value, size_t len)
 {
     struct aml_audio_device *adev = (struct aml_audio_device *) dev;
     struct aml_arc_hdmi_desc *hdmi_desc = &adev->hdmi_descs;
     char *pt = NULL, *tmp = NULL;
     int i = 0;
+    unsigned int *ptr = (unsigned int *)(&hdmi_desc->SAD[0]);
 
     if (strlen (value) > len) {
         ALOGE ("value array overflow!");
         return -EINVAL;
     }
 
+    memset(hdmi_desc->SAD, 0, 38);
+
     pt = strtok_r (value, "[], ", &tmp);
     while (pt != NULL) {
-        //index 1 means avr port
-        if (i == 1)
+
+        if (i == 0) //index 0 means avr cec length
+            hdmi_desc->EDID_length = atoi (pt);
+        else if (i == 1) //index 1 means avr port
             hdmi_desc->avr_port = atoi (pt);
+        else
+            hdmi_desc->SAD[TLV_HEADER_SIZE + i - 2] = atoi (pt);
 
         pt = strtok_r (NULL, "[], ", &tmp);
         i++;
     }
 
-    ALOGI ("ARC HDMI AVR port = %d", hdmi_desc->avr_port);
+    ptr[0] = 0;
+    ptr[1] = (unsigned int)hdmi_desc->EDID_length;
+
+    if (hdmi_desc->EDID_length == 0) {
+        ALOGI("ARC is disconnect!");
+        adev->arc_hdmi_updated = 0;
+        update_edid(adev, 1);
+    } else {
+        ALOGI("ARC is connected, EDID_length = [%d], ARC HDMI AVR port = [%d]",
+            hdmi_desc->EDID_length, hdmi_desc->avr_port);
+        int edid_length = hdmi_desc->EDID_length;
+        for (i = 0; i < edid_length/3; ) {
+            char AudioFormatCodes = (hdmi_desc->SAD[TLV_HEADER_SIZE + 3*i] >> 3) & 0xF;
+            /* mask EDID of dts and dtshd */
+            if (AudioFormatCodes == _DTS || AudioFormatCodes == _DTSHD) {
+                char *pr = &hdmi_desc->SAD[TLV_HEADER_SIZE + 3*i];
+                memmove(pr, (pr + 3), (edid_length - 3*i - 3));
+                edid_length -= 3;
+            } else {
+                i++;
+            }
+        }
+        hdmi_desc->EDID_length = edid_length;
+        ptr[1] = (unsigned int)hdmi_desc->EDID_length;
+        adev->arc_hdmi_updated = 1;
+    }
+
     return 0;
 }
 
@@ -4720,7 +5208,7 @@ static void dump_format_desc (struct format_desc *desc)
     }
 }
 
-static int set_arc_format (struct audio_hw_device *dev, char *value, size_t len)
+static int set_arc_format(struct audio_hw_device *dev, char *value, size_t len)
 {
     struct aml_audio_device *adev = (struct aml_audio_device *) dev;
     struct aml_arc_hdmi_desc *hdmi_desc = &adev->hdmi_descs;
@@ -4773,15 +5261,17 @@ static int set_arc_format (struct audio_hw_device *dev, char *value, size_t len)
             break;
         case 4:
             if (format == _DDP) {
-                fmt_desc = &hdmi_desc->ddp_fmt;
-                fmt_desc->atmos_supported = val > 0 ? true : false;
-                aml_mixer_ctrl_set_int (&adev->alsa_mixer, AML_MIXER_ID_HDMI_ATMOS_EDID,fmt_desc->atmos_supported);
-                /**
-                 * Add flag to indicate hdmi arc format updated.
-                 * Out write thread checks it and makes decision on output format.
-                 * NOTICE: assuming that DDP format is the last ARC KV parameters.
-                 */
-                adev->arc_hdmi_updated = 1;
+                /* byte 3, bit 0 is atmos bit*/
+                fmt_desc->atmos_supported = (val & 0x1) > 0 ? true : false;
+
+                /* when arc is connected update AVR SAD to hdmi edid */
+                if (adev->disable_pcm_mixing == 1 || fmt_desc->atmos_supported == false)
+                    update_edid(adev, false);
+                else
+                    update_edid(adev, true);
+
+                //aml_mixer_ctrl_set_int(&adev->alsa_mixer,
+                //    AML_MIXER_ID_HDMI_ATMOS_EDID, fmt_desc->atmos_supported);
             } else {
                 fmt_desc->max_bit_rate = val * 80;
             }
@@ -4813,7 +5303,8 @@ const char* outport2String(enum OUT_PORT enOutPort)
         "[0x6]REMOTE_SUBMIX",
         "[0x7]BT_SCO",
         "[0x8]BT_SCO_HEADSET",
-        "[0x9]MAX"
+        "[0x9]A2DP",
+        "[0xA]MAX"
     };
     return apcOutPort[enOutPort];
 }
@@ -4855,6 +5346,8 @@ static int aml_audio_output_routing(struct audio_hw_device *dev,
             break;
         case OUTPORT_HDMI_ARC:
             audio_route_apply_path(aml_dev->ar, "hdmi_arc_off");
+            aml_dev->bHDMIARCon = 0;
+            aml_dev->arc_hdmi_updated = 0;
             break;
         case OUTPORT_HEADPHONE:
             audio_route_apply_path(aml_dev->ar, "headphone_off");
@@ -4862,6 +5355,9 @@ static int aml_audio_output_routing(struct audio_hw_device *dev,
         case OUTPORT_BT_SCO:
         case OUTPORT_BT_SCO_HEADSET:
             break;
+        case OUTPORT_A2DP:
+            ALOGE("%s: active_outport = %s A2DP off", __func__, outport2String(aml_dev->active_outport));
+            break;
         default:
             ALOGE("%s: active_outport = %s unsupport", __func__, outport2String(aml_dev->active_outport));
             break;
@@ -4876,6 +5372,8 @@ static int aml_audio_output_routing(struct audio_hw_device *dev,
             break;
         case OUTPORT_HDMI_ARC:
             audio_route_apply_path(aml_dev->ar, "hdmi_arc");
+            aml_dev->bHDMIARCon = 1;
+            aml_dev->arc_hdmi_updated = 1;
             /* TODO: spdif case need deal with hdmi arc format */
             if (aml_dev->hdmi_format != 3)
                 audio_route_apply_path(aml_dev->ar, "spdif");
@@ -4887,6 +5385,9 @@ static int aml_audio_output_routing(struct audio_hw_device *dev,
         case OUTPORT_BT_SCO:
         case OUTPORT_BT_SCO_HEADSET:
             break;
+        case OUTPORT_A2DP:
+            ALOGE("%s: active_outport = %s A2DP on", __func__, outport2String(outport));
+            break;
         default:
             ALOGE("%s: outport = %s unsupport", __func__, outport2String(outport));
             break;
@@ -4896,10 +5397,11 @@ static int aml_audio_output_routing(struct audio_hw_device *dev,
         aml_dev->active_outport = outport;
     } else if (outport == OUTPORT_SPEAKER && user_setting) {
         /* In this case, user toggle the speaker_mute menu */
-        if (aml_dev->speaker_mute)
+        if (aml_dev->speaker_mute) {
             audio_route_apply_path(aml_dev->ar, "speaker_off");
-        else
+        } else {
             audio_route_apply_path(aml_dev->ar, "speaker");
+        }
         audio_route_update_mixer(aml_dev->ar);
     } else {
         ALOGI("%s: outport %s already exists, do nothing", __func__, outport2String(outport));
@@ -4941,7 +5443,7 @@ static int aml_audio_input_routing(struct audio_hw_device *dev,
     return 0;
 }
 
-#define VAL_LEN 1024
+#define VAL_LEN 2048
 static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs)
 {
     ALOGD ("%s(%p, %s)", __FUNCTION__, dev, kvpairs);
@@ -4996,7 +5498,18 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
     if (ret >= 0) {
         if (val & AUDIO_DEVICE_OUT_HDMI_ARC) {
             adev->bHDMIConnected = 0;
+            adev->bHDMIARCon = 0;
+            adev->arc_hdmi_updated = 0;
             ALOGI("bHDMIConnected: %d\n", val);
+        }/* else if (val & AUDIO_DEVICE_OUT_ALL_A2DP) {
+            adev->a2dp_updated = 1;
+            adev->out_device &= (~val);
+            ALOGI("adev_set_parameters a2dp disconnect: %x, device=%x\n", val, adev->out_device);
+        }*/
+        /* for tv, the adev->reset_dtv_audio is reset in "HDMI ARC Switch" param */
+        if (adev->patch_src == SRC_DTV && !adev->is_TV) {
+            ALOGI("disconnect set reset_dtv_audio 1\n");
+            adev->reset_dtv_audio = 1;
         }
         goto exit;
     }
@@ -5004,10 +5517,22 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
     // HDMI cable plug in
     ret = str_parms_get_int(parms, "connect", &val);
     if (ret >= 0) {
-        if (val & AUDIO_DEVICE_OUT_HDMI_ARC) {
+        if ((val & AUDIO_DEVICE_OUT_HDMI_ARC) || (val & AUDIO_DEVICE_OUT_HDMI)) {
             adev->bHDMIConnected = 1;
             ALOGI("%s,bHDMIConnected: %d\n", __FUNCTION__, val);
-        }
+            if (adev->patch_src == SRC_DTV && !adev->is_TV) {
+                ALOGI("connect set reset_dtv_audio 1\n");
+                adev->reset_dtv_audio = 1;
+            }
+            if (val & AUDIO_DEVICE_OUT_HDMI_ARC) {
+                adev->bHDMIARCon = 1;
+                adev->arc_hdmi_updated = 1;
+            }
+        }/* else if (val & AUDIO_DEVICE_OUT_ALL_A2DP) {
+            adev->a2dp_updated = 1;
+            adev->out_device |= val;
+            ALOGI("adev_set_parameters a2dp connect: %x, device=%x\n", val, adev->out_device);
+        }*/
         goto exit;
     }
 
@@ -5036,18 +5561,51 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
         goto exit;
     }
 
-    //add for fireos tv for Dolby audio setting
-    ret = str_parms_get_int (parms, "hdmi_format", &val);
+    ret = str_parms_get_int(parms, "hdmi_format", &val);
     if (ret >= 0 ) {
         adev->hdmi_format = val;
         ALOGI ("HDMI format: %d\n", adev->hdmi_format);
+        adev->disable_pcm_mixing = (val == BYPASS) ? 1 : 0;
         goto exit;
     }
 
-    ret = str_parms_get_int (parms, "spdif_format", &val);
-    if (ret >= 0 ) {
-        adev->spdif_format = val;
-        ALOGI ("S/PDIF format: %d\n", adev->spdif_format);
+    //add for fireos7 tv of audio output format setting
+    //"digital_output_format=pcm"
+    //"digital_output_format=dd"
+    //"digital_output_format=auto"
+    //"digital_output_format=bypass", the same as "disable_pcm_mixing"
+    ret = str_parms_get_str(parms, "digital_output_format", value, sizeof(value));
+    if (ret >= 0) {
+        struct aml_arc_hdmi_desc *hdmi_desc = &adev->hdmi_descs;
+        if (strcmp(value, "pcm") == 0) {
+            adev->hdmi_format = PCM;
+            adev->disable_pcm_mixing = 0;
+            ALOGI("digital_output_format is PCM\n");
+        } else if (strcmp(value, "dd") == 0) {
+            adev->hdmi_format = DD;
+            adev->disable_pcm_mixing = 0;
+            ALOGI("digital_output_format is DD\n");
+        } else if (strcmp(value, "auto") == 0) {
+            adev->hdmi_format = AUTO;
+            adev->disable_pcm_mixing = 0;
+            ALOGI("digital_output_format is AUTO\n");
+        } else if (strcmp(value, "bypass") == 0) {
+            adev->hdmi_format = BYPASS;
+            adev->disable_pcm_mixing = 1;
+            ALOGI("digital_output_format is bypass\n");
+        } else {
+            ALOGE("unknown kvpairs\n");
+        }
+
+        if (adev->disable_pcm_mixing == 1 ||
+            adev->hdmi_descs.ddp_fmt.atmos_supported == 0) {
+            if (hdmi_desc->default_edid == true)
+                update_edid(adev, false);
+        } else {
+            if (hdmi_desc->default_edid == false)
+                update_edid(adev, true);
+        }
+
         goto exit;
     }
 
@@ -5105,12 +5663,23 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
         goto exit;
     }
 
+    /* eARCTX_CDS */
+    ret = str_parms_get_str (parms, "eARC_RX CDS", value, sizeof (value) );
+    if (ret >= 0) {
+        struct aml_mixer_handle *amixer = &adev->alsa_mixer;
+        struct mixer *pMixer = amixer->pMixer;
+
+        earcrx_config_cds(pMixer, value);
+        goto exit;
+    }
+
 #ifdef ENABLE_TUNER_IN
     ret = str_parms_get_str (parms, "tuner_in", value, sizeof (value) );
     // tuner_in=atv: tuner_in=dtv
     if (ret >= 0) {
         if (adev->tuner2mix_patch) {
             if (strncmp(value, "dtv", 3) == 0) {
+ #ifdef ENABLE_DTV_PATCH
                 adev->patch_src = SRC_DTV;
                 if (adev->audio_patching == 0) {
                     ALOGI("%s, !!! now create the dtv patch now\n ", __func__);
@@ -5119,10 +5688,12 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
                         adev->audio_patching = 1;
                     }
                 }
+#endif
             } else if (strncmp(value, "atv", 3) == 0) {
                 adev->patch_src = SRC_ATV;
                 set_audio_source(&adev->alsa_mixer,
                         ATV, alsa_device_is_auge());
+                adev->atv_switch = true;
             }
             ALOGI("%s, tuner to mixer case, no need to create patch", __func__);
             goto exit;
@@ -5141,6 +5712,10 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
 #ifdef ENABLE_DTV_PATCH
             if ((adev->patch_src == SRC_DTV) && adev->audio_patching) {
                 ALOGI("%s, now release the dtv patch now\n ", __func__);
+                if (!adev->is_TV) {
+                    ALOGI("tunner in set reset_dtv_audio 1\n");
+                    adev->reset_dtv_audio = 1;
+                }
                 ret = release_dtv_patch(adev);
                 if (!ret) {
                     adev->audio_patching = 0;
@@ -5168,6 +5743,15 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
                 }
             }
 #endif
+            if (eDolbyMS12Lib == adev->dolby_lib_type && adev->continuous_audio_mode) {
+                ALOGI("In ATV exit MS12 continuous mode");
+                get_dolby_ms12_cleanup(&adev->ms12);
+                adev->exiting_ms12 = 1;
+                adev->continuous_audio_mode = 0;
+                clock_gettime(CLOCK_MONOTONIC, &adev->ms12_exiting_start);
+                usecase_change_validate_l(adev->active_outputs[STREAM_PCM_NORMAL], true);
+            }
+
             if (!adev->audio_patching) {
                 ALOGI ("%s, create atv patching", __func__);
                 set_audio_source(&adev->alsa_mixer,
@@ -5196,6 +5780,11 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
     if (ret >= 0) {
         bool is_linein_audio = strncmp(value, "linein", 6) == 0;
         bool is_hdmiin_audio = strncmp(value, "hdmi", 4) == 0;
+
+        if (is_hdmiin_audio && adev->audio_patch) {
+            adev->audio_patch->need_do_avsync = true;
+        }
+
         if (is_linein_audio || is_hdmiin_audio) {
 
             struct audio_patch *pAudPatchTmp = NULL;
@@ -5255,7 +5844,7 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
                     release_parser(adev);
 
                     aml_audio_input_routing(dev, INPORT_LINEIN);
-                    adev->patch_src == SRC_LINEIN;
+                    adev->patch_src = SRC_LINEIN;
                     pAudPatchTmp->sources[0].ext.device.type = AUDIO_DEVICE_IN_LINE;
 
                     set_audio_source(&adev->alsa_mixer,
@@ -5265,7 +5854,7 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
                     release_parser(adev);
 
                     aml_audio_input_routing(dev, INPORT_HDMIIN);
-                    adev->patch_src == SRC_HDMIIN;
+                    adev->patch_src = SRC_HDMIIN;
                     pAudPatchTmp->sources[0].ext.device.type = AUDIO_DEVICE_IN_HDMI;
 
                     set_audio_source(&adev->alsa_mixer,
@@ -5328,7 +5917,9 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
         adev->frame_trigger_thred = 0;
         goto exit;
     }
-    if (eDolbyMS12Lib == adev->dolby_lib_type) {
+    /*use dolby_lib_type_last to check ms12 type, because durig playing DTS file,
+      this type will be changed to dcv*/
+    if (eDolbyMS12Lib == adev->dolby_lib_type_last) {
         ret = str_parms_get_int(parms, "dual_decoder_support", &val);
         if (ret >= 0) {
             pthread_mutex_lock(&adev->lock);
@@ -5336,6 +5927,7 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
             adev->dual_decoder_support = val;
             ALOGI("dual_decoder_support set to %d\n", adev->dual_decoder_support);
             set_audio_system_format(AUDIO_FORMAT_PCM_16_BIT);
+            set_audio_app_format(AUDIO_FORMAT_PCM_16_BIT);
             //only use to set associate flag, dd/dd+ format is same.
             if (adev->dual_decoder_support == 1) {
                 set_audio_associate_format(AUDIO_FORMAT_AC3);
@@ -5352,17 +5944,13 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
 #ifdef ENABLE_DTV_PATCH
         ret = str_parms_get_int(parms, "associate_audio_mixing_enable", &val);
         if (ret >= 0) {
-            char *argv_1[3] = {"ms12_runtime", "-xa", "1"};
-            char *argv_0[3] = {"ms12_runtime", "-xa", "0"};
             pthread_mutex_lock(&adev->lock);
             pthread_mutex_lock(&ms12->lock);
             dtv_assoc_audio_cache(-1);
             adev->associate_audio_mixing_enable = val;
             ALOGI("associate_audio_mixing_enable set to %d\n", adev->associate_audio_mixing_enable);
             dolby_ms12_set_asscociated_audio_mixing(adev->associate_audio_mixing_enable);
-            int ms12_runtime_update_ret = aml_ms12_update_runtime_params_direct(
-                &(adev->ms12), 3, (val) ? argv_1 : argv_0);
-            ALOGI("[%d] aml_ms12_update_runtime_params_direct return %d\n", __LINE__, ms12_runtime_update_ret);
+            set_ms12_ad_mixing_enable(ms12, adev->associate_audio_mixing_enable);
             pthread_mutex_unlock(&adev->lock);
             pthread_mutex_unlock(&ms12->lock);
             goto exit;
@@ -5371,10 +5959,7 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
 
         ret = str_parms_get_int(parms, "dual_decoder_mixing_level", &val);
         if (ret >= 0) {
-            int mix_user_prefer = 0;
             int mixing_level = val;
-            char *argv_1[3] = {"ms12_runtime", "-xu", "1"};
-            char *argv_0[3] = {"ms12_runtime", "-xu", "0"};
 
             pthread_mutex_lock(&adev->lock);
             pthread_mutex_lock(&ms12->lock);
@@ -5383,15 +5968,10 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
             } else if (mixing_level > 100) {
                 mixing_level = 100;
             }
-            mix_user_prefer = (mixing_level * 64 - 32 * 100) / 100; //[0,100] mapping to [-32,32]
-            adev->mixing_level = mix_user_prefer;
+            adev->mixing_level = (mixing_level * 64 - 32 * 100) / 100; //[0,100] mapping to [-32,32]
             ALOGI("mixing_level set to %d\n", adev->mixing_level);
             dolby_ms12_set_user_control_value_for_mixing_main_and_associated_audio(adev->mixing_level);
-            int ms12_runtime_update_ret = aml_ms12_update_runtime_params_direct(
-                &(adev->ms12),
-                3,
-                (val) ? argv_1 : argv_0);
-            ALOGI("[%d]aml_ms12_update_runtime_params_direct return %d\n", __LINE__, ms12_runtime_update_ret);
+            set_ms12_ad_mixing_level(ms12, adev->mixing_level);
             pthread_mutex_unlock(&ms12->lock);
             pthread_mutex_unlock(&adev->lock);
             goto exit;
@@ -5399,15 +5979,37 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
 
         ret = str_parms_get_int(parms, "continuous_audio_mode", &val);
         if (ret >= 0) {
+            int disable_continuous = !val;
             ALOGI("%s continuous_audio_mode set to %d\n", __func__ , val);
             char buf[PROPERTY_VALUE_MAX];
-            int disable_continuous = !val;
             ret = property_get(DISABLE_CONTINUOUS_OUTPUT, buf, NULL);
             if (ret > 0) {
                 sscanf(buf, "%d", &disable_continuous);
                 ALOGI("%s[%s] disable_continuous %d\n", DISABLE_CONTINUOUS_OUTPUT, buf, disable_continuous);
+                val = !disable_continuous;
             }
-            pthread_mutex_lock(&adev->lock);
+            // if exit netflix, we need disable atmos lock
+            if (disable_continuous) {
+                adev->atoms_lock_flag = false;
+                set_ms12_atmos_lock(&(adev->ms12), adev->atoms_lock_flag);
+                ALOGI("exit netflix, set atmos lock as 0");
+            }
+            ALOGI("%s ignore the continuous_audio_mode!\n", __func__ );
+            adev->is_netflix = val;
+            /*
+            when netflix switch between bg/fg.for HD audio output should
+            change from PCM/DDP/DD.we need update sink format and
+            optical format
+            */
+            if (!dolby_stream_active(adev)) {
+                if (adev->active_outport == OUTPORT_SPEAKER && adev->bHDMIConnected) {
+                    ALOGI("audio route change to ARC");
+                    aml_audio_output_routing((struct audio_hw_device *)adev, OUTPORT_HDMI_ARC, true);
+                }
+                get_sink_format((struct audio_stream_out *)adev->active_outputs[STREAM_PCM_NORMAL]);
+            }
+            goto exit;
+            /*pthread_mutex_lock(&adev->lock);
             if (continous_mode(adev) && disable_continuous) {
                 // If the Netflix application is terminated, your platform must disable Atmos locking.
                 // For more information, see When to enable/disable Atmos lock.
@@ -5440,14 +6042,14 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
                 }
             }
             pthread_mutex_unlock(&adev->lock);
-            goto exit;
+            goto exit;*/
         }
 
         ret = str_parms_get_int(parms, "hdmi_dolby_atmos_lock", &val);
         if (ret >= 0) {
             ALOGI("%s hdmi_dolby_atmos_lock set to %d\n", __func__ , val);
             char buf[PROPERTY_VALUE_MAX];
-            int b_atmos_lock = val;
+            adev->atoms_lock_flag = val ? true : false;
 
             if (eDolbyMS12Lib == adev->dolby_lib_type) {
             // Note: some guide from www.netflix.com
@@ -5455,14 +6057,9 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
             // when you receive the signal from the Netflix application.
             pthread_mutex_lock(&adev->lock);
             if (continous_mode(adev)) {
-                if (b_atmos_lock == adev->atoms_lock_flag) {
-                    ALOGI("%s already adev->atoms_lock_flag = %d, need to do nothing.\n", __func__,adev->atoms_lock_flag);
-                } else {
-                    // enable/disable atoms lock
-                    dolby_ms12_set_atmos_lock_flag(b_atmos_lock);
-                    adev->atoms_lock_flag = b_atmos_lock;
-                    ALOGI("%s set adev->atoms_lock_flag = %d, \n", __func__,adev->atoms_lock_flag);
-                }
+                // enable/disable atoms lock
+                set_ms12_atmos_lock(&(adev->ms12), adev->atoms_lock_flag);
+                ALOGI("%s set adev->atoms_lock_flag = %d, \n", __func__,adev->atoms_lock_flag);
             } else {
                 ALOGI("%s not in continous mode, do nothing\n", __func__);
             }
@@ -5471,23 +6068,36 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
             goto exit;
         }
 
+        if (strlen(kvpairs) >= sizeof(value)) {
+            ret = -1;
+            ALOGE("ms12_runtime param size exceeds %d", sizeof(value));
+            goto exit;
+        }
         ret = str_parms_get_str(parms, "ms12_runtime", value, sizeof(value));
-        if (ret > 0) {
+        if (ret >= 0) {
+            char *parm = strstr(kvpairs, "=");
             pthread_mutex_lock(&adev->lock);
-            aml_ms12_update_runtime_params(&(adev->ms12), value);
+            if (parm)
+                aml_ms12_update_runtime_params(&(adev->ms12), parm + 1);
             pthread_mutex_unlock(&adev->lock);
             goto exit;
         }
     }
+#ifdef AML_EQ_DRC
     ret = str_parms_get_str(parms, "SOURCE_GAIN", value, sizeof(value));
     if (ret >= 0) {
-        sscanf(value,"%f %f %f %f", &adev->eq_data.s_gain.atv, &adev->eq_data.s_gain.dtv,
-                &adev->eq_data.s_gain.hdmi, &adev->eq_data.s_gain.av);
-        ALOGI("%s() audio source gain: atv:%f, dtv:%f, hdmiin:%f, av:%f", __func__,
-        adev->eq_data.s_gain.atv, adev->eq_data.s_gain.dtv,
-        adev->eq_data.s_gain.hdmi, adev->eq_data.s_gain.av);
+        float fAtvGainDb = 0, fDtvGainDb = 0, fHdmiGainDb = 0, fAvGainDb = 0, fMediaGainDb = 0;
+        sscanf(value,"%f %f %f %f %f", &fAtvGainDb, &fDtvGainDb, &fHdmiGainDb, &fAvGainDb, &fMediaGainDb);
+        ALOGI("%s() audio source gain: atv:%f, dtv:%f, hdmiin:%f, av:%f, media:%f", __func__,
+        fAtvGainDb, fDtvGainDb, fHdmiGainDb, fAvGainDb, fMediaGainDb);
+        adev->eq_data.s_gain.atv = DbToAmpl(fAtvGainDb);
+        adev->eq_data.s_gain.dtv = DbToAmpl(fDtvGainDb);
+        adev->eq_data.s_gain.hdmi = DbToAmpl(fHdmiGainDb);
+        adev->eq_data.s_gain.av = DbToAmpl(fAvGainDb);
+        adev->eq_data.s_gain.media = DbToAmpl(fMediaGainDb);
         goto exit;
     }
+#endif
     ret = str_parms_get_str(parms, "SOURCE_MUTE", value, sizeof(value));
     if (ret >= 0) {
         sscanf(value,"%d", &adev->source_mute);
@@ -5495,6 +6105,7 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
             adev->source_mute?"mute":"unmute");
         goto exit;
     }
+#ifdef AML_EQ_DRC
     ret = str_parms_get_str(parms, "POST_GAIN", value, sizeof(value));
     if (ret >= 0) {
         sscanf(value,"%f %f %f", &adev->eq_data.p_gain.speaker, &adev->eq_data.p_gain.spdif_arc,
@@ -5504,6 +6115,7 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
         adev->eq_data.p_gain.headphone);
         goto exit;
     }
+#endif
 #ifdef ADD_AUDIO_DELAY_INTERFACE
     ret = str_parms_get_int(parms, "hal_param_speaker_delay_time_ms", &val);
     if (ret >= 0) {
@@ -5522,16 +6134,39 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
         aml_audio_delay_set_time(AML_DELAY_OUTPORT_ALL, val);
         goto exit;
     }
+
+    ret = str_parms_get_int(parms, "delay_input_hdmi_ms", &val);
+    if (ret >= 0) {
+        aml_audio_delay_input_set_time(AML_DELAY_INPUT_HDMI, val);
+        goto exit;
+    }
+
+    ret = str_parms_get_int(parms, "delay_input_arc_ms", &val);
+    if (ret >= 0) {
+        aml_audio_delay_input_set_time(AML_DELAY_INPUT_ARC, val);
+        goto exit;
+    }
+
+    ret = str_parms_get_int(parms, "delay_input_opt_ms", &val);
+    if (ret >= 0) {
+        aml_audio_delay_input_set_time(AML_DELAY_INPUT_OPT, val);
+        goto exit;
+    }
+
+    ret = str_parms_get_int(parms, "delay_input_hdmi_bt_ms", &val);
+    if (ret >= 0) {
+        aml_audio_delay_input_set_time(AML_DELAY_INPUT_HDMI_BT, val);
+        goto exit;
+    }
 #endif
-#ifdef ENABLE_EQ
+
+#ifdef AML_EQ_DRC
     ret = str_parms_get_str(parms, "EQ_PARAM", value, sizeof(value));
     if (ret >= 0) {
        sscanf(value, "%lf %lf %u %u %u",&adev->Eq_data.G,&adev->Eq_data.Q,&adev->Eq_data.fc,&adev->Eq_data.type,&adev->Eq_data.band_id);
        setpar_eq(adev->Eq_data.G,adev->Eq_data.Q,adev->Eq_data.fc,adev->Eq_data.type,adev->Eq_data.band_id);
        goto exit;
     }
-#endif
-#ifdef ENABLE_DRC
     ret = str_parms_get_str(parms,"mb_drc",value,sizeof(value));
     if (ret >= 0) {
        sscanf(value, "%u %u %u %u %f %f",&adev->Drc_data.band_id,&adev->Drc_data.attrack_time,&adev->Drc_data.release_time,
@@ -5540,6 +6175,7 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
                 adev->Drc_data.K,adev->Drc_data.threshold);
        goto exit;
     }
+
     ret = str_parms_get_str(parms,"fb_drc",value,sizeof(value));
     if (ret >= 0) {
        sscanf(value, "%u %u %u %u %f %f %u",&adev->Drc_data.band_id,&adev->Drc_data.attrack_time,&adev->Drc_data.release_time,
@@ -5554,7 +6190,6 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
        setcsfilter_drc(adev->Drc_data.band_id,adev->Drc_data.fc);
        goto exit;
     }
-#endif
     ret = str_parms_get_int(parms, "eq_enable", &val);
     if (ret >= 0) {
         aml_mixer_ctrl_set_int(&adev->alsa_mixer, AML_MIXER_ID_AED_EQ_ENABLE, val);
@@ -5586,6 +6221,7 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
             ALOGE("%s: eq_mode_set failed", __FUNCTION__);
         goto exit;
     }
+#endif
 
     ret = str_parms_get_str(parms, "cmd", value, sizeof(value));
     if (ret > 0) {
@@ -5711,69 +6347,140 @@ static int adev_set_parameters (struct audio_hw_device *dev, const char *kvpairs
         ALOGI("is_has_video set to %d\n", adev->is_has_video);
     }
 
+    ret = str_parms_get_str(parms, "reconfigA2dp", value, sizeof(value));
+    if (ret >= 0) {
+        ALOGE ("%s A2DP reconfigA2dp out_device=%x", __FUNCTION__, adev->out_device);
+        goto exit;
+    }
+
+#if defined(AUDIO_EFFECT_EXTERN_DEVICE)
+    if (adev->a2dp_output) {
+        struct a2dp_stream_out* out = (struct a2dp_stream_out*)adev->a2dp_output;
+        ret = str_parms_get_str(parms, "BT_GAIN", value, sizeof(value));
+        if (ret >= 0) {
+            sscanf(value, "%f", &out->bt_gain);
+            ALOGI("%s() audio bt gain: %f", __func__,out->bt_gain);
+        }
+        ret = str_parms_get_str(parms, "BT_MUTE", value, sizeof(value));
+        if (ret >= 0) {
+            sscanf(value, "%d", &out->bt_unmute);
+            ALOGI("%s() audio bt unmute: %d", __func__,out->bt_unmute);
+        }
+
+        ret = str_parms_get_str(parms, "BT_GAIN_RIGHT", value, sizeof(value));
+        if (ret >= 0) {
+            sscanf(value, "%f %f", &out->right_gain,&out->left_gain);
+            ALOGI("%s() audio bt right gain: %f left gain is %f", __func__,out->right_gain, out->left_gain);
+        }
+        ret = str_parms_get_str(parms, "BT_GAIN_LEFT", value, sizeof(value));
+        if (ret >= 0) {
+            sscanf(value, "%f %f", &out->left_gain,&out->right_gain);
+            ALOGI("%s() audio bt left gain: %f right gain is %f", __func__,out->left_gain, out->right_gain);
+        }
+    }
+#endif
+
     ret = str_parms_get_str(parms, "hfp_set_sampling_rate", value, sizeof(value));
     if (ret >= 0) {
-        ALOGE ("Amlogic_HAL - %s: hfp_set_sampling_rate. Abort function and return 0.", __FUNCTION__);
-        return 0;
+        ALOGI ("Amlogic_HAL - %s: hfp_set_sampling_rate. Abort function and return 0.", __FUNCTION__);
+        goto exit;
     }
 
     ret = str_parms_get_str(parms, "hfp_volume", value, sizeof(value));
     if (ret >= 0) {
-        ALOGE ("Amlogic_HAL - %s: hfp_volume. Abort function and return 0.", __FUNCTION__);
-        return 0;
+        ALOGI ("Amlogic_HAL - %s: hfp_volume. Abort function and return 0.", __FUNCTION__);
+        goto exit;
     }
 
     ret = str_parms_get_str(parms, "bt_headset_name", value, sizeof(value));
     if (ret >= 0) {
         ALOGE ("Amlogic_HAL - %s: bt_headset_name. Abort function and return 0.", __FUNCTION__);
-        return 0;
+        goto exit;
     }
 
     ret = str_parms_get_str(parms, "rotation", value, sizeof(value));
     if (ret >= 0) {
-        ALOGE ("Amlogic_HAL - %s: rotation. Abort function and return 0.", __FUNCTION__);
-        return 0;
+        ALOGI ("Amlogic_HAL - %s: rotation. Abort function and return 0.", __FUNCTION__);
+        goto exit;
     }
 
     ret = str_parms_get_str(parms, "bt_headset_nrec", value, sizeof(value));
     if (ret >= 0) {
-        ALOGE ("Amlogic_HAL - %s: bt_headset_nrec. Abort function and return 0.", __FUNCTION__);
-        return 0;
+        ALOGI ("Amlogic_HAL - %s: bt_headset_nrec. Abort function and return 0.", __FUNCTION__);
+        goto exit;
     }
 
     ret = str_parms_get_str(parms, "bt_wbs", value, sizeof(value));
     if (ret >= 0) {
-        ALOGE ("Amlogic_HAL - %s: bt_wbs. Abort function and return 0.", __FUNCTION__);
-        return 0;
+        ALOGI ("Amlogic_HAL - %s: bt_wbs. Abort function and return 0.", __FUNCTION__);
+        goto exit;
     }
 
     ret = str_parms_get_str(parms, "hfp_enable", value, sizeof(value));
     if (ret >= 0) {
-        ALOGE ("Amlogic_HAL - %s: hfp_enable. Abort function and return 0.", __FUNCTION__);
-        return 0;
+        ALOGI ("Amlogic_HAL - %s: hfp_enable. Abort function and return 0.", __FUNCTION__);
+        goto exit;
     }
 
     ret = str_parms_get_str(parms, "HACSetting", value, sizeof(value));
     if (ret >= 0) {
-        ALOGE ("Amlogic_HAL - %s: HACSetting. Abort function and return 0.", __FUNCTION__);
-        return 0;
+        ALOGI ("Amlogic_HAL - %s: HACSetting. Abort function and return 0.", __FUNCTION__);
+        goto exit;
     }
 
     ret = str_parms_get_str(parms, "tty_mode", value, sizeof(value));
     if (ret >= 0) {
-        ALOGE ("Amlogic_HAL - %s: tty_mode. Abort function and return 0.", __FUNCTION__);
-        return 0;
+        ALOGI ("Amlogic_HAL - %s: tty_mode. Abort function and return 0.", __FUNCTION__);
+        goto exit;
     }
 
     ret = str_parms_get_str(parms, "TV-Mute", value, sizeof(value));
     if (ret >= 0) {
-		unsigned int tv_mute = (unsigned int)atoi(value);
-        ALOGE ("Amlogic_HAL - %s: TV-Mute:%d.", __FUNCTION__,tv_mute);
-		adev->need_reset_ringbuffer = tv_mute;
-		adev->tv_mute = tv_mute;
+        unsigned int tv_mute = (unsigned int)atoi(value);
+        ALOGI ("Amlogic_HAL - %s: TV-Mute:%d.", __FUNCTION__,tv_mute);
+        adev->need_reset_ringbuffer = tv_mute;
+        adev->tv_mute = tv_mute;
+        goto exit;
+    }
+    ret = str_parms_get_str(parms, "direct-mode", value, sizeof(value));
+    if (ret >= 0) {
+        unsigned int direct_mode = (unsigned int)atoi(value);
+        ALOGI ("Amlogic_HAL - %s: direct-mode:%d.", __FUNCTION__,direct_mode);
+        adev->direct_mode = direct_mode;
+        goto exit;
+    }
+
+    ret = str_parms_get_str(parms, "show-meminfo", value, sizeof(value));
+    if (ret >= 0) {
+        unsigned int level = (unsigned int)atoi(value);
+        ALOGE ("Amlogic_HAL - %s: ShowMem info level:%d.", __FUNCTION__,level);
+        aml_audio_debug_malloc_showinfo(level);
+        return 0;
+    }
+
+    ret = str_parms_get_str(parms, "diaglogue_enhancement", value, sizeof(value));
+    if (ret >= 0) {
+        adev->ms12.ac4_de = atoi(value);
+        ALOGE ("Amlogic_HAL - %s: set MS12 ac4 Dialogue Enhancement gain :%d.", __FUNCTION__,adev->ms12.ac4_de);
+
+        char parm[12] = "";
+        sprintf(parm, "%s %d", "-ac4_de", adev->ms12.ac4_de);
+        pthread_mutex_lock(&adev->lock);
+        if (strlen(parm) > 0)
+            aml_ms12_update_runtime_params(&(adev->ms12), parm);
+        pthread_mutex_unlock(&adev->lock);
         return 0;
     }
 
+    ret = str_parms_get_str(parms, "bypass_dap", value, sizeof(value));
+    if (ret >= 0) {
+        if (access(MS12_DAP_TUNING_PATH, F_OK) == 0) {
+            sscanf(value,"%d %f", &adev->dap_bypass_enable, &adev->dap_bypassgain);
+        }
+        ALOGD("dap_bypass_enable is %d and dap_bypassgain is %f",adev->dap_bypass_enable, adev->dap_bypassgain);
+        goto exit;
+    }
+
     if (eDolbyMS12Lib == adev->dolby_lib_type) {
         ret = str_parms_get_str(parms, "ms12_runtime", value, sizeof(value));
         if (ret >= 0) {
@@ -5812,7 +6519,7 @@ static char * adev_get_parameters (const struct audio_hw_device *dev,
                                    const char *keys)
 {
     struct aml_audio_device *adev = (struct aml_audio_device *) dev;
-    char temp_buf[64] = {0};
+    char temp_buf[256] = {0};
 
     if (!strcmp (keys, AUDIO_PARAMETER_HW_AV_SYNC) ) {
         ALOGI ("get hwsync id\n");
@@ -5824,9 +6531,16 @@ static char * adev_get_parameters (const struct audio_hw_device *dev,
     } else if (strstr (keys, "hdmi_format") ) {
         sprintf (temp_buf, "hdmi_format=%d", adev->hdmi_format);
         return strdup (temp_buf);
-    } else if (strstr (keys, "spdif_format") ) {
-        sprintf (temp_buf, "spdif_format=%d", adev->spdif_format);
-        return strdup (temp_buf);
+    }  else if (strstr (keys, "digital_output_format") ) {
+        if (adev->hdmi_format == PCM) {
+            return strdup ("digital_output_format=pcm");
+        } else if (adev->hdmi_format == DD) {
+            return strdup ("digital_output_format=dd");
+        } else if (adev->hdmi_format == AUTO) {
+            return strdup ("digital_output_format=auto");
+        } else if (adev->hdmi_format == BYPASS) {
+            return strdup ("digital_output_format=bypass");
+        }
     } else if (strstr (keys, "hdmi_is_passthrough_active") ) {
         sprintf (temp_buf, "hdmi_is_passthrough_active=%d", adev->hdmi_is_pth_active);
         return strdup (temp_buf);
@@ -5847,12 +6561,14 @@ static char * adev_get_parameters (const struct audio_hw_device *dev,
         if (fmtdesc && fmtdesc->fmt == _DDP)
             ddp = fmtdesc->is_support;
 
-        sprintf (temp_buf, "hdmi_encodings=%s", "pcm;");
-        if (ddp)
-            sprintf (temp_buf, "ac3;eac3;");
-        else if (dd)
-            sprintf (temp_buf, "ac3;");
-
+        sprintf (temp_buf, "hdmi_encodings=%s", "pcm|");
+        if (ddp) {
+            sprintf(temp_buf + strlen(temp_buf), "ac3|eac3|");
+            if (fmtdesc->atmos_supported)
+                sprintf(temp_buf + strlen(temp_buf), "atmos|");
+        } else if (dd) {
+            sprintf(temp_buf + strlen(temp_buf), "ac3|");
+        }
         return strdup (temp_buf);
     } else if (strstr (keys, "is_passthrough_active") ) {
         bool active = false;
@@ -5871,15 +6587,19 @@ static char * adev_get_parameters (const struct audio_hw_device *dev,
         pthread_mutex_unlock (&adev->lock);
         sprintf (temp_buf, "is_passthrough_active=%d",active);
         return  strdup (temp_buf);
-    } else if (!strcmp(keys, "SOURCE_GAIN")) {
-        sprintf(temp_buf, "source_gain = %f %f %f %f", adev->eq_data.s_gain.atv, adev->eq_data.s_gain.dtv,
-                adev->eq_data.s_gain.hdmi, adev->eq_data.s_gain.av);
+    }
+#ifdef AML_EQ_DRC
+    else if (!strcmp(keys, "SOURCE_GAIN")) {
+        sprintf(temp_buf, "source_gain = %f %f %f %f %f", adev->eq_data.s_gain.atv, adev->eq_data.s_gain.dtv,
+                adev->eq_data.s_gain.hdmi, adev->eq_data.s_gain.av, adev->eq_data.s_gain.media);
         return strdup(temp_buf);
     } else if (!strcmp(keys, "POST_GAIN")) {
         sprintf(temp_buf, "post_gain = %f %f %f", adev->eq_data.p_gain.speaker, adev->eq_data.p_gain.spdif_arc,
                 adev->eq_data.p_gain.headphone);
         return strdup(temp_buf);
-    } else if (strstr(keys, "dolby_ms12_enable")) {
+    }
+#endif
+    else if (strstr(keys, "dolby_ms12_enable")) {
         int ms12_enable = (eDolbyMS12Lib == adev->dolby_lib_type_last);
         ALOGI("ms12_enable :%d", ms12_enable);
         sprintf(temp_buf, "dolby_ms12_enable=%d", ms12_enable);
@@ -5937,6 +6657,23 @@ static char * adev_get_parameters (const struct audio_hw_device *dev,
         ALOGD("temp_buf %s", temp_buf);
         return strdup(temp_buf);
     }
+    else if (strstr(keys, "eARC_TX CDS")) {
+        struct aml_mixer_handle *amixer = &adev->alsa_mixer;
+        struct mixer *pMixer = amixer->pMixer;
+        char cds[256] = {0};
+
+        earctx_fetch_cds(pMixer, cds);
+        return strdup(cds);
+    }
+    else if (strstr(keys, "eARC_RX CDS")) {
+        struct aml_mixer_handle *amixer = &adev->alsa_mixer;
+        struct mixer *pMixer = amixer->pMixer;
+        char cds[256] = {0};
+
+        earcrx_fetch_cds(pMixer, cds);
+        return strdup(cds);
+    }
+#ifdef AML_EQ_DRC
     else if (strstr(keys, "eq_enable")) {
         int cur_status = aml_mixer_ctrl_get_int(&adev->alsa_mixer,AML_MIXER_ID_AED_EQ_ENABLE);
         sprintf(temp_buf, "%d", cur_status);
@@ -5955,6 +6692,7 @@ static char * adev_get_parameters (const struct audio_hw_device *dev,
         ALOGD("temp_buf %d", cur_status);
         return strdup(temp_buf);
     }
+#endif
     else if (strstr (keys, "stream_dra_channel") ) {
        if (adev->audio_patch != NULL && adev->patch_src == SRC_DTV) {
           if (adev->audio_patch->dtv_NchOriginal > 8 || adev->audio_patch->dtv_NchOriginal < 1) {
@@ -5967,6 +6705,23 @@ static char * adev_get_parameters (const struct audio_hw_device *dev,
           sprintf (temp_buf, "0.0");
        }
         return strdup(temp_buf);
+    } else if (!strncmp(keys, "dap_", 4)) {
+        return dolby_ms12_query_dap_parameters(keys);
+    } else if (strstr (keys, "diaglogue_enhancement") ) {
+       sprintf(temp_buf, "diaglogue_enhancement=%d", adev->ms12.ac4_de);
+       ALOGD("temp_buf %s", temp_buf);
+       return strdup(temp_buf);
+
+    } else if (strstr(keys, "HDMI Switch")) {
+        sprintf(temp_buf, "HDMI Switch=%d", (OUTPORT_HDMI == adev->active_outport));
+        ALOGD("temp_buf %s", temp_buf);
+        return strdup(temp_buf);
+    } else if (strstr(keys, "isReconfigA2dpSupported")) {
+        return  strdup("isReconfigA2dpSupported=1");
+    }
+    else if (strstr(keys, "audioindicator")) {
+        get_audio_indicator(adev, temp_buf);
+        return strdup(temp_buf);
     }
     return strdup("");
 }
@@ -6057,6 +6812,7 @@ static size_t adev_get_input_buffer_size(const struct audio_hw_device *dev __unu
 
 static int choose_stream_pcm_config(struct aml_stream_in *in)
 {
+    struct aml_audio_device *adev = in->dev;
     int channel_count = audio_channel_count_from_in_mask(in->hal_channel_mask);
     int ret = 0;
     if (in->device & AUDIO_DEVICE_IN_ALL_SCO) {
@@ -6068,7 +6824,15 @@ static int choose_stream_pcm_config(struct aml_stream_in *in)
         }
     }
 
-    in->config.channels = channel_count;
+    if (adev->mic_desc) {
+        struct mic_in_desc *desc = adev->mic_desc;
+
+        in->config.channels = desc->config.channels;
+        in->config.rate = desc->config.rate;
+        in->config.format = desc->config.format;
+    } else if (in->config.channels != 8)
+        in->config.channels = channel_count;
+
     switch (in->hal_format) {
         case AUDIO_FORMAT_PCM_16_BIT:
             in->config.format = PCM_FORMAT_S16_LE;
@@ -6131,6 +6895,16 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
     struct aml_stream_in *in;
     int channel_count = audio_channel_count_from_in_mask(config->channel_mask);
     int ret;
+    const audio_channel_mask_t in_mask[8] = {
+        AUDIO_CHANNEL_IN_MONO,
+        AUDIO_CHANNEL_IN_STEREO,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_FRONT,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_FRONT_BACK,
+        AUDIO_CHANNEL_IN_STEREO | AUDIO_CHANNEL_IN_FRONT_BACK | AUDIO_CHANNEL_IN_FRONT_PROCESSED,
+        AUDIO_CHANNEL_IN_6,
+        AUDIO_CHANNEL_IN_6 | AUDIO_CHANNEL_IN_FRONT_PROCESSED,
+        AUDIO_CHANNEL_IN_6 | AUDIO_CHANNEL_IN_FRONT_PROCESSED | AUDIO_CHANNEL_IN_BACK_PROCESSED
+    };
 
     ALOGD("%s: enter: devices(%#x) channel_mask(%#x) rate(%d) format(%#x) source(%d)", __func__,
         devices, config->channel_mask, config->sample_rate, config->format, source);
@@ -6149,13 +6923,24 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
         return -EINVAL;
     }
 
-    if (channel_count == 1)
-        // in fact, this value should be AUDIO_CHANNEL_OUT_BACK_LEFT(16u) according to VTS codes,
-        // but the macroname can be confusing, so I'd like to set this value to
-        // AUDIO_CHANNEL_IN_FRONT(16u) instead of AUDIO_CHANNEL_OUT_BACK_LEFT.
-        config->channel_mask = AUDIO_CHANNEL_IN_FRONT;
-    else
-        config->channel_mask = AUDIO_CHANNEL_IN_STEREO;
+    /* add constrains for MIC which may be used by both loopback and normal record */
+    if (adev->mic_desc && (devices & AUDIO_DEVICE_IN_BUILTIN_MIC ||
+            devices & AUDIO_DEVICE_IN_BACK_MIC)) {
+        struct mic_in_desc *mic_desc = adev->mic_desc;
+
+        ret = check_mic_parameters(mic_desc, config);
+        if (ret < 0) {
+            config->sample_rate = mic_desc->config.rate;
+            config->format = AUDIO_FORMAT_PCM_16_BIT;
+            return ret;
+        }
+    }
+
+    /* channel mask is used to calculate channel number,
+     * Android does not have a proper mask definition for input as output.
+     * Here we only need make sure the total channel number is correct from mask.
+     */
+    config->channel_mask = in_mask[channel_count - 1];
 
     in = (struct aml_stream_in *)calloc(1, sizeof(struct aml_stream_in));
     if (!in)
@@ -6242,29 +7027,29 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
 
 #if (ENABLE_NANO_PATCH == 1)
 /*[SEN5-autumn.zhao-2018-01-11] add for B06 audio support { */
-	recording_device = nano_get_recorde_device();
-	ALOGD("recording_device=%d\n",recording_device);
-	if(recording_device == RECORDING_DEVICE_NANO){
-		int ret = nano_open(&in->config, config,source,&in->stream);
-		if(ret < 0){
-			recording_device = RECORDING_DEVICE_OTHER;
-		}
-		else{
-			ALOGD("use nano function\n");
-			in->stream.common.get_sample_rate = nano_get_sample_rate;
-			in->stream.common.get_buffer_size = nano_get_buffer_size;
-			in->stream.common.get_channels = nano_get_channels;
-			in->stream.common.get_format = nano_get_format;
-			in->stream.read = nano_read;
-		}
-	}
+    recording_device = nano_get_recorde_device();
+    ALOGD("recording_device=%d\n",recording_device);
+    if(recording_device == RECORDING_DEVICE_NANO){
+        int ret = nano_open(&in->config, config,source,&in->stream);
+        if(ret < 0){
+            recording_device = RECORDING_DEVICE_OTHER;
+        }
+        else{
+            ALOGD("use nano function\n");
+            in->stream.common.get_sample_rate = nano_get_sample_rate;
+            in->stream.common.get_buffer_size = nano_get_buffer_size;
+            in->stream.common.get_channels = nano_get_channels;
+            in->stream.common.get_format = nano_get_format;
+            in->stream.read = nano_read;
+        }
+    }
 /*[SEN5-autumn.zhao-2018-01-11] add for B06 audio support } */
 #endif
     *stream_in = &in->stream;
     ALOGD("%s: exit", __func__);
 
 #if ENABLE_NANO_NEW_PATH
-	if (nano_is_connected() && (devices & AUDIO_DEVICE_IN_BUILTIN_MIC)) {
+    if (nano_is_connected() && (devices & AUDIO_DEVICE_IN_BUILTIN_MIC)) {
         ret = nano_input_open(*stream_in, config);
         if (ret < 0) {
             ALOGD("%s: nano_input_open : %d",__func__,ret);
@@ -6273,7 +7058,7 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
 #endif
 
     return 0;
-err:
+/*err:
     if (in->resampler) {
         release_resampler(in->resampler);
         in->resampler = NULL;
@@ -6284,7 +7069,7 @@ err:
     }
     free(in);
     *stream_in = NULL;
-    return ret;
+    return ret;*/
 }
 
 static void adev_close_input_stream(struct audio_hw_device *dev,
@@ -6398,12 +7183,18 @@ int do_output_standby_l(struct audio_stream *stream)
     struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
     struct aml_audio_device *adev = aml_out->dev;
     struct dolby_ms12_desc *ms12 = &(adev->ms12);
-    if (aml_out->usecase >= STREAM_PCM_NORMAL && aml_out->usecase <= STREAM_USECASE_MAX) {
-        ALOGI("%s(%p), stream usecase: %s continuous_audio_mode %d,status %d", __func__,
-            aml_out, str_usecases[aml_out->usecase], adev->continuous_audio_mode,aml_out->status);
-    } else {
-        ALOGI("%s(%p), stream usecase %d invalid.status %d", __func__, aml_out, aml_out->usecase,aml_out->status);
+
+    ALOGI("[%s:%d] stream usecase:%s , continuous:%d", __func__, __LINE__,
+        usecase2Str(aml_out->usecase), adev->continuous_audio_mode);
+
+#ifdef ENABLE_BT_A2DP
+    if ((aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) && aml_out->a2dp_out) {
+        a2dp_out_standby(stream);
+        if ((eDolbyMS12Lib == adev->dolby_lib_type) && (ms12->dolby_ms12_enable == true)) {
+            get_dolby_ms12_cleanup(&adev->ms12);
+        }
     }
+#endif
 
     /*
     if continous mode,we need always have output.
@@ -6439,14 +7230,15 @@ int do_output_standby_l(struct audio_stream *stream)
             aml_out->resampler = NULL;
         }
     }
-    stream_usecase_t usecase = aml_out->usecase;
     usecase_change_validate_l (aml_out, true);
     pthread_mutex_unlock(&adev->alsa_pcm_lock);
-    if (is_usecase_mix (usecase) ) {
+    if (is_usecase_mix (aml_out->usecase) ) {
+        uint32_t usecase = adev->usecase_masks & ~ (1 << STREAM_PCM_MMAP);
+        /*unmask the mmap case*/
         ALOGI ("%s current usecase_masks %x",__func__,adev->usecase_masks);
         /* only relesae hw mixer when no direct output left */
-        if (adev->usecase_masks <= 1) {
-            if (eDolbyMS12Lib == adev->dolby_lib_type) {
+        if (usecase <= 1) {
+            if (eDolbyMS12Lib == adev->dolby_lib_type  && adev->ms12.dolby_ms12_enable) {
                 if (!continous_mode(adev)) {
                     // plug in HMDI ARC case, get_dolby_ms12_cleanup() will block HDMI ARC info send to audio hw
                     // Add some condition here to protect.
@@ -6457,8 +7249,8 @@ int do_output_standby_l(struct audio_stream *stream)
                     //ALOGI("[%s:%d] get_dolby_ms12_cleanup\n", __FUNCTION__, __LINE__);
                     pthread_mutex_lock(&adev->alsa_pcm_lock);
                     struct pcm *pcm = adev->pcm_handle[DIGITAL_DEVICE];
-                    if (is_dual_output_stream(out) && pcm) {
-                        ALOGI("%s close dual output pcm handle %p", __func__, pcm);
+                    if (/*is_dual_output_stream(out) &&*/ pcm) {
+                        ALOGI("%s close dual output raw pcm handle %p", __func__, pcm);
                         pcm_close(pcm);
                         adev->pcm_handle[DIGITAL_DEVICE] = NULL;
                         set_stream_dual_output(out, false);
@@ -6476,7 +7268,7 @@ int do_output_standby_l(struct audio_stream *stream)
             if (!continous_mode(adev)) {
                 adev->mix_init_flag = false;
             } else {
-                if (eDolbyMS12Lib == adev->dolby_lib_type) {
+                if (eDolbyMS12Lib == adev->dolby_lib_type  && adev->ms12.dolby_ms12_enable) {
                     if (adev->need_remove_conti_mode == true) {
                         ALOGI("%s,release ms12 here", __func__);
                         get_dolby_ms12_cleanup(&adev->ms12);
@@ -6486,37 +7278,39 @@ int do_output_standby_l(struct audio_stream *stream)
                         adev->continuous_audio_mode = 0;
                     }
                     pthread_mutex_lock(&adev->ms12.lock);
-                    if (adev->ms12_main1_dolby_dummy == false
-                        && !audio_is_linear_pcm(aml_out->hal_internal_format)) {
-                        char *argv[3] = {"ms12_runtime", "-pause", "0"};
-                        dolby_ms12_set_main_dummy(0, true);
-                        dolby_ms12_flush_main_input_buffer();
-                        dolby_ms12_set_pause_flag(false);
-                        //int iMS12DB = 0;//restore to full volume
-                        //set_dolby_ms12_primary_input_db_gain(&(adev->ms12), iMS12DB , 10);
-                        //adev->ms12.curDBGain = iMS12DB;
-                        aml_ms12_update_runtime_params_direct(&(adev->ms12), 3, argv);
-                        adev->ms12.is_continuous_paused = false;
-                        adev->ms12_main1_dolby_dummy = true;
-                        ALOGI("%s set main dd+ dummy", __func__);
-                    } else if (adev->ms12_ott_enable == true
-                               && audio_is_linear_pcm(aml_out->hal_internal_format)
-                               && (aml_out->flags & AUDIO_OUTPUT_FLAG_HW_AV_SYNC)) {
-#if 0
-                        dolby_ms12_set_ott_sound_input_enable(true);
-                        dolby_ms12_flush_main_input_buffer();
-                        adev->ms12_ott_enable = true;
-#else
-                        char *argv[3] = {"ms12_runtime", "-pause", "0"};
-                        dolby_ms12_flush_main_input_buffer();
-                        dolby_ms12_set_pause_flag(false);
-                        aml_ms12_update_runtime_params_direct(
-                            &(adev->ms12), 3, argv);
-                        adev->ms12.is_continuous_paused = false;
-                        dolby_ms12_set_main_dummy(1, true);
-                        adev->ms12_ott_enable = false;
-                        ALOGI("%s set ott dummy", __func__);
-#endif
+                    /*after standby we should clean ms12 position*/
+                    adev->ms12.last_frames_postion = 0;
+                    /*after ms12 lock, dolby_ms12_enable may be cleared with clean up function*/
+                    if (adev->ms12.dolby_ms12_enable) {
+                        if (adev->ms12_main1_dolby_dummy == false
+                            && !audio_is_linear_pcm(aml_out->hal_internal_format)) {
+                            dolby_ms12_set_main_dummy(0, true);
+                            dolby_ms12_main_flush(out);
+                            dolby_ms12_set_pause_flag(false);
+                            //int iMS12DB = 0;//restore to full volume
+                            //set_dolby_ms12_primary_input_db_gain(&(adev->ms12), iMS12DB , 10);
+                            //adev->ms12.curDBGain = iMS12DB;
+                            adev->ms12.is_continuous_paused = false;
+                            adev->ms12_main1_dolby_dummy = true;
+                            adev->ms12_out->hw_sync_mode = false;
+                            aml_out->hwsync->payload_offset = 0;
+                            adev->ms12.last_frames_postion = 0;
+                            get_sink_format((struct audio_stream_out *)adev->active_outputs[STREAM_PCM_NORMAL]);
+                            ALOGI("%s set main dd+ dummy", __func__);
+                        } else if (adev->ms12_ott_enable == true
+                                   && audio_is_linear_pcm(aml_out->hal_internal_format)
+                                   && (aml_out->flags & AUDIO_OUTPUT_FLAG_HW_AV_SYNC)) {
+
+                            dolby_ms12_main_flush(out);
+                            dolby_ms12_set_pause_flag(false);
+                            adev->ms12.is_continuous_paused = false;
+                            dolby_ms12_set_main_dummy(1, true);
+                            adev->ms12_ott_enable = false;
+                            adev->ms12_out->hw_sync_mode = false;
+                            aml_out->hwsync->payload_offset = 0;
+                            ALOGI("%s set ott dummy", __func__);
+                        }
+                        set_dolby_ms12_runtime_pause(&(adev->ms12), adev->ms12.is_continuous_paused);
                     }
                     pthread_mutex_unlock(&adev->ms12.lock);
                 }
@@ -6527,11 +7321,26 @@ int do_output_standby_l(struct audio_stream *stream)
             //release_spdif_encoder_output_buffer(out);
         }
     }
+
+    if (aml_out->resample_handle) {
+        aml_audio_resample_reset(aml_out->resample_handle);
+    }
+
+
     if (aml_out->is_normal_pcm) {
         set_system_app_mixing_status(aml_out, aml_out->status);
         aml_out->normal_pcm_mixing_config = false;
     }
     aml_out->pause_status = false;//clear pause status
+    if (aml_out->hw_sync_mode && aml_out->tsync_status != TSYNC_STATUS_STOP) {
+        ALOGI("%s set AUDIO_PAUSE\n",__func__);
+        sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_PAUSE");
+        aml_out->tsync_status = TSYNC_STATUS_PAUSED;
+
+        ALOGI("%s set AUDIO_STOP\n",__func__);
+        sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_STOP");
+        aml_out->tsync_status = TSYNC_STATUS_STOP;
+    }
     return 0;
 }
 
@@ -6572,56 +7381,6 @@ static bool is_iec61937_format (struct audio_stream_out *stream)
     return false;
 }
 
-static void aml_tinymix_set_spdif_format(audio_format_t output_format,struct aml_stream_out *stream)
-{
-    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
-    struct aml_audio_device *aml_dev = aml_out->dev;
-    int aml_spdif_format = AML_STEREO_PCM;
-    int spdif_mute = 0;
-    if (output_format == AUDIO_FORMAT_AC3) {
-        aml_spdif_format = AML_DOLBY_DIGITAL;
-#ifdef ENABLE_DTV_PATCH
-        audio_set_spdif_clock(stream, AML_DOLBY_DIGITAL);
-#endif
-    } else if (output_format == AUDIO_FORMAT_E_AC3) {
-        aml_spdif_format = AML_DOLBY_DIGITAL_PLUS;
-#ifdef ENABLE_DTV_PATCH
-        audio_set_spdif_clock(stream, AML_DOLBY_DIGITAL_PLUS);
-#endif
-        // for BOX with ms12 continous mode, need DDP output
-        if ((eDolbyMS12Lib == aml_dev->dolby_lib_type) && aml_dev->continuous_audio_mode && !aml_dev->is_TV) {
-            // do nothing
-        } else {
-            spdif_mute = 1;
-        }
-    } else if (output_format == AUDIO_FORMAT_MAT) {
-        aml_spdif_format = AML_TRUE_HD;
-#ifdef ENABLE_DTV_PATCH
-        audio_set_spdif_clock(stream, AML_TRUE_HD);
-#endif
-        // for BOX with ms12 continous mode, need DDP output
-        if ((eDolbyMS12Lib == aml_dev->dolby_lib_type) && aml_dev->continuous_audio_mode && !aml_dev->is_TV) {
-            // do nothing
-        } else {
-            spdif_mute = 1;
-        }
-    } else if (output_format == AUDIO_FORMAT_DTS) {
-        aml_spdif_format = AML_DTS;
-#ifdef ENABLE_DTV_PATCH
-        audio_set_spdif_clock(stream, AML_DTS);
-#endif
-    } else {
-        aml_spdif_format = AML_STEREO_PCM;
-#ifdef ENABLE_DTV_PATCH
-        audio_set_spdif_clock(stream, AML_STEREO_PCM);
-#endif
-    }
-    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_FORMAT, aml_spdif_format);
-    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_EARC_AUDIO_TYPE, aml_spdif_format);
-    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_MUTE, spdif_mute);
-    ALOGI("%s tinymix AML_MIXER_ID_SPDIF_FORMAT %d,spdif mute %d",
-          __FUNCTION__, aml_spdif_format, spdif_mute);
-}
 audio_format_t get_output_format (struct audio_stream_out *stream)
 {
     struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
@@ -6630,138 +7389,20 @@ audio_format_t get_output_format (struct audio_stream_out *stream)
 
     struct dolby_ms12_desc *ms12 = & (adev->ms12);
 
-    if (eDolbyMS12Lib == adev->dolby_lib_type) {
-        if (ms12->dolby_ms12_enable) {
-            output_format = adev->sink_format;
-        }
-    } else if (eDolbyDcvLib == adev->dolby_lib_type) {
-        if (adev->hdmi_format > 0) {
+    if (!is_dts_format(aml_out->hal_internal_format)) {
+        if (eDolbyMS12Lib == adev->dolby_lib_type) {
             output_format = adev->sink_format;
+        } else if (eDolbyDcvLib == adev->dolby_lib_type) {
+            if (adev->hdmi_format > 0) {
+                output_format = adev->sink_format;
+            }
         }
     }
 
-    if (adev->debug_flag)
+    if (adev->debug_flag > 1)
         ALOGI("%s(), out fmt %#x", __func__, output_format);
     return output_format;
 }
-ssize_t aml_audio_spdif_output (struct audio_stream_out *stream,
-                                void *buffer, size_t byte)
-{
-    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
-    struct aml_audio_device *aml_dev = aml_out->dev;
-    struct pcm *pcm = aml_dev->pcm_handle[DIGITAL_DEVICE];
-    struct aml_audio_patch *patch = aml_dev->audio_patch;
-    struct pcm_config config;
-    int ret = 0;
-    int codec_type = 0;
-
-    if (!is_dual_output_stream(stream)) {
-        ALOGE ("%s() not support, dual flag = %d",
-               __func__, is_dual_output_stream(stream));
-        return -EINVAL;
-    }
-
-    // SWPL-412, when input source is DTV, and UI set "parental_control_av_mute" command to audio hal
-    // we need to mute SPDIF audio output here
-    if (aml_dev->patch_src == SRC_DTV && aml_dev->parental_control_av_mute) {
-        memset(buffer,0x0,byte);
-    }
-    if (!pcm) {
-        /* init pcm configs, no DDP case in dual output */
-        memset(&config, 0, sizeof(struct pcm_config));
-        config.channels = 2;
-        if (eDolbyDcvLib == aml_dev->dolby_lib_type) {
-            config.rate = aml_out->config.rate;
-        } else {
-            config.rate = MM_FULL_POWER_SAMPLING_RATE;
-        }
-        // reset the sample rate
-        if (patch && (IS_HDMI_IN_HW(patch->input_src) ||
-                patch->input_src == AUDIO_DEVICE_IN_SPDIF)) {
-            if (patch->aformat == AUDIO_FORMAT_DTS ||
-                patch->aformat == AUDIO_FORMAT_DTS_HD) {
-                config.rate = aml_out->config.rate;
-                //ALOGD("rate=%d setrate=%d\n",config.rate,aml_out->config.rate);
-            }
-        }
-
-        config.period_size = DEFAULT_PLAYBACK_PERIOD_SIZE * 2;
-        config.period_count = PLAYBACK_PERIOD_COUNT;
-        config.start_threshold = DEFAULT_PLAYBACK_PERIOD_SIZE * 2 * PLAYBACK_PERIOD_COUNT;
-        config.format = PCM_FORMAT_S16_LE;
-
-        aml_tinymix_set_spdif_format(aml_dev->optical_format,aml_out);
-        pthread_mutex_lock(&aml_dev->alsa_pcm_lock);
-        unsigned int port = PORT_SPDIF;
-        port = alsa_device_update_pcm_index(port, PLAYBACK);
-        pcm = pcm_open(aml_out->card, port, PCM_OUT, &config);
-        if (!pcm_is_ready(pcm)) {
-            ALOGE("%s() cannot open pcm_out: %s,card %d,device %d", __func__, pcm_get_error(pcm), aml_out->card, DIGITAL_DEVICE);
-            pcm_close (pcm);
-            pthread_mutex_unlock(&aml_dev->alsa_pcm_lock);
-            return -ENOENT;
-        }
-        ALOGI("%s open dual output pcm handle %p,port %d", __func__, pcm,port);
-        aml_dev->pcm_handle[DIGITAL_DEVICE] = pcm;
-        pthread_mutex_unlock(&aml_dev->alsa_pcm_lock);
-
-    }
-
-    if (eDolbyDcvLib == aml_dev->dolby_lib_type) {
-
-#ifdef ADD_AUDIO_DELAY_INTERFACE
-        // spdif(RAW) delay process, frame size 2 ch * 2 Byte
-        aml_audio_delay_process(AML_DELAY_OUTPORT_SPDIF, buffer, byte, AUDIO_FORMAT_IEC61937, 2);
-#endif
-        pthread_mutex_lock(&aml_dev->alsa_pcm_lock);
-        ret = pcm_write(pcm, buffer, byte);
-        pthread_mutex_unlock(&aml_dev->alsa_pcm_lock);
-        if (ret < 0) {
-            ALOGE("%s write failed,pcm handle %p err num %d", __func__, pcm, ret);
-        }
-        ALOGV("%s(), aml_alsa_output_write bytes = %zu", __func__, byte);
-
-    } else {
-        if (!aml_dev->dual_spdifenc_inited) {
-            if ((eDolbyMS12Lib == aml_dev->dolby_lib_type) && (!aml_dev->is_TV)) {
-                // when use ms12 on BOX case, we also need to allow EAC3 output from SPDIF port .zzz
-                if (aml_dev->optical_format != AUDIO_FORMAT_AC3 &&
-                    aml_dev->optical_format != AUDIO_FORMAT_E_AC3 &&
-                    aml_dev->optical_format != AUDIO_FORMAT_MAT) {
-                    ALOGE("%s() not support, optical format = %#x",
-                          __func__, aml_dev->optical_format);
-                    return -EINVAL;
-                }
-            } else {
-                if (aml_dev->optical_format != AUDIO_FORMAT_AC3) {
-                    ALOGE("%s() not support, optical format = %#x",
-                          __func__, aml_dev->optical_format);
-                    return -EINVAL;
-                }
-            }
-
-            int init_ret = spdifenc_init(pcm, aml_dev->optical_format);
-            if (init_ret == 0) {
-                aml_dev->dual_spdifenc_inited = 1;
-                if (aml_dev->optical_format == AUDIO_FORMAT_AC3) {
-                    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_FORMAT, AML_DOLBY_DIGITAL);
-                    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_EARC_AUDIO_TYPE, AML_DOLBY_DIGITAL);
-                } else if (aml_dev->optical_format == AUDIO_FORMAT_E_AC3) {
-                    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_FORMAT, AML_DOLBY_DIGITAL_PLUS);
-                    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_EARC_AUDIO_TYPE, AML_DOLBY_DIGITAL_PLUS);
-                } else if (aml_dev->optical_format == AUDIO_FORMAT_MAT) {
-                    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_FORMAT, AML_TRUE_HD);
-                }
-                spdifenc_set_mute(aml_out->offload_mute);
-                ALOGI("%s tinymix AML_MIXER_ID_SPDIF_FORMAT %d\n", __FUNCTION__, AML_DOLBY_DIGITAL);
-            }
-        }
-
-        ret = spdifenc_write(buffer, byte);
-        //ALOGI("%s(), spdif write bytes = %d", __func__, ret);
-    }
-    return ret;
-}
 
 /* AEC need a wall clock (monotonic clk?) to sync*/
 static aec_timestamp get_timestamp(void) {
@@ -6770,7 +7411,7 @@ static aec_timestamp get_timestamp(void) {
     aec_timestamp return_val;
     /*clock_gettime(CLOCK_MONOTONIC, &ts);*/
     clock_gettime(CLOCK_REALTIME, &ts);
-    current_time = ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
+    current_time = (unsigned long long)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
     return_val.timeStamp = current_time;
     return return_val;
 }
@@ -6976,7 +7617,7 @@ static void output_mute(struct audio_stream_out *stream, size_t *output_buffer_b
     struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
     struct aml_audio_device *adev = aml_out->dev;
     size_t target_len = MIN(aml_out->tmp_buffer_8ch_size, *output_buffer_bytes);
-    int timer_in_ms = 0;
+    //int timer_in_ms = 0;
 
     if (adev->patch_src == SRC_LINEIN || adev->patch_src == SRC_SPDIFIN
             || adev->patch_src == SRC_HDMIIN || adev->patch_src == SRC_ARCIN) {
@@ -6986,7 +7627,7 @@ static void output_mute(struct audio_stream_out *stream, size_t *output_buffer_b
             clock_gettime(CLOCK_MONOTONIC, &adev->mute_start_ts);
             adev->patch_start = true;
             adev->mute_start = true;
-            timer_in_ms = 1000;
+            adev->timer_in_ms = 1000;
             //ALOGI ("%s() detect AUX/SPDIF start mute!", __func__);
         }
 
@@ -6995,27 +7636,28 @@ static void output_mute(struct audio_stream_out *stream, size_t *output_buffer_b
             clock_gettime(CLOCK_MONOTONIC, &adev->mute_start_ts);
             adev->spdif_fmt_hw = adev->active_input->spdif_fmt_hw;
             adev->mute_start = true;
-            timer_in_ms = 500;
+            adev->timer_in_ms = 500;
             ALOGI ("%s() detect AUX/SPDIF format change, start mute!", __func__);
         }
     } else if (adev->patch_src == SRC_DTV || adev->patch_src == SRC_ATV) {
         /*dtv start patching, mute 200ms, then start fade in.*/
-        if (adev->audio_patch != NULL && (!adev->patch_start)) {
+        if (adev->audio_patch != NULL && (!adev->patch_start) && (adev->audio_patch->output_thread_exit == 0)) {
             clock_gettime(CLOCK_MONOTONIC, &adev->mute_start_ts);
-            adev->patch_start = 1;
+            adev->patch_start = true;
             adev->mute_start = true;
-            timer_in_ms = 200;
+            adev->timer_in_ms = 200;
             ALOGI ("%s() detect tv source start mute 200ms", __func__);
         }
     }
 
     if (aml_out->tmp_buffer_8ch != NULL && adev->mute_start) {
-        if (!Stop_watch(adev->mute_start_ts, timer_in_ms)) {
+        if (!Stop_watch(adev->mute_start_ts, adev->timer_in_ms)) {
             adev->mute_start = false;
+            adev->timer_in_ms = 0;
             start_ease_in(adev);
-            ALOGI ("%s() tv source unmute, start fade in", __func__);
+            ALOGI("%s() tv source unmute, start fade in", __func__);
         } else {
-            ALOGD("%s line %d target memset len 0x%x\n", __func__, __LINE__, target_len);
+            ALOGV("%s line %d target memset len 0x%x\n", __func__, __LINE__, target_len);
             memset(aml_out->tmp_buffer_8ch, 0, target_len);
         }
     }
@@ -7024,6 +7666,7 @@ static void output_mute(struct audio_stream_out *stream, size_t *output_buffer_b
     aml_audio_ease_process(adev->audio_ease, aml_out->tmp_buffer_8ch, target_len);
     return;
 }
+
 #define EQ_GAIN_DEFAULT (0.16)
 /* ms12v2 output format is 8 channel 16 bit */
 ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
@@ -7032,13 +7675,13 @@ ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
                                 void **output_buffer,
                                 size_t *output_buffer_bytes,
                                 audio_format_t output_format,
-				int nchannels)
+                                int nchannels)
 {
     struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
     struct aml_audio_device *adev = aml_out->dev;
     int16_t *tmp_buffer = (int16_t *) buffer;
     int16_t *effect_tmp_buf = NULL;
-    int out_frames = bytes / (nchannels * 2); /* input is nchannel 16 bit */
+    int out_frames = bytes / (nchannels * 2); /* input is nchannels 16 bit */
     size_t i;
     int j, ret;
     uint32_t latency_frames = 0;
@@ -7076,7 +7719,7 @@ ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
             *output_buffer_bytes = adev->temp_buf_pos;
         }
     } else {
-        /* nchannel 16 bit PCM, and there is no effect applied after MS12 processing */
+        /* nchannels 16 bit PCM, and there is no effect applied after MS12 processing */
         if (aml_out->is_tv_platform == 1) {
             int16_t *tmp_buffer = (int16_t *)buffer;
             size_t out_frames = bytes / (nchannels * 2); /* input is nchannels 16 bit */
@@ -7085,9 +7728,12 @@ ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
             effect_descriptor_t tmpdesc;
             int32_t *spk_tmp_buf;
             int32_t *ps32SpdifTempBuffer = NULL;
+#ifdef AML_EQ_DRC
             float source_gain;
             float gain_speaker = adev->eq_data.p_gain.speaker;
-
+#else
+            float gain_speaker = 1.0;
+#endif
             /* handling audio effect process here */
             if (adev->effect_buf_size < bytes) {
                 adev->effect_buf = realloc(adev->effect_buf, bytes);
@@ -7123,6 +7769,7 @@ ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
             memcpy(effect_tmp_buf, tmp_buffer, bytes);
 #endif
 
+#ifdef AML_EQ_DRC
             /*apply dtv source gain for speaker*/
             if (adev->patch_src == SRC_DTV && adev->audio_patching)
                 source_gain = adev->eq_data.s_gain.dtv;
@@ -7137,6 +7784,7 @@ ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
 
             if (source_gain != 1.0)
                 apply_volume(source_gain, effect_tmp_buf, sizeof(int16_t), bytes);
+#endif
 
             /*aduio effect process for speaker*/
             if (adev->native_postprocess.num_postprocessors == adev->native_postprocess.total_postprocessors) {
@@ -7162,7 +7810,7 @@ ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
             }
 
             if (aml_getprop_bool("media.audiohal.outdump")) {
-                FILE *fp1 = fopen("/data/audio/audio_spk.pcm", "a+");
+                FILE *fp1 = fopen("/data/vendor/audiohal/ms12_out_spk.pcm", "a+");
                 if (fp1) {
                     int flen = fwrite((char *)tmp_buffer, 1, bytes, fp1);
                     ALOGV("%s buffer %p size %zu\n", __FUNCTION__, effect_tmp_buf, bytes);
@@ -7202,7 +7850,7 @@ ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
             gain_speaker *= aml_out->volume_l;
             apply_volume_16to32(gain_speaker, effect_tmp_buf, spk_tmp_buf, bytes);
 
-            /* nchannels 32 bits --> 8 ch 32 bit mapping */
+            /* nchannels 32 bit --> 8 channel 32 bit mapping */
             if (aml_out->tmp_buffer_8ch_size < out_frames * 32) {
                 aml_out->tmp_buffer_8ch = realloc(aml_out->tmp_buffer_8ch, out_frames * 32);
                 if (!aml_out->tmp_buffer_8ch) {
@@ -7216,7 +7864,6 @@ ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
                 aml_out->tmp_buffer_8ch_size = out_frames * 32;
             }
 
-            /* TODO: channel mapping from nchannels -> output speaker configuration */
             for (i = 0; i < out_frames; i++) {
                 for (j = 0; j < nchannels; j++) {
                     aml_out->tmp_buffer_8ch[8 * i + j] = (int32_t)spk_tmp_buf[nchannels * i + j];
@@ -7281,9 +7928,13 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
     uint64_t total_frame = 0;
 
     /* raw data need packet to IEC61937 format by spdif encoder */
-    if ((output_format == AUDIO_FORMAT_AC3) || (output_format == AUDIO_FORMAT_E_AC3) || (output_format == AUDIO_FORMAT_MAT)) {
-        //ALOGI("%s, aml_out->hal_format %x , is_iec61937_format = %d, \n", __func__, aml_out->hal_format,is_iec61937_format(stream));
-        if ((is_iec61937_format(stream) == true) ||
+    if ((output_format == AUDIO_FORMAT_AC3)   ||
+        (output_format == AUDIO_FORMAT_E_AC3) ||
+        (output_format == AUDIO_FORMAT_MAT)) {
+        if (adev->debug_flag)
+            ALOGI("%s, aml_out->hal_format %x , is_iec61937_format = %d, \n",
+                __func__, aml_out->hal_format,is_iec61937_format(stream));
+        if (((is_iec61937_format(stream) == true) && (aml_out->hal_internal_format != AUDIO_FORMAT_MAT)) ||
             (adev->dolby_lib_type == eDolbyDcvLib)) {
             *output_buffer = (void *) buffer;
             *output_buffer_bytes = bytes;
@@ -7305,9 +7956,9 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
             }
             spdif_encoder_ad_flush_output_current_position();
 
-            //ALOGI("%s: SPDIF", __func__);
             *output_buffer = adev->temp_buf;
             *output_buffer_bytes = adev->temp_buf_pos;
+            //ALOGI("%s: SPDIF encoder size=%d", __func__, *output_buffer_bytes);
         }
     } else if (output_format == AUDIO_FORMAT_DTS) {
         *output_buffer = (void *) buffer;
@@ -7316,57 +7967,61 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
         int32_t *tmp_buffer = (int32_t *)buffer;
         size_t out_frames = bytes / FRAMESIZE_32BIT_STEREO;
 
-        if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm && adev->bHDMIARCon) {
+        if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm /*&& adev->bHDMIARCon*/) {
             apply_volume(1.0, tmp_buffer, sizeof(uint32_t), bytes);
             *output_buffer = tmp_buffer;
             *output_buffer_bytes = bytes;
         } else {
-        float gain_speaker = adev->sink_gain[OUTPORT_SPEAKER];
-        if (aml_out->hw_sync_mode)
-             gain_speaker *= aml_out->volume_l;
-        apply_volume(gain_speaker, tmp_buffer, sizeof(uint32_t), bytes);
-
-        /* 2 ch 32 bit --> 8 ch 32 bit mapping, need 8X size of input buffer size */
-        if (aml_out->tmp_buffer_8ch_size < FRAMESIZE_32BIT_8ch * out_frames) {
-            aml_out->tmp_buffer_8ch = realloc(aml_out->tmp_buffer_8ch, FRAMESIZE_32BIT_8ch * out_frames);
-            if (!aml_out->tmp_buffer_8ch) {
-                ALOGE("%s: realloc tmp_buffer_8ch buf failed size = %zu format = %#x", __func__,
-                        FRAMESIZE_32BIT_8ch * out_frames, output_format);
-                return -ENOMEM;
-            } else {
-                ALOGI("%s: realloc tmp_buffer_8ch size from %zu to %zu format = %#x", __func__,
-                        aml_out->tmp_buffer_8ch_size, FRAMESIZE_32BIT_8ch * out_frames, output_format);
+            float gain_speaker = adev->sink_gain[OUTPORT_SPEAKER];
+            if (aml_out->hw_sync_mode)
+                 gain_speaker *= aml_out->volume_l;
+            apply_volume(gain_speaker, tmp_buffer, sizeof(uint32_t), bytes);
+
+            /* 2 ch 32 bit --> 8 ch 32 bit mapping, need 8X size of input buffer size */
+            if (aml_out->tmp_buffer_8ch_size < FRAMESIZE_32BIT_8ch * out_frames) {
+                aml_out->tmp_buffer_8ch = realloc(aml_out->tmp_buffer_8ch, FRAMESIZE_32BIT_8ch * out_frames);
+                if (!aml_out->tmp_buffer_8ch) {
+                    ALOGE("%s: realloc tmp_buffer_8ch buf failed size = %zu format = %#x", __func__,
+                            FRAMESIZE_32BIT_8ch * out_frames, output_format);
+                    return -ENOMEM;
+                } else {
+                    ALOGI("%s: realloc tmp_buffer_8ch size from %zu to %zu format = %#x", __func__,
+                            aml_out->tmp_buffer_8ch_size, FRAMESIZE_32BIT_8ch * out_frames, output_format);
+                }
+                aml_out->tmp_buffer_8ch_size = FRAMESIZE_32BIT_8ch * out_frames;
             }
-            aml_out->tmp_buffer_8ch_size = FRAMESIZE_32BIT_8ch * out_frames;
-        }
 
-        for (i = 0; i < out_frames; i++) {
-            aml_out->tmp_buffer_8ch[8 * i] = tmp_buffer[2 * i];
-            aml_out->tmp_buffer_8ch[8 * i + 1] = tmp_buffer[2 * i + 1];
-            aml_out->tmp_buffer_8ch[8 * i + 2] = tmp_buffer[2 * i];
-            aml_out->tmp_buffer_8ch[8 * i + 3] = tmp_buffer[2 * i + 1];
-            aml_out->tmp_buffer_8ch[8 * i + 4] = tmp_buffer[2 * i];
-            aml_out->tmp_buffer_8ch[8 * i + 5] = tmp_buffer[2 * i + 1];
-            aml_out->tmp_buffer_8ch[8 * i + 6] = 0;
-            aml_out->tmp_buffer_8ch[8 * i + 7] = 0;
-        }
+            for (i = 0; i < out_frames; i++) {
+                aml_out->tmp_buffer_8ch[8 * i]     = tmp_buffer[2 * i];
+                aml_out->tmp_buffer_8ch[8 * i + 1] = tmp_buffer[2 * i + 1];
+                aml_out->tmp_buffer_8ch[8 * i + 2] = tmp_buffer[2 * i];
+                aml_out->tmp_buffer_8ch[8 * i + 3] = tmp_buffer[2 * i + 1];
+                aml_out->tmp_buffer_8ch[8 * i + 4] = tmp_buffer[2 * i];
+                aml_out->tmp_buffer_8ch[8 * i + 5] = tmp_buffer[2 * i + 1];
+                aml_out->tmp_buffer_8ch[8 * i + 6] = 0;
+                aml_out->tmp_buffer_8ch[8 * i + 7] = 0;
+            }
 
-        *output_buffer = aml_out->tmp_buffer_8ch;
-        *output_buffer_bytes = FRAMESIZE_32BIT_8ch * out_frames;
+            *output_buffer = aml_out->tmp_buffer_8ch;
+            *output_buffer_bytes = FRAMESIZE_32BIT_8ch * out_frames;
         }
     } else {
         /*atom project supports 32bit hal only*/
         /*TODO: Direct PCM case, I think still needs EQ and AEC */
+
         if (aml_out->is_tv_platform == 1) {
             int16_t *tmp_buffer = (int16_t *)buffer;
             size_t out_frames = bytes / (2 * 2);
-
             int16_t *effect_tmp_buf;
             effect_descriptor_t tmpdesc;
             int32_t *spk_tmp_buf;
             int32_t *ps32SpdifTempBuffer = NULL;
             float source_gain;
+#ifdef AML_EQ_DRC
             float gain_speaker = adev->eq_data.p_gain.speaker;
+#else
+            float gain_speaker = 1.0;
+#endif
 
             /* handling audio effect process here */
             if (adev->effect_buf_size < bytes) {
@@ -7384,9 +8039,10 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
                     ALOGE ("realloc headphone buf failed size %zu format = %#x", bytes, output_format);
                     return -ENOMEM;
                 }
-                adev->spdif_output_buf = realloc(adev->spdif_output_buf, bytes*2);
+                // 16bit -> 32bit, need realloc
+                adev->spdif_output_buf = realloc(adev->spdif_output_buf, bytes * 2);
                 if (!adev->spdif_output_buf) {
-                    ALOGE ("realloc spdif buf failed size %zu format = %#x", bytes*2, output_format);
+                    ALOGE ("realloc spdif buf failed size %zu format = %#x", bytes * 2, output_format);
                     return -ENOMEM;
                 }
             }
@@ -7402,6 +8058,7 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
 #endif
 
             /*apply dtv source gain for speaker*/
+#ifdef AML_EQ_DRC
             if (adev->patch_src == SRC_DTV && adev->audio_patching)
                 source_gain = adev->eq_data.s_gain.dtv;
             else if (adev->patch_src == SRC_HDMIIN && adev->audio_patching)
@@ -7411,33 +8068,43 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
             else if (adev->patch_src == SRC_ATV && adev->audio_patching)
                 source_gain = adev->eq_data.s_gain.atv;
             else
-                source_gain = 1.0;
+                source_gain = adev->eq_data.s_gain.media;
 
             if (source_gain != 1.0)
                 apply_volume(source_gain, effect_tmp_buf, sizeof(int16_t), bytes);
+#else
+            source_gain = 1.0;
+#endif
 
+            if (adev->patch_src == SRC_DTV && adev->audio_patch != NULL) {
+                aml_audio_switch_output_mode((int16_t *)effect_tmp_buf, bytes, adev->audio_patch->mode);
+            } else if ( adev->audio_patch == NULL) {
+               if (adev->sound_track_mode == 3)
+                  adev->sound_track_mode = AM_AOUT_OUTPUT_LRMIX;
+               aml_audio_switch_output_mode((int16_t *)effect_tmp_buf, bytes, adev->sound_track_mode);
+            }
             /*aduio effect process for speaker*/
             if (adev->native_postprocess.num_postprocessors == adev->native_postprocess.total_postprocessors) {
                 for (j = 0; j < adev->native_postprocess.num_postprocessors; j++) {
-                    audio_post_process(adev->native_postprocess.postprocessors[j], effect_tmp_buf, out_frames);
-                }
-                /*
-                according to dts profile2 block diagram: Trusurround:X->Truvolume->TBHDX->customer modules->MC Dynamics
-                virtualx will be called twice,first implementation for process Trusurround:X->Truvolume->TBHDX
-                final implementation for process MC Dynamics
-                */
-                if (adev->native_postprocess.postprocessors[0] != NULL) {
-                    (*(adev->native_postprocess.postprocessors[0]))->get_descriptor(adev->native_postprocess.postprocessors[0], &tmpdesc);
-                    if (0 == strcmp(tmpdesc.name,"VirtualX")) {
-                        audio_post_process(adev->native_postprocess.postprocessors[0], effect_tmp_buf, out_frames);
+                    if (adev->effect_in_ch == 6) {
+                        if (adev->native_postprocess.postprocessors[j] != NULL) {
+                            (*(adev->native_postprocess.postprocessors[j]))->get_descriptor(adev->native_postprocess.postprocessors[j], &tmpdesc);
+                            if (0 != strcmp(tmpdesc.name,"VirtualX")) {
+                                audio_post_process(adev->native_postprocess.postprocessors[j], effect_tmp_buf, out_frames);
+                            }
+                        }
+                    } else {
+                        audio_post_process(adev->native_postprocess.postprocessors[j], effect_tmp_buf, out_frames);
                     }
                 }
-            } else {
+            }
+#if 0
+            else {
                 gain_speaker *= EQ_GAIN_DEFAULT;
             }
-
+#endif
             if (aml_getprop_bool("media.audiohal.outdump")) {
-                FILE *fp1 = fopen("/data/audio_spk.pcm", "a+");
+                FILE *fp1 = fopen("/data/vendor/audiohal/ms12_out_spk.pcm", "a+");
                 if (fp1) {
                     int flen = fwrite((char *)effect_tmp_buf, 1, bytes, fp1);
                     ALOGV("%s buffer %p size %zu\n", __FUNCTION__, effect_tmp_buf, bytes);
@@ -7445,83 +8112,91 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
                 }
             }
 
-            if (adev->patch_src == SRC_DTV && adev->audio_patch != NULL) {
-                aml_audio_switch_output_mode((int16_t *)effect_tmp_buf, bytes, adev->audio_patch->mode);
-            } else if ( adev->audio_patch == NULL) {
-               if (adev->sound_track_mode == 3)
-                  adev->sound_track_mode = AM_AOUT_OUTPUT_LRMIX;
-               aml_audio_switch_output_mode((int16_t *)effect_tmp_buf, bytes, adev->sound_track_mode);
-            }
-
-            /* SPDIF keep the max volume 1.0 */
-            for (i = 0; i < out_frames; i++) {
-                ps32SpdifTempBuffer[2 * i]      = tmp_buffer[2 * i] << 16;
-                ps32SpdifTempBuffer[2 * i + 1]  = tmp_buffer[2 * i + 1] << 16;
-            }
-#ifdef ADD_AUDIO_DELAY_INTERFACE
-            aml_audio_delay_process(AML_DELAY_OUTPORT_SPEAKER, effect_tmp_buf, out_frames * 2 * 2, AUDIO_FORMAT_PCM_16_BIT, 2);
-            if (OUTPORT_SPEAKER == adev->active_outport) {
-                if (AUDIO_FORMAT_PCM_16_BIT == aml_out->hal_internal_format) {
-                    // spdif(PCM) out delay process, frame size 2ch * 4 Byte
-                    aml_audio_delay_process(AML_DELAY_OUTPORT_SPDIF, ps32SpdifTempBuffer, out_frames * 2 * 4, AUDIO_FORMAT_PCM_16_BIT, 2);
-                }
-            }
-#endif
-
-            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm && adev->bHDMIARCon) {
+            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm/* && adev->bHDMIARCon */) {
                 apply_volume_16to32(1.0, tmp_buffer, spk_tmp_buf, bytes);
                 *output_buffer = (void *) spk_tmp_buf;
                 *output_buffer_bytes = bytes * 2;
             } else {
-            /* apply volume for spk/hp, SPDIF/HDMI keep the max volume */
-            gain_speaker *= (adev->sink_gain[OUTPORT_SPEAKER]);
-            apply_volume_16to32(gain_speaker, effect_tmp_buf, spk_tmp_buf, bytes);
-
-            /* 2 ch 32 bit --> 8 ch 32 bit mapping, need 8X size of input buffer size */
-            if (aml_out->tmp_buffer_8ch_size < 8 * bytes) {
-                aml_out->tmp_buffer_8ch = realloc(aml_out->tmp_buffer_8ch, 8 * bytes);
-                if (!aml_out->tmp_buffer_8ch) {
-                    ALOGE("%s: realloc tmp_buffer_8ch buf failed size = %zu format = %#x",
-                        __func__, 8 * bytes, output_format);
-                    return -ENOMEM;
+                 /* apply volume for spk/hp, SPDIF/HDMI keep the max volume */
+                if (adev->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+                    if ((adev->patch_src == SRC_DTV || adev->patch_src == SRC_HDMIIN
+                            || adev->patch_src == SRC_LINEIN || adev->patch_src == SRC_ATV)
+                            && adev->audio_patching) {
+                        gain_speaker *= (adev->sink_gain[OUTPORT_A2DP]);
+                        apply_volume_16to32(gain_speaker * source_gain, effect_tmp_buf, spk_tmp_buf, bytes);
+                    } else {
+                        apply_volume_16to32(source_gain, effect_tmp_buf, spk_tmp_buf, bytes);
+                    }
                 } else {
-                    ALOGI("%s: realloc tmp_buffer_8ch size from %zu to %zu format = %#x",
-                        __func__, aml_out->tmp_buffer_8ch_size, 8 * bytes, output_format);
+                    gain_speaker *= (adev->sink_gain[OUTPORT_SPEAKER]);
+                    apply_volume_16to32(gain_speaker * source_gain * adev->dap_bypassgain, effect_tmp_buf, spk_tmp_buf, bytes);
+                    if (eDolbyMS12Lib == adev->dolby_lib_type) {
+                        /* SPDIF with source_gain*/
+                        if (get_buffer_read_space(&adev->ms12.spdif_ring_buffer) >= (int)bytes) {
+                            ring_buffer_read(&adev->ms12.spdif_ring_buffer, (unsigned char*)adev->ms12.lpcm_temp_buffer, bytes);
+                            apply_volume_16to32(source_gain, (int16_t *)adev->ms12.lpcm_temp_buffer, ps32SpdifTempBuffer, bytes);
+                        }
+                    }
                 }
-                aml_out->tmp_buffer_8ch_size = 8 * bytes;
-            }
 
-            if (alsa_device_is_auge()) {
-                for (i = 0; i < out_frames; i++) {
-                    aml_out->tmp_buffer_8ch[8 * i + 0] = (int32_t)spk_tmp_buf[2 * i];
-                    aml_out->tmp_buffer_8ch[8 * i + 1] = (int32_t)spk_tmp_buf[2 * i + 1];
-                    aml_out->tmp_buffer_8ch[8 * i + 2] = (int32_t)tmp_buffer[2 * i] << 16;
-                    aml_out->tmp_buffer_8ch[8 * i + 3] = (int32_t)tmp_buffer[2 * i + 1] << 16;
-                    aml_out->tmp_buffer_8ch[8 * i + 4] = (int32_t)tmp_buffer[2 * i] << 16;
-                    aml_out->tmp_buffer_8ch[8 * i + 5] = (int32_t)tmp_buffer[2 * i + 1] << 16;
-                    aml_out->tmp_buffer_8ch[8 * i + 6] = (int32_t)tmp_buffer[2 * i] << 16;
-                    aml_out->tmp_buffer_8ch[8 * i + 7] = (int32_t)tmp_buffer[2 * i + 1] << 16;
+#ifdef ADD_AUDIO_DELAY_INTERFACE
+                aml_audio_delay_process(AML_DELAY_OUTPORT_SPEAKER, spk_tmp_buf,
+                            out_frames * 2 * 4, AUDIO_FORMAT_PCM_16_BIT, 2);
+                if (OUTPORT_SPEAKER == adev->active_outport && AUDIO_FORMAT_PCM_16_BIT == aml_out->hal_internal_format) {
+                    // spdif(PCM) out delay process, frame size 2ch * 4 Byte
+                    aml_audio_delay_process(AML_DELAY_OUTPORT_SPDIF, ps32SpdifTempBuffer,
+                        out_frames * 2 * 4, AUDIO_FORMAT_PCM_16_BIT, 2);
                 }
-            } else {
-                for (i = 0; i < out_frames; i++) {
-                    aml_out->tmp_buffer_8ch[8 * i + 0] = (int32_t)tmp_buffer[2 * i] << 16;
-                    aml_out->tmp_buffer_8ch[8 * i + 1] = (int32_t)tmp_buffer[2 * i + 1] << 16;
-                    aml_out->tmp_buffer_8ch[8 * i + 2] = (int32_t)spk_tmp_buf[2 * i];
-                    aml_out->tmp_buffer_8ch[8 * i + 3] = (int32_t)spk_tmp_buf[2 * i + 1];
-                    aml_out->tmp_buffer_8ch[8 * i + 4] = (int32_t)tmp_buffer[2 * i] << 16;
-                    aml_out->tmp_buffer_8ch[8 * i + 5] = (int32_t)tmp_buffer[2 * i + 1] << 16;
-                    aml_out->tmp_buffer_8ch[8 * i + 6] = 0;
-                    aml_out->tmp_buffer_8ch[8 * i + 7] = 0;
+#endif
+                /* 2 ch 32 bit --> 8 ch 32 bit mapping, need 8X size of input buffer size */
+                if (aml_out->tmp_buffer_8ch_size < 8 * bytes) {
+                    aml_out->tmp_buffer_8ch = realloc(aml_out->tmp_buffer_8ch, 8 * bytes);
+                    if (!aml_out->tmp_buffer_8ch) {
+                        ALOGE("%s: realloc tmp_buffer_8ch buf failed size = %zu format = %#x",
+                            __func__, 8 * bytes, output_format);
+                        return -ENOMEM;
+                    } else {
+                        ALOGI("%s: realloc tmp_buffer_8ch size from %zu to %zu format = %#x",
+                            __func__, aml_out->tmp_buffer_8ch_size, 8 * bytes, output_format);
+                    }
+                    aml_out->tmp_buffer_8ch_size = 8 * bytes;
                 }
-            }
 
-            *output_buffer = aml_out->tmp_buffer_8ch;
-            *output_buffer_bytes = 8 * bytes;
+                if (alsa_device_is_auge()) {
+                    for (i = 0; i < out_frames; i++) {
+                        aml_out->tmp_buffer_8ch[8 * i + 0] = (int32_t)spk_tmp_buf[2 * i];
+                        aml_out->tmp_buffer_8ch[8 * i + 1] = (int32_t)spk_tmp_buf[2 * i + 1];
+                        aml_out->tmp_buffer_8ch[8 * i + 2] = (int32_t)spk_tmp_buf[2 * i];
+                        aml_out->tmp_buffer_8ch[8 * i + 3] = (int32_t)spk_tmp_buf[2 * i + 1];
+                        aml_out->tmp_buffer_8ch[8 * i + 4] = (int32_t)spk_tmp_buf[2 * i];
+                        aml_out->tmp_buffer_8ch[8 * i + 5] = (int32_t)spk_tmp_buf[2 * i + 1];
+                        aml_out->tmp_buffer_8ch[8 * i + 6] = (int32_t)spk_tmp_buf[2 * i];
+                        aml_out->tmp_buffer_8ch[8 * i + 7] = (int32_t)spk_tmp_buf[2 * i + 1];
+                    }
+                } else {
+                    for (i = 0; i < out_frames; i++) {
+                        aml_out->tmp_buffer_8ch[8 * i + 0] = (int32_t)tmp_buffer[2 * i] << 16;
+                        aml_out->tmp_buffer_8ch[8 * i + 1] = (int32_t)tmp_buffer[2 * i + 1] << 16;
+                        //aml_out->tmp_buffer_8ch[8 * i + 2] = (int32_t)spk_tmp_buf[2 * i];
+                        //aml_out->tmp_buffer_8ch[8 * i + 3] = (int32_t)spk_tmp_buf[2 * i + 1];
+                        aml_out->tmp_buffer_8ch[8 * i + 2] = (int32_t)tmp_buffer[2 * i] << 16;
+                        aml_out->tmp_buffer_8ch[8 * i + 3] = (int32_t)tmp_buffer[2 * i + 1] << 16;
+                        aml_out->tmp_buffer_8ch[8 * i + 4] = (int32_t)tmp_buffer[2 * i] << 16;
+                        aml_out->tmp_buffer_8ch[8 * i + 5] = (int32_t)tmp_buffer[2 * i + 1] << 16;
+                        aml_out->tmp_buffer_8ch[8 * i + 6] = 0;
+                        aml_out->tmp_buffer_8ch[8 * i + 7] = 0;
+                    }
+                }
+
+                *output_buffer = aml_out->tmp_buffer_8ch;
+                *output_buffer_bytes = 8 * bytes;
             }
         } else {
             float gain_speaker = 1.0;
-            if (adev->is_STB)
+            if (!adev->is_TV)
                 gain_speaker = adev->sink_gain[adev->active_outport];
+            else if (aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP)
+                gain_speaker = adev->sink_gain[OUTPORT_A2DP];
             else
                 gain_speaker = adev->sink_gain[OUTPORT_SPEAKER];
 
@@ -7553,13 +8228,40 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
  *specially, the dual decoder is false and continuous audio mode is false.
  *because Dolby MS12 is working at LiveTV+(Dual Decoder) or Continuous Mode.
  */
-static bool is_bypass_dolbyms12(struct audio_stream_out *stream)
+bool is_bypass_dolbyms12(struct audio_stream_out *stream)
 {
     struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
     struct aml_audio_device *adev = aml_out->dev;
 
-    return ((adev->disable_pcm_mixing == true) && (adev->dual_decoder_support == false) && \
-            (adev->continuous_audio_mode == false) && (get_output_format(stream) == AUDIO_FORMAT_E_AC3));
+    audio_format_t support_format = get_output_format(stream);
+    bool is_byass_format = false;
+    bool is_bypass_setting = false;
+    /*dts audio should bypass this dolby's decoder*/
+    bool is_dts = is_dts_format(aml_out->hal_internal_format);
+
+    /*(bypass ms12 setting is that passthrough and NOT dual-decoder and NOT continuous mode */
+    if ((adev->hdmi_format == BYPASS) && (!adev->dual_decoder_support) && (adev->continuous_audio_mode == false))
+        is_bypass_setting = true;
+
+    if (adev->debug_flag > 1)
+        ALOGI("%s line %d is_bypass_setting %d is_byass_format %d is_high_rate_pcm %d is_dts %d\n",
+            __func__, __LINE__, is_bypass_setting, is_byass_format,  is_high_rate_pcm(stream), is_dts);
+
+    return ((is_bypass_setting && is_byass_format) || is_dts);
+}
+
+static bool is_high_rate_pcm(struct audio_stream_out *stream) {
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+
+    return (audio_is_linear_pcm(aml_out->hal_internal_format) &&
+           (aml_out->hal_rate > 48000));
+}
+
+static bool is_multi_channel_pcm(struct audio_stream_out *stream) {
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+
+    return (audio_is_linear_pcm(aml_out->hal_internal_format) &&
+           (aml_out->hal_ch > 2));
 }
 
 ssize_t hw_write (struct audio_stream_out *stream
@@ -7567,7 +8269,7 @@ ssize_t hw_write (struct audio_stream_out *stream
                   , size_t bytes
                   , audio_format_t output_format)
 {
-    ALOGD ("+%s() buffer %p bytes %zu", __func__, buffer, bytes);
+    ALOGV ("+%s() buffer %p bytes %zu", __func__, buffer, bytes);
     struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
     struct aml_audio_device *adev = aml_out->dev;
     const uint16_t *tmp_buffer = buffer;
@@ -7579,7 +8281,9 @@ ssize_t hw_write (struct audio_stream_out *stream
     uint32_t latency_frames = 0;
     uint64_t total_frame = 0;
     uint64_t write_frames = 0;
+    uint64_t  sys_total_cost = 0;
     int  adjust_ms = 0;
+
     adev->debug_flag = aml_audio_get_debug_flag();
     if (adev->debug_flag) {
         ALOGI("+%s() buffer %p bytes %zu, format %#x", __func__, buffer, bytes, output_format);
@@ -7592,17 +8296,29 @@ ssize_t hw_write (struct audio_stream_out *stream
     if (aml_out->status != STREAM_HW_WRITING) {
         ALOGI("%s, aml_out %p alsa open output_format %#x\n", __func__, aml_out, output_format);
         if (eDolbyDcvLib == adev->dolby_lib_type) {
-            if (!is_dual_output_stream(stream)) {
-                aml_tinymix_set_spdif_format(output_format,aml_out);
-            }
-        } else {
             aml_tinymix_set_spdif_format(output_format,aml_out);
         }
-
         if (adev->useSubMix) {
-            ret = aml_alsa_output_open(stream);
-            if (ret) {
-                ALOGE("%s() open failed", __func__);
+            if (aml_out->usecase == STREAM_PCM_DIRECT && adev->audio_patching) {
+                if (!adev->is_TV && (adev->ddp).digital_raw > 0 &&
+                        output_format != AUDIO_FORMAT_PCM_16_BIT && output_format != AUDIO_FORMAT_PCM) {
+                    // TODO: mbox+dvb and bypass case
+                    ret = aml_alsa_output_open(stream);
+                    if (ret) {
+                        ALOGE("%s() open failed", __func__);
+                    }
+                } else {
+                    ret = aml_alsa_output_open(stream);
+                    if (ret) {
+                        ALOGE("%s() open failed", __func__);
+                    }
+                }
+            } else {
+                // TODO: as discussed with lianlian, these code may still need in the future
+                //ret = aml_alsa_output_open(stream);
+                //if (ret) {
+                //    ALOGE("%s() open failed", __func__);
+                //}
             }
         } else {
             if (!adev->tuner2mix_patch) {
@@ -7613,11 +8329,11 @@ ssize_t hw_write (struct audio_stream_out *stream
             }
         }
 
-        if (!ret)
+        if (ret == 0)
             aml_out->status = STREAM_HW_WRITING;
     }
 
-    if (eDolbyMS12Lib == adev->dolby_lib_type) {
+    if (eDolbyMS12Lib == adev->dolby_lib_type && !is_bypass_dolbyms12(stream)) {
         if (aml_out->hw_sync_mode && !adev->ms12.is_continuous_paused) {
             // histroy here: ms12lib->pcm_output()->hw_write() aml_out is passed as private data
             //               when registering output callback function in dolby_ms12_register_pcm_callback()
@@ -7627,65 +8343,84 @@ ssize_t hw_write (struct audio_stream_out *stream
             if (aml_out->hwsync->aout) {
                 if (is_bypass_dolbyms12(stream))
                     aml_audio_hwsync_audio_process(aml_out->hwsync, aml_out->hwsync->payload_offset, &adjust_ms);
-                else
-                    aml_audio_hwsync_audio_process(aml_out->hwsync, dolby_ms12_get_consumed_payload(), &adjust_ms);
+                else {
+                    uint64_t ms12_consumed = dolby_ms12_get_decoder_n_bytes_consumed(adev->ms12.dolby_ms12_ptr, aml_out->hal_internal_format, MAIN_INPUT_STREAM);
+                    ALOGV("ms12 consumed=%lld format=0x%x", ms12_consumed, aml_out->hal_internal_format);
+                    if (!audio_is_linear_pcm(aml_out->hal_internal_format)) {
+                        /*if ms12 decoder doens't generate any data, we should not use the consume offset to get pts*/
+                        uint64_t ms12_dec_out_nframes = dolby_ms12_get_decoder_nframes_pcm_output(adev->ms12.dolby_ms12_ptr, aml_out->hal_internal_format, MAIN_INPUT_STREAM);
+                        ALOGV("ms12 decoder generate pcm =%lld", ms12_dec_out_nframes);
+                        if (ms12_dec_out_nframes) {
+                            aml_audio_hwsync_audio_process(aml_out->hwsync, ms12_consumed, &adjust_ms);
+                        }
+                    } else {
+                        /* for non 48khz hwsync pcm, the pts check in is used original 44.1khz offset,
+                         * but we resample it before send to ms12, so we consumed offset is 48khz,
+                         * so we need convert it
+                         */
+                        if(audio_is_linear_pcm(aml_out->hwsync->aout->hal_internal_format) &&
+                            (aml_out->hwsync->aout->hal_rate != 48000)) {
+                            ms12_consumed = ms12_consumed * aml_out->hwsync->aout->hal_rate / 48000;
+                        }
+                        aml_audio_hwsync_audio_process(aml_out->hwsync, ms12_consumed, &adjust_ms);
+                    }
+                }
             } else {
-                ALOGW("%s,aml_out->hwsync->aout == NULL",__FUNCTION__);
+                ALOGV("%s,aml_out->hwsync->aout == NULL",__FUNCTION__);
             }
         }
     }
-    if (aml_out->pcm) {
+    if (aml_out->pcm
+#ifdef ENABLE_BT_A2DP
+        || aml_out->a2dp_out
+#endif
+        ) {
 #ifdef ADD_AUDIO_DELAY_INTERFACE
         ret = aml_audio_delay_process(AML_DELAY_OUTPORT_ALL, (void *) tmp_buffer, bytes, output_format, 2);
         if (ret < 0) {
-            ALOGW("aml_audio_delay_process skip, ret:%#x", ret);
-        }
-#endif
-        if (adjust_ms) {
-            int adjust_bytes = 0;
-            memset((void*)buffer, 0, bytes);
-            if (output_format == AUDIO_FORMAT_E_AC3) {
-                adjust_bytes = 192 * 4 * abs(adjust_ms);
-            } else if (output_format == AUDIO_FORMAT_AC3) {
-                adjust_bytes = 48 * 4 * abs(adjust_ms);
-            } else if (output_format == AUDIO_FORMAT_MAT) {
-                adjust_bytes = 768 * 4 * abs(adjust_ms);
+            //ALOGW("aml_audio_delay_process skip, ret:%#x", ret);
+        }
+#endif
+        ret = insert_silence_data(stream, buffer, bytes, adjust_ms, output_format);
+        if (ret < 0) {
+            ALOGE("insert_silence_data occur error, ret:%#x", ret);
+            return ret;
+        }
+
+#ifdef ENABLE_BT_A2DP
+        if (adev->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+            ret = a2dp_out_write(stream, buffer, bytes);
+        } else 
+#endif
+        {
+            if ((adev->audio_patch) && (adev->audio_patch->init_flush_count > 0)) {
+                if (get_buffer_read_space(&adev->audio_patch->aml_ringbuffer) < PATCH_STOP_FLUSH_THRESHOLD)
+                    adev->audio_patch->init_flush_count = 0;
+                else
+                    adev->audio_patch->init_flush_count--;
+
+                ALOGI("init_flush_count = %d, level = %d",
+                       adev->audio_patch->init_flush_count,
+                       get_buffer_read_space(&adev->audio_patch->aml_ringbuffer));
+                ret = bytes;
             } else {
-                adjust_bytes = 48 * 32 * abs(adjust_ms);    //8ch 32 bit.
-            }
-            adjust_bytes &= ~255;
-            ALOGI("%s hwsync audio need %s %d ms,adjust bytes %d",
-                  __func__, adjust_ms > 0 ? "insert" : "skip", abs(adjust_ms), adjust_bytes);
-            if (adjust_ms > 0) {
-                char *buf = malloc(1024);
-                int write_size = 0;
-                if (!buf) {
-                    ALOGE("%s malloc failed", __func__);
-                    pthread_mutex_unlock(&adev->alsa_pcm_lock);
-                    return -1;
-                }
-                memset(buf, 0, 1024);
-                while (adjust_bytes > 0) {
-                    write_size = adjust_bytes > 1024 ? 1024 : adjust_bytes;
-                    ret = aml_alsa_output_write(stream, (void*)buf, write_size);
-                    if (ret < 0) {
-                        ALOGE("%s alsa write fail when insert", __func__);
-                        break;
+                if (aml_getprop_bool("media.audiohal.outdump")) {
+                    FILE *fp1 = fopen("/data/vendor/audiohal/speaker_output.pcm", "a+");
+                    if (fp1) {
+                        int flen = fwrite((char *)buffer, 1, bytes, fp1);
+                        fclose(fp1);
                     }
-                    adjust_bytes -= write_size;
                 }
-                free(buf);
-            } else {
-                //do nothing.
-                /*
-                if (bytes > (size_t)adjust_bytes)
-                    bytes -= adjust_bytes;
-                else
-                    bytes = 0;
-                */
+#ifdef ENABLE_BT_A2DP
+                if (adev->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+                    ret = a2dp_out_write(stream, buffer, bytes);
+                } else
+#endif
+                {
+                    ret = aml_alsa_output_write(stream, (void *) buffer, bytes, output_format);
+                }
             }
         }
-        ret = aml_alsa_output_write(stream, (void *) buffer, bytes);
         //ALOGE("!!aml_alsa_output_write"); ///zzz
         if (ret < 0) {
             ALOGE("ALSA out write fail");
@@ -7713,17 +8448,18 @@ ssize_t hw_write (struct audio_stream_out *stream
                         }
                     }
                 } else {
-                    if (aml_out->is_tv_platform == true) {
-                        out_frames = out_frames / 8;
-                    }
-
-                    if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm &&
-                            adev->bHDMIARCon) {
+                    if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm /*&&
+                            adev->bHDMIARCon*/) {
                         out_frames = out_frames * 4;
+                    } else if (aml_out->is_tv_platform) {
+                        if (aml_out->hal_format == AUDIO_FORMAT_IEC61937 && eDolbyDcvLib == adev->dolby_lib_type) {
+                            aml_out->frame_write_sum = 0;
+                            out_frames = aml_out->input_bytes_size / audio_stream_out_frame_size(stream);
+                        } else {
+                            out_frames = out_frames / 8;
+                        }
                     }
-
                     aml_out->frame_write_sum += out_frames;
-
                     total_frame =  aml_out->frame_write_sum;
                 }
             }
@@ -7752,11 +8488,9 @@ ssize_t hw_write (struct audio_stream_out *stream
             if (aml_out->flags & AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO) {
                 if (aml_out->hal_internal_format == AUDIO_FORMAT_AC3) {
                     write_frames = aml_out->input_bytes_size / 6144 * 32 * 48;
-                }
-                else if (aml_out->hal_internal_format == AUDIO_FORMAT_E_AC3) {
+                } else if (aml_out->hal_internal_format == AUDIO_FORMAT_E_AC3) {
                     write_frames = aml_out->input_bytes_size / 24576 * 32 * 48;
-                }
-                else if (aml_out->hal_internal_format == AUDIO_FORMAT_MAT) {
+                } else if (aml_out->hal_internal_format == AUDIO_FORMAT_MAT) {
                     write_frames = aml_out->input_bytes_size / 61440 * 32 * 48;
                 }
             } else {
@@ -7767,40 +8501,39 @@ ssize_t hw_write (struct audio_stream_out *stream
                     write_frames = aml_out->frame_write_sum;
                 }
                 else {
-                    size_t playload_used = dolby_ms12_get_consumed_payload();
-                    int ddp_size = 0;
-                    if (aml_out->last_playload_used > 0) {
-                        ddp_size = playload_used - aml_out->last_playload_used;
-                        /*santity check if current frame size matchs dd+ spec*/
-                        if (ddp_size > 0 && ddp_size < 4096) {
-                            if (aml_out->ddp_frame_size != ddp_size) {
-                                ALOGI("ddp frame changed from %d to %d",aml_out->ddp_frame_size,ddp_size);
-                                aml_out->ddp_frame_size = ddp_size;
-                            }
-                        }
+                    size_t playload_used = dolby_ms12_get_decoder_n_bytes_consumed(adev->ms12.dolby_ms12_ptr, aml_out->hal_internal_format, MAIN_INPUT_STREAM);
+                    if (aml_out->last_playload_used && (playload_used > aml_out->last_playload_used)) {
+                        //Fixme: how to get the right frame size
+                        aml_out->ddp_frame_size = (int)(playload_used - aml_out->last_playload_used);
                     }
                     aml_out->last_playload_used = playload_used;
-                    write_frames = aml_out->input_bytes_size/aml_out->ddp_frame_size*32*48;
+                    write_frames = dolby_ms12_get_decoder_nframes_pcm_output(adev->ms12.dolby_ms12_ptr, aml_out->hal_internal_format, MAIN_INPUT_STREAM);
                 }
             }
         }
     } else {
         if (eDolbyMS12Lib == adev->dolby_lib_type) {
             if (!audio_is_linear_pcm(aml_out->hal_internal_format)) {
-                //unsigned long long output_size = 0;
-                //dolby_ms12_get_pcm_output_size(&output_size,NULL);
-                //total_frame = total_frame/aml_out->ddp_frame_size*32*48;
-                //total_frame = output_size/4;
-                total_frame = dolby_ms12_get_consumed_payload() + aml_out->continuous_audio_offset;
-                total_frame = total_frame / aml_out->ddp_frame_size * 32 * 48;
+                /*use the pcm which is gennerated by udc, to get the total frame by nbytes/nbtyes_per_sample
+                 *Please be careful about the aml_out->continuous_audio_offset;*/
+                if (adev->ms12.nbytes_of_dmx_output_pcm_frame) {
+                    total_frame = dolby_ms12_get_decoder_nframes_pcm_output(adev->ms12.dolby_ms12_ptr, aml_out->hal_internal_format, MAIN_INPUT_STREAM);
+                }
+                else
+                    total_frame = 0;
+                write_frames =  aml_out->total_ddp_frame_nblks * 256;/*256samples in one block*/
                 if (adev->debug_flag) {
-                    ALOGI("%s,ms12 dolby offset %llu,time %"PRIu64" ms", __func__,
-                          dolby_ms12_get_consumed_payload(), total_frame / 48);
+                     ALOGI("%s,total_frame %llu write_frames %"PRIu64" total frame block nums %"PRIu64",total_frames %"PRIu64"",
+                         __func__, total_frame, write_frames, aml_out->total_ddp_frame_nblks,total_frame);
                 }
             }
             /*case 3*/
             else if (aml_out->hw_sync_mode) {
-                total_frame = dolby_ms12_get_consumed_payload() / 4;
+                /*This is tunnel PCM case*/
+                audio_format_t hwsync_format = AUDIO_FORMAT_DEFAULT;
+                if (aml_out->hwsync && aml_out->hwsync->aout)
+                    hwsync_format = aml_out->hwsync->aout->hal_internal_format;
+                total_frame = dolby_ms12_get_decoder_nframes_pcm_output(adev->ms12.dolby_ms12_ptr, hwsync_format, MAIN_INPUT_STREAM);
             }
             /*case 1*/
             else {
@@ -7820,14 +8553,39 @@ ssize_t hw_write (struct audio_stream_out *stream
         if (total_frame >= latency_frames) {
             aml_out->last_frames_postion = total_frame - latency_frames;
         } else {
-            aml_out->last_frames_postion = total_frame;
+            aml_out->last_frames_postion = 0;
         }
+        //ALOGI("position =%lld time sec = %ld, nanosec = %ld latency=%d", aml_out->last_frames_postion, aml_out->lasttimestamp.tv_sec , aml_out->lasttimestamp.tv_nsec, latency_frames);
     }
     if (eDolbyMS12Lib == adev->dolby_lib_type) {
         if (continous_mode(adev)) {
-            adev->ms12.last_frames_postion = aml_out->last_frames_postion;
-            clock_gettime(CLOCK_MONOTONIC, &adev->ms12.timestamp);
+            /* the ms12 generate pcm out is not changed, we assume it is the same one
+             * don't update the position
+             */
+            if (total_frame != adev->ms12.last_ms12_pcm_out_position) {
+                struct timespec ts;
+                clock_gettime(CLOCK_MONOTONIC, &ts);
+                adev->ms12.timestamp.tv_sec = ts.tv_sec;
+                adev->ms12.timestamp.tv_nsec = ts.tv_nsec;
+                adev->ms12.last_frames_postion = aml_out->last_frames_postion;
+                adev->ms12.last_ms12_pcm_out_position = total_frame;
+            }
+        }
+        /* check sys audio postion */
+        sys_total_cost = dolby_ms12_get_consumed_sys_audio();
+        if (adev->ms12.last_sys_audio_cost_pos != sys_total_cost) {
+            struct timespec ts;
+            clock_gettime(CLOCK_MONOTONIC, &ts);
+            adev->ms12.sys_audio_timestamp.tv_sec = ts.tv_sec;
+            adev->ms12.sys_audio_timestamp.tv_nsec = ts.tv_nsec;
+            /*FIXME. 2ch 16 bit audio */
+            adev->ms12.sys_audio_frame_pos = adev->ms12.sys_audio_base_pos + sys_total_cost/4 - latency_frames;
         }
+        if (adev->debug_flag)
+            ALOGI("sys audio pos %"PRIu64" ms ,sys_total_cost %"PRIu64",base pos %"PRIu64",latency %d \n",
+                    adev->ms12.sys_audio_frame_pos/48,sys_total_cost,adev->ms12.sys_audio_base_pos,latency_frames);
+        adev->ms12.last_sys_audio_cost_pos = sys_total_cost;
+
     }
 
     if (adev->debug_flag) {
@@ -7853,7 +8611,7 @@ ssize_t hw_write (struct audio_stream_out *stream
 }
 
 
-static void config_output(struct audio_stream_out *stream)
+void config_output(struct audio_stream_out *stream,bool reset_decoder)
 {
     struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
     struct aml_stream_out *out = NULL;
@@ -7870,10 +8628,23 @@ static void config_output(struct audio_stream_out *stream)
 
     int is_arc_connected = 0;
 
-    if (adev->bHDMIARCon && adev->bHDMIConnected && adev->speaker_mute) {
+    adev->dcvlib_bypass_enable = 0;
+    adev->dtslib_bypass_enable = 0;
+
+    if (adev->bHDMIConnected/*&&  adev->bHDMIARCon && adev->speaker_mute*/) {
         is_arc_connected = 1;
     }
 
+#ifdef ENABLE_BT_A2DP
+    if (aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+        ALOGD("config_output: output: %p, a2dp_out=%p", aml_out, aml_out->a2dp_out);
+        if (aml_out->a2dp_out == NULL)
+            a2dp_output_enable(stream);
+    } else {
+        a2dp_output_disable(stream);
+    }
+#endif
+
     /*
     *   when ARC is connecting, and user switch [Sound Output Device] to "ARC"
     *   we need to set out_port as OUTPORT_HDMI_ARC ,
@@ -7907,13 +8678,33 @@ static void config_output(struct audio_stream_out *stream)
     ALOGI("%s() adev->dolby_lib_type = %d", __FUNCTION__, adev->dolby_lib_type);
     if (aml_out->hal_internal_format != AUDIO_FORMAT_DTS
             && aml_out->hal_internal_format != AUDIO_FORMAT_DTS_HD) {
-        if (eDolbyMS12Lib == adev->dolby_lib_type) {
+         struct dca_dts_dec *dts_dec = & (adev->dts_hd);
+         if (dts_dec->status == 1) {
+            dca_decoder_release_patch(dts_dec);
+            virtualx_setparameter(adev,0,0,2);
+            virtualx_setparameter(adev,VIRTUALXINMODE,0,5);
+            virtualx_setparameter(adev,TRUVOLUMEINMODE,0,5);
+            adev->effect_in_ch = 2;
+            if (dts_dec->digital_raw > 0) {
+                struct pcm *pcm = adev->pcm_handle[DIGITAL_DEVICE];
+                if (pcm && is_dual_output_stream(stream)) {
+                    ALOGI("%s close dual output pcm handle %p", __func__, pcm);
+                    pcm_close(pcm);
+                    adev->pcm_handle[DIGITAL_DEVICE] = NULL;
+                    set_stream_dual_output(stream, false);
+                    aml_tinymix_set_spdif_format(AUDIO_FORMAT_PCM_16_BIT,aml_out);
+                }
+            }
+            ALOGI("dca_decoder_release_patch release");
+        }
+
+        if (eDolbyMS12Lib == adev->dolby_lib_type && !is_bypass_dolbyms12(stream) && reset_decoder == true) {
             pthread_mutex_lock(&adev->lock);
             get_dolby_ms12_cleanup(&adev->ms12);
             pthread_mutex_lock(&adev->alsa_pcm_lock);
             struct pcm *pcm = adev->pcm_handle[DIGITAL_DEVICE];
 
-            if (is_dual_output_stream(stream) && pcm) {
+            if (pcm) {
                 ALOGI("%s close pcm handle %p", __func__, pcm);
                 pcm_close(pcm);
                 adev->pcm_handle[DIGITAL_DEVICE] = NULL;
@@ -7943,22 +8734,30 @@ static void config_output(struct audio_stream_out *stream)
             if (continous_mode(adev)) {
                 adev->ms12_main1_dolby_dummy = main1_dummy;
                 adev->ms12_ott_enable = ott_input;
-                dolby_ms12_set_ott_sound_input_enable(true/*ott_input*/);
-                dolby_ms12_set_dolby_main1_as_dummy_file(true);
+                /*AC4 does not support -ui (OTT sound) */
+                dolby_ms12_set_ott_sound_input_enable(aformat != AUDIO_FORMAT_AC4);
+                dolby_ms12_set_dolby_main1_as_dummy_file(aformat != AUDIO_FORMAT_AC4);
             }
             ring_buffer_reset(&adev->spk_tuning_rbuf);
             adev->ms12.is_continuous_paused = false;
-            ret = get_the_dolby_ms12_prepared(aml_out, aformat, AUDIO_CHANNEL_OUT_STEREO, aml_out->hal_rate);
-            if (continous_mode(adev)) {
+            ret = get_the_dolby_ms12_prepared(aml_out, aformat,
+                aml_out->hal_channel_mask,
+                aml_out->hal_rate);
+
+            /*set the volume to current one*/
+            dolby_ms12_set_main_volume(aml_out->volume_l);
+
+            if (continous_mode(adev) && adev->ms12.dolby_ms12_enable) {
                 dolby_ms12_set_main_dummy(0, main1_dummy);
                 dolby_ms12_set_main_dummy(1, !ott_input);
             }
             adev->mix_init_flag = true;
-            ALOGD("%s() get_the_dolby_ms12_prepared %s, ott_enable = %d, main1_dummy = %d",
+            ALOGI("%s() get_the_dolby_ms12_prepared %s, ott_enable = %d, main1_dummy = %d",
                     __FUNCTION__, (ret == 0) ? "succuss" : "fail", ott_input, main1_dummy);
             store_stream_presentation(adev);
             pthread_mutex_unlock(&adev->lock);
-        } else if (eDolbyDcvLib == adev->dolby_lib_type) {
+        }
+        else if ((eDolbyDcvLib == adev->dolby_lib_type) || is_bypass_dolbyms12(stream)) {
             pthread_mutex_lock(&adev->alsa_pcm_lock);
             if (aml_out->status == STREAM_HW_WRITING) {
                 aml_alsa_output_close(stream);
@@ -7978,7 +8777,7 @@ static void config_output(struct audio_stream_out *stream)
             case DD:
                 ddp_dec->digital_raw = 1;
                 //STB case
-                if (adev->is_STB) {
+                if (!adev->is_TV) {
                     set_stream_dual_output(stream, false);
                 } else {
                     set_stream_dual_output(stream, true);
@@ -7986,8 +8785,9 @@ static void config_output(struct audio_stream_out *stream)
                 adev->dcvlib_bypass_enable = 0;
                 break;
             case AUTO:
+            case BYPASS:
                 //STB case
-                if (adev->is_STB) {
+                if (!adev->is_TV) {
                     char *cap = NULL;
                     cap = (char *) get_hdmi_sink_cap (AUDIO_PARAMETER_STREAM_SUP_FORMATS,0,&(adev->hdmi_descs));
                     if (cap && mystrstr(cap, "AUDIO_FORMAT_E_AC3")) {
@@ -8013,8 +8813,8 @@ static void config_output(struct audio_stream_out *stream)
                     }
                 } else {
                     if (adev->hdmi_descs.ddp_fmt.is_support) {
-                        ddp_dec->digital_raw = 2;
                         adev->dcvlib_bypass_enable = 1;
+                        ddp_dec->digital_raw = 2;
                     } else if (adev->hdmi_descs.dd_fmt.is_support) {
                         if (aml_out->hal_internal_format == AUDIO_FORMAT_E_AC3) {
                             adev->dcvlib_bypass_enable = 0;
@@ -8044,7 +8844,10 @@ static void config_output(struct audio_stream_out *stream)
                 ddp_dec->digital_raw = 0;
                 break;
             }
-
+            if (aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+                ALOGI("disable raw output when a2dp device\n");
+                ddp_dec->digital_raw = 0;
+            }
             ALOGI("%s:%d ddp_dec->digital_raw:%d, dcvlib_bypass_enable:%d, dual_output_flag: %d", __func__, __LINE__,
                 ddp_dec->digital_raw, adev->dcvlib_bypass_enable,is_dual_output_stream(stream));
             if (adev->dcvlib_bypass_enable != 1) {
@@ -8100,67 +8903,41 @@ static void config_output(struct audio_stream_out *stream)
         pthread_mutex_unlock(&adev->alsa_pcm_lock);
         update_stream_dual_output(stream);
 
-        /*init or close dts decoder*/
+        /*
+         *dts decoder config params are defined here
+         *including license or none-license
+         */
+        dca_decoder_config(stream, &dtscd_flag);
+
         struct dca_dts_dec *dts_dec = & (adev->dts_hd);
-        switch (adev->hdmi_format) {
-        case PCM:
-            dts_dec->digital_raw = 0;
-            adev->dtslib_bypass_enable = 0;
-            break;
-        case DD:
-            dts_dec->digital_raw = 1;
-            //STB case
-            if (adev->is_STB) {
-                set_stream_dual_output(stream, false);
-            } else {
-                set_stream_dual_output(stream, true);
-            }
-            adev->dtslib_bypass_enable = 0;
-            adev->optical_format = AUDIO_FORMAT_AC3;
-            break;
-        case AUTO:
-            if (adev->active_outport == OUTPORT_HDMI_ARC) {
-                if (adev->hdmi_descs.dtshd_fmt.is_support) {
-                    adev->dtslib_bypass_enable = 1;
-                    dts_dec->digital_raw = 2;
-                } else if (adev->hdmi_descs.dts_fmt.is_support) {
-                    if (aml_out->hal_internal_format == AUDIO_FORMAT_DTS_HD) {
-                       adev->dtslib_bypass_enable = 0;
-                } else if (aml_out->hal_internal_format == AUDIO_FORMAT_DTS) {
-                        dts_dec->digital_raw = 1;
-                        if (dts_dec->is_dtscd == 1) {
-                            adev->dtslib_bypass_enable = 0;
-                            dtscd_flag = true;
-                        } else {
-                            adev->dtslib_bypass_enable = 1;
-                        }
-                    }
-                } else {
-                    dts_dec->digital_raw = 0;
-                    adev->dtslib_bypass_enable = 0;
-                }
-            } else if (adev->active_outport == OUTPORT_SPEAKER) {
-                dts_dec->digital_raw = 1;
-                adev->dtslib_bypass_enable = 0;
-            }
-            break;
-        default:
-            dts_dec->digital_raw = 0;
-            break;
-        }
-        ALOGI("dts_dec->digital_raw:%d adev->dtslib_bypass_enable:%d", dts_dec->digital_raw, adev->dtslib_bypass_enable);
         if (adev->dtslib_bypass_enable != 1) {
             if (dts_dec->status != 1 && (aml_out->hal_internal_format == AUDIO_FORMAT_DTS
                                          || aml_out->hal_internal_format == AUDIO_FORMAT_DTS_HD)) {
                 int status = dca_decoder_init_patch(dts_dec);
+                if (adev->virtualx_mulch) {
+                    virtualx_setparameter(adev,0,0,2);
+                    virtualx_setparameter(adev,VIRTUALXINMODE,1,5);
+                    virtualx_setparameter(adev,TRUVOLUMEINMODE,4,5);
+                    adev->effect_in_ch = 6;
+                } else {
+                    virtualx_setparameter(adev,VIRTUALXINMODE,0,5);
+                    virtualx_setparameter(adev,TRUVOLUMEINMODE,0,5);
+                    adev->effect_in_ch = 2;
+                }
                 if ((patch && audio_parse_get_audio_type_direct(patch->audio_parse_para) == DTSCD) || dtscd_flag) {
                     dts_dec->is_dtscd = 1;
-                    ALOGI("dts cd stream,dtscd_flag %d,type %d",dtscd_flag,audio_parse_get_audio_type_direct(patch->audio_parse_para));
+                    ALOGI("dts cd stream,dtscd_flag %d",dtscd_flag);
+                    if (patch)
+                        ALOGI("dts cd stream type %d",audio_parse_get_audio_type_direct(patch->audio_parse_para));
                 }
                 ALOGI("dca_decoder_init_patch return :%d", status);
             } else if (dts_dec->status == 1 && (aml_out->hal_internal_format == AUDIO_FORMAT_DTS
                                                 || aml_out->hal_internal_format == AUDIO_FORMAT_DTS_HD)) {
                 dca_decoder_release_patch(dts_dec);
+                virtualx_setparameter(adev,0,0,2);
+                virtualx_setparameter(adev,VIRTUALXINMODE,0,5);
+                virtualx_setparameter(adev,TRUVOLUMEINMODE,0,5);
+                adev->effect_in_ch = 2;
                 if (dts_dec->digital_raw > 0) {
                     struct pcm *pcm = adev->pcm_handle[DIGITAL_DEVICE];
                     if (pcm && is_dual_output_stream(stream)) {
@@ -8185,17 +8962,10 @@ static void config_output(struct audio_stream_out *stream)
         pthread_mutex_unlock(&adev->lock);
     }
 
-    /*TV-4745: After switch from normal PCM playing to MS12, the device will
-     be changed to SPDIF, but when switch back to the normal PCM, the out device
-     is still SPDIF, then the sound is abnormal.
-    */
-    if (!(continous_mode(adev) && (eDolbyMS12Lib == adev->dolby_lib_type))) {
-        if (adev->sink_format == AUDIO_FORMAT_PCM_16_BIT || adev->sink_format == AUDIO_FORMAT_PCM_32_BIT) {
-            aml_out->device = PORT_I2S;
-        } else {
-            aml_out->device = PORT_SPDIF;
-        }
-    }
+    /* set up initial draining when output pipeline for patch is set up */
+    if (patch)
+        patch->init_flush_count = PATCH_INIT_FLUSH_CNT;
+
     ALOGI("%s(), device: %d", __func__, aml_out->device);
     return ;
 }
@@ -8203,7 +8973,6 @@ static void config_output(struct audio_stream_out *stream)
 ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *buffer,
                                  size_t bytes)
 {
-    ALOGV("%s write in %zu!", __FUNCTION__, bytes);
     struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
     struct aml_audio_device *adev = aml_out->dev;
     struct aml_stream_out *ms12_out = (struct aml_stream_out *)adev->ms12_out;
@@ -8214,17 +8983,25 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
     void *output_buffer = NULL;
     size_t output_buffer_bytes = 0;
     bool need_reconfig_output = false;
+    bool need_reset_decoder = true;
     void   *write_buf = NULL;
     size_t  write_bytes = 0;
     size_t  hwsync_cost_bytes = 0;
     int total_write = 0;
     size_t used_size = 0;
     int write_retry = 0;
+    size_t total_bytes = bytes;
+    size_t bytes_cost = 0;
+    int ms12_write_failed = 0;
     static int pre_hdmi_out_format = 0;
+    effect_descriptor_t tmpdesc;
     audio_hwsync_t *hw_sync = aml_out->hwsync;
+    int return_bytes = bytes;
+    bool digital_input_src = (patch && \
+           (patch->input_src == AUDIO_DEVICE_IN_HDMI || patch->input_src == AUDIO_DEVICE_IN_SPDIF));
     if (adev->debug_flag) {
         ALOGI("%s:%d out:%p write in %zu,format:0x%x,ms12_ott:%d,conti:%d,hw_sync:%d", __FUNCTION__, __LINE__,
-              aml_out, bytes, aml_out->hal_internal_format,adev->ms12_ott_enable,adev->continuous_audio_mode,aml_out->hw_sync_mode);
+            aml_out, bytes, aml_out->hal_internal_format,adev->ms12_ott_enable,adev->continuous_audio_mode,aml_out->hw_sync_mode);
         ALOGI("useSubMix:%d, dolby:%d, hal_format:0x%x, usecase:0x%x, usecase_masks:0x%x",
             adev->useSubMix, adev->dolby_lib_type, aml_out->hal_format, aml_out->usecase, adev->usecase_masks);
         if (patch) {
@@ -8233,20 +9010,26 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
             ALOGD("not create patch!!!");
         }
     }
-    int return_bytes = bytes;
 
     if (buffer == NULL) {
         ALOGE ("%s() invalid buffer %p\n", __FUNCTION__, buffer);
         return -1;
     }
 
-    if (eDolbyMS12Lib != adev->dolby_lib_type) {
+#if 0
+    //if (eDolbyMS12Lib != adev->dolby_lib_type) {
         // For compatible by lianlian
         if (aml_out->standby) {
             ALOGI("%s(), standby to unstandby", __func__);
             aml_out->standby = false;
         }
+    //}
+#else
+    // LINUX Change
+    if (aml_out->standby) {
+        aml_out->standby = false;
     }
+#endif
 
     // why clean up, ms12 thead will handle all?? zz
     if (eDolbyMS12Lib == adev->dolby_lib_type) {
@@ -8265,8 +9048,8 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
         pthread_mutex_lock (&adev->lock);
         /* recovery from stanby case */
         if (aml_out->status == STREAM_STANDBY) {
-            ALOGI("%s() recovery from standby, dev masks %#x, stream usecase[%s]",
-                  __func__, adev->usecase_masks, str_usecases[aml_out->usecase]);
+            ALOGI("%s() recovery from standby, dev masks %#x, usecase[%s]",
+                  __func__, adev->usecase_masks, usecase2Str(aml_out->usecase));
             adev->usecase_masks |= (1 << aml_out->usecase);
             case_cnt = popcount(adev->usecase_masks);
         }
@@ -8275,7 +9058,7 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
             aml_audio_hwsync_init(aml_out->hwsync, aml_out);
         }
         if (eDolbyMS12Lib == adev->dolby_lib_type) {
-            if (case_cnt > 2 && adev->need_remove_conti_mode == true) {
+            if (case_cnt > MAX_INPUT_STREAM_CNT && adev->need_remove_conti_mode == true) {
                 ALOGI("%s,exit continuous release ms12 here", __func__);
                 get_dolby_ms12_cleanup(&adev->ms12);
                 adev->need_remove_conti_mode = false;
@@ -8291,42 +9074,63 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
         pthread_mutex_unlock(&adev->lock);
     }
     if (case_cnt > 2) {
-        ALOGE ("%s usemask %x,we do not support two direct stream output at the same time.TO CHECK CODE FLOW!!!!!!",__func__,adev->usecase_masks);
+        ALOGE ("%s usemask %x,we do not support two direct stream output at the same time.TO CHECK CODE FLOW!!!!!!",
+                __func__,adev->usecase_masks);
         return return_bytes;
     }
 
+    /* if VirtualX lib is in system, dts decoder output should be 5.1 channel*/
+    update_VX_format(aml_out, &need_reconfig_output);
+
     /* here to check if the audio HDMI ARC format updated. */
     if (adev->arc_hdmi_updated) {
         ALOGI ("%s(), arc format updated, need reconfig output", __func__);
         need_reconfig_output = true;
+        /*
+        we reset the whole decoder pipeline when audio routing change,
+        audio output option change, we do not need do a/v sync in this user case.
+        in order to get a low cpu loading, we enabled less ms12 modules in each
+        hdmi in user case, we need reset the pipeline to get proper one.
+        */
+        need_reset_decoder =digital_input_src ? true: false;
         adev->arc_hdmi_updated = 0;
     }
     /* here to check if the hdmi audio output format dynamic changed. */
-    if (pre_hdmi_out_format != adev->hdmi_format &&
+    if (pre_hdmi_out_format != adev->hdmi_format/* &&
         aml_out->hal_internal_format != AUDIO_FORMAT_PCM_16_BIT &&
-        aml_out->hal_internal_format != AUDIO_FORMAT_PCM_32_BIT) {
+        aml_out->hal_internal_format != AUDIO_FORMAT_PCM_32_BIT*/) {
         pre_hdmi_out_format = adev->hdmi_format;
         need_reconfig_output = true;
+        need_reset_decoder =digital_input_src ? true: false;
+        ALOGI ("%s(), check if the hdmi audio output format dynamic changed!\n", __func__);
+    }
+
+    if (adev->a2dp_updated) {
+        ALOGI ("%s(), a2dp updated, need reconfig output, %d %d", __func__, adev->out_device, aml_out->out_device);
+        need_reconfig_output = true;
+        adev->a2dp_updated = 0;
     }
 
     /* here to check if the audio output routing changed. */
     if (adev->out_device != aml_out->out_device) {
         ALOGI ("%s(), output routing changed, need reconfig output", __func__);
         need_reconfig_output = true;
+        need_reset_decoder = false;
         aml_out->out_device = adev->out_device;
     }
+hwsync_rewrite:
     /* handle HWSYNC audio data*/
     if (aml_out->hw_sync_mode) {
         uint64_t  cur_pts = 0xffffffff;
         int outsize = 0;
         char tempbuf[128];
-        ALOGV ("before aml_audio_hwsync_find_frame bytes %zu\n", bytes);
-        hwsync_cost_bytes = aml_audio_hwsync_find_frame(aml_out->hwsync, buffer, bytes, &cur_pts, &outsize);
+        ALOGV ("before aml_audio_hwsync_find_frame bytes %zu\n", total_bytes - bytes_cost);
+        hwsync_cost_bytes = aml_audio_hwsync_find_frame(aml_out->hwsync, (char *)buffer + bytes_cost, total_bytes - bytes_cost, &cur_pts, &outsize);
         if (cur_pts > 0xffffffff) {
             ALOGE("APTS exeed the max 32bit value");
         }
         ALOGV ("after aml_audio_hwsync_find_frame bytes remain %zu,cost %zu,outsize %d,pts %"PRIx64"\n",
-               bytes - hwsync_cost_bytes, hwsync_cost_bytes, outsize, cur_pts);
+               total_bytes - bytes_cost - hwsync_cost_bytes, hwsync_cost_bytes, outsize, cur_pts);
         //TODO,skip 3 frames after flush, to tmp fix seek pts discontinue issue.need dig more
         // to find out why seek ppint pts frame is remained after flush.WTF.
         if (aml_out->skip_frame > 0) {
@@ -8335,7 +9139,7 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
             return hwsync_cost_bytes;
         }
         if (cur_pts != 0xffffffff && outsize > 0) {
-            if (eDolbyMS12Lib == adev->dolby_lib_type) {
+            if (eDolbyMS12Lib == adev->dolby_lib_type && !is_bypass_dolbyms12(stream)) {
                 // missing code with aml_audio_hwsync_checkin_apts, need to add for netflix tunnel mode. zzz
                 aml_audio_hwsync_checkin_apts(aml_out->hwsync, aml_out->hwsync->payload_offset, cur_pts);
                 aml_out->hwsync->payload_offset += outsize;
@@ -8364,7 +9168,7 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
                         enum hwsync_status sync_status = CONTINUATION;
                         apts_gap = get_pts_gap (pcr, apts32);
                         sync_status = check_hwsync_status (apts_gap);
-
+                        //ALOGI("pts = %d pcr=%d gap=%d", apts32/90, pcr/90, apts_gap / 90);
                         // limit the gap handle to 0.5~5 s.
                         if (sync_status == ADJUSTMENT) {
                             // two cases: apts leading or pcr leading
@@ -8386,7 +9190,7 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
                                     ALOGI ("audio slow 0x%x,skip frame @pts 0x%"PRIx64",pcr 0x%x,cur apts 0x%x\n",
                                        apts_gap, cur_pts, pcr, apts32);
                                     aml_out->frame_skip_sum  +=   1536;
-                                    bytes = outsize;
+                                    return_bytes = hwsync_cost_bytes;
                                     goto exit;
                                 }
                             }
@@ -8412,25 +9216,24 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
             */
             return_bytes = hwsync_cost_bytes;
             write_bytes = outsize;
-            //in_frames = outsize / frame_size;
             write_buf = hw_sync->hw_sync_body_buf;
 
-            // Tunnel Mode PCM is 16bits 2ch
-            if ((eDolbyMS12Lib == adev->dolby_lib_type) && continous_mode(adev) &&
-                audio_is_linear_pcm(aml_out->hal_internal_format)) {
-                short *sample = (short*) write_buf;
-                int out_frames = write_bytes / (2*2); // 2 bytes per sample
-                int kk;
-                for (kk = 0; kk <  out_frames; kk++) {
-                    sample[kk * 2] *= aml_out->volume_l;
-                    sample[kk * 2 + 1] *= aml_out->volume_r;
+            /*resample is init for hw sync mode in open stream*/
+            if (aml_out->resample_handle != NULL) {
+                int ret = aml_audio_resample_process(aml_out->resample_handle, write_buf, write_bytes);
+                if (ret < 0) {
+                    ALOGE("resample process error\n");
+
+                    goto exit;
                 }
+                ALOGV("resample in =%d out=%d", write_bytes, aml_out->resample_handle->resample_size);
+                write_buf = aml_out->resample_handle->resample_buffer;
+                write_bytes = aml_out->resample_handle->resample_size;
             }
-
         } else {
             return_bytes = hwsync_cost_bytes;
             if (need_reconfig_output) {
-                config_output(stream);
+                config_output(stream,need_reset_decoder);
             }
             goto exit;
         }
@@ -8442,15 +9245,24 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
     /* here to check if the audio input format changed. */
     if (adev->audio_patch) {
         audio_format_t cur_aformat;
+        audio_channel_mask_t cur_channel_mask;
         if (IS_HDMI_IN_HW(patch->input_src) ||
                 patch->input_src == AUDIO_DEVICE_IN_SPDIF) {
             cur_aformat = audio_parse_get_audio_type (patch->audio_parse_para);
+#ifdef HDMI_ARC_PCM_32BIT_INPUT
+            if (IS_HDMI_IN_HW(patch->input_src) && (audio_is_linear_pcm(cur_aformat))) {
+                /* for HDMI & ARC/eARC PCM input, use 32 bit as input */
+                /* audio_parse_get_audio_type only returns AUDIO_FORMAT_PCM_16_BIT */
+                cur_aformat = AUDIO_FORMAT_PCM_32_BIT;
+            }
+#endif
+            cur_channel_mask = audio_parse_get_audio_channel_mask(patch->audio_parse_para);
             if (adev->debug_flag) {
                 audio_type_parse_t *status = patch->audio_parse_para;
                 ALOGI("%s:%d cur_aformat:0x%x, aformat:0x%x", __func__, __LINE__, cur_aformat, patch->aformat);
             }
-            if (cur_aformat != patch->aformat) {
-                ALOGI ("HDMI/SPDIF input format changed from %#x to %#x\n", patch->aformat, cur_aformat);
+            if ((cur_aformat != patch->aformat) || (aml_out->hal_channel_mask != cur_channel_mask)) {
+                ALOGI ("HDMI/SPDIF input format/channel mask changed from %#x/%#x to %#x/%#x\n", patch->aformat, aml_out->hal_channel_mask, cur_aformat, cur_channel_mask);
                 patch->aformat = cur_aformat;
                 //FIXME: if patch audio format change, the hal_format need to redefine.
                 //then the out_get_format() can get it.
@@ -8461,7 +9273,7 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
                     aml_out->hal_format = cur_aformat;
                 }
                 aml_out->hal_internal_format = cur_aformat;
-                aml_out->hal_channel_mask = audio_parse_get_audio_channel_mask (patch->audio_parse_para);
+                aml_out->hal_channel_mask = cur_channel_mask;
                 ALOGI ("%s hal_channel_mask %#x\n", __FUNCTION__, aml_out->hal_channel_mask);
                 if (aml_out->hal_internal_format == AUDIO_FORMAT_DTS) {
                     adev->dolby_lib_type = eDolbyDcvLib;
@@ -8470,6 +9282,7 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
                 }
                 //we just do not support dts decoder,just mute as LPCM
                 need_reconfig_output = true;
+                need_reset_decoder = true;
                 /* reset audio patch ringbuffer */
                 ring_buffer_reset(&patch->aml_ringbuffer);
 
@@ -8477,6 +9290,7 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
                 // fixed switch between RAW and PCM noise, drop delay residual data
                 aml_audio_delay_clear(AML_DELAY_OUTPORT_SPDIF);
                 aml_audio_delay_clear(AML_DELAY_OUTPORT_ALL);
+                aml_audio_delay_clear(AML_DELAY_INPORT_ALL);
 #endif
                 // HDMI input && HDMI ARC output case, when input format change, output format need also change
                 // for examle: hdmi input DD+ => DD,  HDMI ARC DD +=> DD
@@ -8509,11 +9323,10 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
         }
     }
 
-    if (eDolbyMS12Lib == adev->dolby_lib_type &&
-        aml_out->hal_internal_format != AUDIO_FORMAT_DTS &&
-        aml_out->hal_internal_format != AUDIO_FORMAT_DTS_HD) {
+    if (eDolbyMS12Lib == adev->dolby_lib_type && !is_bypass_dolbyms12(stream)) {
         if (adev->need_reset_for_dual_decoder == true) {
             need_reconfig_output = true;
+            need_reset_decoder = true;
             adev->need_reset_for_dual_decoder = false;
             ALOGI("%s get the dual decoder support, need reset ms12", __FUNCTION__);
         }
@@ -8524,10 +9337,12 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
          */
         if (!adev->ms12.dolby_ms12_enable) {
             need_reconfig_output = true;
+            need_reset_decoder = true;
         }
     }
     if (need_reconfig_output) {
-        config_output (stream);
+        config_output (stream,need_reset_decoder);
+        need_reconfig_output = false;
     }
 
     if ((eDolbyMS12Lib == adev->dolby_lib_type) && !is_bypass_dolbyms12(stream)) {
@@ -8537,7 +9352,7 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
         if (ms12_out == NULL) {
             // add protection here
             ALOGI("%s,ERRPR ms12_out = NULL,adev->ms12_out = %p", __func__, adev->ms12_out);
-            return bytes;
+            return write_bytes;
         }
         /*
         continous mode,available dolby format coming,need set main dolby dummy to false
@@ -8552,47 +9367,79 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
             ms12_out->hal_internal_format = aml_out->hal_internal_format;
             ms12_out->hw_sync_mode = aml_out->hw_sync_mode;
             ms12_out->hwsync = aml_out->hwsync;
+            get_sink_format((struct audio_stream_out *)aml_out);
             pthread_mutex_unlock(&adev->trans_lock);
             ALOGI("%s set dolby main1 dummy false", __func__);
         } else if (continous_mode(adev) && adev->ms12_ott_enable == false
                    && audio_is_linear_pcm(aml_out->hal_internal_format)) {
+            ALOGI("%s set dolby ott enable,ms12 stream %p,hwsync stream %p",
+                       __func__,ms12_out->hwsync,aml_out->hwsync);
             pthread_mutex_lock(&adev->lock);
             dolby_ms12_set_main_dummy(1, false);
             adev->ms12_ott_enable = true;
+            get_sink_format((struct audio_stream_out *)aml_out);
             pthread_mutex_unlock(&adev->lock);
             pthread_mutex_lock(&adev->trans_lock);
             ms12_out->hal_internal_format = aml_out->hal_internal_format;
             ms12_out->hw_sync_mode = aml_out->hw_sync_mode;
             ms12_out->hwsync = aml_out->hwsync;
             pthread_mutex_unlock(&adev->trans_lock);
-            ALOGI("%s set dolby ott enable", __func__);
         }
         if (continous_mode(adev)) {
             if ((adev->ms12.dolby_ms12_enable == true) && (adev->ms12.is_continuous_paused == true)) {
-                char *argv[3] = {"ms12_runtime", "-pause", "0"};
                 pthread_mutex_lock(&ms12->lock);
-                int ms12_runtime_update_ret = 0;
                 dolby_ms12_set_pause_flag(false);
-                ms12_runtime_update_ret = aml_ms12_update_runtime_params_direct(&(adev->ms12), 3, argv);
-
                 adev->ms12.is_continuous_paused = false;
+                set_dolby_ms12_runtime_pause(&(adev->ms12), adev->ms12.is_continuous_paused);
                 pthread_mutex_unlock(&ms12->lock);
-                ALOGI("%s ms12 set unpause flag runtime return %d\n", __func__, ms12_runtime_update_ret);
             }
         }
     }
     aml_out->input_bytes_size += write_bytes;
 
-    if ((patch && patch->aformat == AUDIO_FORMAT_DTS) || (aml_out->hal_internal_format == AUDIO_FORMAT_DTS)
-        || (patch && patch->aformat == AUDIO_FORMAT_DTS_HD)) {
+    if (patch && (adev->dtslib_bypass_enable || adev->dcvlib_bypass_enable)) {
+        int cur_samplerate = audio_parse_get_audio_samplerate(patch->audio_parse_para);
+        if (cur_samplerate != patch->input_sample_rate) {
+            ALOGI ("HDMI/SPDIF input samplerate from %d to %d\n", patch->input_sample_rate, cur_samplerate);
+            patch->input_sample_rate = cur_samplerate;
+            if (patch->aformat == AUDIO_FORMAT_DTS ||  patch->aformat == AUDIO_FORMAT_DTS_HD) {
+                if (aml_out->hal_format == AUDIO_FORMAT_IEC61937) {
+                    if (cur_samplerate == 44100 || cur_samplerate == 32000) {
+                        aml_out->config.rate = cur_samplerate;
+                    } else {
+                        aml_out->config.rate = 48000;
+                    }
+                }
+            } else if (patch->aformat == AUDIO_FORMAT_AC3) {
+                if (aml_out->hal_format == AUDIO_FORMAT_IEC61937) {
+                    aml_out->config.rate = cur_samplerate;
+                }
+            } else if (patch->aformat == AUDIO_FORMAT_E_AC3) {
+                if (aml_out->hal_format == AUDIO_FORMAT_IEC61937) {
+                    if (cur_samplerate == 192000 || cur_samplerate == 176400) {
+                        aml_out->config.rate = cur_samplerate / 4;
+                    } else {
+                        aml_out->config.rate = cur_samplerate;
+                    }
+                }
+            } else {
+                aml_out->config.rate = 48000;
+            }
+            ALOGI("adev->dtslib_bypass_enable :%d,adev->dcvlib_bypass_enable:%d, aml_out->config.rate :%d\n",adev->dtslib_bypass_enable,
+            adev->dcvlib_bypass_enable,aml_out->config.rate);
+        }
+    }
+
+    if ((patch && is_dts_format(patch->aformat)) || is_dts_format(aml_out->hal_internal_format)) {
         audio_format_t output_format;
+        int16_t *tmp_buffer;
         if (adev->dtslib_bypass_enable) {
             if (aml_out->hal_format == AUDIO_FORMAT_IEC61937) {
                 output_format = aml_out->hal_internal_format;
                 if (adev->debug_flag) {
                     ALOGD("%s:%d DTS write passthrough data", __func__, __LINE__);
                 }
-                if (audio_hal_data_processing(stream, (void *)buffer, bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+                if (audio_hal_data_processing(stream, (void *)write_buf, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
                     hw_write(stream, output_buffer, output_buffer_bytes, output_format);
                 }
                 return return_bytes;
@@ -8604,14 +9451,14 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
             if (adev->debug_flag) {
                 ALOGD("%s:%d DTS decoder start", __func__, __LINE__);
             }
-            ret = dca_decoder_process_patch(dts_dec, (unsigned char *)buffer, bytes);
+            ret = dca_decoder_process_patch(dts_dec, (unsigned char *)write_buf, write_bytes);
         } else {
-            config_output(stream);
+            config_output(stream,need_reset_decoder);
         }
 
 #if 1
         //wirte raw data
-        if (dts_dec->digital_raw == 1 && is_dual_output_stream(stream)) {
+        if (dts_dec->digital_raw == 1 && is_dual_output_stream(stream) && dts_dec->outlen_raw > 0) {
             /* all the HDMI in we goes through into decoder, because sometimes it is 44.1 khz, we don't know
                 such info if we doesn't decoded it.
             */
@@ -8629,13 +9476,13 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
                             aml_out->config.rate,dts_dec->pcm_out_info.sample_rate,dts_dec->outlen_raw);
                  }
                  if (ret == 0 && dts_dec->outlen_raw) {
-                    aml_audio_spdif_output(stream, (void *)dts_dec->outbuf_raw, dts_dec->outlen_raw);
+                    aml_audio_spdif_output(stream, (void *)dts_dec->outbuf_raw, dts_dec->outlen_raw,adev->optical_format);
                  }
             } else if (aml_out->hal_internal_format == AUDIO_FORMAT_DTS){
                 if (adev->debug_flag) {
                     ALOGD("%s:%d non SPDIF/HDMIIN, DTS output bytes:%d", __func__, __LINE__, bytes);
                 }
-                aml_audio_spdif_output(stream, (void *)buffer, bytes);
+                aml_audio_spdif_output(stream, (void *)write_buf, write_bytes,adev->optical_format);
             }
         } else if (adev->active_outport == OUTPORT_HDMI_ARC) {
             output_format = AUDIO_FORMAT_DTS;
@@ -8656,7 +9503,7 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
                 aml_out->lasttimestamp.tv_sec = aml_out->timestamp.tv_sec;
                 aml_out->lasttimestamp.tv_nsec = aml_out->timestamp.tv_nsec;
             }
-            return bytes;
+            return write_bytes;
         }
         /* if one frame size is too big, such as 4096 frames = 85ms, but the alsa buffer only 42ms
            it will block the whole pipeline, we must increase the alsa buffer
@@ -8667,63 +9514,48 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
             aml_out->config.period_size = DEFAULT_PLAYBACK_PERIOD_SIZE;
         }
         //write pcm data
-        int read_bytes =  PLAYBACK_PERIOD_COUNT * DEFAULT_PLAYBACK_PERIOD_SIZE ;
+        int read_bytes =  PLAYBACK_PERIOD_COUNT * DEFAULT_PLAYBACK_PERIOD_SIZE * (dts_dec->pcm_out_info.channel_num / 2);
         bytes  = read_bytes;
-
+        int tmp_bytes = bytes;
         while (get_buffer_read_space(&dts_dec->output_ring_buf) > (int)bytes) {
+            audio_format_t output_format = AUDIO_FORMAT_PCM_16_BIT;
             ring_buffer_read(&dts_dec->output_ring_buf, dts_dec->outbuf, bytes);
-
-#if defined(IS_ATOM_PROJECT)
-            audio_format_t output_format = AUDIO_FORMAT_PCM_32_BIT;
-            if (!adev->output_tmp_buf || adev->output_tmp_buf_size < 2 * bytes) {
-                adev->output_tmp_buf = realloc(adev->output_tmp_buf, 2 * bytes);
-                adev->output_tmp_buf_size = 2 * bytes;
-            }
-            uint16_t *p = (uint16_t *)dts_dec->outbuf;
-            int32_t *p1 = (int32_t *)adev->output_tmp_buf;
-            void *tmp_buffer = (void *)adev->output_tmp_buf;
-            for (unsigned i = 0; i < bytes / 2; i++) {
-                p1[i] = ((int32_t)p[i]) << 16;
-            }
-
-            bytes *= 2;
-            double lfe;
             if (dts_dec->pcm_out_info.channel_num == 6) {
-                int samplenum = bytes / (dts_dec->pcm_out_info.channel_num * 4);
-                //ALOGI("dts_dec->pcm_out_info.channel_num:%d samplenum:%d bytes:%d",dts_dec->pcm_out_info.channel_num,samplenum,bytes);
-                //Lt = L + (C *  -3 dB)  - (Ls * -1.2 dB)  -  (Rs * -6.2 dB)
-                //Rt = R + (C * -3 dB) + (Ls * -6.2 dB) + (Rs *  -1.2 dB)
-                for (int i = 0; i < samplenum; i++ ) {
-                    lfe = (double)p1[6 * i + 3]*(1.678804f / 4);
-                    p1[6 * i] = p1[6 * i] + p1[6 * i + 2] * 0.707945 - p1[6 * i + 4] * 0.870963 - p1[6 * i + 5] * 0.489778;
-                    p1[6 * i + 1] = p1[6 * i + 1] + p1[6 * i + 2] * 0.707945 + p1[6 * i + 4] * 0.489778 + p1[6 * i + 5] * 0.870963;
-                    p1[2 * i ] = (p1[6 * i] >> 2) + (int32_t)lfe;
-                    p1[2 * i  + 1] = (p1[6 * i + 1] >> 2) + (int32_t)lfe;
-                }
-                bytes /= 3;
-             }
-#if 0
-if (getprop_bool("media.audio_hal.dts.outdump")) {
-FILE *fp1 = fopen("/data/tmp/dd_mix.raw", "a+");
-if (fp1) {
-    int flen = fwrite((char *)tmp_buffer, 1, bytes, fp1);
-    fclose(fp1);
-} else {
-    ALOGD("could not open files!");
-}
-}
-#endif
-
-#else
-            void *tmp_buffer = (void *) dts_dec->outbuf;
-            audio_format_t output_format = AUDIO_FORMAT_PCM_16_BIT;
-#endif
-            aml_hw_mixer_mixing(&adev->hw_mixer, tmp_buffer, bytes, output_format);
-            if (audio_hal_data_processing(stream, tmp_buffer, bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+                int16_t *dts_buffer = (int16_t *) dts_dec->outbuf;
+                if (adev->effect_buf_size < bytes) {
+                    adev->effect_buf = realloc(adev->effect_buf, bytes);
+                    if (!adev->effect_buf) {
+                        ALOGE ("realloc effect buf failed size %zu format = %#x", bytes, output_format);
+                        return -ENOMEM;
+                     } else {
+                        ALOGI("realloc effect_buf size from %zu to %zu format = %#x", adev->effect_buf_size, bytes, output_format);
+                     }
+                     adev->effect_buf_size = bytes;
+                }
+                tmp_buffer = (int16_t *)adev->effect_buf;
+                memcpy(tmp_buffer, dts_buffer, bytes);
+                if (adev->native_postprocess.postprocessors[0] != NULL) {
+                    (*(adev->native_postprocess.postprocessors[0]))->get_descriptor(adev->native_postprocess.postprocessors[0], &tmpdesc);
+                    if (0 == strcmp(tmpdesc.name,"VirtualX")) {
+                        audio_post_process(adev->native_postprocess.postprocessors[0], tmp_buffer, bytes/(6 * 2));
+                    }
+                }
+                tmp_bytes /= 3;
+            } else {
+                if (adev->effect_in_ch != 2) {
+                    /*for special dts source*/
+                    virtualx_setparameter(adev,VIRTUALXINMODE,0,5);
+                    virtualx_setparameter(adev,TRUVOLUMEINMODE,0,5);
+                    adev->effect_in_ch = 2;
+                }
+                tmp_buffer = (int16_t *) dts_dec->outbuf;
+                tmp_bytes = bytes;
+            }
+            aml_hw_mixer_mixing(&adev->hw_mixer, (void*)tmp_buffer, tmp_bytes, output_format);
+            if (audio_hal_data_processing(stream, (void*)tmp_buffer, tmp_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
                 hw_write(stream, output_buffer, output_buffer_bytes, output_format);
             }
         }
-
         aml_out->frame_write_sum = (aml_out->input_bytes_size  - dts_dec->remain_size )  / audio_stream_out_frame_size(stream);
         aml_out->last_frames_postion = aml_out->frame_write_sum - out_get_latency_frames (stream);
         return return_bytes;
@@ -8743,10 +9575,17 @@ if (fp1) {
         //#ifdef DOLBY_MS12_ENABLE
         if (eDolbyMS12Lib == adev->dolby_lib_type) {
             if (is_bypass_dolbyms12(stream)) {
-                if (audio_hal_data_processing (stream, buffer, bytes, &output_buffer, &output_buffer_bytes, output_format) == 0)
+                if (adev->debug_flag) {
+                    ALOGI("%s passthrough dolbyms12, format %#x\n", __func__, aml_out->hal_format);
+                }
+
+                if (audio_hal_data_processing (stream, write_buf, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0)
                     hw_write (stream, output_buffer, output_buffer_bytes, output_format);
             }
             else {
+                dolby_ms12_bypass_process(stream, (char*)write_buf, write_bytes);
+                /*begin to write, clear the total write*/
+                total_write = 0;
 re_write:
                 if (adev->debug_flag) {
                     ALOGI("%s dolby_ms12_main_process before write_bytes %zu!\n", __func__, write_bytes);
@@ -8766,7 +9605,7 @@ re_write:
                         write_bytes -= used_size;
                         aml_audio_sleep(1000);
                         if (adev->debug_flag >= 2) {
-                            ALOGI("%s sleeep 5ms\n", __FUNCTION__);
+                            ALOGI("%s sleeep 1ms\n", __FUNCTION__);
                         }
                         write_retry++;
                         if (adev->ms12.dolby_ms12_enable) {
@@ -8775,7 +9614,7 @@ re_write:
                     }
                     if (write_retry >= 400) {
                         ALOGE("%s main write retry time output,left %zu", __func__, write_bytes);
-                        //bytes -= write_bytes;
+                        ms12_write_failed = 1;
                     }
                     goto exit;
                 } else {
@@ -8783,16 +9622,12 @@ re_write:
                 }
             }
         } else if (eDolbyDcvLib == adev->dolby_lib_type) {
-            //#else
-            //ALOGI("aml_out->hal_format %0x ",aml_out->hal_format);
-
             if (adev->dcvlib_bypass_enable) {
                 if (aml_out->hal_format == AUDIO_FORMAT_IEC61937) {
                     output_format = get_output_format(stream);
-                    if (audio_hal_data_processing(stream, (void *)buffer, bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+                    if (audio_hal_data_processing(stream, (void *)write_buf, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
                         hw_write(stream, output_buffer, output_buffer_bytes, output_format);
                     }
-
                     return return_bytes;
                 }
             }
@@ -8804,36 +9639,32 @@ re_write:
                 if (ddp_dec->status == 1) {
 #if defined(IS_ATOM_PROJECT)
                     /*for 32bit hal, raw data only support 16bit*/
-                    int16_t *p = (int16_t *)buffer;
-                    int32_t *p1 = (int32_t *)buffer;
-                    for (size_t i = 0; i < bytes/4; i++) {
+                    int16_t *p = (int16_t *)write_buf;
+                    int32_t *p1 = (int32_t *)write_buf;
+                    for (size_t i = 0; i < write_bytes/4; i++) {
                         p[i] = p1[i] >> 16;
                     }
-                    bytes /= 2;
+                    write_bytes /= 2;
 #endif
-                    ret = dcv_decoder_process_patch(ddp_dec, (unsigned char *)buffer, bytes);
+                    ret = dcv_decoder_process_patch(ddp_dec, (unsigned char *)write_buf, write_bytes);
                 } else {
-                    config_output(stream);
+                    config_output(stream,need_reset_decoder);
                 }
                 if (ret < 0 ) {
                     if (adev->debug_flag)
                         ALOGE("%s(), %d decoder error, ret %d", __func__, __LINE__, ret);
-                    if (aml_out->frame_write_sum > 0 ) {
-                        aml_out->frame_write_sum = (aml_out->input_bytes_size - ddp_dec->remain_size)  / audio_stream_out_frame_size(stream);
-                        aml_out->last_frames_postion = aml_out->frame_write_sum  - out_get_latency_frames (stream);
-                    }
-                    return bytes;
+                    return return_bytes;
                 }
                 /*wirte raw data*/
                 if (ddp_dec->outlen_raw > 0 && is_dual_output_stream(stream)) {/*dual output: pcm & raw*/
                     if (ddp_dec->pcm_out_info.sample_rate > 0)
                         aml_out->config.rate = ddp_dec->pcm_out_info.sample_rate;
-                    aml_audio_spdif_output(stream, (void *)ddp_dec->outbuf_raw, ddp_dec->outlen_raw);
+                    aml_audio_spdif_output(stream, (void *)ddp_dec->outbuf_raw, ddp_dec->outlen_raw,adev->optical_format);
                 }
                 //now only TV ARC output is using single output. we are implementing the OTT HDMI output in this case.
                 // TODO  add OUTPUT_HDMI in this case
                 // or STB case
-                else if (ddp_dec->digital_raw > 0 && (adev->active_outport == OUTPORT_HDMI_ARC || adev->is_STB)) {/*single raw output*/
+                else if (ddp_dec->digital_raw > 0 && (adev->active_outport == OUTPORT_HDMI_ARC || !adev->is_TV)) {/*single raw output*/
                     if (ddp_dec->pcm_out_info.sample_rate > 0)
                         aml_out->config.rate = ddp_dec->pcm_out_info.sample_rate;
                     if (patch)
@@ -8865,9 +9696,6 @@ re_write:
                         hw_write(stream, output_buffer, output_buffer_bytes, output_format);
                     }
                 }
-
-                aml_out->frame_write_sum = (aml_out->input_bytes_size - ddp_dec->remain_size) / audio_stream_out_frame_size(stream);
-                aml_out->last_frames_postion = aml_out->frame_write_sum - out_get_latency_frames (stream);
                 return return_bytes;
             }
 
@@ -8897,7 +9725,6 @@ re_write:
                     if (adev->debug_flag) {
                         ALOGD("%s:%d mixing hw_sync mode, output_format:0x%x, hw_sync_frame_size:%d", __func__, __LINE__, output_format, hw_sync->hw_sync_frame_size);
                     }
-
                     aml_hw_mixer_mixing(&adev->hw_mixer, tmp_buffer, hw_sync->hw_sync_frame_size, output_format);
                     if (audio_hal_data_processing(stream, tmp_buffer, hw_sync->hw_sync_frame_size, &output_buffer, &output_buffer_bytes, output_format) == 0) {
                         hw_write(stream, output_buffer, output_buffer_bytes, output_format);
@@ -8905,11 +9732,20 @@ re_write:
 #if defined(IS_ATOM_PROJECT)
                 }
 #endif
+
             } else {
                 if (adev->debug_flag) {
                     ALOGD("%s:%d mixing non-hw_sync mode, output_format:0x%x, write_bytes:%d", __func__, __LINE__, output_format, write_bytes);
                 }
+                if (getprop_bool("media.audiohal.mixer")) {
+                    aml_audio_dump_audio_bitstreams("/data/audio/beforemix.raw",
+                        tmp_buffer, write_bytes);
+                }
                 aml_hw_mixer_mixing(&adev->hw_mixer, tmp_buffer, write_bytes, output_format);
+                if (getprop_bool("media.audiohal.mixer")) {
+                    aml_audio_dump_audio_bitstreams("/data/audio/mixed.raw",
+                            tmp_buffer, write_bytes);
+                }
                 if (audio_hal_data_processing(stream, tmp_buffer, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
                     hw_write(stream, output_buffer, output_buffer_bytes, output_format);
                 }
@@ -8920,10 +9756,10 @@ re_write:
             if (audio_hal_data_processing(stream, tmp_buffer, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
                 hw_write(stream, output_buffer, output_buffer_bytes, output_format);
             }
-
         }
     }
 exit:
+
     if (eDolbyMS12Lib == adev->dolby_lib_type) {
         if (continous_mode(adev)) {
             aml_out->timestamp = adev->ms12.timestamp;
@@ -8932,8 +9768,27 @@ exit:
         }
     }
 
+    /*if the data consume is not complete, it will be send again by audio flinger,
+      this old data will cause av sync problem after seek.
+    */
+    if ((eDolbyMS12Lib == adev->dolby_lib_type) && (continous_mode(adev)) && (aml_out->hw_sync_mode) && !ms12_write_failed) {
+        /*
+        if the data is not  consumed totally,
+        we need re-send data again
+        */
+        if (return_bytes > 0 && total_bytes > (return_bytes + bytes_cost)) {
+            bytes_cost += return_bytes;
+            ALOGV("total bytes=%d cost=%d return=%d", total_bytes,bytes_cost,return_bytes);
+            goto hwsync_rewrite;
+        }
+        else if (return_bytes < 0)
+            return return_bytes;
+        else
+            return total_bytes;
+    }
+
     if (adev->debug_flag) {
-        ALOGI("%s return %zu!\n", __FUNCTION__, bytes);
+        ALOGI("%s return %zu!\n", __FUNCTION__, return_bytes);
     }
     return return_bytes;
 }
@@ -8949,7 +9804,8 @@ ssize_t mixer_aux_buffer_write(struct audio_stream_out *stream, const void *buff
     size_t in_frames = bytes / frame_size;
     size_t bytes_remaining = bytes;
     size_t bytes_written = 0;
-    int need_reconfig_ms12 = 0;
+    bool need_reconfig_output = false;
+    bool  need_reset_decoder = false;
     int retry = 0;
     unsigned int alsa_latency_frame = 0;
     pthread_mutex_lock(&adev->lock);
@@ -8959,7 +9815,6 @@ ssize_t mixer_aux_buffer_write(struct audio_stream_out *stream, const void *buff
         ALOGD("%s:%d size:%d, dolby_lib_type:0x%x, frame_size:%d", __func__, __LINE__, bytes, adev->dolby_lib_type, frame_size);
     }
 
-
     if ((aml_out->status == STREAM_HW_WRITING) && hw_mix) {
         ALOGI("%s(), aux do alsa close\n", __func__);
         pthread_mutex_lock(&adev->alsa_pcm_lock);
@@ -8998,28 +9853,34 @@ ssize_t mixer_aux_buffer_write(struct audio_stream_out *stream, const void *buff
             /*only system sound active*/
             if (!hw_mix) {
                 /* here to check if the audio HDMI ARC format updated. */
-                if ((adev->arc_hdmi_updated) && (adev->ms12.dolby_ms12_enable == true)) {
+                if (((adev->arc_hdmi_updated) || (adev->a2dp_updated)) && (adev->ms12.dolby_ms12_enable == true)) {
                     //? if we need protect
                     adev->arc_hdmi_updated = 0;
-                    need_reconfig_ms12 = 1;
-                    ALOGI("%s() HDMI ARC EndPoint changing status, need reconfig Dolby MS12\n", __func__);
+                    adev->a2dp_updated = 0;
+                    need_reconfig_output = true;
+                    ALOGI("%s() HDMI ARC EndPoint or a2dp changing status, need reconfig Dolby MS12\n", __func__);
                 }
 
                 /* here to check if the audio output routing changed. */
                 if ((adev->out_device != aml_out->out_device) && (adev->ms12.dolby_ms12_enable == true)) {
                     ALOGI("%s(), output routing changed from 0x%x to 0x%x,need MS12 reconfig output", __func__, aml_out->out_device, adev->out_device);
                     aml_out->out_device = adev->out_device;
-                    need_reconfig_ms12 = 1;
+                    need_reconfig_output = true;
                 }
-
                 /* here to check if ms12 is already enabled */
                 if (!adev->ms12.dolby_ms12_enable) {
                     ALOGI("%s(), 0x%x, Swithing system output to MS12, need MS12 reconfig output", __func__, aml_out->out_device);
-                    need_reconfig_ms12 = 1;
+                    need_reconfig_output = true;
+                    need_reset_decoder = true;
                 }
 
-                if (need_reconfig_ms12) {
-                    config_output(stream);
+                if (adev->ms12.hdmi_format != adev->hdmi_format) {
+                    ALOGI("%s(), swithing digital format from %d --> %d", __func__, adev->ms12.hdmi_format, adev->hdmi_format);
+                    need_reconfig_output = true;
+                    adev->ms12.hdmi_format = adev->hdmi_format;
+                }
+                if (need_reconfig_output) {
+                    config_output(stream,need_reset_decoder);
                 }
             }
         }
@@ -9070,8 +9931,8 @@ ssize_t mixer_aux_buffer_write(struct audio_stream_out *stream, const void *buff
         uint32_t u32SampleRate = out_get_sample_rate(&stream->common);
         uint32_t u32FreeBuffer = aml_hw_mixer_get_space(&adev->hw_mixer);
 
-        uint64_t u64BufferDelayUs = ((AML_HW_MIXER_BUF_SIZE * 1000) / ( frame_size * u32SampleRate)) * 1000;
-        uint64_t u64ConstantDelayUs = bytes * 1000000 / (frame_size * u32SampleRate * 3);
+        uint64_t u64BufferDelayUs = ((uint64_t)(AML_HW_MIXER_BUF_SIZE * 1000) / ( frame_size * u32SampleRate)) * 1000;
+        uint64_t u64ConstantDelayUs = (uint64_t)bytes * 1000000 / (frame_size * u32SampleRate * 3);
 
         ALOGV("%s:%d sampleRate:%d, bytes_written:%d, frame_size:%d, u32FreeBuffer:%d, delay:%llums", __func__, __LINE__,
             u32SampleRate, bytes_written, frame_size, u32FreeBuffer, (u64ConstantDelayUs/1000));
@@ -9080,7 +9941,7 @@ ssize_t mixer_aux_buffer_write(struct audio_stream_out *stream, const void *buff
         // when idle buffer is less than 2/5, sleep 1/5 buffer size time
         if (u32FreeBuffer < 2 * AML_HW_MIXER_BUF_SIZE / 5) {
             // (1/5 * AML_HW_MIXER_BUF_SIZE) / (frame_size * u32SampleRate) * 1000000 us
-            uint64_t u64DelayTimeUs = ((AML_HW_MIXER_BUF_SIZE * 1000) / u32SampleRate) * (1000 / (5 * frame_size));
+            uint64_t u64DelayTimeUs = ((uint64_t)(AML_HW_MIXER_BUF_SIZE * 1000) / u32SampleRate) * (1000 / (5 * frame_size));
             usleep(u64DelayTimeUs);
             ALOGI("%s:%d, mixer idle buffer less than 2/5, need usleep:%lldms end ", __func__, __LINE__, u64DelayTimeUs/1000);
         }
@@ -9109,8 +9970,8 @@ ssize_t mixer_aux_buffer_write(struct audio_stream_out *stream, const void *buff
             aml_out->last_frames_postion -= alsa_latency_frame;
         }
         if (adev->debug_flag) {
-            ALOGI("%s stream audio presentation %"PRIu64" latency_frame %d.ms12 system latency_frame %d", __func__,
-                  aml_out->last_frames_postion, alsa_latency_frame, system_latency);
+            ALOGI("%s stream audio presentation %"PRIu64" latency_frame %d.ms12 system latency_frame %d,write total %"PRIu64"", __func__,
+                  aml_out->last_frames_postion, alsa_latency_frame, system_latency,aml_out->frame_write_sum);
         }
     } else {
         aml_out->last_frames_postion = aml_out->frame_write_sum;
@@ -9119,6 +9980,54 @@ ssize_t mixer_aux_buffer_write(struct audio_stream_out *stream, const void *buff
 
 }
 
+ssize_t mixer_app_buffer_write(struct audio_stream_out *stream, const void *buffer, size_t bytes)
+{
+   struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+   struct aml_audio_device *adev = aml_out->dev;
+   struct dolby_ms12_desc *ms12 = &(adev->ms12);
+   int ret = 0;
+   size_t frame_size = audio_stream_out_frame_size(stream);
+   size_t bytes_remaining = bytes;
+   size_t bytes_written = 0;
+   int retry = 20;
+
+   if (adev->debug_flag) {
+       ALOGD("[%s:%d] size:%d, frame_size:%d", __func__, __LINE__, bytes, frame_size);
+   }
+
+   if (eDolbyMS12Lib != adev->dolby_lib_type) {
+        ALOGW("[%s:%d] dolby_lib_type:%d, is not ms12, not support app write", __func__, __LINE__, adev->dolby_lib_type);
+        return -1;
+   }
+
+   if (is_bypass_dolbyms12(stream)) {
+       ALOGW("[%s:%d] is_bypass_dolbyms12, not support app write", __func__, __LINE__);
+       return -1;
+   }
+
+   while (bytes_remaining && adev->ms12.dolby_ms12_enable && retry > 0) {
+       size_t used_size = 0;
+       ret = dolby_ms12_app_process(stream, (char *)buffer + bytes_written, bytes_remaining, &used_size);
+       if (!ret) {
+           bytes_remaining -= used_size;
+           bytes_written += used_size;
+       }
+       retry--;
+       if (bytes_remaining) {
+           aml_audio_sleep(1000);
+       }
+   }
+   if (retry <= 10) {
+       ALOGE("[%s:%d] write retry=%d ", __func__, __LINE__, retry);
+   }
+   if (retry == 0 && bytes_remaining != 0) {
+       ALOGE("[%s:%d] write timeout 10 ms ", __func__, __LINE__);
+       bytes -= bytes_remaining;
+   }
+
+   return bytes;
+}
+
 ssize_t process_buffer_write(struct audio_stream_out *stream,
                             const void *buffer,
                             size_t bytes)
@@ -9128,7 +10037,13 @@ ssize_t process_buffer_write(struct audio_stream_out *stream,
     void *output_buffer = NULL;
     size_t output_buffer_bytes = 0;
     if (adev->debug_flag) {
-        ALOGD("%s:%d size:%d, hal_internal_format:0x%x", __func__, __LINE__, bytes, aml_out->hal_internal_format);
+        ALOGD("%s:%p device:%x,%x", __func__, stream, aml_out->out_device, adev->out_device);
+    }
+
+    if (adev->out_device != aml_out->out_device) {
+        ALOGD("%s:%p device:%x,%x", __func__, stream, aml_out->out_device, adev->out_device);
+        aml_out->out_device = adev->out_device;
+        config_output(stream,true);
     }
 
     if (audio_hal_data_processing(stream, buffer, bytes, &output_buffer, &output_buffer_bytes, aml_out->hal_internal_format) == 0) {
@@ -9147,8 +10062,8 @@ static int usecase_change_validate_l(struct aml_stream_out *aml_out, bool is_sta
     bool hw_mix;
 
     if (is_standby) {
-        ALOGI("++%s(), dev usecase masks = %#x, is_standby = %d, out usecase %s",
-              __func__, aml_dev->usecase_masks, is_standby, aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? str_usecases[aml_out->usecase] : "STREAM_USECASE_INVAL");
+        ALOGI("++[%s:%d], dev masks:%#x, is_standby:%d, out usecase:%s", __func__, __LINE__,
+            aml_dev->usecase_masks, is_standby, usecase2Str(aml_out->usecase));
         /**
          * If called by standby, reset out stream's usecase masks and clear the aml_dev usecase masks.
          * So other active streams could know that usecase have been changed.
@@ -9157,13 +10072,8 @@ static int usecase_change_validate_l(struct aml_stream_out *aml_out, bool is_sta
         aml_out->dev_usecase_masks = 0;
         aml_out->write = NULL;
         aml_dev->usecase_masks &= ~(1 << aml_out->usecase);
-        if (aml_out->usecase == STREAM_RAW_DIRECT ||
-            aml_out->usecase == STREAM_RAW_HWSYNC) {
-            aml_dev->rawtopcm_flag = true;
-            ALOGI("enable rawtopcm_flag !!!");
-        }
-        ALOGI("--%s(), dev usecase masks = %#x, is_standby = %d, out usecase %s",
-              __func__, aml_dev->usecase_masks, is_standby, aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? str_usecases[aml_out->usecase] : "STREAM_USECASE_INVAL");
+        ALOGI("--[%s:%d], dev masks:%#x, is_standby:%d, out usecase %s", __func__, __LINE__,
+            aml_dev->usecase_masks, is_standby, usecase2Str(aml_out->usecase));
         return 0;
     }
 
@@ -9173,21 +10083,21 @@ static int usecase_change_validate_l(struct aml_stream_out *aml_out, bool is_sta
     }
 
         /* check the usecase validation */
-    if (popcount(aml_dev->usecase_masks) > 2) {
-        ALOGE("%s(), invalid usecase masks = %#x, out usecase %s!",
-              __func__, aml_dev->usecase_masks, str_usecases[aml_out->usecase]);
+    if (popcount(aml_dev->usecase_masks) > MAX_INPUT_STREAM_CNT) {
+        ALOGE("[%s:%d], invalid masks:%#x, out usecase:%s!", __func__, __LINE__,
+            aml_dev->usecase_masks, usecase2Str(aml_out->usecase));
         return -EINVAL;
     }
 
     if (((aml_dev->continuous_audio_mode == 1) && (aml_dev->debug_flag > 1)) || \
         (aml_dev->continuous_audio_mode == 0))
-        ALOGI("++++%s(),continuous_audio_mode %d dev usecase masks = %#x, out usecase_masks = %#x, out usecase %s",
-              __func__, aml_dev->continuous_audio_mode, aml_dev->usecase_masks, aml_out->dev_usecase_masks, aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? str_usecases[aml_out->usecase] : "STREAM_USECASE_INVAL");
+        ALOGI("++++[%s:%d],continuous:%d dev masks:%#x,out masks:%#x,out usecase:%s,aml_out:%p", __func__,  __LINE__,
+            aml_dev->continuous_audio_mode, aml_dev->usecase_masks, aml_out->dev_usecase_masks, usecase2Str(aml_out->usecase), aml_out);
 
     /* new output case entered, so no masks has been set to the out stream */
     if (!aml_out->dev_usecase_masks) {
         if ((1 << aml_out->usecase) & aml_dev->usecase_masks) {
-            ALOGE("%s(), usecase: %s already exists!!", __func__, aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? str_usecases[aml_out->usecase] : "STREAM_USECASE_INVAL");
+            ALOGE("[%s:%d], usecase: %s already exists!!, aml_out:%p", __func__,  __LINE__, usecase2Str(aml_out->usecase), aml_out);
             return -EINVAL;
         }
 
@@ -9217,7 +10127,7 @@ static int usecase_change_validate_l(struct aml_stream_out *aml_out, bool is_sta
              * This case only for normal output without mixing
              */
             aml_out->write = process_buffer_write;
-            ALOGI("%s(),1 process_buffer_write ", __FUNCTION__);
+            ALOGI("[%s:%d],1 process_buffer_write ", __func__, __LINE__);
         }
     } else {
         /**
@@ -9229,7 +10139,11 @@ static int usecase_change_validate_l(struct aml_stream_out *aml_out, bool is_sta
             aml_out->write = mixer_aux_buffer_write;
             //ALOGE("%s(),2 mixer_aux_buffer_write !", __FUNCTION__);
             //FIXEME if need config ms12 here if neeeded.
-
+#ifdef ENABLE_MMAP
+        } else if (aml_out->flags & AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) {
+            aml_out->write = mixer_app_buffer_write;
+            //ALOGI("[%s:%d], mixer_app_buffer_write !", __func__, __LINE__);
+#endif
         } else {
             aml_out->write = mixer_main_buffer_write;
             //ALOGE("%s(),2 mixer_main_buffer_write !", __FUNCTION__);
@@ -9240,11 +10154,64 @@ static int usecase_change_validate_l(struct aml_stream_out *aml_out, bool is_sta
     aml_out->dev_usecase_masks = aml_dev->usecase_masks;
     if (((aml_dev->continuous_audio_mode == 1) && (aml_dev->debug_flag > 1)) || \
         (aml_dev->continuous_audio_mode == 0))
-        ALOGI("----%s(), continuous_audio_mode %d dev usecase masks = %#x, out usecase_masks = %#x, out usecase %s",
-              __func__, aml_dev->continuous_audio_mode, aml_dev->usecase_masks, aml_out->dev_usecase_masks, aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? str_usecases[aml_out->usecase] : "STREAM_USECASE_INVAL");
+        ALOGI("----[%s:%d], continuous:%d dev masks:%#x, out masks:%#x, out usecase:%s", __func__, __LINE__,
+            aml_dev->continuous_audio_mode, aml_dev->usecase_masks, aml_out->dev_usecase_masks, usecase2Str(aml_out->usecase));
     return 0;
 }
 
+static bool is_disable_ms12_continuous(struct audio_stream_out *stream) {
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device *adev = aml_out->dev;
+    /*check the UI setting and source/sink format */
+    if (is_bypass_dolbyms12(stream)) {
+        return true;
+    }
+    /*in netflix , we always use contiuous mode*/
+    if (adev->is_netflix) {
+        return false;
+    }
+    /*
+    currently,by default. we enable some dolby format into continous mode to
+    get a better experence for switch output format and pause resume.
+    44.1k/32K need do the main audio  switch, need add later.
+    7.1 DDP has dependent frames per each frameset. need more code to
+    seperate the two frames. TBD
+    MAT/AC4 will be added later
+    */
+    if ((aml_out->hal_internal_format == AUDIO_FORMAT_AC3 \
+        || aml_out->hal_internal_format == AUDIO_FORMAT_E_AC3 \
+        || aml_out->hal_internal_format == AUDIO_FORMAT_AC4 \
+        /*|| aml_out->hal_internal_format == AUDIO_FORMAT_DOLBY_TRUEHD*/) &&
+        aml_out->hal_rate == 48000) {
+         return false;
+    }
+    /*for other raw case, we disbale it first*/
+    else if (!audio_is_linear_pcm(aml_out->hal_internal_format)) {
+        return true;
+    } else if (is_high_rate_pcm(stream) || is_multi_channel_pcm(stream)) {
+        /*high bit rate pcm case, we need disable ms12 continuous mode*/
+        return true;
+    }
+    return false;
+}
+
+static bool is_need_reset_ms12_continuous(struct audio_stream_out *stream) {
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device *adev = aml_out->dev;
+    /*check the UI setting and source/sink format */
+    if (is_bypass_dolbyms12(stream)) {
+        return false;
+    }
+    if (!adev->continuous_audio_mode || !adev->ms12.dolby_ms12_enable)
+        return false;
+    if (is_dolby_ms12_support_compression_format(aml_out->hal_internal_format) && \
+         (aml_out->hal_internal_format != adev->ms12.main_input_fmt || \
+          aml_out->hal_rate != adev->ms12.main_input_sr)) {
+         return true;
+    }
+    return false;
+}
+
 /* out_write entrance: every write goes in here. */
 ssize_t out_write_new(struct audio_stream_out *stream,
                       const void *buffer,
@@ -9254,8 +10221,34 @@ ssize_t out_write_new(struct audio_stream_out *stream,
     struct aml_audio_device *adev = aml_out->dev;
     ssize_t ret = 0;
     write_func  write_func_p = NULL;
+    size_t frame_size = audio_stream_out_frame_size(stream);
+    size_t in_frames = bytes / frame_size;
 
-    ALOGV("%s: out_stream(%p) position(%zu)", __func__, stream, bytes);
+    if (adev->debug_flag > 1) {
+        ALOGI("+<IN>%s: out_stream(%p) position(%zu)", __func__, stream, bytes);
+    }
+
+    if (aml_out->continuous_mode_check) {
+        if (adev->dolby_lib_type_last == eDolbyMS12Lib) {
+            if (is_disable_ms12_continuous(stream)) {
+                if (adev->continuous_audio_mode) {
+                    adev->delay_disable_continuous = 0;
+                    ALOGI("Need disable MS12 continuous");
+                    get_dolby_ms12_cleanup(&adev->ms12);
+                    adev->continuous_audio_mode = 0;
+                    adev->exiting_ms12 = 1;
+                    aml_out->restore_continuous = true;
+                    clock_gettime(CLOCK_MONOTONIC, &adev->ms12_exiting_start);
+                }
+            }
+            else if (is_need_reset_ms12_continuous(stream)) {
+                    adev->delay_disable_continuous = 0;
+                    ALOGI("Need reset MS12 continuous as main audio changed\n");
+                    get_dolby_ms12_cleanup(&adev->ms12);
+            }
+        }
+        aml_out->continuous_mode_check = false;
+    }
 
     /**
      * deal with the device output changes
@@ -9264,7 +10257,25 @@ ssize_t out_write_new(struct audio_stream_out *stream,
      * pthread_mutex_unlock(&aml_out->lock);
      */
     pthread_mutex_lock(&adev->lock);
+    if (adev->direct_mode) {
+        /*
+         * when the third_party apk calls pcm_close during use and then calls pcm_open again,
+         * primary hal does not access the sound card,
+         * continue to let the third_party apk access the sound card.
+         */
+        aml_alsa_output_close(stream);
+        aml_out->status = STREAM_STANDBY;
+        ALOGI("%s,direct mode write,skip bytes %zu\n",__func__,bytes);
+        /*TODO accurate delay time */
+        usleep(in_frames*1000/48);
+        aml_out->frame_write_sum += in_frames;
+        pthread_mutex_unlock(&adev->lock);
+        return bytes;
+    }
     ret = usecase_change_validate_l(aml_out, false);
+    if (aml_out->is_normal_pcm) {
+        adev->sys_audio_frame_written = aml_out->frame_write_sum;
+    }
     if (ret < 0) {
         ALOGE("%s() failed", __func__);
         pthread_mutex_unlock(&adev->lock);
@@ -9276,13 +10287,16 @@ ssize_t out_write_new(struct audio_stream_out *stream,
     pthread_mutex_unlock(&adev->lock);
     if (write_func_p) {
         ret = write_func_p(stream, buffer, bytes);
+        /* update audio format to display audio info banner.*/
+        update_audio_format(adev, aml_out->hal_internal_format);
     }
     if (ret > 0) {
         aml_out->total_write_size += ret;
     }
     if (adev->debug_flag > 1) {
-        ALOGI("-%s() ret %zd,%p %"PRIu64"\n", __func__, ret, stream, aml_out->total_write_size);
+        ALOGI("-<OUT>%s() ret %zd,%p %"PRIu64"\n", __func__, ret, stream, aml_out->total_write_size);
     }
+
     return ret;
 }
 
@@ -9333,13 +10347,24 @@ int adev_open_output_stream_new(struct audio_hw_device *dev,
         // In V1.1, android out lpcm stream and hwsync pcm stream goes to aml mixer,
         // tv source keeps the original way.
         // Next step is to make all compitable.
-        if (aml_out->usecase == STREAM_PCM_NORMAL || aml_out->usecase == STREAM_PCM_HWSYNC) {
-            ret = initSubMixingInput(aml_out, config);
-            if (ret < 0) {
-                ALOGE("initSub mixing input failed");
+        if (aml_out->usecase == STREAM_PCM_NORMAL ||
+            aml_out->usecase == STREAM_PCM_HWSYNC ||
+            aml_out->usecase == STREAM_PCM_MMAP) {
+            /*for 96000, we need bypass submix, this is for DTS certification*/
+            if (config->sample_rate == 96000 || config->sample_rate == 88200) {
+                aml_out->bypass_submix = true;
+                aml_out->stream.write = out_write_direct;
+                aml_out->stream.common.standby = out_standby_direct;
+            } else {
+                ret = initSubMixingInput(aml_out, config);
+                aml_out->bypass_submix = false;
+                if (ret < 0) {
+                    ALOGE("initSub mixing input failed");
+                }
             }
         } else {
-            ALOGI("%s(), direct usecase: %s", __func__, usecase_to_str(aml_out->usecase));
+            aml_out->bypass_submix = true;
+            ALOGI("%s(), direct usecase: %s", __func__, usecase2Str(aml_out->usecase));
             if (adev->is_TV) {
                 aml_out->stream.write = out_write_new;
                 aml_out->stream.common.standby = out_standby_new;
@@ -9354,6 +10379,22 @@ int adev_open_output_stream_new(struct audio_hw_device *dev,
         adev->spdif_encoder_init_flag = false;
     }
 
+#ifdef ENABLE_BT_A2DP
+    if (devices & AUDIO_DEVICE_OUT_ALL_A2DP) {
+        if (!audio_is_linear_pcm(aml_out->hal_format)) {
+            aml_out->stream.write = out_write_new;
+            aml_out->stream.common.standby = out_standby_new;
+            aml_out->stream.pause = out_pause_new;
+            aml_out->stream.resume = out_resume_new;
+            aml_out->stream.flush = out_flush_new;
+        }
+        a2dp_output_enable(&aml_out->stream);
+    }
+#endif
+
+    aml_out->codec_type = get_codec_type(aml_out->hal_internal_format);
+    aml_out->continuous_mode_check = true;
+
     pthread_mutex_lock(&adev->lock);
     adev->active_outputs[aml_out->usecase] = aml_out;
     pthread_mutex_unlock(&adev->lock);
@@ -9361,8 +10402,8 @@ int adev_open_output_stream_new(struct audio_hw_device *dev,
     if (aml_getprop_bool("media.audio.hal.debug")) {
         aml_out->debug_stream = 1;
     }
-    ALOGD("-%s: out %p: usecase = %s card = %d devices = %d", __func__,
-        aml_out, usecase_to_str(aml_out->usecase), aml_out->card, aml_out->device);
+    ALOGD("-%s: out %p: usecase:%s card:%d alsa devices:%d", __func__,
+        aml_out, usecase2Str(aml_out->usecase), aml_out->card, aml_out->device);
 
     return 0;
 }
@@ -9373,21 +10414,32 @@ void adev_close_output_stream_new(struct audio_hw_device *dev,
     struct aml_audio_device *adev = (struct aml_audio_device *)dev;
     struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
 
-    if (!stream) {
-        ALOGE("%s: nullptr\n");
-        return;
-    }
-    ALOGD("%s: enter usecase = %s", __func__, str_usecases[aml_out->usecase]);
+    ALOGD("%s: enter usecase = %s", __func__, usecase2Str(aml_out->usecase));
     /* call legacy close to reuse codes */
     adev->active_outputs[aml_out->usecase] = NULL;
+
+#ifdef ENABLE_BT_A2DP
+    if (aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+        a2dp_output_disable(stream);
+    }
+#endif
+
     if (adev->useSubMix) {
-        if (aml_out->is_normal_pcm || aml_out->usecase == STREAM_PCM_HWSYNC) {
-            deleteSubMixingInput(aml_out);
+        if (aml_out->is_normal_pcm ||
+            aml_out->usecase == STREAM_PCM_HWSYNC ||
+            aml_out->usecase == STREAM_PCM_MMAP) {
+            if (!aml_out->bypass_submix) {
+                deleteSubMixingInput(aml_out);
+            }
         }
     }
-    if (aml_out->hw_sync_mode) {
+    if (aml_out->hw_sync_mode && aml_out->tsync_status != TSYNC_STATUS_STOP) {
+        ALOGI("%s set AUDIO_PAUSE when close stream\n",__func__);
+        sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_PAUSE");
+
         ALOGI("%s set AUDIO_STOP when close stream\n",__func__);
         sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_STOP");
+        aml_out->tsync_status = TSYNC_STATUS_STOP;
     }
 
     adev_close_output_stream(dev, stream);
@@ -9395,17 +10447,17 @@ void adev_close_output_stream_new(struct audio_hw_device *dev,
     ALOGD("%s: exit", __func__);
 }
 
-int calc_time_interval_us(struct timespec *ts0, struct timespec *ts1)
+int calc_time_interval_us(struct timespec *ts_start, struct timespec *ts_end)
 {
     int64_t start_us, end_us;
     int64_t interval_us;
 
 
-    start_us = ts0->tv_sec * 1000000LL +
-               ts0->tv_nsec / 1000LL;
+    start_us = ts_start->tv_sec * 1000000LL +
+               ts_start->tv_nsec / 1000LL;
 
-    end_us   = ts1->tv_sec * 1000000LL +
-               ts1->tv_nsec / 1000LL;
+    end_us   = ts_end->tv_sec * 1000000LL +
+               ts_end->tv_nsec / 1000LL;
 
     interval_us = end_us - start_us;
 
@@ -9424,6 +10476,94 @@ static void ts_wait_time(struct timespec *ts, uint32_t time)
     }
 }
 
+/* multichannel PCM from HDMI has a swapped C/LFE layout */
+static void repack_c_lfe(void *data, int size, int frame_size, audio_format_t format)
+{
+    int frame_count = size / frame_size;
+    int i;
+
+    if (format == AUDIO_FORMAT_PCM_16_BIT) {
+        for (i = 0; i < frame_count; i++) {
+            short *p = (short *)((char *)data + i * frame_size);
+            short tmp = p[2];
+            p[2] = p[3];
+            p[3] = tmp;
+        }
+    } else if (format == AUDIO_FORMAT_PCM_32_BIT) {
+        for (i = 0; i < frame_count; i++) {
+            int *p = (int *)((char *)data + i * frame_size);
+            int tmp = p[2];
+            p[2] = p[3];
+            p[3] = tmp;
+        }
+    }
+
+}
+
+/* multichannel PCM from ARC/eARC need collect real
+ * channel data from ca, the input is fixed 8 channels
+ * when calling this function
+ * Reference: CEA-861-D table 20 Audio InfoFrame Data Byte 4
+ */
+static int repack_arc_input(void *data, int size, int ca, audio_format_t format)
+{
+    const unsigned char channel_mask[] = {
+        0x03, 0x07, 0x0b, 0x0f, 0x13, 0x17, 0x1b, 0x1f,
+        0x33, 0x37, 0x3b, 0x3f, 0x73, 0x77, 0x7b, 0x7f,
+        0xf3, 0xf7, 0xfb, 0xff, 0xc3, 0xc7, 0xcb, 0xcf,
+        0xd3, 0xd7, 0xdb, 0xdf, 0xf3, 0xf7, 0xfb, 0xff
+    };
+    int i, j;
+    int out_chan;
+    unsigned char mask;
+
+    /* some sanity check */
+    if ((ca < 0) || (ca > 0x1f) || ((format != AUDIO_FORMAT_PCM_16_BIT) && (format != AUDIO_FORMAT_PCM_32_BIT))) {
+       return size;
+    }
+
+    mask = channel_mask[ca];
+    if (ca > 0x13) {
+        mask &= 0x3f;
+    }
+
+    if (format == AUDIO_FORMAT_PCM_16_BIT) {
+        short *in = (short *)data;
+        short *out = (short *)data;
+        for (i = 0; i < size / 8 / 2; i++) {
+            for (j = 0; j < 8; j++) {
+                if (mask & (1 << j)) {
+                    *out++ = *in++;
+                } else {
+                    in++;
+                }
+            }
+        }
+    } else {
+        int *in = (int *)data;
+        int *out = (int *)data;
+        for (i = 0; i < size / 8 / 4; i++) {
+            for (j = 0; j < 8; j++) {
+                if (mask & (1 << j)) {
+                    *out++ = *in++;
+                } else {
+                    in++;
+                }
+            }
+        }
+    }
+
+    out_chan = __builtin_popcount(mask);
+
+    if ((ca & 0xc) == 0xc) {
+        repack_c_lfe(data,  size * out_chan / 8,
+                     out_chan * ((format == AUDIO_FORMAT_PCM_16_BIT) ? 2 : 4),
+                     format);
+    }
+
+    return size * out_chan / 8;
+}
+
 // buffer/period ratio, bigger will add more latency
 void *audio_patch_input_threadloop(void *data)
 {
@@ -9440,13 +10580,14 @@ void *audio_patch_input_threadloop(void *data)
     read_bytes = DEFAULT_CAPTURE_PERIOD_SIZE * CAPTURE_PERIOD_COUNT;
     int ret = 0, retry = 0;
     audio_format_t cur_aformat  = AUDIO_FORMAT_INVALID;
-    audio_format_t last_aformat = AUDIO_FORMAT_INVALID;
+    audio_format_t last_aformat = patch->in_format;
     int ring_buffer_size = 0;
     bool bSpdifin_PAO = false;
     hdmiin_audio_packet_t cur_audio_packet = AUDIO_PACKET_AUDS;
     hdmiin_audio_packet_t last_audio_packet = AUDIO_PACKET_AUDS;
     int txl_chip = is_txl_chip();
     int last_channel_count = 2;
+    int last_ca = 0;
 
     ALOGD("%s: enter", __func__);
     patch->chanmask = stream_config.channel_mask = patch->in_chanmask;
@@ -9473,11 +10614,26 @@ void *audio_patch_input_threadloop(void *data)
     if (ringbuffer) {
         ring_buffer_size = ringbuffer->size;
     }
+
+#ifdef ADD_AUDIO_DELAY_INTERFACE
+    if (patch->input_src == AUDIO_DEVICE_IN_HDMI) {
+        aml_audio_delay_input_set_type(
+            (aml_dev->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) ?
+            AML_DELAY_INPUT_HDMI_BT : AML_DELAY_INPUT_HDMI);
+    } else if (patch->input_src == AUDIO_DEVICE_IN_SPDIF) {
+        aml_audio_delay_input_set_type(AML_DELAY_INPUT_OPT);
+    } else if (patch->input_src == AUDIO_DEVICE_IN_HDMI_ARC) {
+        aml_audio_delay_input_set_type(AML_DELAY_INPUT_ARC);
+    } else {
+        aml_audio_delay_input_set_type(AML_DELAY_INPUT_DEFAULT);
+    }
+#endif
+
     while (!patch->input_thread_exit) {
         int bytes_avail = 0;
         int period_mul = 1;
         int read_threshold = 0;
-        switch (patch->aformat) {
+        switch (last_aformat) {
         case AUDIO_FORMAT_E_AC3:
             period_mul = EAC3_MULTIPLIER;
             break;
@@ -9514,6 +10670,15 @@ void *audio_patch_input_threadloop(void *data)
             memset(patch->in_buf, 0, bytes_avail);
         }
 
+#ifdef ADD_AUDIO_DELAY_INTERFACE
+        //TODO: multi-channel PCM input
+        if (bytes_avail > 0) {
+            aml_audio_delay_input_process(patch->in_buf, bytes_avail,
+                last_aformat, last_channel_count /* channel_num */, patch->in_sample_rate,
+                (last_aformat == AUDIO_FORMAT_PCM_32_BIT) ? 4 : 2 /*sample_size*/);
+        }
+#endif
+
 #if 0
         clock_gettime(CLOCK_MONOTONIC, &after_read);
         us = calc_time_interval_us(&before_read, &after_read);
@@ -9531,16 +10696,48 @@ void *audio_patch_input_threadloop(void *data)
                 feeddata_audio_type_parse(&patch->audio_parse_para, patch->in_buf, bytes_avail);
             }
 
+            /* multichannel PCM from HDMI has a swapped C/LFE layout */
+            if (IS_HDMI_IN_HW(patch->input_src) &&
+                audio_is_linear_pcm(cur_aformat) &&
+                (in->hal_channel_mask & AUDIO_CHANNEL_IN_CENTER) &&
+                (in->hal_channel_mask & AUDIO_CHANNEL_IN_LOW_FREQUENCY)) {
+                repack_c_lfe(patch->in_buf, bytes_avail, audio_stream_in_frame_size(&in->stream), cur_aformat);
+            }
+
+            if ((patch->input_src == AUDIO_DEVICE_IN_HDMI_ARC) &&
+                (last_channel_count == 8)) {
+                bytes_avail = repack_arc_input(patch->in_buf, bytes_avail, last_ca, cur_aformat);
+            }
+
             do {
 
-                if (IS_HDMI_IN_HW(patch->input_src)) {
-                    // hdmi in audio channels recofig.
+                // Note: we are not touching patch->aformat and patch->aformat is used by
+                // output threadloop to detect format changing to reset output path (e.g. MS12)
+                if (patch->input_src == AUDIO_DEVICE_IN_HDMI) {
+                    // hdmi in audio channels reconfig
                     int current_channel = get_hdmiin_channel(&aml_dev->alsa_mixer);
-                    if (current_channel != -1 && current_channel != last_channel_count) {
+                    cur_aformat = audio_parse_get_audio_type(patch->audio_parse_para);
+#ifdef HDMI_ARC_PCM_32BIT_INPUT
+                    if (audio_is_linear_pcm(cur_aformat)) {
+                        cur_aformat = AUDIO_FORMAT_PCM_32_BIT;
+                    }
+#endif
+                    if ((current_channel != -1 && current_channel != last_channel_count) ||
+                        (cur_aformat != last_aformat)) {
                         ALOGI("%s(), channel count changed from %d to %d!",
                             __func__, last_channel_count, current_channel);
                         last_channel_count = current_channel;
+                        last_aformat = cur_aformat;
+                        ring_buffer_reset(ringbuffer);
+#ifdef ADD_AUDIO_DELAY_INTERFACE
+                        aml_audio_delay_clear(AML_DELAY_INPORT_ALL);
+#endif
+
+#ifdef HDMI_ARC_PCM_32BIT_INPUT
+                        in->hal_format = audio_is_linear_pcm(cur_aformat) ? AUDIO_FORMAT_PCM_32_BIT : AUDIO_FORMAT_PCM_16_BIT;
+#endif
                         in_reset_config_param(stream_in, AML_INPUT_STREAM_CONFIG_TYPE_CHANNELS, &current_channel);
+                        break;
                     }
 
                     cur_audio_packet = get_hdmiin_audio_packet(&aml_dev->alsa_mixer);
@@ -9552,11 +10749,15 @@ void *audio_patch_input_threadloop(void *data)
                         int buf_size = 0;
 
                         cur_aformat = audio_parse_get_audio_type(patch->audio_parse_para);
+#ifdef HDMI_ARC_PCM_32BIT_INPUT
+                        if (audio_is_linear_pcm(cur_aformat)) {
+                            cur_aformat = AUDIO_FORMAT_PCM_32_BIT;
+                        }
+#endif
                         ALOGD("HDMI Format Switch from 0x%x to 0x%x last_type=%d cur_type=%d\n",
                             last_aformat, cur_aformat, last_audio_packet, cur_audio_packet);
 
-                        if (cur_audio_packet == AUDIO_PACKET_HBR ||
-                            (patch->aformat == AUDIO_FORMAT_DTS_HD)) {
+                        if (cur_audio_packet == AUDIO_PACKET_HBR) {
                             // if it is high bitrate bitstream, use PAO and increase the buffer size
                             bSpdifin_PAO = true;
                             period_size = DEFAULT_CAPTURE_PERIOD_SIZE * 4;
@@ -9571,18 +10772,71 @@ void *audio_patch_input_threadloop(void *data)
 
                         if (!alsa_device_is_auge()) {
                             set_spdifin_pao(&aml_dev->alsa_mixer, bSpdifin_PAO);
-                        } else {
-                            set_spdifin_pao(&aml_dev->alsa_mixer, false);
                         }
                         ring_buffer_reset_size(ringbuffer, buf_size);
+#ifdef ADD_AUDIO_DELAY_INTERFACE
+                        aml_audio_delay_clear(AML_DELAY_INPORT_ALL);
+#endif
                         in_reset_config_param(stream_in, AML_INPUT_STREAM_CONFIG_TYPE_PERIODS, &period_size);
                         last_aformat = cur_aformat;
                         last_audio_packet = cur_audio_packet;
                         break;
                     }
+                } else if (patch->input_src == AUDIO_DEVICE_IN_HDMI_ARC) {
+                    // HDMI ARC/eARC IN audio channels reconfig
+                    int current_channel = get_arcin_channel(&aml_dev->alsa_mixer);
+                    int current_ca = get_arcin_ca(&aml_dev->alsa_mixer);
+                    cur_aformat = audio_parse_get_audio_type(patch->audio_parse_para);
+#ifdef HDMI_ARC_PCM_32BIT_INPUT
+                    if (audio_is_linear_pcm(cur_aformat)) {
+                        cur_aformat = AUDIO_FORMAT_PCM_32_BIT;
+                    }
+#endif
+                    if (audio_is_linear_pcm(cur_aformat)) {
+                        if ((current_channel != -1 && current_channel != last_channel_count) ||
+                            (current_ca != last_ca) ||
+                            (cur_aformat != last_aformat)) {
+                            ALOGI("%s(), channel count and assignment changed from %d/0x%x to %d/0x%x",
+                                __func__, last_channel_count, last_ca, current_channel, current_ca);
+                            last_channel_count = current_channel;
+                            last_ca = current_ca;
+                            in->hal_format = last_aformat = cur_aformat;
+                            /* setup input channel mask to make audio_stream_in_frame_size correct */
+                            in->hal_channel_mask = aml_map_ca_to_mask(current_ca);
+                            //in->hal_format = patch->aformat = cur_aformat;
+                            ring_buffer_reset(ringbuffer);
+#ifdef ADD_AUDIO_DELAY_INTERFACE
+                            aml_audio_delay_clear(AML_DELAY_INPORT_ALL);
+#endif
+                            in_reset_config_param(stream_in, AML_INPUT_STREAM_CONFIG_TYPE_CHANNELS, &current_channel);
+                            break;
+                        }
+                    }
+#ifdef HDMI_ARC_PCM_32BIT_INPUT
+                    else if (cur_aformat != last_aformat) {
+                        /* for bit stream input, reopen input with AUDIO_FORMAT_PCM_16_BIT */
+                        current_channel = 2;
+                        in->hal_format = AUDIO_FORMAT_PCM_16_BIT;
+                        ring_buffer_reset(ringbuffer);
+#ifdef ADD_AUDIO_DELAY_INTERFACE
+                        aml_audio_delay_clear(AML_DELAY_INPORT_ALL);
+#endif
+                        last_aformat = cur_aformat;
+                        in_reset_config_param(stream_in, AML_INPUT_STREAM_CONFIG_TYPE_CHANNELS, &current_channel);
+                        break;
+                    }
+#endif
+                }
 
-
+#if 0
+                {
+                    FILE *fp = fopen("/data/vendor/audiohal/in.raw", "a+");
+                    if (fp) {
+                        fwrite((unsigned char*)patch->in_buf, 1, bytes_avail, fp);
+                        fclose(fp);
+                    }
                 }
+#endif
                 if (get_buffer_write_space(ringbuffer) >= bytes_avail) {
                     retry = 0;
                     ret = ring_buffer_write(ringbuffer,
@@ -9599,11 +10853,13 @@ void *audio_patch_input_threadloop(void *data)
                         }
                     }
                     //usleep(1000);
+#if 0
                 } else if ((aml_dev->in_device & AUDIO_DEVICE_IN_HDMI_ARC) &&
                         (access(SYS_NODE_EARC_RX, F_OK) == 0) &&
                         (aml_mixer_ctrl_get_int(&aml_dev->alsa_mixer,
                                 AML_MIXER_ID_HDMI_EARC_AUDIO_ENABLE) == 0)) {
                     ALOGW("%s(), arc in disconnect,please check the status", __func__);
+#endif
                 } else {
                     retry = 1;
                     pthread_cond_signal(&patch->cond);
@@ -9634,66 +10890,12 @@ void *audio_patch_input_threadloop(void *data)
     return (void *)0;
 }
 
-static unsigned int calc_drop_size(unsigned int dropms, struct audio_config* stream_config)
-{
-    unsigned int size = 0;
-    unsigned int byte_width = 0;
-    unsigned int channum;
-    channum = audio_channel_count_from_out_mask(stream_config->channel_mask);
-    if (AUDIO_FORMAT_PCM_16_BIT == stream_config->format) {
-        byte_width = 2;
-    } else if (AUDIO_FORMAT_PCM_32_BIT == stream_config->format) {
-        byte_width = 4;
-    } else if (AUDIO_FORMAT_PCM_8_BIT == stream_config->format) {
-        byte_width = 1;
-    } else {
-        byte_width = 0;
-    }
-    size = dropms * byte_width * channum * stream_config->sample_rate / 1000;
-    return size;
-}
-
-#define AVSYNC_SAMPLE_INTERVAL (50)
-#define AVSYNC_SAMPLE_MAX_CNT (10)
-
-static int do_avsync(struct aml_audio_patch *patch, int period_mul, struct audio_config *stream_config)
-{
-    ring_buffer_t *ringbuffer = &(patch->aml_ringbuffer);
-
-    if (patch->avsync_sample_interval >= AVSYNC_SAMPLE_INTERVAL * period_mul) {
-        aml_dev_try_avsync(patch);
-        if (patch->avsync_adelay > 0) {
-            ALOGI("now delay the audio output by %d\n", patch->avsync_adelay);
-        }
-
-        if (patch->avsync_drop > 0) {
-            unsigned int drop_byte = calc_drop_size(patch->avsync_drop,
-                stream_config);
-
-            ALOGI("avsync the dropp size is %d\n", drop_byte);
-            if (drop_byte > DROP_AUDIO_SIZE) {
-                ring_buffer_read(ringbuffer,
-                    (unsigned char*)patch->drop_buf, DROP_AUDIO_SIZE);
-                drop_byte = drop_byte - DROP_AUDIO_SIZE;
-            } else {
-                ring_buffer_read(ringbuffer,
-                    (unsigned char*)patch->drop_buf, drop_byte);
-            }
-        }
-        patch->avsync_sample_interval = 0;
-    } else {
-        patch->avsync_sample_interval++;
-    }
-
-    return 0;
-}
-
 void *audio_patch_output_threadloop(void *data)
 {
     struct aml_audio_patch *patch = (struct aml_audio_patch *)data;
-    struct audio_hw_device *dev = patch->dev;
-    struct aml_audio_device *aml_dev = (struct aml_audio_device *) dev;
-    ring_buffer_t *ringbuffer = &(patch->aml_ringbuffer);
+    struct audio_hw_device *dev;
+    struct aml_audio_device *aml_dev;
+    ring_buffer_t *ringbuffer;
     struct audio_stream_out *stream_out = NULL;
     struct aml_stream_out *aml_out = NULL,*out;
     struct audio_config stream_config;
@@ -9701,27 +10903,20 @@ void *audio_patch_output_threadloop(void *data)
     int write_bytes = DEFAULT_PLAYBACK_PERIOD_SIZE * PLAYBACK_PERIOD_COUNT;
     int ret;
     ALOGD("%s: enter", __func__);
+
+    if (!patch) {
+        ALOGE("%s: patch is null", __func__);
+        return (void *)0;
+    }
+    dev = patch->dev;
+    aml_dev = (struct aml_audio_device *) dev;
+    ringbuffer = &(patch->aml_ringbuffer);
+    memset(&stream_config, 0, sizeof(struct audio_config));
     stream_config.channel_mask = patch->out_chanmask;
     stream_config.sample_rate = patch->out_sample_rate;
     stream_config.format = patch->out_format;
-
-#ifdef DOLBY_MS12_INPUT_FORMAT_TEST
-    char buf[PROPERTY_VALUE_MAX];
-    int prop_ret = -1;
-    int format = 0;
-
-    prop_ret = property_get("dolby.ms12.input.format", buf, NULL);
-    if (prop_ret > 0) {
-        format = atoi(buf);
-        if (format == 1) {
-            stream_config.format = AUDIO_FORMAT_AC3;
-        } else if (format == 2) {
-            stream_config.format = AUDIO_FORMAT_E_AC3;
-        } else if (format == 3) {
-            stream_config.format = AUDIO_FORMAT_DOLBY_TRUEHD;
-        }
-    }
-#endif
+    /*affinity the thread to cpu 2/3 which has few IRQ*/
+    aml_audio_set_cpu23_affinity();
     /*
     may we just exit from a direct active stream playback
     still here.we need remove to standby to new playback
@@ -9729,7 +10924,7 @@ void *audio_patch_output_threadloop(void *data)
     pthread_mutex_lock(&aml_dev->lock);
     aml_out = direct_active(aml_dev);
     if (aml_out) {
-        ALOGI("%s stream %p active,need standby aml_out->usecase:%d ", __func__, aml_out, aml_out->usecase);
+        ALOGI("%s stream %p active,need standby aml_out->usecase:%s ", __func__, aml_out, usecase2Str(aml_out->usecase));
         pthread_mutex_lock(&aml_out->lock);
         do_output_standby_l((struct audio_stream *)aml_out);
         pthread_mutex_unlock(&aml_out->lock);
@@ -9770,13 +10965,13 @@ void *audio_patch_output_threadloop(void *data)
         case AUDIO_FORMAT_E_AC3:
             period_mul = EAC3_MULTIPLIER;
             break;
-        case AUDIO_FORMAT_DTS_HD:
-            period_mul = 4;
-            break;
         case AUDIO_FORMAT_DOLBY_TRUEHD:
         case AUDIO_FORMAT_MAT:
             period_mul = 16;
             break;
+        case AUDIO_FORMAT_DTS_HD:
+            period_mul = 4;
+            break;
         default:
             period_mul = 1;
         }
@@ -9805,29 +11000,40 @@ void *audio_patch_output_threadloop(void *data)
             if (ret == 0) {
                 ALOGE("%s(), ring_buffer read 0 data!", __func__);
             }
+
+            /* avsync for dev->dev patch*/
+            if (patch && (patch->need_do_avsync == true) && (patch->input_signal_stable == true) &&
+                    (aml_dev->patch_src == SRC_ATV || aml_dev->patch_src == SRC_HDMIIN ||
+                    aml_dev->patch_src == SRC_LINEIN || aml_dev->patch_src == SRC_SPDIFIN)) {
+
+                aml_dev_try_avsync(patch);
+                if (patch->skip_frames) {
+                    //ALOGD("%s(), skip this period data for avsync!", __func__);
+                    usleep(5);
+                    continue;
+                }
+            }
 #if 0
             struct timespec before_read;
             struct timespec after_read;
             int us = 0;
             clock_gettime(CLOCK_MONOTONIC, &before_read);
+            ALOGV("++%s ringbuf get data ok, start to out write, bytes-%d",
+                  __FUNCTION__, ret);
 #endif
 
-            ALOGV("++%s ringbuf get data ok, start to out write, bytes = %d",
-                  __FUNCTION__, ret);
-            ret = out_write_new(stream_out, patch->out_buf, ret);
+            out_write_new(stream_out, patch->out_buf, ret);
+#if 0
             ALOGV("++%s ringbuf get data ok, out write over!, retbytes = %d",
                   __FUNCTION__, ret);
-#if 0
             clock_gettime(CLOCK_MONOTONIC, &after_read);
             us = calc_time_interval_us(&before_read, &after_read);
             ALOGD("function gap =%d \n", us);
 #endif
-            //do_avsync(patch, period_mul, &stream_config);
         } else {
-            ALOGW("%s(), no enough data in ring buffer, available data size:%d, need data size:%d", __func__,
+            ALOGV("%s(), no enough data in ring buffer, available data size:%d, need data size:%d", __func__,
                 get_buffer_read_space(ringbuffer), (write_bytes * period_mul));
-            //repeat last period data, when no data in ringbuffer
-            ret = out_write_new(stream_out, patch->out_buf, DEFAULT_PLAYBACK_PERIOD_SIZE);
+           //ret = out_write_new(stream_out, patch->out_buf, DEFAULT_PLAYBACK_PERIOD_SIZE);
             usleep( (DEFAULT_PLAYBACK_PERIOD_SIZE) * 1000000 / 4 /
                 stream_config.sample_rate);
         }
@@ -9877,7 +11083,6 @@ static int create_patch_l(struct audio_hw_device *dev,
     patch->input_src = input;
     patch->is_dtv_src = false;
     patch->aformat = AUDIO_FORMAT_PCM_16_BIT;
-    patch->avsync_sample_max_cnt = AVSYNC_SAMPLE_MAX_CNT;
     aml_dev->audio_patch = patch;
     pthread_mutex_init(&patch->mutex, NULL);
     pthread_cond_init(&patch->cond, NULL);
@@ -9887,16 +11092,13 @@ static int create_patch_l(struct audio_hw_device *dev,
     patch->output_src = AUDIO_DEVICE_OUT_SPEAKER;
     patch->out_sample_rate = 48000;
     patch->out_chanmask = AUDIO_CHANNEL_OUT_STEREO;
-#if defined(IS_ATOM_PROJECT)
-    patch->in_format = AUDIO_FORMAT_PCM_32_BIT;
-    patch->out_format = AUDIO_FORMAT_PCM_32_BIT;
-#else
     patch->in_format = AUDIO_FORMAT_PCM_16_BIT;
     patch->out_format = AUDIO_FORMAT_PCM_16_BIT;
-#endif
-    patch->avsync_drop = 0;
-    patch->avsync_adelay = 0;
-    patch->drop_buf = calloc(1, sizeof(unsigned char) * DROP_AUDIO_SIZE);
+
+    /* when audio patch start, singal is unstale or
+     * patch signal is unstable, it need do avsync
+     */
+    patch->need_do_avsync = true;
 
     if (aml_dev->useSubMix) {
         // switch normal stream to old tv mode writing
@@ -9992,7 +11194,6 @@ int release_patch_l(struct aml_audio_device *aml_dev)
     patch->output_thread_exit = 1;
     pthread_join(patch->audio_output_threadID, NULL);
     ring_buffer_release(&patch->aml_ringbuffer);
-    free(patch->drop_buf);
     free(patch);
     aml_dev->audio_patch = NULL;
     ALOGD("%s: exit", __func__);
@@ -10321,16 +11522,17 @@ static int adev_create_audio_patch(struct audio_hw_device *dev,
     enum IN_PORT inport = INPORT_HDMIIN;
     unsigned int i = 0;
     int ret = -1;
-    ALOGI("++%s, src_config->ext.device.type(0x%x)", __FUNCTION__,src_config->ext.device.type);
-    if (bypass_primary_patch(src_config)) {
-        ALOGD("bluetooth voice search is in use, bypass adev_create_audio_patch()!!\n");
-        goto err;
-    }
+    aml_dev->no_underrun_max = property_get_int32("media.audio_hal.nounderrunmax", 8);
     if (!sources || !sinks || !handle) {
         ALOGE("%s: null pointer!", __func__);
         ret = -EINVAL;
         goto err;
     }
+    ALOGI("++%s, src_config->ext.device.type(0x%x)", __FUNCTION__,src_config->ext.device.type);
+    if (bypass_primary_patch(src_config)) {
+        ALOGD("bluetooth voice search is in use, bypass adev_create_audio_patch()!!\n");
+        goto err;
+    }
 
     if ((num_sources != 1) || (num_sinks > AUDIO_PATCH_PORTS_MAX)) {
         ALOGE("%s: unsupport num sources or sinks", __func__);
@@ -10383,6 +11585,11 @@ static int adev_create_audio_patch(struct audio_hw_device *dev,
         case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
             outport = OUTPORT_BT_SCO_HEADSET;
             break;
+        case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP:
+        case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:
+        case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER:
+            outport = OUTPORT_A2DP;
+            break;
         default:
             ALOGE("d-m %s: invalid sink device type %#x",
                   __func__, sink_config->ext.device.type);
@@ -10548,6 +11755,11 @@ static int adev_create_audio_patch(struct audio_hw_device *dev,
         case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
             outport = OUTPORT_BT_SCO_HEADSET;
             break;
+        case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP:
+        case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:
+        case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER:
+            outport = OUTPORT_A2DP;
+            break;
         default:
             ALOGE("d-d %s: invalid sink device type %#x",
                   __func__, sink_config->ext.device.type);
@@ -10577,6 +11789,7 @@ static int adev_create_audio_patch(struct audio_hw_device *dev,
         if (ret < 0) {
             ALOGE("%s() output routing failed", __func__);
         }
+        aml_dev->out_device = sink_config->ext.device.type;
 
         if (sink_config->config_mask & AUDIO_PORT_CONFIG_SAMPLE_RATE) {
             sample_rate = sink_config->sample_rate;
@@ -10658,7 +11871,23 @@ static int adev_create_audio_patch(struct audio_hw_device *dev,
             if (inport == INPORT_TUNER) {
                 aml_dev->patch_src = SRC_ATV;
             }
-        } else if ((inport == INPORT_TUNER) && (aml_dev->patch_src == SRC_DTV)) {
+            if (inport == INPORT_HDMIIN ||
+                inport == INPORT_ARCIN  ||
+                inport == INPORT_LINEIN ||
+                inport == INPORT_SPDIF  ||
+                inport == INPORT_TUNER) {
+
+                if (eDolbyMS12Lib == aml_dev->dolby_lib_type && aml_dev->continuous_audio_mode)
+                {
+                    get_dolby_ms12_cleanup(&aml_dev->ms12);
+                    aml_dev->exiting_ms12 = 1;
+                    aml_dev->continuous_audio_mode = 0;
+                    clock_gettime(CLOCK_MONOTONIC, &aml_dev->ms12_exiting_start);
+                    usecase_change_validate_l(aml_dev->active_outputs[STREAM_PCM_NORMAL], true);
+                    ALOGI("enter patching mode, exit MS12 continuous mode");
+                }
+            }
+            } else if ((inport == INPORT_TUNER) && (aml_dev->patch_src == SRC_DTV)) {
 #ifdef ENABLE_DTV_PATCH
              if ((aml_dev->patch_src == SRC_DTV) && aml_dev->audio_patching) {
                  ALOGI("%s, now release the dtv patch now\n ", __func__);
@@ -10739,6 +11968,12 @@ static int adev_release_audio_patch(struct audio_hw_device *dev,
                 && aml_dev->audio_patching == 1) {
             release_patch(aml_dev);
         }
+        /*for no patch case, we need to restore it*/
+        if (eDolbyMS12Lib == aml_dev->dolby_lib_type && (aml_dev->continuous_audio_mode_default == 1))
+        {
+            aml_dev->continuous_audio_mode = 1;
+            ALOGI("%s restore continuous_audio_mode=%d", __func__, aml_dev->continuous_audio_mode);
+        }
         aml_dev->audio_patching = 0;
         aml_dev->patch_src = SRC_INVAL;
         aml_dev->parental_control_av_mute = false;
@@ -10757,9 +11992,6 @@ static int adev_release_audio_patch(struct audio_hw_device *dev,
         }
 #endif
         aml_dev->patch_src = SRC_INVAL;
-        if (aml_dev->patch_src == SRC_DTV) {
-            ALOGI("patch src == DTV now line %d \n", __LINE__);
-        }
         aml_dev->tuner2mix_patch = false;
     }
 
@@ -10770,6 +12002,7 @@ static int adev_release_audio_patch(struct audio_hw_device *dev,
     aml_audio_delay_clear(AML_DELAY_OUTPORT_SPEAKER);
     aml_audio_delay_clear(AML_DELAY_OUTPORT_SPDIF);
     aml_audio_delay_clear(AML_DELAY_OUTPORT_ALL);
+    aml_audio_delay_clear(AML_DELAY_INPORT_ALL);
 #endif
 
 #if defined(IS_ATOM_PROJECT)
@@ -10795,6 +12028,11 @@ static int aml_dev_dump_latency(struct aml_audio_device *aml_dev, int fd)
     int frame_size = 0;
     int ret = 0;
     snd_pcm_sframes_t frames = 0;
+    int ms12_latency_decoder = MS12_DECODER_LATENCY;
+    int ms12_latency_pipeline = MS12_PIPELINE_LATENCY;
+    int ms12_latency_dap = MS12_DAP_LATENCY;
+    int ms12_latency_encoder = MS12_ENCODER_LATENCY;
+
     dprintf(fd, "-------------[AML_HAL] audio Latency--------------------------\n");
 
     frame_size = CHANNEL_CNT * audio_bytes_per_sample(AUDIO_FORMAT_PCM_16_BIT);
@@ -10810,8 +12048,6 @@ static int aml_dev_dump_latency(struct aml_audio_device *aml_dev, int fd)
             rbuf_ltcy /= MAT_MULTIPLIER;
         }
         v_ltcy = aml_sysfs_get_int("/sys/class/video/vframe_walk_delay");
-    } else {
-        return 0;
     }
 
     if (aml_dev->spk_tuning_lvl) {
@@ -10822,18 +12058,31 @@ static int aml_dev_dump_latency(struct aml_audio_device *aml_dev, int fd)
         spk_tuning_ltcy = frames / SAMPLE_RATE_MS;
     }
 
-    if (eDolbyMS12Lib == aml_dev->dolby_lib_type) {
-        if (aml_dev->ms12.dolby_ms12_enable == true) {
-            int dolby_main_avail = dolby_ms12_get_main_buffer_avail(NULL);
-            if (dolby_main_avail > 0) {
-                ms12_ltcy = dolby_main_avail / frame_size / SAMPLE_RATE_MS;
-                if (patch && patch->aformat == AUDIO_FORMAT_E_AC3) {
-                    ms12_ltcy /= EAC3_MULTIPLIER;
-                } else if ((patch->aformat == AUDIO_FORMAT_DOLBY_TRUEHD) || (patch->aformat == AUDIO_FORMAT_MAT)) {
-                    ms12_ltcy /= MAT_MULTIPLIER;
-                }
+    if ((eDolbyMS12Lib == aml_dev->dolby_lib_type) &&
+        aml_dev->ms12.dolby_ms12_enable &&
+        aml_dev->ms12_out) {
+        audio_format_t format = aml_dev->ms12_out->hal_internal_format;
+        int dolby_main_avail = dolby_ms12_get_main_buffer_avail(NULL);
+
+        if (dolby_main_avail > 0) {
+            ms12_ltcy = dolby_main_avail / frame_size / SAMPLE_RATE_MS;
+            if (format == AUDIO_FORMAT_E_AC3) {
+                ms12_ltcy /= EAC3_MULTIPLIER;
+            } else if ((format == AUDIO_FORMAT_DOLBY_TRUEHD) || (format == AUDIO_FORMAT_MAT)) {
+                ms12_ltcy /= MAT_MULTIPLIER;
             }
         }
+
+        ms12_ltcy += ms12_latency_pipeline;
+
+        if ((format & AUDIO_FORMAT_MAIN_MASK) != AUDIO_FORMAT_PCM)
+            ms12_ltcy += ms12_latency_decoder;
+        if (aml_dev->ms12_out->device == PORT_I2S) {
+            ms12_ltcy += ms12_latency_dap;
+        } else if ((aml_dev->optical_format == AUDIO_FORMAT_AC3) ||
+                   (aml_dev->optical_format == AUDIO_FORMAT_E_AC3)) {
+            ms12_ltcy += ms12_latency_encoder;
+        }
     }
 
     if (aml_dev->pcm_handle[I2S_DEVICE]) {
@@ -10854,16 +12103,18 @@ static int aml_dev_dump_latency(struct aml_audio_device *aml_dev, int fd)
         ret = pcm_ioctl(in->pcm, SNDRV_PCM_IOCTL_DELAY, &frames);
         if (ret >= 0) {
             alsa_in_ltcy = frames / SAMPLE_RATE_MS;
-            if (patch && patch->aformat == AUDIO_FORMAT_E_AC3) {
-                alsa_in_ltcy /= EAC3_MULTIPLIER;
-            } else if ((patch->aformat == AUDIO_FORMAT_DOLBY_TRUEHD) || (patch->aformat == AUDIO_FORMAT_MAT)) {
-                alsa_in_ltcy /= MAT_MULTIPLIER;
+            if (patch) {
+                if (patch->aformat == AUDIO_FORMAT_E_AC3) {
+                    alsa_in_ltcy /= EAC3_MULTIPLIER;
+                } else if ((patch->aformat == AUDIO_FORMAT_DOLBY_TRUEHD) || (patch->aformat == AUDIO_FORMAT_MAT)) {
+                    alsa_in_ltcy /= MAT_MULTIPLIER;
+                }
             }
         }
     }
 
     if (patch) {
-        int in_path_ltcy = alsa_in_ltcy + rbuf_ltcy + ms12_ltcy;
+        int in_path_ltcy = alsa_in_ltcy + rbuf_ltcy;
         int out_path_ltcy = 0;
         int whole_path_ltcy = 0;
 
@@ -10877,6 +12128,8 @@ static int aml_dev_dump_latency(struct aml_audio_device *aml_dev, int fd)
             out_path_ltcy = alsa_out_spdif_ltcy / MAT_MULTIPLIER;
         }
 
+        out_path_ltcy += ms12_ltcy;
+
         whole_path_ltcy = in_path_ltcy + out_path_ltcy;
 
         dprintf(fd, "[AML_HAL]      audio patch latency         : %6d ms\n", rbuf_ltcy);
@@ -10891,6 +12144,24 @@ static int aml_dev_dump_latency(struct aml_audio_device *aml_dev, int fd)
         } else {
             dprintf(fd, "[AML_HAL]      video path total latency    : N/A\n");
         }
+    } else {
+        int out_path_ltcy = 0;
+
+        if (aml_dev->sink_format == AUDIO_FORMAT_PCM_16_BIT) {
+            out_path_ltcy = alsa_out_i2s_ltcy + spk_tuning_ltcy;
+        } else if (aml_dev->sink_format == AUDIO_FORMAT_AC3) {
+            out_path_ltcy = alsa_out_spdif_ltcy;
+        } else if (aml_dev->sink_format == AUDIO_FORMAT_E_AC3) {
+            out_path_ltcy = alsa_out_spdif_ltcy / EAC3_MULTIPLIER;
+        } else if ((aml_dev->sink_format == AUDIO_FORMAT_DOLBY_TRUEHD) || (aml_dev->sink_format == AUDIO_FORMAT_MAT)) {
+            out_path_ltcy = alsa_out_spdif_ltcy / MAT_MULTIPLIER;
+        }
+        out_path_ltcy += ms12_ltcy;
+
+        dprintf(fd, "[AML_HAL]      MS12 buffer latency         : %6d ms\n", ms12_ltcy);
+        dprintf(fd, "[AML_HAL]      alsa hw i2s latency         : %6d ms\n", alsa_out_i2s_ltcy);
+        dprintf(fd, "[AML_HAL]      alsa hw spdif latency       : %6d ms\n", alsa_out_spdif_ltcy);
+        dprintf(fd, "[AML_HAL]      audio total latency         : %6d ms\n", out_path_ltcy);
     }
     return 0;
 }
@@ -10978,14 +12249,22 @@ static int adev_dump(const audio_hw_device_t *device, int fd)
             aml_dev->hdmi_format);
     dprintf(fd, "[AML_HAL]      dolby_lib: %d\n",
             aml_dev->dolby_lib_type);
+    if (aml_dev->useSubMix) {
+        subMixingDump(fd, aml_dev);
+    }
     return 0;
 }
 
 static int adev_close(hw_device_t *device)
 {
     struct aml_audio_device *adev = (struct aml_audio_device *)device;
-
+    pthread_mutex_lock(&adev->lock);
     ALOGD("%s: enter", __func__);
+    adev->count--;
+    if (adev->count > 0) {
+        pthread_mutex_unlock(&adev->lock);
+        return 0;
+    }
     unload_ddp_decoder_lib();
     if (eDolbyMS12Lib == adev->dolby_lib_type_last) {
         aml_ms12_lib_release();
@@ -11015,7 +12294,9 @@ static int adev_close(hw_device_t *device)
     if (adev->ar) {
         audio_route_free(adev->ar);
     }
+#ifdef AML_EQ_DRC
     eq_drc_release(&adev->eq_data);
+#endif
     close_mixer_handle(&adev->alsa_mixer);
     if (adev->sm) {
         deleteHalSubMixing(adev->sm);
@@ -11028,8 +12309,13 @@ static int adev_close(hw_device_t *device)
         aml_audio_delay_deinit();
     }
 #endif
-
+#ifdef PDM_MIC_CHANNELS
+    if (adev->mic_desc)
+        free(adev->mic_desc);
+#endif
+    pthread_mutex_unlock(&adev->lock);
     free(device);
+    aml_audio_debug_malloc_close();
     return 0;
 }
 
@@ -11069,7 +12355,7 @@ static int adev_set_audio_port_config (struct audio_hw_device *dev, const struct
                    patch->sinks[0].id == config->id) {
             ALOGI("patch found mix->dev id %d, patchset %p", patch->id, patch_set);
             break;
-        } else if (config->ext.device.type == AUDIO_DEVICE_IN_HDMI
+        } else if ((config->ext.device.type == AUDIO_DEVICE_IN_HDMI || config->ext.device.type == AUDIO_DEVICE_IN_HDMI_ARC)
                 && patch->sources[0].ext.device.type == AUDIO_DEVICE_IN_LINE) {
             ALOGI("HDMIIN DVI case, using LINEIN patch");
             break;
@@ -11131,6 +12417,11 @@ static int adev_set_audio_port_config (struct audio_hw_device *dev, const struct
             case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
                 outport = OUTPORT_BT_SCO_HEADSET;
                 break;
+            case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP:
+            case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:
+            case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER:
+                outport = OUTPORT_A2DP;
+                break;
             default:
                 ALOGE ("%s: invalid out device type %#x",
                           __func__, config->ext.device.type);
@@ -11190,7 +12481,8 @@ static int adev_set_audio_port_config (struct audio_hw_device *dev, const struct
                 break;
             }
 
-            aml_dev->src_gain[inport] = 1.0;
+            //aml_dev->src_gain[inport] = 1.0;
+            aml_dev->src_gain[inport] = DbToAmpl((float)config->gain.values[1] / 100);
             if (patch->sinks[0].type == AUDIO_PORT_TYPE_DEVICE) {
                 if (num_sinks == 2) {
                     switch (outport) {
@@ -11198,7 +12490,7 @@ static int adev_set_audio_port_config (struct audio_hw_device *dev, const struct
                         aml_dev->sink_gain[outport] = 1.0;
                         break;
                     case OUTPORT_SPEAKER:
-                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[0]) / 100);
+                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[2]) / 100);
                         break;
                     default:
                         ALOGE("%s: invalid out device type %#x",
@@ -11212,7 +12504,7 @@ static int adev_set_audio_port_config (struct audio_hw_device *dev, const struct
                         break;
                     case AUDIO_DEVICE_OUT_HDMI:
                         outport = OUTPORT_HDMI;
-                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[0]) / 100);
+                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[2]) / 100);
                         break;
                     case AUDIO_DEVICE_OUT_SPDIF:
                         outport = OUTPORT_SPDIF;
@@ -11220,19 +12512,19 @@ static int adev_set_audio_port_config (struct audio_hw_device *dev, const struct
                         break;
                     case AUDIO_DEVICE_OUT_AUX_LINE:
                         outport = OUTPORT_AUX_LINE;
-                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[0]) / 100);
+                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[2]) / 100);
                         break;
                     case AUDIO_DEVICE_OUT_SPEAKER:
                         outport = OUTPORT_SPEAKER;
-                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[0]) / 100);
+                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[2]) / 100);
                         break;
                     case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:
                         outport = OUTPORT_HEADPHONE;
-                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[0]) / 100);
+                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[2]) / 100);
                         break;
                     case AUDIO_DEVICE_OUT_REMOTE_SUBMIX:
                         outport = OUTPORT_REMOTE_SUBMIX;
-                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[0]) / 100);
+                        aml_dev->sink_gain[outport] = DbToAmpl(((float)config->gain.values[2]) / 100);
                         break;
                     case AUDIO_DEVICE_OUT_BLUETOOTH_SCO:
                         outport = OUTPORT_BT_SCO;
@@ -11240,6 +12532,12 @@ static int adev_set_audio_port_config (struct audio_hw_device *dev, const struct
                     case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
                         outport = OUTPORT_BT_SCO_HEADSET;
                         break;
+                    case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP:
+                    case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:
+                    case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER:
+                        outport = OUTPORT_A2DP;
+                        aml_dev->sink_gain[outport] = DbToAmpl((float)(config->gain.values[0] / 100));
+                        break;
                 default:
                     ALOGE ("%s: invalid out device type %#x",
                               __func__, patch->sinks->ext.device.type);
@@ -11256,6 +12554,7 @@ static int adev_set_audio_port_config (struct audio_hw_device *dev, const struct
                         // So. Temporary remove here.
                         // TODO: find out when call this function will cause HDMI ARC mute
                         //ret = set_dolby_ms12_primary_input_db_gain(&aml_dev->ms12, config->gain.values[1] / 100);
+                        dolby_ms12_set_main_volume(DbToAmpl(config->gain.values[1]/100));
                         pthread_mutex_unlock(&aml_dev->lock);
                         if (ret < 0) {
                             ALOGE("set dolby primary gain failed");
@@ -11290,9 +12589,46 @@ static int adev_get_audio_port(struct audio_hw_device *dev __unused, struct audi
 #define MAX_SPK_EXTRA_LATENCY_MS (100)
 #define DEFAULT_SPK_EXTRA_LATENCY_MS (15)
 
+//#define PDM_MIC_CHANNELS 4
+int init_mic_desc(struct aml_audio_device *adev)
+{
+    struct mic_in_desc *mic_desc = calloc(1, sizeof(struct mic_in_desc));
+    if (!mic_desc)
+        return -ENOMEM;
+
+    /* Config the default MIC-IN device */
+    mic_desc->mic = DEV_MIC_PDM;
+    mic_desc->config.rate = 16000;
+    mic_desc->config.format = PCM_FORMAT_S16_LE;
+
+#if (PDM_MIC_CHANNELS == 4)
+    ALOGI("%s(), 4 channels PDM mic", __func__);
+    mic_desc->config.channels = 4;
+#elif (PDM_MIC_CHANNELS == 2)
+    mic_desc->config.channels = 2;
+    ALOGI("%s(), 2 channels PDM mic", __func__);
+#else
+    ALOGI("%s(), default 2 channels PDM mic", __func__);
+    mic_desc->config.channels = 2;
+#endif
+
+    adev->mic_desc = mic_desc;
+    return 0;
+};
+
 static int adev_open(const hw_module_t* module, const char* name, hw_device_t** device)
 {
-    struct aml_audio_device *adev;
+    static struct aml_audio_device *adev;
+    if (adev != NULL && adev->count > 0) {
+        ALOGI("adev exsits ,reuse");
+        pthread_mutex_lock(&adev->lock);
+        adev->count++;
+        *device = &adev->hw_device.common;
+        pthread_mutex_unlock(&adev->lock);
+        ALOGI("*device:%p",*device);
+        return 0;
+    }
+    aml_audio_debug_malloc_open();
     size_t bytes_per_frame = audio_bytes_per_sample(AUDIO_FORMAT_PCM_16_BIT)
                              * audio_channel_count_from_out_mask(AUDIO_CHANNEL_OUT_STEREO);
     int buffer_size = PLAYBACK_PERIOD_COUNT * DEFAULT_PLAYBACK_PERIOD_SIZE * bytes_per_frame;
@@ -11353,7 +12689,10 @@ static int adev_open(const hw_module_t* module, const char* name, hw_device_t**
     adev->hw_device.get_audio_port = adev_get_audio_port;
     adev->hw_device.dump = adev_dump;
     adev->active_outport = -1;
-
+    adev->virtualx_mulch = true;
+    adev->dap_bypass_enable = (access(MS12_DAP_TUNING_PATH, F_OK) == 0) ? 0 : 1;
+    adev->dap_bypassgain = 1.0;
+    adev->hdmi_format = AUTO;
     card = alsa_device_get_card_index();
     if ((card < 0) || (card > 7)) {
         ALOGE("error to get audio card");
@@ -11374,11 +12713,12 @@ static int adev_open(const hw_module_t* module, const char* name, hw_device_t**
     adev->in_device = AUDIO_DEVICE_IN_BUILTIN_MIC & ~AUDIO_DEVICE_BIT_IN;
     adev->hi_pcm_mode = false;
 
+#ifdef AML_EQ_DRC
     adev->eq_data.card = adev->card;
     if (eq_drc_init(&adev->eq_data) == 0) {
-        ALOGI("%s() audio source gain: atv:%f, dtv:%f, hdmiin:%f, av:%f", __func__,
+        ALOGI("%s() audio source gain: atv:%f, dtv:%f, hdmiin:%f, av:%f, media:%f", __func__,
            adev->eq_data.s_gain.atv, adev->eq_data.s_gain.dtv,
-           adev->eq_data.s_gain.hdmi, adev->eq_data.s_gain.av);
+           adev->eq_data.s_gain.hdmi, adev->eq_data.s_gain.av, adev->eq_data.s_gain.media);
         ALOGI("%s() audio device gain: speaker:%f, spdif_arc:%f, headphone:%f", __func__,
            adev->eq_data.p_gain.speaker, adev->eq_data.p_gain.spdif_arc,
               adev->eq_data.p_gain.headphone);
@@ -11389,6 +12729,7 @@ static int adev_open(const hw_module_t* module, const char* name, hw_device_t**
         ALOGI("%s() audio noise gate level: %fdB, attack_time = %dms, release_time = %dms", __func__,
               adev->aml_ng_level, adev->aml_ng_attack_time, adev->aml_ng_release_time);
     }
+#endif
 
     ret = aml_audio_output_routing(&adev->hw_device, OUTPORT_SPEAKER, false);
     if (ret < 0) {
@@ -11440,32 +12781,41 @@ static int adev_open(const hw_module_t* module, const char* name, hw_device_t**
         spdif_tuning_latency = 0;
     }
 
+    adev->dolby_lib_type = detect_dolby_lib_type();
+    adev->dolby_lib_type_last = adev->dolby_lib_type;
     /* convert MS to data buffer length need to cache */
     adev->spk_tuning_lvl = (spdif_tuning_latency * bytes_per_frame * MM_FULL_POWER_SAMPLING_RATE) / 1000;
     /* end of spker tuning things */
     *device = &adev->hw_device.common;
     adev->dts_post_gain = 1.0;
+
+    adev->atv_switch = false;
     /* set default HP gain */
     adev->sink_gain[OUTPORT_HEADPHONE] = 1.0;
     adev->ms12_main1_dolby_dummy = true;
     adev->ms12_ott_enable = false;
-    adev->continuous_audio_mode = 0;
+    adev->continuous_audio_mode_default = 0;
     adev->need_remove_conti_mode = false;
+#if 1
+    /*for ms12 case, we set default continuous mode*/
+    if (eDolbyMS12Lib == adev->dolby_lib_type) {
+        adev->continuous_audio_mode_default = 1;
+    }
+#endif
+    /*we can use property to debug it*/
     ret = property_get(DISABLE_CONTINUOUS_OUTPUT, buf, NULL);
     if (ret > 0) {
         sscanf(buf, "%d", &disable_continuous);
         if (!disable_continuous) {
-            adev->continuous_audio_mode = 1;
+            adev->continuous_audio_mode_default = 1;
         }
         ALOGI("%s[%s] disable_continuous %d\n", DISABLE_CONTINUOUS_OUTPUT, buf, disable_continuous);
     }
+    adev->continuous_audio_mode = adev->continuous_audio_mode_default;
     pthread_mutex_init(&adev->alsa_pcm_lock, NULL);
     pthread_mutex_init(&adev->patch_lock, NULL);
     open_mixer_handle(&adev->alsa_mixer);
 
-    // try to detect which dobly lib is readable
-    adev->dolby_lib_type = detect_dolby_lib_type();
-    adev->dolby_lib_type_last = adev->dolby_lib_type;
     if (eDolbyMS12Lib != adev->dolby_lib_type) {
         adev->ms12.dolby_ms12_enable = false;
     } else {
@@ -11520,6 +12870,7 @@ static int adev_open(const hw_module_t* module, const char* name, hw_device_t**
 #endif
     adev->sink_gain[OUTPORT_SPEAKER] = 1.0;
     adev->sink_gain[OUTPORT_HDMI] = 1.0;
+    adev->sink_gain[OUTPORT_A2DP] = 1.0;
 
     adev->useSubMix = false;
 #ifdef SUBMIXER_V1_1
@@ -11535,11 +12886,14 @@ static int adev_open(const hw_module_t* module, const char* name, hw_device_t**
 
     if (adev->useSubMix) {
         ret = initHalSubMixing(&adev->sm, MIXER_LPCM, adev, adev->is_TV);
+        if (ret < 0) {
+            ALOGE("%s: initHalSubMixing err ret %d", __func__, ret);
+        }
         adev->tsync_fd = aml_hwsync_open_tsync();
         if (adev->tsync_fd < 0) {
             ALOGE("%s() open tsync failed", __func__);
         }
-        adev->rawtopcm_flag = false;
+        adev->raw_to_pcm_flag = false;
     }
 
 #ifdef ENABLE_NOISE_GATE
@@ -11558,10 +12912,14 @@ static int adev_open(const hw_module_t* module, const char* name, hw_device_t**
         goto err_ringbuf;
     }
 
+#ifdef PDM_MIC_CHANNELS
+    init_mic_desc(adev);
+#endif
     // adev->debug_flag is set in hw_write()
     // however, sometimes function didn't goto hw_write() before encounting error.
     // set debug_flag here to see more debug log when debugging.
     adev->debug_flag = aml_audio_get_debug_flag();
+    adev->count = 1;
     ALOGD("%s: exit", __func__);
     return 0;
 
diff --git a/audio_hal/audio_hw.h b/audio_hal/audio_hw.h
index 6c1e7ba..91c215f 100644
--- a/audio_hal/audio_hw.h
+++ b/audio_hal/audio_hw.h
@@ -53,6 +53,19 @@
 #ifdef ADD_AUDIO_DELAY_INTERFACE
 #include "aml_audio_delay.h"
 #endif
+
+#ifndef PCM_STATE_SETUP
+#define PCM_STATE_SETUP 1
+#endif
+
+#ifndef PCM_STATE_PREPARED
+#define PCM_STATE_PREPARED 2
+#endif
+
+#ifndef PCM_NONBLOCK
+#define PCM_NONBLOCK 0x00000010
+#endif
+
 /* number of frames per period */
 /*
  * change DEFAULT_PERIOD_SIZE from 1024 to 512 for passing CTS
@@ -104,23 +117,34 @@ static unsigned int DEFAULT_OUT_SAMPLING_RATE = 48000;
 
 #define DDP_FRAME_SIZE      768
 #define EAC3_MULTIPLIER 4
-#define MAT_MULTIPLIER  16
 #define MAX(a,b) (((a) > (b)) ? (a) : (b))
 #define MIN(a,b) (((a) < (b)) ? (a) : (b))
 
 #define SYS_NODE_EARC_RX           "/sys/class/extcon/earcrx/state"
 #define SYS_NODE_EARC_TX           "/sys/class/extcon/earctx/state"
 
+#define MS12_DAP_TUNING_PATH       "/vendor/etc/ms12_tuning.dat"
+
 #define IS_HDMI_IN_HW(device) ((device) == AUDIO_DEVICE_IN_HDMI ||\
                              (device) == AUDIO_DEVICE_IN_HDMI_ARC)
 
 #define IS_HDMI_ARC_OUT_HW(device) ((access(SYS_NODE_EARC_TX, F_OK) == 0) &&\
                 (device & AUDIO_DEVICE_OUT_HDMI_ARC))
 
+#define MAT_MULTIPLIER 16
+
 #define SUPPORT_EARC_OUT_HW (access(SYS_NODE_EARC_TX, F_OK) == 0)
+#define JITTER_DURATION_MS  6
 
-enum {
+#define MS12_DECODER_LATENCY 32
+#define MS12_ENCODER_LATENCY 32
+#define MS12_DAP_LATENCY 40
+#define MS12_PIPELINE_LATENCY 6
+
+/*the same as "AUDIO HAL FORMAT" in kernel*/
+enum audio_hal_format {
     TYPE_PCM = 0,
+    TYPE_DTS_EXPRESS = 1,
     TYPE_AC3 = 2,
     TYPE_DTS = 3,
     TYPE_EAC3 = 4,
@@ -129,7 +153,12 @@ enum {
     TYPE_TRUE_HD = 7,
     TYPE_DTS_HD_MA = 8,//should not used after we unify DTS-HD&DTS-HD MA
     TYPE_PCM_HIGH_SR = 9,
-    TYPE_AC4 = 10
+    TYPE_AC4 = 10,
+    TYPE_MAT = 11,
+    TYPE_DDP_ATMOS = 12,
+    TYPE_TRUE_HD_ATMOS = 13,
+    TYPE_MAT_ATMOS = 14,
+    TYPE_AC4_ATMOS = 15,
 };
 
 #define FRAMESIZE_16BIT_STEREO 4
@@ -150,6 +179,12 @@ enum Result {
 
 #define AML_HAL_MIXER_BUF_SIZE  64*1024
 
+/* each MS12 callback for ALSA output is for 256 samples ~5ms for 48k
+ * 30 times -> 150ms latency for initial draining
+ */
+#define PATCH_INIT_FLUSH_CNT       30
+#define PATCH_STOP_FLUSH_THRESHOLD 4096
+
 #define SYSTEM_APP_SOUND_MIXING_ON 1
 #define SYSTEM_APP_SOUND_MIXING_OFF 0
 struct aml_hal_mixer {
@@ -194,7 +229,10 @@ struct format_desc {
 };
 
 struct aml_arc_hdmi_desc {
+    int EDID_length;
     unsigned int avr_port;
+    char SAD[38]; /* 3 bytes for each audio format, max 30 bytes for audio edid, 8 bytes for TLV header */
+    bool default_edid;
     struct format_desc pcm_fmt;
     struct format_desc dts_fmt;
     struct format_desc dtshd_fmt;
@@ -247,7 +285,8 @@ enum OUT_PORT {
     OUTPORT_REMOTE_SUBMIX       = 6,
     OUTPORT_BT_SCO              = 7,
     OUTPORT_BT_SCO_HEADSET      = 8,
-    OUTPORT_MAX                 = 9,
+    OUTPORT_A2DP                = 9,
+    OUTPORT_MAX                 = 10,
 };
 
 enum IN_PORT {
@@ -269,15 +308,15 @@ struct audio_patch_set {
 };
 
 typedef enum stream_usecase {
-    STREAM_PCM_NORMAL = 0,
-    STREAM_PCM_DIRECT,
-    STREAM_PCM_HWSYNC,
-    STREAM_RAW_DIRECT,
-    STREAM_RAW_HWSYNC,
-    STREAM_PCM_PATCH,
-    STREAM_RAW_PATCH,
-    STREAM_USECASE_MAX,
-    STREAM_USECASE_INVAL = -1
+    STREAM_PCM_NORMAL       = 0,
+    STREAM_PCM_DIRECT       = 1,
+    STREAM_PCM_HWSYNC       = 2,
+    STREAM_RAW_DIRECT       = 3,
+    STREAM_RAW_HWSYNC       = 4,
+    STREAM_PCM_PATCH        = 5,
+    STREAM_RAW_PATCH        = 6,
+    STREAM_PCM_MMAP         = 7,
+    STREAM_USECASE_MAX      = 8,
 } stream_usecase_t;
 
 typedef enum alsa_device {
@@ -316,7 +355,7 @@ typedef union {
 } aec_timestamp;
 
 struct aml_audio_mixer;
-const char *usecase_to_str(stream_usecase_t usecase);
+const char* usecase2Str(stream_usecase_t enUsecase);
 const char* outport2String(enum OUT_PORT enOutPort);
 const char* inport2String(enum IN_PORT enInPort);
 
@@ -331,6 +370,18 @@ struct aml_bt_output {
     size_t resampler_buffer_size_in_frames;
     size_t resampler_in_frames;
 };
+
+enum mic_in_dev {
+    DEV_MIC_PDM = 0,
+    DEV_MIC_TDM,
+    DEV_MIC_CNT
+};
+
+struct mic_in_desc {
+    enum mic_in_dev mic;
+    struct pcm_config config;
+};
+
 #define MAX_STREAM_NUM   5
 #define HDMI_ARC_MAX_FORMAT  20
 struct aml_audio_device {
@@ -365,9 +416,9 @@ struct aml_audio_device {
     unsigned hdmi_arc_ad[HDMI_ARC_MAX_FORMAT];
     bool hi_pcm_mode;
     bool audio_patching;
+    bool atv_switch;
     /* audio configuration for dolby HDMI/SPDIF output */
     int hdmi_format;
-    int spdif_format;
     int hdmi_is_pth_active;
     int disable_pcm_mixing;
     /* mute/unmute for vchip  lock control */
@@ -376,6 +427,7 @@ struct aml_audio_device {
     struct audio_config output_config;
     struct aml_arc_hdmi_desc hdmi_descs;
     int arc_hdmi_updated;
+    int a2dp_updated;
     struct aml_native_postprocess native_postprocess;
     /* to classify audio patch sources */
     enum patch_src_assortion patch_src;
@@ -460,8 +512,12 @@ struct aml_audio_device {
     size_t frame_trigger_thred;
     struct aml_audio_parser *aml_parser;
     int continuous_audio_mode;
+    int continuous_audio_mode_default;
+    int delay_disable_continuous;
     bool atoms_lock_flag;
     bool need_remove_conti_mode;
+    int  exiting_ms12;
+    struct timespec ms12_exiting_start;
     int debug_flag;
     int dcvlib_bypass_enable;
     int dtslib_bypass_enable;
@@ -491,7 +547,8 @@ struct aml_audio_device {
     bool useSubMix;
     //int cnt_stream_using_mixer;
     int tsync_fd;
-    bool rawtopcm_flag;
+    bool raw_to_pcm_flag;
+    bool is_netflix;
     int dtv_aformat;
     unsigned int dtv_i2s_clock;
     unsigned int dtv_spidif_clock;
@@ -503,8 +560,37 @@ struct aml_audio_device {
     int reset_dtv_audio;
     int patch_start;
     int mute_start;
+    int timer_in_ms;
     aml_audio_ease_t  *audio_ease;
     int sound_track_mode;
+
+    /* MIC_IN<->PDM/TDM and default configs */
+    struct mic_in_desc *mic_desc;
+    bool virtualx_mulch;
+    int effect_in_ch;
+    /*
+    for karaoke use case, the apk will acess
+    the sound card device directly.the apk will
+    send the direct mode flag to audio hal. the audio
+    hal need by-pass hw acess until the apk release flag
+    */
+    unsigned int direct_mode;
+    /*three variable used for when audio discontinue and underrun,
+      whether mute output*/
+    int discontinue_mute_flag;
+    int audio_discontinue;
+    int no_underrun_count;
+    int no_underrun_max;
+    int count;/*record the number of adev_open calls*/
+    /* display audio format on UI, both streaming and hdmiin*/
+    audio_format_t hal_internal_format;
+    bool is_dolby_atmos;
+    int update_type;
+    uint64_t  sys_audio_frame_written;
+    audio_format_t spdif_out_format;
+    uint32_t       spdif_out_rate;
+    int   dap_bypass_enable;
+    float dap_bypassgain;
 };
 
 struct meta_data {
@@ -531,11 +617,13 @@ struct aml_stream_out {
     audio_format_t hal_format;
     /* samplerate exposed to AudioFlinger. */
     unsigned int hal_rate;
+    /* channel number for every output stream */
     unsigned int hal_ch;
     /* frame size for every output stream */
     unsigned int hal_frame_size;
     audio_output_flags_t flags;
     audio_devices_t out_device;
+    struct a2dp_stream_out *a2dp_out;
     struct pcm *pcm;
     struct pcm *earc_pcm;
     struct resampler_itfe *resampler;
@@ -558,6 +646,7 @@ struct aml_stream_out {
     void *audioeffect_tmp_buffer;
     bool pause_status;
     bool hw_sync_mode;
+    int  tsync_status;
     float volume_l;
     float volume_r;
     int last_codec_type;
@@ -596,10 +685,10 @@ struct aml_stream_out {
     int dropped_size;
     unsigned long long mute_bytes;
     bool is_get_mute_bytes;
-    size_t frame_deficiency;
+    int frame_deficiency;
     bool normal_pcm_mixing_config;
     uint32_t latency_frames;
-    enum MIXER_INPUT_PORT port_index;
+    aml_mixer_input_port_type_e enInputPortType;
     int exiting;
     pthread_mutex_t cond_lock;
     pthread_cond_t cond;
@@ -614,7 +703,18 @@ struct aml_stream_out {
     bool need_convert;
     size_t last_playload_used;
     void * alsa_vir_buf_handle;
+    void    *pstMmapAudioParam;    // aml_mmap_audio_param_st (aml_mmap_audio.h)
     aml_audio_resample_t *resample_handle;
+    int need_drop_size;
+    bool bypass_submix;
+    int ddp_frame_nblks;
+    uint64_t total_ddp_frame_nblks;
+    int framevalid_flag;
+    bool restore_continuous;
+    uint64_t  last_frame_reported;
+    struct timespec  last_timestamp_reported;
+    bool continuous_mode_check;
+    void * ac4_parser_handle;
 };
 
 typedef ssize_t (*write_func)(struct audio_stream_out *stream, const void *buffer, size_t bytes);
@@ -684,11 +784,11 @@ inline struct pcm_config update_earc_out_config(struct pcm_config *config)
     return earc_config;
 }
 
-static inline int continous_mode(struct aml_audio_device *adev)
+inline int continous_mode(struct aml_audio_device *adev)
 {
     return adev->continuous_audio_mode;
 }
-static inline bool direct_continous(struct audio_stream_out *stream)
+inline bool direct_continous(struct audio_stream_out *stream)
 {
     struct aml_stream_out *out = (struct aml_stream_out *)stream;
     struct aml_audio_device *adev = out->dev;
@@ -698,7 +798,7 @@ static inline bool direct_continous(struct audio_stream_out *stream)
         return false;
     }
 }
-static inline bool primary_continous(struct audio_stream_out *stream)
+inline bool primary_continous(struct audio_stream_out *stream)
 {
     struct aml_stream_out *out = (struct aml_stream_out *)stream;
     struct aml_audio_device *adev = out->dev;
@@ -709,16 +809,18 @@ static inline bool primary_continous(struct audio_stream_out *stream)
     }
 }
 /* called when adev locked */
-static inline int dolby_stream_active(struct aml_audio_device *adev)
+inline int dolby_stream_active(struct aml_audio_device *adev)
 {
     int i = 0;
     int is_dolby = 0;
     struct aml_stream_out *out = NULL;
     for (i = 0 ; i < STREAM_USECASE_MAX; i++) {
         out = adev->active_outputs[i];
-        if (out && (out->hal_internal_format == AUDIO_FORMAT_AC3 ||
-                    out->hal_internal_format == AUDIO_FORMAT_E_AC3 ||
-                    out->hal_internal_format == AUDIO_FORMAT_MAT)) {
+        if (out && (out->hal_internal_format == AUDIO_FORMAT_AC3
+            || out->hal_internal_format == AUDIO_FORMAT_E_AC3
+            || out->hal_internal_format == AUDIO_FORMAT_DOLBY_TRUEHD
+            || out->hal_internal_format == AUDIO_FORMAT_AC4
+            || out->hal_internal_format == AUDIO_FORMAT_MAT)) {
             is_dolby = 1;
             break;
         }
@@ -741,7 +843,7 @@ static inline int hwsync_lpcm_active(struct aml_audio_device *adev)
     return is_hwsync_lpcm;
 }
 
-static inline struct aml_stream_out *direct_active(struct aml_audio_device *adev)
+inline struct aml_stream_out *direct_active(struct aml_audio_device *adev)
 {
     int i = 0;
     struct aml_stream_out *out = NULL;
@@ -759,8 +861,6 @@ static inline struct aml_stream_out *direct_active(struct aml_audio_device *adev
 audio_format_t get_output_format(struct audio_stream_out *stream);
 void *audio_patch_output_threadloop(void *data);
 
-ssize_t aml_audio_spdif_output(struct audio_stream_out *stream,
-                               void *buffer, size_t bytes);
 
 /*
  *@brief audio_hal_data_processing
@@ -819,4 +919,8 @@ int release_patch_l(struct aml_audio_device *adev);
 int start_ease_in(struct aml_audio_device *adev);
 int start_ease_out(struct aml_audio_device *adev);
 
+enum hwsync_status check_hwsync_status (uint apts_gap);
+void config_output(struct audio_stream_out *stream,bool reset_decoder);
+bool is_bypass_dolbyms12(struct audio_stream_out *stream);
+
 #endif
diff --git a/audio_hal/audio_hw_dtv.c b/audio_hal/audio_hw_dtv.c
index 5b6c9be..6a8b1ea 100644
--- a/audio_hal/audio_hw_dtv.c
+++ b/audio_hal/audio_hw_dtv.c
@@ -30,7 +30,6 @@
 #include <pthread.h>
 #include <stdint.h>
 #include <stdlib.h>
-#include <string.h>
 #include <sys/prctl.h>
 #include <sys/stat.h>
 #include <sys/time.h>
@@ -67,15 +66,23 @@
 #define TSYNC_EVENT "/sys/class/tsync/event"
 #define TSYNC_APTS "/sys/class/tsync/pts_audio"
 #define TSYNC_VPTS "/sys/class/tsync/pts_video"
+#define TSYNC_DEMUX_APTS "/sys/class/stb/audio_pts"
+#define TSYNC_DEMUX_VPTS "/sys/class/stb/video_pts"
 
 #define TSYNC_FIRST_VPTS "/sys/class/tsync/firstvpts"
 #define TSYNC_AUDIO_MODE "/sys/class/tsync_pcr/tsync_audio_mode"
 #define TSYNC_AUDIO_LEVEL "/sys/class/tsync_pcr/tsync_audio_level"
 #define TSYNC_LAST_CHECKIN_APTS "/sys/class/tsync_pcr/tsync_last_discontinue_checkin_apts"
+#define TSYNC_CHECKIN_APTS "/sys/class/tsync_pcr/tsync_checkin_apts"
+#define TSYNC_CHECKIN_VPTS "/sys/class/tsync_pcr/tsync_checkin_vpts"
+#define TSYNC_CHECKIN_AOFFSET "/sys/class/tsync_pcr/tsync_checkin_aoffset"
+#define TSYNC_VIDEO_STATE "/sys/class/tsync_pcr/tsync_video_state"
+#define TSYNC_AUDIO_STATE "/sys/class/tsync_pcr/tsync_audio_state"
 #define TSYNC_PCR_DEBUG "/sys/class/tsync_pcr/tsync_pcr_debug"
 #define TSYNC_APTS_DIFF "/sys/class/tsync_pcr/tsync_pcr_apts_diff"
 #define TSYNC_VPTS_ADJ "/sys/class/tsync_pcr/tsync_vpts_adjust"
 #define TSYNC_PCR_MODE "/sys/class/tsync_pcr/tsync_pcr_mode"
+#define TSYNC_PCR_INITED_MODE "/sys/class/tsync_pcr/tsync_pcr_inited_mode"
 #define TSYNC_FIRSTCHECKIN_APTS "/sys/class/tsync/checkin_firstapts"
 #define TSYNC_DEMUX_PCR         "/sys/class/tsync/demux_pcr"
 #define TSYNC_LASTCHECKIN_APTS "/sys/class/tsync/last_checkin_apts"
@@ -89,8 +96,12 @@
 #define AC3_IEC61937_FRAME_SIZE 6144
 #define EAC3_IEC61937_FRAME_SIZE 24576
 #define DECODER_PTS_DEFAULT_LATENCY (200 * 90)
-#define DECODER_PTS_MAX_LATENCY (320 * 90)
+#define DECODER_PTS_MAX_LATENCY (500 * 90)
 #define DEMUX_PCR_APTS_LATENCY (300 * 90)
+#define DEMUX_PCR_VPTS_LATENCY (500 * 90)
+#define LOOKUP_AC3_MIN_BYTES (512 * 3 * 6)
+#define LOOKUP_MPEG_MIN_BYTES (48 * 4 * 200)
+#define DTV_FADED_OUT_MS (50)
 #define DEFAULT_ARC_DELAY_MS (100)
 #define PCM 0  /*AUDIO_FORMAT_PCM_16_BIT*/
 #define DD 4   /*AUDIO_FORMAT_AC3*/
@@ -108,6 +119,13 @@
 #define DTV_DECODER_CHECKIN_FIRSTAPTS_PATH "/sys/class/tsync/checkin_firstapts"
 #define DTV_DECODER_TSYNC_MODE      "/sys/class/tsync/mode"
 #define PROPERTY_LOCAL_ARC_LATENCY   "media.amnuplayer.audio.delayus"
+#define PROPERTY_DTV_SPEAKER_LATENCY   "media.dtv.speaker.delayus"
+#define PROPERTY_DTV_RESAMPLE_DISABLE   "media.dtv.resample.disable"
+#define PROPERTY_LOCAL_PASSTHROUGH_LATENCY  "media.dtv.passthrough.latencyms"
+#define AUDIO_EAC3_FRAME_SIZE 16
+#define AUDIO_AC3_FRAME_SIZE 4
+#define AUDIO_TV_PCM_FRAME_SIZE 32
+#define AUDIO_DEFAULT_PCM_FRAME_SIZE 4
 
 //pthread_mutex_t dtv_patch_mutex = PTHREAD_MUTEX_INITIALIZER;
 pthread_mutex_t dtv_cmd_mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -145,6 +163,11 @@ enum {
     AUDIO_LATENCY,
     AUDIO_RUNNING,
 };
+enum tsync_mode_e {
+    TSYNC_MODE_VMASTER,
+    TSYNC_MODE_AMASTER,
+    TSYNC_MODE_PCRMASTER,
+};
 
 const unsigned int mute_dd_frame[] = {
     0x5d9c770b, 0xf0432014, 0xf3010713, 0x2020dc62, 0x4842020, 0x57100404, 0xf97c3e1f, 0x9fcfe7f3, 0xf3f97c3e, 0x3e9fcfe7, 0xe7f3f97c, 0x7c3e9fcf, 0xcfe7f3f9, 0xfb7c3e9f, 0xf97c75fe, 0x9fcfe7f3,
@@ -178,10 +201,28 @@ const unsigned int mute_ddp_frame[] = {
 
 static int create_dtv_output_stream_thread(struct aml_audio_patch *patch);
 static int release_dtv_output_stream_thread(struct aml_audio_patch *patch);
+static int dtv_get_ac3_frame_size(struct aml_audio_patch *patch, int main_avail);
 extern int calc_time_interval_us(struct timespec *ts0, struct timespec *ts1);
-extern size_t aml_alsa_output_write(struct audio_stream_out *stream, void *buffer, size_t bytes);
 struct cmd_list cmd_array[16]; // max cache 16 cmd;
 
+static int sysfs_get_systemfs_str(const char *path, char *val, int len)
+{
+    int fd;
+    int bytes;
+    fd = open(path, O_RDONLY);
+    if (fd >= 0) {
+        memset(val, 0, len);
+        bytes = read(fd, val, len);
+        close(fd);
+        if (bytes > 0) {
+            return 0;
+        }
+    } else {
+        ALOGE("unable to open file %s,err: %s", path, strerror(errno));
+    }
+    return -1;
+}
+
 static unsigned long decoder_apts_lookup(unsigned int offset)
 {
     unsigned int pts = 0;
@@ -251,11 +292,24 @@ static unsigned int decoder_get_latency(void)
     return (unsigned int)latency;
 }
 
+static void decoder_stop_audio(struct aml_audio_patch *patch)
+{
+    char buff[64];
+    if (patch == NULL ||
+        patch->tsync_mode == TSYNC_MODE_PCRMASTER) {
+        return;
+    }
+    sprintf(buff, "AUDIO_STOP");
+    if (sysfs_set_sysfs_str(TSYNC_EVENT, buff) == -1) {
+        ALOGE("set AUDIO_STOP failed \n");
+    }
+}
+
 static void decoder_set_pcrsrc(unsigned int pcrsrc)
 {
     char tempbuf[128];
     memset(tempbuf, 0, 128);
-    sprintf(tempbuf, "%x", pcrsrc);
+    sprintf(tempbuf, "%d", pcrsrc);
     if (aml_sysfs_set_str(TSYNC_PCRSCR, tempbuf) == -1) {
         ALOGE("set pcr lantcy failed %s\n", tempbuf);
     }
@@ -313,6 +367,92 @@ static int get_tsync_pcr_debug(void)
     return debug;
 }
 
+static unsigned int get_tsync_checkin_pts(int type)
+{
+    int ret = 0;
+    unsigned int pts = 0;
+    char buff[32];
+    if (type == 0) {
+        ret = aml_sysfs_get_str(TSYNC_CHECKIN_VPTS, buff, sizeof(buff));
+    } else if (type == 1) {
+        ret = aml_sysfs_get_str(TSYNC_CHECKIN_APTS, buff, sizeof(buff));
+    } else {
+        pts = 0;
+    }
+    if (ret > 0) {
+        ret = sscanf(buff, "0x%x\n", &pts);
+    }
+    return pts;
+}
+
+static unsigned int get_tsync_checkin_firstaoffset(void)
+{
+    int ret = 0;
+    unsigned int offset = 0;
+    char buff[32];
+    ret = aml_sysfs_get_str(TSYNC_CHECKIN_AOFFSET, buff, sizeof(buff));
+    if (ret > 0) {
+        ret = sscanf(buff, "0x%x\n", &offset);
+    }
+    return offset;
+}
+
+static int get_tsync_pcr_inited(void)
+{
+    int ret, mode = 0;
+    char buff[64];
+    ret = aml_sysfs_get_str(TSYNC_PCR_INITED_MODE, buff, sizeof(buff));
+    if (ret > 0) {
+        ret = sscanf(buff, "%d", &mode);
+    }
+    if (mode == 0) {
+        return 1;
+    }
+    return 0;
+}
+
+static int get_tsync_video_state(void)
+{
+    int ret = 0;
+    int state = 2;
+    char buff[32];
+    ret = aml_sysfs_get_str(TSYNC_VIDEO_STATE, buff, sizeof(buff));
+    if (ret > 0) {
+        ret = sscanf(buff, "%d\n", &state);
+    }
+    return state;
+}
+
+static int get_tsync_audio_state(void)
+{
+    int ret = 0;
+    int state = 2;
+    char buff[32];
+    ret = aml_sysfs_get_str(TSYNC_AUDIO_STATE, buff, sizeof(buff));
+    if (ret > 0) {
+        ret = sscanf(buff, "%d\n", &state);
+    }
+    return state;
+}
+
+static uint get_vsync_cached_pts(struct aml_audio_patch *patch, struct aml_audio_device *aml_dev, uint pcrpts)
+{
+    uint checkin_vpts;
+    if (!patch || !aml_dev) {
+        return 0;
+    }
+    if (patch->dtv_pcr_mode) {
+        return 0;
+    }
+    checkin_vpts = get_tsync_checkin_pts(0);
+    if (checkin_vpts && checkin_vpts != 0xffffffff) {
+        if (checkin_vpts > pcrpts) {
+            return checkin_vpts - pcrpts;
+        }
+    }
+    return 0;
+}
+
 static int get_video_delay(void)
 {
     char tempbuf[128];
@@ -352,10 +492,13 @@ static void clean_dtv_patch_pts(struct aml_audio_patch *patch)
     }
 }
 
-static int get_audio_discontinue(void)
+static int get_audio_discontinue(struct aml_audio_patch *patch)
 {
     char tempbuf[128];
     int a_discontinue = 0, ret;
+    if (patch->tsync_mode != TSYNC_MODE_PCRMASTER) {
+        return a_discontinue;
+    }
     ret = aml_sysfs_get_str(TSYNC_AUDIO_LEVEL, tempbuf, sizeof(tempbuf));
     if (ret > 0) {
         ret = sscanf(tempbuf, "%d\n", &a_discontinue);
@@ -370,21 +513,25 @@ static int get_audio_discontinue(void)
 
 static void init_cmd_list(void)
 {
+    pthread_mutex_lock(&dtv_cmd_mutex);
     dtv_cmd_list.next = NULL;
     dtv_cmd_list.cmd = -1;
     dtv_cmd_list.cmd_num = 0;
     dtv_cmd_list.used = 0;
     dtv_cmd_list.initd = 1;
     memset(cmd_array, 0, sizeof(cmd_array));
+    pthread_mutex_unlock(&dtv_cmd_mutex);
 }
 
 static void deinit_cmd_list(void)
 {
+    pthread_mutex_lock(&dtv_cmd_mutex);
     dtv_cmd_list.next = NULL;
     dtv_cmd_list.cmd = -1;
     dtv_cmd_list.cmd_num = 0;
     dtv_cmd_list.used = 0;
     dtv_cmd_list.initd = 0;
+    pthread_mutex_unlock(&dtv_cmd_mutex);
 }
 
 static struct cmd_list *cmd_array_get(void)
@@ -427,22 +574,39 @@ static void _add_cmd_to_tail(struct cmd_list *node)
 int dtv_patch_add_cmd(int cmd)
 {
     struct cmd_list *list = NULL;
-
+    struct cmd_list *cmd_list = NULL;
+    int index = 0;
     if (dtv_cmd_list.initd == 0) {
         return 0;
     }
-
-    list = cmd_array_get();
-    if (list == NULL) {
+    pthread_mutex_lock(&dtv_cmd_mutex);
+    for (index = 0; index < 16; index++) {
+        if (cmd_array[index].used == 0) {
+            break;
+        }
+    }
+    if (index == 16) {
+        pthread_mutex_unlock(&dtv_cmd_mutex);
+        ALOGI("list is full, add by live \n");
+        return -1;
+    }
+    cmd_list = &cmd_array[index];
+    /*if (cmd_list == NULL) {
+        pthread_mutex_unlock(&dtv_cmd_mutex);
         ALOGI("can't get cmd list, add by live \n");
         return -1;
+    }*/
+    cmd_list->cmd = cmd;
+    cmd_list->next = NULL;
+    cmd_list->used = 1;
+    list = &dtv_cmd_list;
+    while (list->next != NULL) {
+        list = list->next;
     }
+    list->next = cmd_list;
+    dtv_cmd_list.cmd_num++;
+    pthread_mutex_unlock(&dtv_cmd_mutex);
     ALOGI("add by live dtv_patch_add_cmd the cmd is %d \n", cmd);
-    list->cmd = cmd;
-    list->next = NULL;
-    list->used = 1;
-
-    _add_cmd_to_tail(list);
     return 0;
 }
 
@@ -462,8 +626,8 @@ int dtv_patch_get_cmd(void)
         pthread_mutex_unlock(&dtv_cmd_mutex);
         return cmd;
     }
+    list->used = 0;
     pthread_mutex_unlock(&dtv_cmd_mutex);
-    cmd_array_put(list);
     ALOGI("leave dtv_patch_get_cmd the cmd is %d \n", cmd);
     return cmd;
 }
@@ -477,16 +641,21 @@ int dtv_patch_cmd_is_empty(void)
     pthread_mutex_unlock(&dtv_cmd_mutex);
     return 0;
 }
-static int dtv_patch_buffer_space(void *args)
+
+static int dtv_patch_buffer_info(void *args, BUFFER_INFO_E info_flag)
 {
     int left = 0;
     struct aml_audio_patch *patch = (struct aml_audio_patch *)args;
     ring_buffer_t *ringbuffer = &(patch->aml_ringbuffer);
-    left = get_buffer_write_space(ringbuffer);
+    if (info_flag == BUFFER_SPACE) {
+        left = get_buffer_write_space(ringbuffer);
+    } else if (info_flag == BUFFER_LEVEL) {
+        left = get_buffer_read_space(ringbuffer);
+    }
     return left;
 }
 
-static int dtv_patch_audio_info(void *args,unsigned char ori_channum,unsigned char lfepresent)
+static int dtv_patch_audio_info(void *args, unsigned char ori_channum, unsigned char lfepresent)
 {
     struct aml_audio_patch *patch = (struct aml_audio_patch *)args;
     patch->dtv_NchOriginal = ori_channum;
@@ -512,19 +681,30 @@ unsigned long dtv_hal_get_pts(struct aml_audio_patch *patch,
     offset = patch->decoder_offset;
 
     // when first  look up apts,set offset 0
-    if (!patch->first_apts_lookup_over) {
+    if (patch->dtv_first_apts_flag == 0) {
+        int fm_size, avail;
+        avail = get_buffer_read_space(&(patch->aml_ringbuffer));
+        fm_size = dtv_get_ac3_frame_size(patch, avail);
+        offset = get_tsync_checkin_firstaoffset();
+        /* add offset for lookup */
+        if (fm_size > 0 && (int)offset > 0) {
+            if ((int)offset > fm_size) {
+                offset &= (fm_size - 1);
+            }
+            offset = fm_size - offset;
+            patch->decoder_offset += offset;
+        }
         offset = 0;
     }
     offset = decoder_apts_lookup(offset);
 
     pts = offset;
-    if (!patch->first_apts_lookup_over) {
+    if (patch->dtv_first_apts_flag == 0) {
         if (pts == 0) {
             pts = decoder_checkin_firstapts();
             ALOGI("pts = 0,so get checkin_firstapts:0x%lx", pts);
         }
         patch->last_valid_pts = pts;
-        patch->first_apts_lookup_over = 1;
         return pts;
     }
 
@@ -539,12 +719,16 @@ unsigned long dtv_hal_get_pts(struct aml_audio_patch *patch,
         //       patch->last_valid_pts);
         return 0;
     }
-    patch->last_valid_pts = pts;
-    val = pts - lantcy * 90;
-
+    if (pts > lantcy * 90) {
+        val = pts - lantcy * 90;
+    } else {
+        val = 0;
+    }
+    /*+[SE][BUG][SWPL-14811][zhizhong] set the real apts to last_valid_pts for sum cal*/
+    patch->last_valid_pts = val;
     patch->outlen_after_last_validpts = 0;
-    // ALOGI("====get pts:%lx offset:%d lan %d \n", val, patch->decoder_offset,
-    //       lantcy);
+    // ALOGI("====get pts:%lx offset:%d lan %d origin_apts:%lx\n",
+    // val, patch->decoder_offset, lantcy, pts);
     return val;
 }
 
@@ -565,10 +749,28 @@ static void dtv_do_ease_out(struct aml_audio_device *aml_dev)
     if (aml_dev && aml_dev->audio_ease) {
         ALOGI("%s(), do fade out", __func__);
         start_ease_out(aml_dev);
-        usleep(200 * 1000);
+        //usleep(200 * 1000);
     }
 }
 
+static int dtv_get_tsync_mode(void)
+{
+    char tsync_mode_str[12];
+    int tsync_mode = TSYNC_MODE_PCRMASTER;
+    char buf[64];
+    if (sysfs_get_systemfs_str(DTV_DECODER_TSYNC_MODE, buf, sizeof(buf)) == -1) {
+        ALOGI("dtv_get_tsync_mode error");
+        return tsync_mode;
+    }
+    if (sscanf(buf, "%d: %s", &tsync_mode, tsync_mode_str) < 1) {
+        ALOGI("dtv_get_tsync_mode error.");
+        return tsync_mode;
+    }
+    if (tsync_mode > TSYNC_MODE_PCRMASTER || tsync_mode < TSYNC_MODE_VMASTER) {
+        tsync_mode = TSYNC_MODE_PCRMASTER;
+    }
+    return tsync_mode;
+}
 static unsigned int compare_clock(unsigned int clock1, unsigned int clock2)
 {
     if (clock1 == clock2) {
@@ -752,6 +954,9 @@ static void dtv_adjust_output_clock(struct aml_audio_patch * patch, int direct,
     if (!aml_dev || step <= 0) {
         return;
     }
+    if (aml_getprop_int(PROPERTY_DTV_RESAMPLE_DISABLE) == 1) {
+        return;
+    }
     if (patch->decoder_offset < 512 * 2 * 10 &&
         ((patch->aformat == AUDIO_FORMAT_AC3) ||
          (patch->aformat == AUDIO_FORMAT_E_AC3))) {
@@ -785,34 +990,22 @@ static unsigned int dtv_calc_pcrpts_latency(struct aml_audio_patch *patch, unsig
     struct audio_hw_device *adev = patch->dev;
     struct aml_audio_device *aml_dev = (struct aml_audio_device *) adev;
     if (aml_dev->bHDMIARCon == 0 || aml_dev->hdmi_format == PCM) {
+        int delay = aml_getprop_int(PROPERTY_DTV_SPEAKER_LATENCY) / 1000;
+        if (delay) {
+            if (get_video_delay() != -delay) {
+                ALOGI("speaker delay from %d ms to %d ms", get_video_delay(), -delay);
+                set_video_delay(-delay);
+            }
+        }
         return pcrpts;
     } else {
-        return pcrpts + DEFAULT_ARC_DELAY_MS * 90;
-    }
-    if (aml_dev->bHDMIARCon && aml_dev->hdmi_format == PCM) {
-        if (patch->aformat == AUDIO_FORMAT_E_AC3) {
-            pcrpts += 2 * DTV_PTS_CORRECTION_THRESHOLD;
-        } else {
-            pcrpts + DTV_PTS_CORRECTION_THRESHOLD;
-        }
-    } else if (eDolbyMS12Lib == aml_dev->dolby_lib_type && aml_dev->bHDMIARCon) {
-        if (patch->aformat == AUDIO_FORMAT_E_AC3 && !aml_dev->disable_pcm_mixing) {
-            pcrpts += 8 * DTV_PTS_CORRECTION_THRESHOLD;
-        } else if (patch->aformat == AUDIO_FORMAT_E_AC3 && aml_dev->disable_pcm_mixing) {
-            pcrpts += 6 * DTV_PTS_CORRECTION_THRESHOLD;
-        } else {
+        /* for arc output, there were any little lantency */
+        if ((aml_dev->hdmi_format != PCM) &&
+            !aml_dev->disable_pcm_mixing && patch->aformat == AUDIO_FORMAT_E_AC3) {
             pcrpts += 3 * DTV_PTS_CORRECTION_THRESHOLD;
         }
-    } else if (eDolbyDcvLib == aml_dev->dolby_lib_type && aml_dev->bHDMIARCon) {
-        if (patch->aformat == AUDIO_FORMAT_E_AC3) {
-            pcrpts += 4 * DTV_PTS_CORRECTION_THRESHOLD;
-        } else {
-            pcrpts += DTV_PTS_CORRECTION_THRESHOLD;
-        }
-    } else {
-        pcrpts += DTV_PTS_CORRECTION_THRESHOLD;
+        return pcrpts;
     }
-    return pcrpts;
 }
 
 static int dtv_calc_abuf_level(struct aml_audio_patch *patch, struct aml_stream_out *stream_out)
@@ -862,13 +1055,10 @@ static void dtv_check_audio_reset(struct aml_audio_device *aml_dev)
         return;
     }
     //ALOGI("demux_pcr %x first_checkinapts %x,reset %d", demux_pcr, first_checkinapts,aml_dev->reset_dtv_audio);
-    if (demux_pcr > first_checkinapts &&
-        (demux_pcr - first_checkinapts) > AUDIO_PTS_DISCONTINUE_THRESHOLD / 5) {
-        if (aml_dev->reset_dtv_audio) {
-            ALOGI("dtv_audio_reset %d", aml_dev->reset_dtv_audio);
-            aml_sysfs_set_str(AMSTREAM_AUDIO_PORT_RESET, "1");
-            aml_dev->reset_dtv_audio = 0;
-        }
+    if (aml_dev->reset_dtv_audio) {
+        ALOGI("dtv_audio_reset %d", aml_dev->reset_dtv_audio);
+        aml_sysfs_set_str(AMSTREAM_AUDIO_PORT_RESET, "1");
+        aml_dev->reset_dtv_audio = 0;
     }
 }
 
@@ -911,7 +1101,8 @@ static void dtv_set_pcr_latency(struct aml_audio_patch *patch, int mode)
     }
 }
 
-static bool dtv_firstapts_lookup_over(struct aml_audio_patch *patch, struct aml_audio_device *aml_dev, bool a_discontinue)
+static bool dtv_firstapts_lookup_over(struct aml_audio_patch *patch,
+                                      struct aml_audio_device *aml_dev, int avail, bool a_discontinue)
 {
     char buff[32];
     int ret;
@@ -920,6 +1111,7 @@ static bool dtv_firstapts_lookup_over(struct aml_audio_patch *patch, struct aml_
     if (!patch || !aml_dev) {
         return true;
     }
+    patch->tsync_mode = dtv_get_tsync_mode();
     if (a_discontinue) {
         ret = aml_sysfs_get_str(TSYNC_LAST_CHECKIN_APTS, buff, sizeof(buff));
         if (ret > 0) {
@@ -931,14 +1123,46 @@ static bool dtv_firstapts_lookup_over(struct aml_audio_patch *patch, struct aml_
             ret = sscanf(buff, "0x%x\n", &first_checkinapts);
         }
     }
-    ret = aml_sysfs_get_str(TSYNC_PCRSCR, buff, sizeof(buff));
+    if (patch->tsync_mode == TSYNC_MODE_PCRMASTER) {
+        ret = aml_sysfs_get_str(TSYNC_PCRSCR, buff, sizeof(buff));
+    } else {
+        ret = aml_sysfs_get_str(TSYNC_DEMUX_PCR, buff, sizeof(buff));
+    }
     if (ret > 0) {
         ret = sscanf(buff, "0x%x\n", &demux_pcr);
     }
     if (get_tsync_pcr_debug()) {
-        ALOGI("demux_pcr %x first_apts %x, discontinue %d", demux_pcr, first_checkinapts, a_discontinue);
-    }
-    if ((first_checkinapts != 0xffffffff) || (demux_pcr != 0xffffffff)) {
+        ALOGI("demux_pcr %x first_apts %x, avail %d, mode %d",
+              demux_pcr, first_checkinapts, avail, patch->tsync_mode);
+    }
+    if (patch->tsync_mode != TSYNC_MODE_PCRMASTER) {
+        unsigned diff;
+        int buffer_size = 0;
+        if (demux_pcr > 300 * 90 && demux_pcr != 0xffffffff) {
+            demux_pcr = demux_pcr - 300 * 90;
+        } else {
+            demux_pcr = 0;
+        }
+        diff = first_checkinapts - demux_pcr;
+        if ((patch->aformat == AUDIO_FORMAT_AC3) ||
+            (patch->aformat == AUDIO_FORMAT_E_AC3) ||
+            patch->aformat == AUDIO_FORMAT_DTS) {
+            buffer_size = DEFAULT_PLAYBACK_PERIOD_SIZE * PLAYBACK_PERIOD_COUNT * 2;
+        } else {
+            buffer_size = 48 * 4 * (DEMUX_PCR_APTS_LATENCY / 90);
+        }
+        if (first_checkinapts > demux_pcr && demux_pcr) {
+            if (diff < AUDIO_PTS_DISCONTINUE_THRESHOLD) {
+                return false;
+            } else {
+                unsigned diff = demux_pcr - first_checkinapts;
+                aml_dev->dtv_droppcm_size = diff * 48 * 2 * 2 / 90;
+                ALOGI("now must drop size %d\n", aml_dev->dtv_droppcm_size);
+            }
+        } else if (!demux_pcr && avail < buffer_size) {
+            return false;
+        }
+    } else if ((first_checkinapts != 0xffffffff) || (demux_pcr != 0xffffffff)) {
         if (first_checkinapts > demux_pcr) {
             unsigned diff = first_checkinapts - demux_pcr;
             if (diff  < AUDIO_PTS_DISCONTINUE_THRESHOLD) {
@@ -974,26 +1198,31 @@ static int dtv_set_audio_latency(int apts_diff)
     }
     return apts_diff;
 }
-
 static int dtv_write_mute_frame(struct aml_audio_patch *patch,
                                 struct audio_stream_out *stream_out)
 {
-    unsigned char mixbuffer[EAC3_IEC61937_FRAME_SIZE];
+    unsigned char *mixbuffer = NULL;
     uint16_t *p16_mixbuff = NULL;
     int main_size = 0, mix_size = 0;
     int dd_bsmod = 0;
-    int ret;
+    int type = 0;
     struct audio_hw_device *dev = patch->dev;
     struct aml_audio_device *aml_dev = (struct aml_audio_device *)dev;
     struct aml_stream_out *aml_out = (struct aml_stream_out *) stream_out;
+    size_t output_buffer_bytes = 0;
+    void *output_buffer = NULL;
 #if 0
     struct timespec before_read;
     struct timespec after_read;
     int us = 0;
     clock_gettime(CLOCK_MONOTONIC, &before_read);
 #endif
+    mixbuffer = (unsigned char *)calloc(1, EAC3_IEC61937_FRAME_SIZE);
+    if (!mixbuffer) {
+        return -1;
+    }
     //package iec61937
-    memset(mixbuffer, 0, sizeof(mixbuffer));
+    memset(mixbuffer, 0, EAC3_IEC61937_FRAME_SIZE);
     //papbpcpd
     p16_mixbuff = (uint16_t*)mixbuffer;
     p16_mixbuff[0] = 0xf872;
@@ -1016,55 +1245,124 @@ static int dtv_write_mute_frame(struct aml_audio_patch *patch,
     if (aml_out->status != STREAM_HW_WRITING ||
         patch->output_thread_exit == 1) {
         ALOGE("dtv_write_mute_frame exit");
+        free(mixbuffer);
         return -1;
     }
-    pthread_mutex_lock(&aml_dev->alsa_pcm_lock);
-    if (is_dual_output_stream(stream_out)) {
-        memset(mixbuffer, 0, sizeof(mixbuffer));
-        ret = aml_alsa_output_write(stream_out, (void*)mixbuffer, EAC3_IEC61937_FRAME_SIZE);
-        ret = aml_alsa_output_write(stream_out, (void*)mixbuffer, EAC3_IEC61937_FRAME_SIZE);
-        //ALOGI("aml_alsa_output_write pcm");
-    } else if (get_output_format(stream_out) == AUDIO_FORMAT_E_AC3) {
-        ret = aml_alsa_output_write(stream_out, (void*)mixbuffer, EAC3_IEC61937_FRAME_SIZE);
-        //ALOGI("aml_alsa_output_write eac3");
-    } else if (get_output_format(stream_out) == AUDIO_FORMAT_AC3) {
-        ret = aml_alsa_output_write(stream_out, (void*)mixbuffer, AC3_IEC61937_FRAME_SIZE);
-        //ALOGI("aml_alsa_output_write ac3");
+    if (aml_dev->sink_format == AUDIO_FORMAT_PCM_16_BIT) {
+        type = 0;
+    } else if (aml_dev->sink_format != AUDIO_FORMAT_PCM_16_BIT && patch->aformat == AUDIO_FORMAT_E_AC3) {
+        memcpy(mixbuffer + mix_size, mute_ddp_frame, sizeof(mute_ddp_frame));
+        type = 2;
+    } else if (aml_dev->sink_format != AUDIO_FORMAT_PCM_16_BIT && patch->aformat == AUDIO_FORMAT_AC3) {
+        memcpy(mixbuffer + mix_size, mute_dd_frame, sizeof(mute_dd_frame));
+        type = 1;
     } else {
-        memset(mixbuffer, 0, sizeof(mixbuffer));
-        ret = aml_alsa_output_write(stream_out, (void*)mixbuffer, EAC3_IEC61937_FRAME_SIZE);
-        ret = aml_alsa_output_write(stream_out, (void*)mixbuffer, EAC3_IEC61937_FRAME_SIZE);
-        //ALOGI("aml_alsa_output_write PCM");
+        type = 0;
     }
-    if (ret < 0) {
-        ALOGE("ALSA out write fail");
+    if (type == 2) {
+        audio_format_t output_format = AUDIO_FORMAT_E_AC3;
+        size_t write_bytes = EAC3_IEC61937_FRAME_SIZE;
+        if (audio_hal_data_processing(stream_out, (void*)mixbuffer, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+            hw_write(stream_out, output_buffer, output_buffer_bytes, output_format);
+        }
+    } else if (type == 1) {
+        audio_format_t output_format = AUDIO_FORMAT_AC3;
+        size_t write_bytes = AC3_IEC61937_FRAME_SIZE;
+        if (audio_hal_data_processing(stream_out, (void*)mixbuffer, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+            hw_write(stream_out, output_buffer, output_buffer_bytes, output_format);
+        }
+    } else {
+        audio_format_t output_format = AUDIO_FORMAT_PCM_16_BIT;
+        size_t write_bytes = AC3_IEC61937_FRAME_SIZE;
+        memset(mixbuffer, 0, EAC3_IEC61937_FRAME_SIZE);
+        if (audio_hal_data_processing(stream_out, (void*)mixbuffer, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+            hw_write(stream_out, output_buffer, output_buffer_bytes, output_format);
+        }
     }
-    pthread_mutex_unlock(&aml_dev->alsa_pcm_lock);
 #if 0
     clock_gettime(CLOCK_MONOTONIC, &after_read);
     us = calc_time_interval_us(&before_read, &after_read);
-    ALOGI("function gap =%d \n", us);
+    ALOGI("function gap =%d,sink %x,optional %x\n", us, aml_dev->sink_format, aml_dev->optical_format);
 #endif
-    if (ret < 0) {
-        return -1;
-    } else {
-        return 0;
-    }
+    free(mixbuffer);
+    mixbuffer = NULL;
+    return 0;
 }
 
 static int dtv_get_ac3_frame_size(struct aml_audio_patch *patch, int main_avail)
 {
-    unsigned char main_head[32];
-    int main_frame_size = 0, main_head_offset = 0;
-    int ret;
-
-    while (main_frame_size == 0 && main_avail >= (int)sizeof(main_head)) {
-        memset(main_head, 0, sizeof(main_head));
-        ret = ring_buffer_read(&(patch->aml_ringbuffer), main_head, sizeof(main_head));
-        main_frame_size = dcv_decoder_get_framesize(main_head,
-                          ret, &main_head_offset);
-        main_avail -= ret;
-        ALOGI("++%s main_avail %d, main_frame_size %d", __FUNCTION__, main_avail, main_frame_size);
+    int main_frame_size = 0, diff1 = 0, diff2 = 0, diff3 = 0;
+    int offset = 0, offset1 = 0, offset2 = 0, offset3 = 0, offset4 = 0;
+    int ret, t1, t2;
+    unsigned char * tmpbuff = NULL;
+    unsigned char *framebuffer = (unsigned char *)patch->out_buf;
+    if (main_avail < AC3_IEC61937_FRAME_SIZE) {
+        return main_frame_size;
+    }
+    ret = ring_buffer_read(&(patch->aml_ringbuffer), framebuffer, AC3_IEC61937_FRAME_SIZE);
+    if (ret < AC3_IEC61937_FRAME_SIZE) {
+        ALOGI("%s error, return length %d", __func__, ret);
+        return main_frame_size;
+    }
+    while (offset < AC3_IEC61937_FRAME_SIZE - 1) {
+        if ((framebuffer[offset] == 0x0b && framebuffer[offset + 1] == 0x77) || \
+            (framebuffer[offset] == 0x77 && framebuffer[offset + 1] == 0x0b)) {
+            if (offset1 == 0) {
+                offset1 = offset;
+            } else if (offset2 == 0) {
+                offset2 = offset;
+                diff1 = offset2 - offset1;
+            } else if (offset3 == 0) {
+                offset3 = offset;
+                diff2 = offset3 - offset2;
+                if (diff2 == diff1) {
+                    main_frame_size = diff2;
+                    break;
+                }
+            } else if (offset4 == 0) {
+                offset4 = offset;
+                diff3 = offset4 - offset3;
+                if (diff2 == diff3) {
+                    main_frame_size = diff3;
+                    break;
+                } else if (diff1 == diff2 + diff3 || diff3 == diff1 + diff2) {
+                    main_frame_size = (diff3 > diff1) ? diff3 : diff1;
+                    break;
+                }
+            }
+        }
+        offset++;
+    }
+    if (offset1 == 0 || offset2 == 0) {
+        main_frame_size = -1;
+    } else if (offset3 == 0 && main_frame_size == 0) {
+        main_frame_size = diff1;
+    } else if (offset4 == 0 && main_frame_size == 0) {
+        if (diff2 == diff1) {
+            main_frame_size = diff2;
+        } else {
+            main_frame_size = (diff2 > diff1) ? diff2 : diff1;;
+        }
+    } else if (main_frame_size == 0) {
+        main_frame_size = (diff3 > diff1) ? diff3 : diff1;
+        main_frame_size = (main_frame_size > diff2) ? main_frame_size : diff2;
+    }
+    t1 = get_buffer_read_space(&(patch->aml_ringbuffer));
+    tmpbuff = malloc(t1 + AC3_IEC61937_FRAME_SIZE);
+    if (!tmpbuff) {
+        ALOGE("%s, malloc error", __func__);
+        return 0;
+    }
+    memcpy(tmpbuff, framebuffer, AC3_IEC61937_FRAME_SIZE);
+    ring_buffer_read(&(patch->aml_ringbuffer), &tmpbuff[AC3_IEC61937_FRAME_SIZE], t1);
+    ring_buffer_write(&(patch->aml_ringbuffer), (unsigned char *)tmpbuff, t1 + AC3_IEC61937_FRAME_SIZE, 0);
+    free(tmpbuff);
+    if (main_frame_size == -1) {
+        main_frame_size = 0;
+    }
+    if (get_tsync_pcr_debug()) {
+        ALOGI("%s framesize %d,avail %d,diff1 %d,diff2 %d,diff3 %d,offset4 %d,offset3 %d,offset2 %d,offset1 %d",
+              __func__, main_frame_size, main_avail, diff1, diff2, diff3, offset4, offset3, offset2, offset1);
     }
     return main_frame_size;
 }
@@ -1073,19 +1371,72 @@ static void dtv_audio_gap_monitor(struct aml_audio_patch *patch)
 {
     char buff[32];
     unsigned int first_checkinapts = 0;
+    int cur_pts_diff = 0;
+    //int audio_discontinue = 0;
     int ret;
     if (!patch) {
         return;
     }
-    if (get_audio_discontinue() && patch->dtv_audio_tune == AUDIO_RUNNING) {
+    if (patch->tsync_mode != TSYNC_MODE_PCRMASTER) {
+        return;
+    }
+    /*[SE][BUG][OTT-7302][zhizhong.zhang] detect audio discontinue by pts-diff*/
+    /* audio underrun sometimes when dual output in tv platform */
+    /*if ((patch->last_apts != 0  && patch->last_apts != (unsigned long) - 1) &&
+        (patch->last_pcrpts != 0  && patch->last_pcrpts != (unsigned long) - 1)) {
+        cur_pts_diff = patch->last_pcrpts - patch->last_apts;
+        if (audio_discontinue == 0 &&
+            abs(cur_pts_diff) > DTV_PTS_CORRECTION_THRESHOLD * 5) {
+            audio_discontinue = 1;
+            ALOGI("cur_pts_diff=%d, diff=%d, apts=0x%x, pcrpts=0x%x\n",
+                cur_pts_diff, cur_pts_diff/90, patch->last_apts, patch->last_pcrpts);
+        } else
+            audio_discontinue = 0;
+    } */
+    if ((/*audio_discontinue || */get_audio_discontinue(patch)) &&
+        patch->dtv_audio_tune == AUDIO_RUNNING) {
         //ALOGI("%s size %d", __FUNCTION__, get_buffer_read_space(&(patch->aml_ringbuffer)));
         ret = aml_sysfs_get_str(TSYNC_LAST_CHECKIN_APTS, buff, sizeof(buff));
         if (ret > 0) {
             ret = sscanf(buff, "0x%x\n", &first_checkinapts);
         }
         if (first_checkinapts) {
+            int avail, t2, ret = 0;
+            patch->dtv_audio_tune = AUDIO_BREAK;
+            avail = get_buffer_read_space(&(patch->aml_ringbuffer));
+            if (avail == 0) {
+                return;
+            }
+            ret = 0;
+            /* if there were some data in ringbuffer when audio discontinue, discard it and
+            tune into audio_break, then calc apts and pcr to sync audio*/
+            for (t2 = 0; t2 < (1 + avail / 512); t2++) {
+                ret += ring_buffer_read(&(patch->aml_ringbuffer), (unsigned char *)patch->out_buf, 512);
+            }
+            if (patch->aformat == AUDIO_FORMAT_E_AC3 || patch->aformat == AUDIO_FORMAT_AC3 ||
+                patch->aformat == AUDIO_FORMAT_DTS) {
+                patch->decoder_offset += ret;
+            }
+            ALOGI("%s, buffersize %d, read %d, offset %x",  __FUNCTION__, avail, ret, patch->decoder_offset);
+        }/* else if (audio_discontinue == 1) {
             patch->dtv_audio_tune = AUDIO_BREAK;
-            //ALOGI("audio discontinue, audio_break");
+            ALOGI("audio_discontinue set 1,break\n");
+        }*/
+    }
+}
+
+static void dtv_fadeout_monitor(struct aml_audio_patch *patch, struct aml_audio_device *aml_dev)
+{
+    int audio_state = 0, video_state = 0;
+    if (!patch) {
+        return;
+    }
+    audio_state = get_tsync_audio_state();
+    video_state = get_tsync_video_state();
+    if (audio_state != 1 && audio_state != 4 && video_state != 1 && video_state != 2) {
+        if (!patch->dtv_faded_out) {
+            dtv_do_ease_out(aml_dev);
+            patch->dtv_faded_out = 1;
         }
     }
 }
@@ -1093,8 +1444,8 @@ static void dtv_audio_gap_monitor(struct aml_audio_patch *patch)
 static void dtv_do_drop_pcm(int avail, struct aml_audio_patch *patch,
                             struct audio_stream_out *stream_out)
 {
-    struct audio_hw_device *adev = patch->dev;
-    struct aml_audio_device *aml_dev = (struct aml_audio_device *) adev;
+    //struct audio_hw_device *adev = patch->dev;
+    //struct aml_audio_device *aml_dev = (struct aml_audio_device *) adev;
     struct aml_stream_out *out = (struct aml_stream_out *)stream_out;
     int drop_size, t1, t2;
     if (!patch || !patch->dev || !stream_out) {
@@ -1102,15 +1453,18 @@ static void dtv_do_drop_pcm(int avail, struct aml_audio_patch *patch,
     }
     if (patch->dtv_apts_lookup > 0) {
         drop_size = 48 * 4 * (patch->dtv_apts_lookup / 90);
-        if (drop_size > avail) {
-            drop_size = avail;
+        if (avail <= LOOKUP_MPEG_MIN_BYTES) {
+            drop_size = 0;
+        } else if (drop_size > avail - LOOKUP_MPEG_MIN_BYTES) {
+            drop_size = avail - LOOKUP_MPEG_MIN_BYTES;
         }
         t1 = drop_size / patch->out_buf_size;
         for (t2 = 0; t2 < t1; t2++) {
             ring_buffer_read(&(patch->aml_ringbuffer), (unsigned char *)patch->out_buf, patch->out_buf_size);
         }
-        ALOGI("dtv_do_drop:--drop %d,avail %d,diff %d ms\n", 48 * 4 * (patch->dtv_apts_lookup / 90), avail, (int)(drop_size) / 192);
+        ALOGI("dtv_do_drop:--drop %d ms,avail %d,dropped %d bytes %d ms\n", (patch->dtv_apts_lookup / 90), avail, drop_size, (drop_size / 4 / 48));
     } else if (patch->dtv_apts_lookup < 0) {
+        unsigned char *dropbuff = NULL;
         memset(patch->out_buf, 0, patch->out_buf_size);
         if (abs(patch->dtv_apts_lookup) / 90 > 1000) {
             t1 = 1000 * 192;
@@ -1118,40 +1472,109 @@ static void dtv_do_drop_pcm(int avail, struct aml_audio_patch *patch,
             t1 =  192 * abs(patch->dtv_apts_lookup) / 90;
         }
         t2 = t1 / patch->out_buf_size;
-        ALOGI("dtv_do_drop:++drop %d,lookup %d,diff %d ms\n", t1, patch->dtv_apts_lookup, t1 / 192);
-        for (t1 = 0; t1 < t2; t1++) {
-            ring_buffer_write(&(patch->aml_ringbuffer), (unsigned char *)patch->out_buf, patch->out_buf_size, 0);
+        drop_size = t2 * patch->out_buf_size;
+        if (!drop_size) {
+            patch->dtv_apts_lookup = 0;
+            return;
+        }
+        t1 = get_buffer_read_space(&(patch->aml_ringbuffer));
+        t2 = get_buffer_write_space(&(patch->aml_ringbuffer));
+        if (t1 < 0 || t2 < 0) {
+            return;
         }
+        if (drop_size > t2) {
+            drop_size = t2;
+        }
+        t2 = t1 + drop_size;
+        dropbuff = malloc(t2);
+        if (!dropbuff) {
+            patch->dtv_apts_lookup = 0;
+            ALOGE("%s, malloc error", __func__);
+            return;
+        }
+        memset(dropbuff, 0, drop_size);
+        ring_buffer_read(&(patch->aml_ringbuffer), (unsigned char *)&dropbuff[drop_size], t1);
+        ring_buffer_write(&(patch->aml_ringbuffer), (unsigned char *)dropbuff, t2, 0);
+        free(dropbuff);
+        ALOGI("dtv_do_drop:++drop %d ms,size %d,avail %d,now %d\n", patch->dtv_apts_lookup / 90, drop_size, avail, get_buffer_read_space(&(patch->aml_ringbuffer)));
     }
     patch->dtv_apts_lookup = 0;
 }
+/*+[SE][BUG][SWPL-14811][zhizhong] add ac3/e-ac3 pcm drop function*/
+static int dtv_do_drop_ac3_pcm(struct aml_audio_patch *patch,
+            struct audio_stream_out *stream_out)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream_out;
+    struct aml_audio_device *adev = aml_out->dev;
+    size_t frame_size = 0;
+    switch (adev->sink_format) {
+    case AUDIO_FORMAT_E_AC3:
+        frame_size = AUDIO_EAC3_FRAME_SIZE;
+        break;
+    case AUDIO_FORMAT_AC3:
+        frame_size = AUDIO_AC3_FRAME_SIZE;
+        break;
+    default:
+        frame_size = (aml_out->is_tv_platform == true) ? AUDIO_TV_PCM_FRAME_SIZE : AUDIO_DEFAULT_PCM_FRAME_SIZE;
+        break;
+    }
+    aml_out->need_drop_size = (patch->dtv_apts_lookup / 90) * 48 * frame_size;
+    aml_out->need_drop_size &= ~(frame_size - 1);
+    ALOGI("dtv_do_drop need_drop_size=%d,frame_size=%d\n",
+        aml_out->need_drop_size, frame_size);
+    return 0;
+}
 
-static void dtv_do_drop_ac3(int avail, struct aml_audio_patch *patch,
+static void dtv_do_drop_insert_ac3(struct aml_audio_patch *patch,
                             struct audio_stream_out *stream_out)
 {
-    struct audio_hw_device *adev = patch->dev;
-    struct aml_audio_device *aml_dev = (struct aml_audio_device *) adev;
+    struct audio_hw_device *adev;
+    struct aml_audio_device *aml_dev;
     struct aml_stream_out *out = (struct aml_stream_out *)stream_out;
-    int fm_size;
+    int fm_size = 0, avail;
     int drop_size, t1, t2;
-    if (!patch || !patch->dev || !stream_out || aml_dev->tuner2mix_patch == 1) {
+    int write_used_ms = 0;
+    unsigned int cur_pts = 0;
+    unsigned int cur_pcr = 0;
+    int ap_diff = 0;
+    int write_times = 0;
+    struct timespec before_write;
+    struct timespec after_write;
+
+    if (!patch || !patch->dev || !stream_out) {
+        return;
+    }
+    adev = patch->dev;
+    aml_dev = (struct aml_audio_device *) adev;
+    if (aml_dev->tuner2mix_patch == 1) {
         return;
     }
-    fm_size = out->ddp_frame_size;
+    if (eDolbyMS12Lib == aml_dev->dolby_lib_type) {
+        if (out->ddp_frame_size != 0) {
+            fm_size = out->ddp_frame_size;
+        } else {
+            fm_size = dtv_get_ac3_frame_size(patch, get_buffer_read_space(&(patch->aml_ringbuffer)));
+        }
+    } else if (eDolbyDcvLib == aml_dev->dolby_lib_type) {
+        fm_size = dtv_get_ac3_frame_size(patch, get_buffer_read_space(&(patch->aml_ringbuffer)));
+    }
     if (fm_size == 0) {
         fm_size = 512;
     }
     if (patch->dtv_apts_lookup > 0) {
+        avail = get_buffer_read_space(&(patch->aml_ringbuffer));
         drop_size = (patch->dtv_apts_lookup / 90 / 32 * fm_size);
-        if (drop_size > avail) {
-            drop_size = avail;
+        if (avail <= LOOKUP_AC3_MIN_BYTES) {
+            drop_size = 0;
+        } else if (drop_size > avail - LOOKUP_AC3_MIN_BYTES) {
+            drop_size = avail - LOOKUP_AC3_MIN_BYTES;
         }
         t1 = drop_size / fm_size;
         for (t2 = 0; t2 < t1; t2++) {
             ring_buffer_read(&(patch->aml_ringbuffer), (unsigned char *)patch->out_buf, fm_size);
             patch->decoder_offset += fm_size;
         }
-        ALOGI("dtv_do_drop:--drop %d,avail %d,diff %d ms,fm_size %d\n", (patch->dtv_apts_lookup / 90 / 32 * fm_size), avail, t1 * 32, fm_size);
+        ALOGI("dtv_do_drop:--drop %d ms,avail %d,dropped %d bytes %d ms,fm_size %d\n", (patch->dtv_apts_lookup / 90), avail, fm_size * t1, t1 * 32, fm_size);
     } else if (patch->dtv_apts_lookup < 0) {
         if (abs(patch->dtv_apts_lookup) / 90 > 1000) {
             t1 = 1000;
@@ -1159,25 +1582,50 @@ static void dtv_do_drop_ac3(int avail, struct aml_audio_patch *patch,
             t1 =  abs(patch->dtv_apts_lookup) / 90;
         }
         t2 = t1 / 32;
-        ALOGI("dtv_do_drop:++drop %d,lookup %d,diff %d ms,frame %d\n", t2 * fm_size, patch->dtv_apts_lookup, t1, fm_size);
+        ALOGI("dtv_do_insert:++inset lookup %d,diff %d ms\n", patch->dtv_apts_lookup, t1);
+        clock_gettime(CLOCK_MONOTONIC, &before_write);
         t1 = 0;
-        while (t1 == 0 && t2 > 0) {
+        while (t1 == 0 && t2 > 0 && patch->output_thread_exit == 0) {
+
+            write_times++;
             t1 = dtv_write_mute_frame(patch, stream_out);
+            usleep(5000);
+
+            cur_pts = patch->last_apts;
+            get_sysfs_uint(TSYNC_PCRSCR, (unsigned int *) & (cur_pcr));
+            ap_diff = cur_pts - cur_pcr;
+            ALOGI("cur_pts=0x%x, cur_pcr=0x%x,ap_diff=%d\n", cur_pts, cur_pcr, ap_diff);
+            if (ap_diff < 90*10) {
+                ALOGI("write mute pcm enough, write_times=%d break\n", write_times);
+                break;
+            }
             t2--;
+
+            clock_gettime(CLOCK_MONOTONIC, &after_write);
+            write_used_ms = calc_time_interval_us(&before_write, &after_write)/1000;
+            ALOGI("write_used_ms = %d\n", write_used_ms);
+            if (write_used_ms > 1000) {
+                ALOGI("write cost over 1s write_times=%d, break\n", write_times);
+                break;
+            }
         }
     }
+    ALOGI("dtv_do_drop_insert done\n");
 }
 
 static int dtv_audio_tune_check(struct aml_audio_patch *patch, int cur_pts_diff, int last_pts_diff, unsigned int apts)
 {
     char tempbuf[128];
-    struct audio_hw_device *adev = patch->dev;
-    struct aml_audio_device *aml_dev = (struct aml_audio_device *) adev;
-    if (!patch || !patch->dev || aml_dev->tuner2mix_patch == 1) {
+    struct aml_audio_device *aml_dev;
+    if (!patch || !patch->dev) {
+        return 1;
+    }
+    aml_dev = (struct aml_audio_device *) patch->dev;
+    if (aml_dev->tuner2mix_patch == 1 || (aml_dev->out_device & AUDIO_DEVICE_OUT_ALL_A2DP)) {
         patch->dtv_audio_tune = AUDIO_RUNNING;
         return 1;
     }
-    if (get_audio_discontinue() || patch->dtv_has_video == 0 ||
+    if (get_audio_discontinue(patch) || patch->dtv_has_video == 0 ||
         patch->dtv_audio_mode == 1) {
         dtv_adjust_output_clock(patch, DIRECT_NORMAL, DEFAULT_DTV_ADJUST_CLOCK);
         patch->last_apts = 0;
@@ -1205,16 +1653,12 @@ static int dtv_audio_tune_check(struct aml_audio_patch *patch, int cur_pts_diff,
             int pts_diff = (last_pts_diff + cur_pts_diff) / 2;
             int pts_latency = decoder_get_latency();
             pts_latency += pts_diff;
-            if (get_dtv_sync_mode() == 1) {
+            if (patch->dtv_pcr_mode) {
                 ALOGI("dtv_audio_tune audio_latency %d,pts_diff %d", (int)pts_latency / 90, pts_diff / 90);
-                if (pts_latency >= 500 * 90) {
-                    pts_latency = 499 * 90;
-                } else if (pts_latency < 0) {
-                    if (abs(pts_diff) < DTV_PTS_CORRECTION_THRESHOLD) {
-                        pts_latency += abs(pts_diff);
-                    } else {
-                        pts_latency = 0;
-                    }
+                if (pts_latency >= DECODER_PTS_MAX_LATENCY) {
+                    pts_latency = DECODER_PTS_MAX_LATENCY;
+                } else if (pts_latency < (DEMUX_PCR_APTS_LATENCY - DECODER_PTS_DEFAULT_LATENCY)) {
+                    pts_latency = DEMUX_PCR_APTS_LATENCY - DECODER_PTS_DEFAULT_LATENCY;
                 }
                 decoder_set_latency(pts_latency);
             } else {
@@ -1226,14 +1670,91 @@ static int dtv_audio_tune_check(struct aml_audio_patch *patch, int cur_pts_diff,
                 } else if (pts_diff < -1000 * 90) {
                     pts_diff = -1000 * 90;
                 }
-                pcrpts -= pts_diff;
-                decoder_set_pcrsrc(pcrpts);
+                if (pts_diff < 0) {
+                    uint cached_pts = get_vsync_cached_pts(patch, aml_dev, pcrpts);
+                    if (cached_pts > DEMUX_PCR_VPTS_LATENCY) {
+                        pcrpts = (cached_pts > (uint)(abs(pts_diff) + DEMUX_PCR_VPTS_LATENCY) ?
+                                  (pcrpts - pts_diff) : (get_tsync_checkin_pts(0) - DEMUX_PCR_VPTS_LATENCY));
+                        decoder_set_pcrsrc(pcrpts);
+                        ALOGI("dtv_audio_tune cached_pts %d, pts_diff %d, pcrsrc %x, vpts %x", abs(pts_diff), cached_pts, pcrpts, get_tsync_checkin_pts(0));
+                    }
+                } else {
+                    pcrpts -= pts_diff;
+                    decoder_set_pcrsrc(pcrpts);
+                }
             }
             patch->dtv_audio_tune = AUDIO_RUNNING;
         }
         return 1;
     } else if (patch->dtv_audio_tune != AUDIO_RUNNING) {
         return 1;
+    } else if (!patch->dtv_pcr_mode && patch->dtv_audio_tune == AUDIO_RUNNING && !get_tsync_pcr_inited()) {
+        if (abs(cur_pts_diff) > SYSTIME_CORRECTION_THRESHOLD &&
+            abs(last_pts_diff) > SYSTIME_CORRECTION_THRESHOLD &&
+            abs(last_pts_diff - cur_pts_diff) < DTV_PTS_CORRECTION_THRESHOLD) {
+            uint pcrpts = 0, cached_pts = 0;
+            int pts_diff = (last_pts_diff + cur_pts_diff) / 2;
+            get_sysfs_uint(TSYNC_PCRSCR, &pcrpts);
+            cached_pts = get_vsync_cached_pts(patch, aml_dev, pcrpts);
+            if (cached_pts < DEMUX_PCR_VPTS_LATENCY && pts_diff < 0) {
+                if (abs(pts_diff) > SYSTIME_CORRECTION_THRESHOLD) {
+                    patch->dtv_audio_tune = AUDIO_LOOKUP;
+                    clean_dtv_patch_pts(patch);
+                    return 1;
+                }
+                return 0;
+            }
+            patch->dtv_audio_tune = AUDIO_LATENCY;
+            if (get_tsync_pcr_debug()) {
+                ALOGI("dtv_audio_tune audio_latency cur_pts_diff %d, last_pts_diff %d, cached_pts %d",
+                      cur_pts_diff / 90, last_pts_diff / 90, cached_pts);
+            }
+            return 1;
+        }
+    } else if (patch->dtv_pcr_mode && patch->dtv_audio_tune == AUDIO_RUNNING && get_tsync_pcr_inited()) {
+        int pts_threshold, pts_diff, pts_latency, avail;
+        /*if ((patch->aformat == AUDIO_FORMAT_AC3) ||
+            (patch->aformat == AUDIO_FORMAT_E_AC3) || patch->aformat == AUDIO_FORMAT_DTS) {*/
+            pts_threshold = SYSTIME_CORRECTION_THRESHOLD * 3;
+        /*} else {
+            pts_threshold = SYSTIME_CORRECTION_THRESHOLD * 3;
+        }*/
+        if (abs(cur_pts_diff) > pts_threshold && abs(last_pts_diff) > pts_threshold &&
+            abs(last_pts_diff - cur_pts_diff) < DTV_PTS_CORRECTION_THRESHOLD) {
+            pts_diff = (last_pts_diff + cur_pts_diff) / 2;
+            if (pts_diff > 0) {
+                pts_latency = decoder_get_latency();
+                if (pts_diff + pts_latency > DECODER_PTS_MAX_LATENCY) {
+                    bool can_relookup = false;
+                    avail = get_buffer_read_space(&(patch->aml_ringbuffer));
+                    if (patch->aformat == AUDIO_FORMAT_AC3 || patch->aformat == AUDIO_FORMAT_E_AC3) {
+                        int fm_size = patch->dtv_ac3_fmsize;
+                        if (avail > LOOKUP_AC3_MIN_BYTES && fm_size > 0) {
+                            if (avail - LOOKUP_AC3_MIN_BYTES > 3 * fm_size) {
+                                can_relookup = true;
+                            }
+                        }
+                    } else {
+                        if (avail > LOOKUP_MPEG_MIN_BYTES) {
+                            if (avail - LOOKUP_MPEG_MIN_BYTES > LOOKUP_MPEG_MIN_BYTES) {
+                                can_relookup = true;
+                            }
+                        }
+                    }
+                    if (can_relookup) {
+                        patch->dtv_audio_tune = AUDIO_LOOKUP;
+                        dtv_set_audio_latency(0);
+                        clean_dtv_patch_pts(patch);
+                        return 1;
+                    }
+                }
+                if (pts_latency < DECODER_PTS_MAX_LATENCY) {
+                    patch->dtv_audio_tune = AUDIO_LATENCY;
+                    clean_dtv_patch_pts(patch);
+                    return 1;
+                }
+            }
+        }
     }
     return 0;
 }
@@ -1249,7 +1770,7 @@ static void do_pll1_by_pts(unsigned int pcrpts, struct aml_audio_patch *patch,
     if (get_tsync_pcr_debug()) {
         ALOGI("process_pts_sync, diff:%d,pcrpts %x,size %d, latency %d, mode %d",
               (int)(pcrpts - apts) / 90, pcrpts, get_buffer_read_space(&(patch->aml_ringbuffer)),
-              (int)decoder_get_latency() / 90, get_dtv_sync_mode());
+              (int)decoder_get_latency() / 90, patch->dtv_pcr_mode);
     }
     last_apts = patch->last_apts;
     last_pcrpts = patch->last_pcrpts;
@@ -1300,14 +1821,36 @@ static void do_pll2_by_pts(unsigned int pcrpts, struct aml_audio_patch *patch,
                            unsigned int apts, struct aml_stream_out *stream_out)
 {
     unsigned int last_pcrpts, last_apts;
+    unsigned int cur_vpts = 0;
     int pcrpts_diff, last_pts_diff, cur_pts_diff;
     struct audio_hw_device *adev = patch->dev;
     struct aml_audio_device *aml_dev = (struct aml_audio_device *) adev;
     struct aml_mixer_handle * handle = &(aml_dev->alsa_mixer);
+    int ret = 0;
+    char buff[32] = {0};
+
     if (get_tsync_pcr_debug()) {
-        ALOGI("process_ac3_sync, diff:%d,pcrpts %x,size %d, latency %d,mode %d",
-              (int)(pcrpts - apts) / 90, pcrpts, get_buffer_read_space(&(patch->aml_ringbuffer)),
-              (int)decoder_get_latency() / 90, get_dtv_sync_mode());
+        char buff[32];
+        unsigned int cur_vpts = 0;
+        unsigned int demux_vpts = 0;
+        unsigned int demux_apts = 0;
+        int ret1 = aml_sysfs_get_str(TSYNC_VPTS, buff, sizeof(buff));
+        if (ret1 > 0) {
+            ret1 = sscanf(buff, "0x%x\n", &cur_vpts);
+        }
+        ret1 = aml_sysfs_get_str(TSYNC_DEMUX_APTS, buff, sizeof(buff));
+        if (ret1 > 0) {
+            ret1 = sscanf(buff, "%u\n", &demux_apts);
+        }
+        ret1 = aml_sysfs_get_str(TSYNC_DEMUX_VPTS, buff, sizeof(buff));
+        if (ret1 > 0) {
+            ret1 = sscanf(buff, "%u\n", &demux_vpts);
+        }
+
+        ALOGI("process_ac3_sync, diff:%d,apts %x(%x,cache:%dms), vpts %x(%x,cache:%dms), pcrpts %x, av-diff:%d, size %d, latency %d, mode %d, pll_state=%d\n",
+              (int)(pcrpts - apts) / 90, apts, demux_apts, (int)(demux_apts - apts) / 90,cur_vpts, demux_vpts, (int)(demux_vpts - cur_vpts) / 90, pcrpts, (int)(apts - cur_vpts)/90,
+              get_buffer_read_space(&(patch->aml_ringbuffer)), (int)decoder_get_latency() / 90, patch->dtv_pcr_mode, patch->pll_state);
+
     }
     last_apts = patch->last_apts;
     last_pcrpts = patch->last_pcrpts;
@@ -1362,6 +1905,56 @@ static void do_pll2_by_pts(unsigned int pcrpts, struct aml_audio_patch *patch,
     }
 }
 
+static void do_tsync_by_apts(unsigned int pcrpts, struct aml_audio_patch *patch,
+                             unsigned int apts)
+{
+    char tempbuf[128];
+    unsigned int last_pcrpts, last_apts;
+    int pcrpts_diff, last_pts_diff, cur_pts_diff;
+    struct aml_audio_device *aml_dev;
+    if (!patch || !patch->dev) {
+        return;
+    }
+    aml_dev = (struct aml_audio_device *) patch->dev;
+    if (get_tsync_pcr_debug()) {
+        ALOGI("do_tsync_by_apts, diff:%d,pcrpts %x,curpts %x, size %d",
+              (int)(pcrpts - apts) / 90, pcrpts, apts,
+              get_buffer_read_space(&(patch->aml_ringbuffer)));
+    }
+    last_apts = patch->last_apts;
+    last_pcrpts = patch->last_pcrpts;
+    patch->last_pcrpts = pcrpts;
+    patch->last_apts = apts;
+    last_pts_diff = last_pcrpts - last_apts;
+    cur_pts_diff = pcrpts - apts;
+    pcrpts_diff = pcrpts - last_pcrpts;
+    if (last_apts == 0 || last_pcrpts == 0 || aml_dev->tuner2mix_patch == 1
+        || patch->dtv_has_video == 0 || patch->dtv_audio_mode == 1) {
+        return;
+    }
+    if (abs(last_pts_diff - cur_pts_diff) > DTV_PTS_CORRECTION_THRESHOLD) {
+        return;
+    }
+    if (abs(cur_pts_diff) <= SYSTIME_CORRECTION_THRESHOLD) {
+        // now the av is syncd ,so do nothing;
+    } else if (abs(cur_pts_diff) < AUDIO_PTS_DISCONTINUE_THRESHOLD) {
+        sprintf(tempbuf, "%u", (unsigned int)apts);
+        if (get_tsync_pcr_debug()) {
+            ALOGI("reset the apts to %x pcrpts %x pts_diff %d ms\n", apts, pcrpts, cur_pts_diff / 90);
+        }
+        sysfs_set_sysfs_str(TSYNC_APTS, tempbuf);
+    } else {
+        if (get_tsync_pcr_debug()) {
+            ALOGI("AUDIO_TSTAMP_DISCONTINUITY, the apts %x, pcrpts %x pts_diff %d \n",
+                  apts, pcrpts, cur_pts_diff);
+        }
+        sprintf(tempbuf, "AUDIO_TSTAMP_DISCONTINUITY:0x%lx", (unsigned long)apts);
+        if (sysfs_set_sysfs_str(TSYNC_EVENT, tempbuf) == -1) {
+            ALOGI("unable to open file %s,err: %s", TSYNC_EVENT, strerror(errno));
+        }
+    }
+}
+
 void process_ac3_sync(struct aml_audio_patch *patch, unsigned long pts, struct aml_stream_out *stream_out)
 {
 
@@ -1373,6 +1966,9 @@ void process_ac3_sync(struct aml_audio_patch *patch, unsigned long pts, struct a
     unsigned int pts_diff;
     unsigned long cur_out_pts;
 
+    if (!patch || !patch->dev || !stream_out) {
+        return;
+    }
     if (patch->dtv_first_apts_flag == 0) {
         sprintf(tempbuf, "AUDIO_START:0x%x", (unsigned int)pts);
         ALOGI("dtv set tsync -> %s", tempbuf);
@@ -1383,14 +1979,15 @@ void process_ac3_sync(struct aml_audio_patch *patch, unsigned long pts, struct a
     } else {
         cur_out_pts = pts;
         get_sysfs_uint(TSYNC_PCRSCR, &pcrpts);
-        if (!patch || !patch->dev || !stream_out) {
-            return;
-        }
         if (pts == 0) {
             return;
         }
-        pcrpts = dtv_calc_pcrpts_latency(patch, pcrpts);
-        do_pll2_by_pts(pcrpts, patch, cur_out_pts, stream_out);
+        if (patch->tsync_mode == TSYNC_MODE_PCRMASTER) {
+            pcrpts = dtv_calc_pcrpts_latency(patch, pcrpts);
+            do_pll2_by_pts(pcrpts, patch, cur_out_pts, stream_out);
+        } else {
+            do_tsync_by_apts(pcrpts, patch, cur_out_pts);
+        }
     }
 }
 
@@ -1401,11 +1998,25 @@ void process_pts_sync(unsigned int pcm_lancty, struct aml_audio_patch *patch,
     int bytewidth = 2;
     int sysmbol = 48;
     char tempbuf[128];
+    char value[128];
     unsigned int pcrpts, apts;
     unsigned int calc_len = 0;
     unsigned long pts = 0, lookpts;
+    unsigned long pts_add = 0;
     unsigned long cache_pts = 0;
     unsigned long cur_out_pts = 0;
+    unsigned long cur_out_pts_add = 0;
+    static unsigned int pts_diff_count = 0;
+    unsigned long last_pts;
+
+    unsigned long pts_threshold = 100*90;
+    if (property_get("media.libplayer.pts_threshold", value, NULL) > 0) {
+        pts_threshold = atoi(value);
+    }
+    if (!patch || !patch->dev || !stream_out) {
+        return;
+    }
+    last_pts = patch->last_out_pts;
 
     pts = lookpts = dtv_patch_get_pts();
     if (pts == patch->last_valid_pts) {
@@ -1420,12 +2031,21 @@ void process_pts_sync(unsigned int pcm_lancty, struct aml_audio_patch *patch,
         ALOGI("dtv set tsync -> %s", tempbuf);
         if (sysfs_set_sysfs_str(TSYNC_EVENT, tempbuf) == -1) {
             ALOGE("set AUDIO_START failed \n");
+            pts_diff_count = 0;
         }
         patch->dtv_pcm_readed = 0;
         patch->dtv_first_apts_flag = 1;
         patch->last_valid_pts = pts;
+        patch->last_out_pts = pts;
     } else {
         unsigned int pts_diff;
+        pts_add = patch->last_out_pts;
+        calc_len = patch->dtv_pcm_readed;
+        cache_pts = (calc_len * 90) / (sysmbol * channel_count * bytewidth);
+        cur_out_pts_add = pts_add + cache_pts;
+        if (aml_getprop_bool("media.audiohal.debug"))
+        ALOGI("======patch->last_out_pts = %lx cache_pts = %lx calc_len = %d, cur_out_pts_add = %lx", patch->last_out_pts, cache_pts, calc_len, cur_out_pts_add);
+
         if (pts != (unsigned long) - 1) {
             calc_len = (unsigned int)rbuf_level;
             cache_pts = (calc_len * 90) / (sysmbol * channel_count * bytewidth);
@@ -1441,48 +2061,106 @@ void process_pts_sync(unsigned int pcm_lancty, struct aml_audio_patch *patch,
             }
             patch->last_valid_pts = cur_out_pts;
             patch->dtv_pcm_readed = 0;
+            patch->last_out_pts = cur_out_pts_add;
         } else {
             pts = patch->last_valid_pts;
             calc_len = patch->dtv_pcm_readed;
             cache_pts = (calc_len * 90) / (sysmbol * channel_count * bytewidth);
             cur_out_pts = pts + cache_pts;
-            return;
+            if (aml_getprop_bool("media.audiohal.debug"))
+            ALOGI("======patch->last_valid_pts = %lx cache_pts = %lx calc_len = %d, cur_out_pts = %lx", patch->last_valid_pts, cache_pts, calc_len, cur_out_pts);
+            if (patch->tsync_mode == TSYNC_MODE_PCRMASTER) {
+                return;
+            }
         }
-        if (!patch || !patch->dev || !stream_out) {
+        get_sysfs_uint(TSYNC_PCRSCR, &pcrpts);
+        if (patch->tsync_mode == TSYNC_MODE_PCRMASTER) {
+            //pcrpts -= DTV_PTS_CORRECTION_THRESHOLD;
+            do_pll1_by_pts(pcrpts, patch, cur_out_pts, stream_out);
             return;
         }
-        get_sysfs_uint(TSYNC_PCRSCR, &pcrpts);
-        //pcrpts -= DTV_PTS_CORRECTION_THRESHOLD;
-        do_pll1_by_pts(pcrpts, patch, cur_out_pts, stream_out);
+        if (pcrpts > cur_out_pts) {
+            pts_diff = pcrpts - cur_out_pts;
+        } else {
+            pts_diff = cur_out_pts - pcrpts;
+        }
+
+        {
+            get_sysfs_uint(TSYNC_APTS, &apts);
+            if (lookpts != (unsigned long) - 1 && abs((int)(cur_out_pts - pcrpts)) > AUDIO_PTS_DISCONTINUE_THRESHOLD) {
+                ALOGI("AUDIO_TSTAMP_DISCONTINUITY,not set sync event, the apts %x, apts %lx pcrpts %x pts_diff %d \n",
+                      apts, cur_out_pts, pcrpts, pts_diff);
+                sprintf(tempbuf, "AUDIO_TSTAMP_DISCONTINUITY:0x%lx",
+                       (unsigned long)cur_out_pts);
+                if (sysfs_set_sysfs_str(TSYNC_EVENT, tempbuf) == -1) {
+                    ALOGI("unable to open file %s,err: %s", TSYNC_EVENT, strerror(errno));
+                }
+                return;
+            }
+        }
+
+        if (aml_getprop_bool("media.audiohal.debug"))
+            ALOGI("cur_out_pts and cur_out_pts_add!!! %lx/%lx, diff=%d", cur_out_pts, cur_out_pts_add, abs((int)(cur_out_pts - cur_out_pts_add)));
+        if (abs((int)(cur_out_pts - cur_out_pts_add)) > (int)pts_threshold) {
+            pts_diff_count ++;
+            if (pts_diff_count > 10) {
+                ALOGI("need use cur_out_pts to reset apts!!! %lx/%lx, diff=%d", cur_out_pts, cur_out_pts_add, abs((int)(cur_out_pts - cur_out_pts_add)));
+                patch->last_out_pts = cur_out_pts_add = cur_out_pts;
+                pts_diff_count = 0;
+            }
+        } else {
+            pts_diff_count = 0;
+        }
+        if (last_pts != cur_out_pts_add) {
+            sprintf(tempbuf, "%u", (unsigned int)cur_out_pts_add);
+            sysfs_set_sysfs_str(TSYNC_APTS, tempbuf);
+            if (aml_getprop_bool("media.audiohal.debug"))
+                ALOGI("reset the apts to %lx pcrpts %x pts_diff %d \n", cur_out_pts_add, pcrpts, abs((int)(cur_out_pts_add - pcrpts)));
+        }
     }
 }
 
 void dtv_avsync_process(struct aml_audio_patch* patch, struct aml_stream_out* stream_out)
 {
     unsigned long pts ;
+    int audio_output_delay = 0;
     ring_buffer_t *ringbuffer = &(patch->aml_ringbuffer);
     struct audio_hw_device *dev = patch->dev;
     struct aml_audio_device *aml_dev = (struct aml_audio_device *)dev;
     if (patch->dtv_decoder_state != AUDIO_DTV_PATCH_DECODER_STATE_RUNING) {
         return;
     }
+    patch->dtv_pcr_mode = get_dtv_sync_mode();
+    aml_dev->audio_discontinue = get_audio_discontinue(patch);
+
+    audio_output_delay = aml_getprop_int(PROPERTY_LOCAL_PASSTHROUGH_LATENCY);
+    if (patch->last_audio_delay != audio_output_delay) {
+        patch->last_audio_delay = audio_output_delay;
+        patch->dtv_audio_tune = AUDIO_LOOKUP;
+        ALOGI("set audio_output_delay = %d\n", audio_output_delay);
+    }
+
     if (patch->aformat == AUDIO_FORMAT_E_AC3 || patch->aformat == AUDIO_FORMAT_AC3) {
         if (stream_out != NULL) {
-            unsigned int  pcm_lantcy = out_get_latency(&(stream_out->stream));
+            /*The decoder has one frame cached,need to add 32ms to the latency*/
+            unsigned int  pcm_lantcy = out_get_latency(&(stream_out->stream)) + 32
+                                        + audio_output_delay;
             pts = dtv_hal_get_pts(patch, pcm_lantcy);
             process_ac3_sync(patch, pts, stream_out);
         }
     } else if (patch->aformat ==  AUDIO_FORMAT_DTS || patch->aformat == AUDIO_FORMAT_DTS_HD) {
         if (stream_out != NULL) {
             ringbuffer = &(patch->aml_ringbuffer);
-            unsigned int pcm_lantcy = out_get_latency(&(stream_out->stream));
+            unsigned int pcm_lantcy = out_get_latency(&(stream_out->stream)) +
+                                        audio_output_delay;
             pts = dtv_hal_get_pts(patch, pcm_lantcy);
             process_ac3_sync(patch, pts, stream_out);
         }
     } else {
         {
             if (stream_out != NULL) {
-                unsigned int pcm_lantcy = out_get_latency(&(stream_out->stream));
+                unsigned int pcm_lantcy = out_get_latency(&(stream_out->stream)) +
+                                            audio_output_delay;
                 int abuf_level = get_buffer_read_space(ringbuffer);
                 process_pts_sync(pcm_lantcy, patch, abuf_level, stream_out);
             }
@@ -1491,25 +2169,6 @@ void dtv_avsync_process(struct aml_audio_patch* patch, struct aml_stream_out* st
     dtv_audio_gap_monitor(patch);
 }
 
-static bool dtv_is_pcrmaster(void)
-{
-    char tsync_mode_str[12];
-    int tsync_mode;
-    char buf[64];
-    if (sysfs_get_sysfs_str(DTV_DECODER_TSYNC_MODE, buf, sizeof(buf)) == -1) {
-        ALOGI("dtv_is_pcrmaster is 22");
-        return false;
-    }
-    if (sscanf(buf, "%d: %s", &tsync_mode, tsync_mode_str) < 1) {
-        return false;
-    }
-    if (tsync_mode == 2) {
-        ALOGI("dtv_is_pcrmaster is true");
-        return true;
-    }
-    return true; //false;
-}
-
 static int dtv_patch_pcm_wirte(unsigned char *pcm_data, int size,
                                int symbolrate, int channel, void *args)
 {
@@ -1520,14 +2179,15 @@ static int dtv_patch_pcm_wirte(unsigned char *pcm_data, int size,
     int left, need_resample;
     int write_size, return_size;
     unsigned char *write_buf;
-    int16_t tmpbuf[OUTPUT_BUFFER_SIZE];
+    int16_t *tmpbuf = NULL;
     int valid_paramters = 1;
     write_buf = pcm_data;
     if (pcm_data == NULL || size == 0) {
         return 0;
     }
 
-    if (patch->dtv_decoder_state == AUDIO_DTV_PATCH_DECODER_STATE_INIT) {
+    if (patch->dtv_decoder_state == AUDIO_DTV_PATCH_DECODER_STATE_INIT ||
+        patch->dtv_decoder_state == AUDIO_DTV_PATCH_DECODER_STATE_PAUSE) {
         return 0;
     }
 
@@ -1586,6 +2246,11 @@ static int dtv_patch_pcm_wirte(unsigned char *pcm_data, int size,
         if (patch->chanmask == 1) {
             int16_t *buf = (int16_t *)write_buf;
             int i = 0, samples_num;
+            tmpbuf = (int16_t *)malloc(OUTPUT_BUFFER_SIZE * 2);
+            if (tmpbuf == NULL) {
+                ALOGE("malloc buffer failed\n");
+                return -1;
+            }
             samples_num = write_size / (patch->chanmask * sizeof(int16_t));
             for (; i < samples_num; i++) {
                 tmpbuf[2 * (samples_num - i) - 1] = buf[samples_num - i - 1];
@@ -1593,6 +2258,10 @@ static int dtv_patch_pcm_wirte(unsigned char *pcm_data, int size,
             }
             write_size = write_size * 2;
             write_buf = (unsigned char *)tmpbuf;
+            if (write_size > left || write_size > (OUTPUT_BUFFER_SIZE * 2)) {
+                ALOGI("resample, channel, write_size %d, left %d", write_size, left);
+                write_size = ((left) < (OUTPUT_BUFFER_SIZE * 2)) ? (left) : (OUTPUT_BUFFER_SIZE * 2);
+            }
         }
         if (need_resample == 1) {
             if (patch->dtv_resample.input_sr != (unsigned int)patch->sample_rate) {
@@ -1605,6 +2274,9 @@ static int dtv_patch_pcm_wirte(unsigned char *pcm_data, int size,
                 patch->resample_outbuf =
                     (unsigned char *)malloc(OUTPUT_BUFFER_SIZE * 3);
                 if (!patch->resample_outbuf) {
+                    if (tmpbuf) {
+                        free(tmpbuf);
+                    }
                     ALOGE("malloc buffer failed\n");
                     return -1;
                 }
@@ -1616,6 +2288,10 @@ static int dtv_patch_pcm_wirte(unsigned char *pcm_data, int size,
                                          (int16_t *)patch->resample_outbuf);
             write_size = out_frame << 2;
             write_buf = patch->resample_outbuf;
+            if (write_size > left || write_size > (OUTPUT_BUFFER_SIZE * 3)) {
+                ALOGI("resample, process, write_size %d, left %d", write_size, left);
+                write_size = ((left) < (OUTPUT_BUFFER_SIZE * 3)) ? (left) : (OUTPUT_BUFFER_SIZE * 3);
+            }
         }
     }
 
@@ -1651,6 +2327,10 @@ static int dtv_patch_pcm_wirte(unsigned char *pcm_data, int size,
     patch->dtv_pcm_writed += return_size;
 
     pthread_cond_signal(&patch->cond);
+    if (tmpbuf) {
+        free(tmpbuf);
+        tmpbuf = NULL;
+    }
     return return_size;
 }
 
@@ -1669,6 +2349,9 @@ static int dtv_patch_raw_wirte(unsigned char *raw_data, int size, void *args)
     }
 
     left = get_buffer_write_space(ringbuffer);
+    if (left < 0) {
+        return 0;
+    }
     if (left > size) {
         write_size = size;
     } else {
@@ -1679,31 +2362,6 @@ static int dtv_patch_raw_wirte(unsigned char *raw_data, int size, void *args)
                       UNCOVER_WRITE);
     return write_size;
 }
-static int raw_dump_fd = -1;
-void dump_raw_buffer(const void *data_buf, int size)
-{
-    ALOGI("enter the dump_raw_buffer save %d len data now\n", size);
-    if (raw_dump_fd < 0) {
-        if (access("/data/raw.es", 0) == 0) {
-            raw_dump_fd = open("/data/raw.es", O_RDWR);
-            if (raw_dump_fd < 0) {
-                ALOGE("%s, Open device file \"%s\" error: %s.\n", __FUNCTION__,
-                      "/data/raw.es", strerror(errno));
-            }
-        } else {
-            raw_dump_fd = open("/data/raw.es", O_RDWR);
-            if (raw_dump_fd < 0) {
-                ALOGE("%s, Create device file \"%s\" error: %s.\n", __FUNCTION__,
-                      "/data/raw.es", strerror(errno));
-            }
-        }
-    }
-
-    if (raw_dump_fd >= 0) {
-        write(raw_dump_fd, data_buf, size);
-    }
-    return;
-}
 
 extern int do_output_standby_l(struct audio_stream *stream);
 extern void adev_close_output_stream_new(struct audio_hw_device *dev,
@@ -1731,6 +2389,8 @@ void *audio_dtv_patch_output_threadloop(void *data)
     int write_bytes = DEFAULT_PLAYBACK_PERIOD_SIZE * PLAYBACK_PERIOD_COUNT;
     int ret;
     int apts_diff = 0;
+    unsigned char *mixbuffer = NULL;
+    unsigned char *ad_buffer = NULL;
 
     ALOGI("++%s live ", __FUNCTION__);
     // FIXME: get actual configs
@@ -1767,6 +2427,9 @@ void *audio_dtv_patch_output_threadloop(void *data)
 #else
     patch->output_src = AUDIO_DEVICE_OUT_AUX_DIGITAL;
 #endif
+    if (aml_dev->out_device & AUDIO_DEVICE_OUT_ALL_A2DP)
+        patch->output_src = aml_dev->out_device;
+
     ret = adev_open_output_stream_new(patch->dev, 0,
                                       patch->output_src,        // devices_t
                                       AUDIO_OUTPUT_FLAG_DIRECT, // flags
@@ -1778,17 +2441,28 @@ void *audio_dtv_patch_output_threadloop(void *data)
 
     ALOGI("++%s live create a output stream success now!!!\n ", __FUNCTION__);
 
+    mixbuffer = (unsigned char *)calloc(1, EAC3_IEC61937_FRAME_SIZE);
+    if (!mixbuffer) {
+        ret = -ENOMEM;
+        goto exit_outbuf;
+    }
+    ad_buffer = (unsigned char *)calloc(1, EAC3_IEC61937_FRAME_SIZE);
+    if (!ad_buffer) {
+        ret = -ENOMEM;
+        goto exit_outbuf;
+    }
     patch->out_buf_size = write_bytes * EAC3_MULTIPLIER;
     patch->out_buf = calloc(1, patch->out_buf_size);
     if (!patch->out_buf) {
         ret = -ENOMEM;
         goto exit_outbuf;
     }
-    memset(&patch->dtv_resample, 0, sizeof(struct resample_para));
-    patch->resample_outbuf = NULL;
     patch->dtv_audio_mode = get_dtv_audio_mode();
     patch->dtv_audio_tune = AUDIO_FREE;
     patch->first_apts_lookup_over = 0;
+    patch->tsync_mode = TSYNC_MODE_PCRMASTER;
+    patch->dtv_faded_out = 0;
+    patch->dtv_ac3_fmsize = 0;
     ALOGI("++%s live start output pcm now patch->output_thread_exit %d!!!\n ",
           __FUNCTION__, patch->output_thread_exit);
 
@@ -1813,8 +2487,6 @@ void *audio_dtv_patch_output_threadloop(void *data)
                 unsigned char ad_head[32];
                 int main_frame_size = 0, last_main_frame_size = 0, main_head_offset = 0, main_head_left = 0;
                 int ad_frame_size = 0, ad_head_offset = 0, ad_head_left = 0;
-                unsigned char mixbuffer[EAC3_IEC61937_FRAME_SIZE];
-                unsigned char ad_buffer[EAC3_IEC61937_FRAME_SIZE];
                 uint16_t *p16_mixbuff = NULL;
                 uint32_t *p32_mixbuff = NULL;
                 int main_size = 0, ad_size = 0, mix_size = 0;
@@ -1865,7 +2537,7 @@ void *audio_dtv_patch_output_threadloop(void *data)
                     } else if (patch->dtv_audio_tune == AUDIO_BREAK) {
                         unsigned int first_checkinapts = 0xffffffff;
                         unsigned int demux_pcr = 0xffffffff;
-                        int a_discontinue = get_audio_discontinue();
+                        int a_discontinue = get_audio_discontinue(patch);
                         dtv_set_audio_latency(apts_diff);
                         ret = aml_sysfs_get_str(TSYNC_LAST_CHECKIN_APTS, buff, sizeof(buff));
                         if (ret > 0) {
@@ -1890,11 +2562,17 @@ void *audio_dtv_patch_output_threadloop(void *data)
                         //ALOGI("dtv_audio_tune audio_lookup\n");
                         clean_dtv_patch_pts(patch);
                     } else if (patch->dtv_audio_tune == AUDIO_DROP) {
-                        dtv_do_drop_ac3(main_avail, patch, stream_out);
-                        clean_dtv_patch_pts(patch);
-                        patch->dtv_apts_lookup = 0;
-                        //ALOGI("dtv_audio_tune audio_latency\n");
-                        patch->dtv_audio_tune = AUDIO_LATENCY;
+                        aml_out = (struct aml_stream_out *)stream_out;
+                        dtv_do_drop_insert_ac3(patch, stream_out);
+                        if (patch->dtv_apts_lookup < 0 ||
+                            (patch->dtv_apts_lookup > 0 &&
+                            aml_out->need_drop_size == 0)) {
+                            clean_dtv_patch_pts(patch);
+                            patch->dtv_apts_lookup = 0;
+                            patch->ac3_pcm_dropping = 0;
+                            ALOGI("dtv_audio_tune audio_latency\n");
+                            patch->dtv_audio_tune = AUDIO_LATENCY;
+                        }
                     }
 
                     //dtv_assoc_get_main_frame_size(&main_frame_size);
@@ -1952,7 +2630,7 @@ void *audio_dtv_patch_output_threadloop(void *data)
                         }
                     }
 
-                    memset(ad_buffer, 0, sizeof(ad_buffer));
+                    memset(ad_buffer, 0, EAC3_IEC61937_FRAME_SIZE);
                     if (ad_frame_size > 0 && (ad_avail >= ad_frame_size - ad_head_left)) {
                         if (ad_head_left > 0) {
                             memcpy(ad_buffer, ad_head + ad_head_offset, ad_head_left);
@@ -1981,7 +2659,7 @@ void *audio_dtv_patch_output_threadloop(void *data)
                     dolby_ms12_get_pcm_output_size(&all_pcm_len1, &all_zero_len);
 
                     //package iec61937
-                    memset(mixbuffer, 0, sizeof(mixbuffer));
+                    memset(mixbuffer, 0, EAC3_IEC61937_FRAME_SIZE);
                     //papbpcpd
                     p16_mixbuff = (uint16_t*)mixbuffer;
                     p16_mixbuff[0] = 0xf872;
@@ -2053,6 +2731,7 @@ void *audio_dtv_patch_output_threadloop(void *data)
                 unsigned long long all_pcm_len1 = 0;
                 unsigned long long all_pcm_len2 = 0;
                 unsigned long long all_zero_len = 0;
+                aml_out = (struct aml_stream_out *)stream_out;
                 int avail = get_buffer_read_space(ringbuffer);
                 if (avail > 0) {
                     if (avail > (int)patch->out_buf_size) {
@@ -2064,26 +2743,35 @@ void *audio_dtv_patch_output_threadloop(void *data)
                         write_len = 512;
                     }
 
-                    if (aml_dev->ddp.curFrmSize != 0) {
+                    if (eDolbyMS12Lib == aml_dev->dolby_lib_type && aml_out->ddp_frame_size != 0) {
+                        write_len = aml_out->ddp_frame_size;
+                        patch->dtv_ac3_fmsize = aml_out->ddp_frame_size;
+                    } else if (eDolbyDcvLib == aml_dev->dolby_lib_type && aml_dev->ddp.curFrmSize != 0) {
                         write_len = aml_dev->ddp.curFrmSize;
+                        patch->dtv_ac3_fmsize = aml_dev->ddp.curFrmSize;
                     }
 
                     if (!patch->first_apts_lookup_over) {
                         apts_diff = dtv_set_audio_latency(0);
-                        if (!dtv_firstapts_lookup_over(patch, aml_dev, false) || avail < 512 * 2) {
+                        if (!dtv_firstapts_lookup_over(patch, aml_dev, avail, false) || avail < LOOKUP_AC3_MIN_BYTES) {
                             ALOGI("hold the aduio for cache data, avail %d", avail);
                             pthread_mutex_unlock(&(patch->dtv_output_mutex));
                             usleep(5000);
                             continue;
                         }
                         patch->first_apts_lookup_over = 1;
-                        patch->dtv_audio_tune = AUDIO_LOOKUP;
+                        if (patch->tsync_mode == TSYNC_MODE_PCRMASTER) {
+                            patch->dtv_audio_tune = AUDIO_LOOKUP;
+                        } else {
+                            patch->dtv_audio_tune = AUDIO_RUNNING;
+                        }
                         clean_dtv_patch_pts(patch);
                         //ALOGI("dtv_audio_tune audio_lookup\n");
                     } else if (patch->dtv_audio_tune == AUDIO_BREAK) {
-                        int a_discontinue = get_audio_discontinue();
+                        int a_discontinue = get_audio_discontinue(patch);
                         dtv_set_audio_latency(apts_diff);
-                        if (!dtv_firstapts_lookup_over(patch, aml_dev, true) && !a_discontinue) {
+                        if (!dtv_firstapts_lookup_over(patch, aml_dev, avail, true) || avail < LOOKUP_AC3_MIN_BYTES ||
+                            (a_discontinue && avail < LOOKUP_AC3_MIN_BYTES * 4)) {
                             ALOGI("hold the aduio for cache data, avail %d", avail);
                             pthread_mutex_unlock(&(patch->dtv_output_mutex));
                             usleep(5000);
@@ -2091,16 +2779,25 @@ void *audio_dtv_patch_output_threadloop(void *data)
                         }
                         patch->dtv_audio_tune = AUDIO_LOOKUP;
                         clean_dtv_patch_pts(patch);
+                        if (aml_dev->audio_ease) {
+                            aml_dev->patch_start = false;
+                        }
                         //ALOGI("dtv_audio_tune audio_lookup\n");
                     } else if (patch->dtv_audio_tune == AUDIO_DROP) {
-                        dtv_do_drop_ac3(avail, patch, stream_out);
-                        clean_dtv_patch_pts(patch);
-                        patch->dtv_apts_lookup = 0;
-                        patch->dtv_audio_tune = AUDIO_LATENCY;
-                        //ALOGI("dtv_audio_tune audio_latency\n");
+                        dtv_do_drop_insert_ac3(patch, stream_out);
+                        aml_out = (struct aml_stream_out *)stream_out;
+                        if (patch->dtv_apts_lookup < 0 ||
+                            (patch->dtv_apts_lookup > 0 &&
+                            aml_out->need_drop_size == 0)) {
+                            clean_dtv_patch_pts(patch);
+                            patch->dtv_apts_lookup = 0;
+                            patch->ac3_pcm_dropping = 0;
+                            patch->dtv_audio_tune = AUDIO_LATENCY;
+                            ALOGI("dtv_audio_tune ac3 audio_latency\n");
+                        }
                     }
-                    ret = ring_buffer_read(ringbuffer, (unsigned char *)patch->out_buf, write_len);
-                    if (ret == 0) {
+                    write_len = ring_buffer_read(ringbuffer, (unsigned char *)patch->out_buf, write_len);
+                    if (write_len == 0) {
                         pthread_mutex_unlock(&(patch->dtv_output_mutex));
                         /*ALOGE("%s(), ring_buffer read 0 data!", __func__);*/
                         usleep(1000);
@@ -2119,7 +2816,7 @@ void *audio_dtv_patch_output_threadloop(void *data)
                     } else {
                         remain_size = aml_dev->ddp.remain_size;
                     }
-                    ret = out_write_new(stream_out, patch->out_buf, ret);
+                    ret = out_write_new(stream_out, patch->out_buf, write_len);
                     if (eDolbyMS12Lib == aml_dev->dolby_lib_type) {
                         unsigned long long all_pcm_len = 0, all_zero_len = 0;
                         int size = dolby_ms12_get_main_buffer_avail(NULL);
@@ -2231,21 +2928,27 @@ void *audio_dtv_patch_output_threadloop(void *data)
                 }
                 if (!patch->first_apts_lookup_over) {
                     apts_diff = dtv_set_audio_latency(0);
-                    if (!dtv_firstapts_lookup_over(patch, aml_dev, false) || avail < 48 * 4 * 50) {
+                    if (!dtv_firstapts_lookup_over(patch, aml_dev, avail, false) || avail < LOOKUP_MPEG_MIN_BYTES) {
                         ALOGI("hold the aduio for cache data, avail %d", avail);
                         pthread_mutex_unlock(&(patch->dtv_output_mutex));
                         usleep(5000);
                         continue;
                     }
                     patch->first_apts_lookup_over = 1;
-                    patch->dtv_audio_tune = AUDIO_LOOKUP;
+                    if (patch->tsync_mode == TSYNC_MODE_PCRMASTER) {
+                        patch->dtv_audio_tune = AUDIO_LOOKUP;
+                    } else {
+                        patch->dtv_audio_tune = AUDIO_RUNNING;
+                    }
                     //ALOGI("dtv_audio_tune audio_lookup\n");
                     clean_dtv_patch_pts(patch);
                     patch->out_buf_size = out->config.period_size * audio_stream_out_frame_size(&out->stream);
+                    write_len = patch->out_buf_size;
                 } else if (patch->dtv_audio_tune == AUDIO_BREAK) {
-                    int a_discontinue = get_audio_discontinue();
+                    int a_discontinue = get_audio_discontinue(patch);
                     dtv_set_audio_latency(apts_diff);
-                    if (!dtv_firstapts_lookup_over(patch, aml_dev, true) && !a_discontinue) {
+                    if (!dtv_firstapts_lookup_over(patch, aml_dev, avail, true) || avail < LOOKUP_MPEG_MIN_BYTES ||
+                        (a_discontinue && avail < LOOKUP_MPEG_MIN_BYTES * 6)) {
                         ALOGI("hold the aduio for cache data, avail %d", avail);
                         pthread_mutex_unlock(&(patch->dtv_output_mutex));
                         usleep(5000);
@@ -2254,6 +2957,9 @@ void *audio_dtv_patch_output_threadloop(void *data)
                     patch->dtv_audio_tune = AUDIO_LOOKUP;
                     //ALOGI("dtv_audio_tune audio_lookup\n");
                     clean_dtv_patch_pts(patch);
+                    if (aml_dev->audio_ease) {
+                        aml_dev->patch_start = false;
+                    }
                 }
                 if (patch->dtv_audio_tune == AUDIO_DROP) {
                     dtv_do_drop_pcm(avail, patch, stream_out);
@@ -2286,6 +2992,14 @@ void *audio_dtv_patch_output_threadloop(void *data)
     free(patch->out_buf);
 exit_outbuf:
     adev_close_output_stream_new(dev, stream_out);
+    if (mixbuffer) {
+        free(mixbuffer);
+        mixbuffer = NULL;
+    }
+    if (ad_buffer) {
+        free(ad_buffer);
+        ad_buffer = NULL;
+    }
 exit_open:
     if (aml_dev->audio_ease) {
         aml_dev->patch_start = false;
@@ -2293,6 +3007,7 @@ exit_open:
     if (get_video_delay() != 0) {
         set_video_delay(0);
     }
+    decoder_stop_audio(patch);
     ALOGI("--%s live ", __FUNCTION__);
     return ((void *)0);
 }
@@ -2335,12 +3050,14 @@ static void *audio_dtv_patch_process_threadloop(void *data)
     int cmd = AUDIO_DTV_PATCH_CMD_NUM;
     struct dolby_ddp_dec *ddp_dec = &(aml_dev->ddp);
     struct dca_dts_dec *dts_dec = &(aml_dev->dts_hd);
+    pthread_mutex_lock(&patch->dtv_input_mutex);
     patch->sample_rate = stream_config.sample_rate = 48000;
     patch->chanmask = stream_config.channel_mask = AUDIO_CHANNEL_IN_STEREO;
     patch->aformat = stream_config.format = AUDIO_FORMAT_PCM_16_BIT;
+    patch->dtv_decoder_state = AUDIO_DTV_PATCH_DECODER_STATE_INIT;
+    pthread_mutex_unlock(&patch->dtv_input_mutex);
 
     ALOGI("++%s live \n", __FUNCTION__);
-    patch->dtv_decoder_state = AUDIO_DTV_PATCH_DECODER_STATE_INIT;
 
     while (!patch->input_thread_exit) {
         pthread_mutex_lock(&patch->dtv_input_mutex);
@@ -2349,8 +3066,8 @@ static void *audio_dtv_patch_process_threadloop(void *data)
         case AUDIO_DTV_PATCH_DECODER_STATE_INIT: {
             ALOGI("++%s live now  open the audio decoder now !\n", __FUNCTION__);
             dtv_patch_input_open(&adec_handle, dtv_patch_pcm_wirte,
-                                 dtv_patch_buffer_space,
-                                 dtv_patch_audio_info,patch);
+                                 dtv_patch_buffer_info,
+                                 dtv_patch_audio_info, patch);
             patch->dtv_decoder_state = AUDIO_DTV_PATCH_DECODER_STATE_START;
         }
         break;
@@ -2371,6 +3088,10 @@ static void *audio_dtv_patch_process_threadloop(void *data)
 
             if (cmd == AUDIO_DTV_PATCH_CMD_START) {
                 patch->dtv_decoder_state = AUDIO_DTV_PATCH_DECODER_STATE_RUNING;
+                memset(&patch->dtv_resample, 0, sizeof(struct resample_para));
+                if (patch->resample_outbuf) {
+                    memset(patch->resample_outbuf, 0, OUTPUT_BUFFER_SIZE * 3);
+                }
                 dtv_patch_input_start(adec_handle, patch->dtv_aformat,
                                       patch->dtv_has_video);
                 create_dtv_output_stream_thread(patch);
@@ -2380,7 +3101,10 @@ static void *audio_dtv_patch_process_threadloop(void *data)
                 patch->dtv_first_apts_flag = 0;
                 patch->outlen_after_last_validpts = 0;
                 patch->last_valid_pts = 0;
+                patch->last_out_pts = 0;
                 patch->first_apts_lookup_over = 0;
+                patch->ac3_pcm_dropping = 0;
+                patch->last_audio_delay = 0;
                 if (patch->dtv_aformat == ACODEC_FMT_AC3) {
                     patch->aformat = AUDIO_FORMAT_AC3;
                     ddp_dec->is_iec61937 = false;
@@ -2394,6 +3118,7 @@ static void *audio_dtv_patch_process_threadloop(void *data)
                 } else if (patch->dtv_aformat == ACODEC_FMT_DTS) {
                     patch->aformat = AUDIO_FORMAT_DTS;
                     dca_decoder_init_patch(dts_dec);
+                    dts_dec->is_dtv = true;
                     patch->decoder_offset = 0;
                     patch->first_apts_lookup_over = 0;
                 } else {
@@ -2433,11 +3158,16 @@ static void *audio_dtv_patch_process_threadloop(void *data)
             } else if (cmd == AUDIO_DTV_PATCH_CMD_STOP) {
                 ALOGI("++%s live now  stop  the audio decoder now \n",
                       __FUNCTION__);
-                release_dtv_output_stream_thread(patch);
-                dtv_adjust_output_clock(patch, DIRECT_NORMAL, DEFAULT_DTV_ADJUST_CLOCK);
-                dtv_do_ease_out(aml_dev);
                 dtv_patch_input_stop(adec_handle);
+                if (patch->dtv_faded_out == 0) {
+                    dtv_do_ease_out(aml_dev);
+                    patch->dtv_faded_out = 1;
+                    usleep(DTV_FADED_OUT_MS * 1000);
+                }
+                dtv_adjust_output_clock(patch, DIRECT_NORMAL, DEFAULT_DTV_ADJUST_CLOCK);
+                release_dtv_output_stream_thread(patch);
                 dtv_assoc_audio_stop(1);
+                dts_dec->is_dtv = false;
                 patch->dtv_decoder_state = AUDIO_DTV_PATCH_DECODER_STATE_INIT;
             } else {
                 ALOGI("++%s line %d  live state unsupport state %d cmd %d !\n",
@@ -2461,6 +3191,9 @@ static void *audio_dtv_patch_process_threadloop(void *data)
                 patch->dtv_decoder_state = AUDIO_DTV_PATCH_DECODER_STATE_RUNING;
             } else if (cmd == AUDIO_DTV_PATCH_CMD_STOP) {
                 ALOGI("++%s live now  stop  the audio decoder now \n", __FUNCTION__);
+                release_dtv_output_stream_thread(patch);
+                dtv_adjust_output_clock(patch, DIRECT_NORMAL, DEFAULT_DTV_ADJUST_CLOCK);
+                dtv_do_ease_out(aml_dev);
                 dtv_patch_input_stop(adec_handle);
                 dtv_assoc_audio_stop(1);
                 patch->dtv_decoder_state = AUDIO_DTV_PATCH_DECODER_STATE_INIT;
@@ -2500,14 +3233,16 @@ void release_dtvin_buffer(struct aml_audio_patch *patch)
 void dtv_in_write(struct audio_stream_out *stream, const void* buffer, size_t bytes)
 {
     struct aml_stream_out *out = (struct aml_stream_out *) stream;
-    struct aml_audio_device *adev = out->dev;
-    struct aml_audio_patch *patch = adev->audio_patch;
+    struct aml_audio_device *adev;
+    struct aml_audio_patch *patch;
     int abuf_level = 0;
 
     if (stream == NULL || buffer == NULL || bytes == 0) {
         ALOGI("[%s] pls check the input parameters \n", __FUNCTION__);
         return ;
     }
+    adev = out->dev;
+    patch = adev->audio_patch;
     if ((adev->patch_src == SRC_DTV) && (patch->dtvin_buffer_inited == 1)) {
         abuf_level = get_buffer_write_space(&patch->dtvin_ringbuffer);
         if (abuf_level <= (int)bytes) {
@@ -2523,12 +3258,13 @@ int dtv_in_read(struct audio_stream_in *stream, void* buffer, size_t bytes)
     int ret = 0;
     unsigned int es_length = 0;
     struct aml_stream_in *in = (struct aml_stream_in *)stream;
-    struct aml_audio_device *adev = in->dev;
 
     if (stream == NULL || buffer == NULL || bytes == 0) {
         ALOGI("[%s] pls check the input parameters \n", __FUNCTION__);
+        return 0;
     }
 
+    struct aml_audio_device *adev = in->dev;
     struct aml_audio_patch *patch = adev->audio_patch;
     struct dolby_ddp_dec *ddp_dec = & (adev->ddp);
     //ALOGI("[%s] patch->aformat=0x%x patch->dtv_decoder_ready=%d bytes:%d\n", __FUNCTION__,patch->aformat,patch->dtv_decoder_ready,bytes);
@@ -2638,10 +3374,6 @@ static int release_dtv_output_stream_thread(struct aml_audio_patch *patch)
 {
     int ret = 0;
     ALOGI("++%s   ---- %d\n", __FUNCTION__, patch->ouput_thread_created);
-    if (patch->resample_outbuf) {
-        free(patch->resample_outbuf);
-        patch->resample_outbuf = NULL;
-    }
     if (patch->ouput_thread_created == 1) {
         patch->output_thread_exit = 1;
         pthread_join(patch->audio_output_threadID, NULL);
@@ -2692,7 +3424,6 @@ int create_dtv_patch_l(struct audio_hw_device *dev, audio_devices_t input,
     patch->dev = dev;
     patch->input_src = input;
     patch->aformat = AUDIO_FORMAT_PCM_16_BIT;
-    patch->avsync_sample_max_cnt = AVSYNC_SAMPLE_MAX_CNT;
     patch->is_dtv_src = true;
 
     patch->output_thread_exit = 0;
@@ -2742,10 +3473,10 @@ int create_dtv_patch_l(struct audio_hw_device *dev, audio_devices_t input,
 
     ALOGI("--%s", __FUNCTION__);
     return 0;
-err_parse_thread:
+/*err_parse_thread:
 err_out_thread:
     patch->input_thread_exit = 1;
-    pthread_join(patch->audio_input_threadID, NULL);
+    pthread_join(patch->audio_input_threadID, NULL);*/
 err_in_thread:
     ring_buffer_release(&(patch->aml_ringbuffer));
 err_ring_buf:
@@ -2775,6 +3506,10 @@ int release_dtv_patch_l(struct aml_audio_device *aml_dev)
     pthread_join(patch->audio_input_threadID, NULL);
 
     pthread_mutex_destroy(&patch->dtv_input_mutex);
+    if (patch->resample_outbuf) {
+        free(patch->resample_outbuf);
+        patch->resample_outbuf = NULL;
+    }
     release_dtv_output_stream_thread(patch);
     release_dtvin_buffer(patch);
     dtv_assoc_deinit();
@@ -2806,8 +3541,12 @@ int create_dtv_patch(struct audio_hw_device *dev, audio_devices_t input,
 int release_dtv_patch(struct aml_audio_device *aml_dev)
 {
     int ret = 0;
-
-    dtv_do_ease_out(aml_dev);
+    struct aml_audio_patch *patch = aml_dev->audio_patch;
+    if (patch && !patch->dtv_faded_out) {
+        dtv_do_ease_out(aml_dev);
+        patch->dtv_faded_out = 1;
+        usleep(DTV_FADED_OUT_MS * 1000);
+    }
     pthread_mutex_lock(&aml_dev->patch_lock);
     ret = release_dtv_patch_l(aml_dev);
     pthread_mutex_unlock(&aml_dev->patch_lock);
diff --git a/audio_hal/audio_hw_insert_silence_data.c b/audio_hal/audio_hw_insert_silence_data.c
new file mode 100644
index 0000000..b8eda60
--- /dev/null
+++ b/audio_hal/audio_hw_insert_silence_data.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "audio_hw_primary"
+//#define LOG_NDEBUG 0
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <time.h>
+#include <inttypes.h>
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <sys/prctl.h>
+#include <utils/Timers.h>
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+#include <cutils/str_parms.h>
+#include <cutils/properties.h>
+#include <linux/ioctl.h>
+#include <hardware/hardware.h>
+#include <system/audio.h>
+#include <audio_utils/channels.h>
+#include "aml_DRC_param_gen.h"
+#include "aml_EQ_param_gen.h"
+
+#if ANDROID_PLATFORM_SDK_VERSION >= 25 //8.0
+#include <system/audio-base.h>
+#endif
+
+#include <hardware/audio.h>
+#include <sound/asound.h>
+#include <tinyalsa/asoundlib.h>
+#include <audio_route/audio_route.h>
+#include <aml_data_utils.h>
+#include <spdifenc_wrap.h>
+#include <aml_volume_utils.h>
+#include <aml_android_utils.h>
+#include <aml_alsa_mixer.h>
+
+#include "audio_format_parse.h"
+#include "aml_volume_utils.h"
+#include "aml_data_utils.h"
+#include "alsa_manager.h"
+#include "audio_hw.h"
+#include "audio_hw_utils.h"
+#include "alsa_manager.h"
+#include "alsa_device_parser.h"
+#include "aml_audio_stream.h"
+#include "alsa_config_parameters.h"
+#include "aml_avsync_tuning.h"
+#include "audio_a2dp_hw.h"
+
+int insert_silence_data(struct audio_stream_out *stream
+                  , const void *buffer
+                  , size_t bytes
+                  , int  adjust_ms
+                  , audio_format_t output_format)
+{
+    int ret = 0;
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device *adev = aml_out->dev;
+
+    if (adjust_ms) {
+        int adjust_bytes = 0;
+        if ((output_format == AUDIO_FORMAT_E_AC3) || (output_format == AUDIO_FORMAT_AC3)) {
+            int i = 0;
+            int bAtmos = 0;
+            int insert_frame = adjust_ms/32;
+            int raw_size = 0;
+            if (insert_frame > 0) {
+                char *raw_buf = NULL;
+                char *temp_buf = NULL;
+                /*atmos lock or input is ddp atmos*/
+                if (adev->atoms_lock_flag ||
+                    (adev->ms12.is_dolby_atmos && adev->ms12_main1_dolby_dummy == false)) {
+                    bAtmos = 1;
+                }
+                raw_buf = aml_audio_get_muteframe(output_format, &raw_size, bAtmos);
+                ALOGI("insert atmos=%d raw frame size=%d times=%d", bAtmos, raw_size, insert_frame);
+                if (raw_buf && (raw_size > 0)) {
+                    temp_buf = malloc(raw_size);
+                    if (!temp_buf) {
+                        ALOGE("%s malloc failed", __func__);
+                        pthread_mutex_unlock(&adev->alsa_pcm_lock);
+                        return -1;
+                    }
+                    for (i = 0; i < insert_frame; i++) {
+                        memcpy(temp_buf, raw_buf, raw_size);
+                        ret = aml_alsa_output_write(stream, (void*)temp_buf, raw_size, output_format);
+                        if (ret < 0) {
+                            ALOGE("%s alsa write fail when insert", __func__);
+                            break;
+                        }
+                    }
+                    free(temp_buf);
+                }
+            }
+        } else {
+            memset((void*)buffer, 0, bytes);
+            if (aml_out->a2dp_out) {
+                adjust_bytes = 48 * 4 * abs(adjust_ms); // 2ch 16bit
+            } else if (output_format == AUDIO_FORMAT_E_AC3) {
+                adjust_bytes = 192 * 4 * abs(adjust_ms);
+            } else if (output_format == AUDIO_FORMAT_AC3) {
+                adjust_bytes = 48 * 4 * abs(adjust_ms);
+            } else {
+                if (adev->is_TV) {
+                    adjust_bytes = 48 * 32 * abs(adjust_ms);    //8ch 32 bit.
+                } else {
+                    adjust_bytes = 48 * 4 * abs(adjust_ms); // 2ch 16bit
+                }
+            }
+            adjust_bytes &= ~255;
+            ALOGI("%s hwsync audio need %s %d ms,adjust bytes %d",
+                  __func__, adjust_ms > 0 ? "insert" : "skip", abs(adjust_ms), adjust_bytes);
+            if (adjust_ms > 0) {
+                char *buf = malloc(1024);
+                int write_size = 0;
+                if (!buf) {
+                    ALOGE("%s malloc failed", __func__);
+                    pthread_mutex_unlock(&adev->alsa_pcm_lock);
+                    return -1;
+                }
+                memset(buf, 0, 1024);
+                while (adjust_bytes > 0) {
+                    write_size = adjust_bytes > 1024 ? 1024 : adjust_bytes;
+#ifdef ENABLE_BT_A2DP
+                    if (adev->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+                        ret = a2dp_out_write(stream, (void*)buf, write_size);
+                    } else
+#endif
+                    {
+                        ret = aml_alsa_output_write(stream, (void*)buf, write_size, output_format);
+                    }
+                    if (ret < 0) {
+                        ALOGE("%s alsa write fail when insert", __func__);
+                        break;
+                    }
+                    adjust_bytes -= write_size;
+                }
+                free(buf);
+                buf = NULL;
+            }
+        }
+    }
+
+    return ret;
+}
+
+
diff --git a/audio_hal/audio_hw_insert_silence_data.h b/audio_hal/audio_hw_insert_silence_data.h
new file mode 100644
index 0000000..281d8d0
--- /dev/null
+++ b/audio_hal/audio_hw_insert_silence_data.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018-2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AUDIO_HW_INSERT_SILENCE_DATA_H_
+#define _AUDIO_HW_INSERT_SILENCE_DATA_H_
+
+
+/*
+ *@brief insert silence data
+ *
+ * input parameters
+ *     stream: audio_stream_out handle
+ *     buffer: data buffer address
+ *     bytes: data size
+ *     adjust_ms: duration of the insert data
+ *     output_format: data format
+ * output parameters
+ *     retunr: -1 occure some error
+ *              0 success
+ */
+
+int insert_silence_data(struct audio_stream_out *stream
+                  , const void *buffer
+                  , size_t bytes
+                  , int  adjust_ms
+                  , audio_format_t output_format);
+
+#endif
+
diff --git a/audio_hal/audio_hw_ms12.c b/audio_hal/audio_hw_ms12.c
index 576a14a..693f323 100644
--- a/audio_hal/audio_hw_ms12.c
+++ b/audio_hal/audio_hw_ms12.c
@@ -16,6 +16,7 @@
 
 #define LOG_TAG "audio_hw_primary"
 //#define LOG_NDEBUG 0
+#define __USE_GNU
 
 #include <cutils/log.h>
 #include <dolby_ms12.h>
@@ -36,14 +37,20 @@
 #include "dolby_lib_api.h"
 #include "aml_audio_timer.h"
 #include "audio_virtual_buf.h"
+#include "ac3_parser_utils.h"
+#include "aml_audio_ac3parser.h"
+#include "audio_hw_utils.h"
+#include "aml_audio_spdif_output.h"
+#include "aml_audio_ms12_bypass.h"
+#include "aml_audio_ac4parser.h"
+#include "aml_volume_utils.h"
+
 
-//#define DOLBY_MS12_OUTPUT_FORMAT_TEST
 
 #define DOLBY_DRC_LINE_MODE 0
 #define DOLBY_DRC_RF_MODE   1
-
 #define DDP_MAX_BUFFER_SIZE 2560//dolby ms12 input buffer threshold
-
+#define CONVERT_ONEDB_TO_GAIN  1.122018f
 #define MS12_MAIN_INPUT_BUF_NS (96000000LL)
 /*if we choose 96ms, it will cause audio filnger underrun,
   if we choose 64ms, it will cause ms12 underrun,
@@ -51,16 +58,25 @@
 */
 #define MS12_SYS_INPUT_BUF_NS  (84000000LL)
 
+#define NANO_SECOND_PER_SECOND 1000000000LL
+
 
 #define MS12_MAIN_BUF_INCREASE_TIME_MS (0)
 #define MS12_SYS_BUF_INCREASE_TIME_MS (1000)
+#define DDPI_UDC_COMP_LINE 2
+
 
+#define MS12_OUTPUT_PCM_FILE "/data/vendor/audiohal/ms12_pcm.raw"
+#define MS12_OUTPUT_BITSTREAM_FILE "/data/vendor/audiohal/ms12_bitstream.raw"
+#define MS12_INPUT_SYS_PCM_FILE "/data/vendor/audiohal/ms12_input_sys.pcm"
+#define MS12_INPUT_SYS_MAIN_FILE "/data/vendor/audiohal/ms12_input_main.raw"
+#define MS12_INPUT_SYS_MAIN_FILE2 "/data/vendor/audiohal/ms12_input_spdif.raw"
+#define MS12_INPUT_SYS_APP_FILE "/data/vendor/audiohal/ms12_input_app.pcm"
 
+#define MS12_MAIN_WRITE_RETIMES             (600)
+#define MS12_ATMOS_TRANSITION_THRESHOLD     (3)
 
-#define MS12_OUTPUT_PCM_FILE "/data/audio_out/ms12_pcm.raw"
-#define MS12_OUTPUT_BITSTREAM_FILE "/data/audio_out/ms12_bitstream.raw"
-#define MS12_INPUT_SYS_PCM_FILE "/data/audio_out/ms12_input_sys.pcm"
-#define MS12_INPUT_SYS_MAIN_FILE "/data/audio_out/ms12_input_main.raw"
+static int nbytes_of_dolby_ms12_downmix_output_pcm_frame();
 
 
 /*
@@ -68,7 +84,7 @@
  */
 static void dump_ms12_output_data(void *buffer, int size, char *file_name)
 {
-    if (aml_getprop_bool("media.audiohal.outdump.ms12")) {
+    if (aml_getprop_bool("media.audiohal.outdump")) {
         FILE *fp1 = fopen(file_name, "a+");
         if (fp1) {
             int flen = fwrite((char *)buffer, 1, size, fp1);
@@ -80,16 +96,145 @@ static void dump_ms12_output_data(void *buffer, int size, char *file_name)
 
 static void *dolby_ms12_threadloop(void *data);
 
-static int _get_ms12_output_config(audio_format_t format)
+static void set_ms12_out_ddp_5_1(audio_format_t input_format, bool is_sink_supported_ddp_atmos)
+{
+    /*In case of AC-4 or Dolby Digital Plus input, set legacy ddp out ON/OFF*/
+    bool is_ddp = (input_format == AUDIO_FORMAT_AC3) || (input_format == AUDIO_FORMAT_E_AC3);
+    bool is_ac4 = (input_format == AUDIO_FORMAT_AC4);
+    if (is_ddp || is_ac4) {
+        bool is_out_ddp_5_1 = !is_sink_supported_ddp_atmos;
+        /*
+         *case1 support ddp atmos(is_out_ddp_5_1 as false), MS12 should output Dolby Atmos as 5.1.2
+         *case2 only support ddp(is_out_ddp_5_1 as true), MS12 should downmix Atmos signals rendered from 5.1.2 to 5.1
+         *It only effect the DDP-Atmos(5.1.2) output.
+         *1.ATMOS INPUT, the ddp encoder output will output DDP-ATMOS
+         *2.None-Atmos and Continuous with -atmos_lock=1,the ddp encoder output will output DDP-ATMOS.
+         */
+        dolby_ms12_set_ddp_5_1_out(is_out_ddp_5_1);
+    }
+}
+
+bool is_platform_supported_ddp_atmos(bool atmos_supported, enum OUT_PORT current_out_port)
 {
-    if (format == AUDIO_FORMAT_AC3)
-        return MS12_OUTPUT_MASK_DD;
-    else if (format == AUDIO_FORMAT_E_AC3)
-        return MS12_OUTPUT_MASK_DDP;
-    else if (format == AUDIO_FORMAT_MAT)
-        return MS12_OUTPUT_MASK_MAT;
+    if (current_out_port == OUTPORT_HDMI_ARC) {
+        /*ARC case*/
+        return atmos_supported;
+    }
+    else {
+        /*SPEAKER/HEADPHONE case*/
+        return true;
+    }
+
+}
+
+bool is_ms12_out_ddp_5_1_suitable(bool is_ddp_atmos)
+{
+    bool is_ms12_out_ddp_5_1 = dolby_ms12_get_ddp_5_1_out();
+    bool is_sink_only_ddp_5_1 = !is_ddp_atmos;
+
+    if (is_ms12_out_ddp_5_1 == is_sink_only_ddp_5_1) {
+        /*
+         *Sink device can decode MS12 DDP bitstream correctly
+         *case1 Sink device Support DDP ATMOS, MS12 output DDP-ATMOS(5.1.2)
+         *case2 Sink device Support DDP, MS12 output DDP(5.1)
+         */
+        return true;
+    } else {
+        /*
+         *case1 Sink device support DDP ATMOS, but MS12 output DDP(5.1)
+         *case2 Sink device support DDP 5.1, but MS12 output DDP-ATMOS(5.1.2)
+         *should reconfig the parameter about MS12 output DDP bitstream.
+         */
+        return false;
+    }
+}
+
+/*
+ *@brief get ms12 output configure mask
+ */
+static int get_ms12_output_mask(audio_format_t sink_format,audio_format_t  optical_format,bool is_arc)
+{
+    int  output_config;
+    if (sink_format == AUDIO_FORMAT_E_AC3)
+        output_config =  MS12_OUTPUT_MASK_DDP;
+    else if (sink_format == AUDIO_FORMAT_AC3)
+        output_config = MS12_OUTPUT_MASK_DD;
+    else if (sink_format == AUDIO_FORMAT_MAT)
+        output_config = MS12_OUTPUT_MASK_MAT;
+    else if (sink_format == AUDIO_FORMAT_PCM_16_BIT && optical_format == AUDIO_FORMAT_AC3)
+        output_config = MS12_OUTPUT_MASK_DD | MS12_OUTPUT_MASK_SPEAKER;
+    else if (sink_format == AUDIO_FORMAT_PCM_16_BIT && optical_format == AUDIO_FORMAT_E_AC3)
+        output_config = MS12_OUTPUT_MASK_DDP | MS12_OUTPUT_MASK_SPEAKER;
+    else if (sink_format == AUDIO_FORMAT_PCM_16_BIT && optical_format == AUDIO_FORMAT_MAT)
+        output_config = MS12_OUTPUT_MASK_MAT | MS12_OUTPUT_MASK_SPEAKER;
+    else if (is_arc)
+        output_config = MS12_OUTPUT_MASK_STEREO;
     else
-        return MS12_OUTPUT_MASK_SPEAKER;
+        output_config = MS12_OUTPUT_MASK_SPEAKER | MS12_OUTPUT_MASK_STEREO;
+    return output_config;
+}
+
+
+static void update_ms12_atmos_info(struct dolby_ms12_desc *ms12) {
+    int is_atmos = 0;
+
+    is_atmos = (dolby_ms12_get_input_atmos_info() == 1);
+    /*atmos change from 1 to 0, we need a threshold cnt*/
+    if (ms12->is_dolby_atmos && !is_atmos) {
+        ms12->atmos_info_change_cnt++;
+        if (ms12->atmos_info_change_cnt > MS12_ATMOS_TRANSITION_THRESHOLD) {
+            ms12->is_dolby_atmos = 0;
+        } else {
+            ms12->is_dolby_atmos = 1;
+        }
+    } else {
+        ms12->atmos_info_change_cnt = 0;
+        ms12->is_dolby_atmos = is_atmos;
+    }
+    ALOGV("atmos =%d new =%d cnt=%d",ms12->is_dolby_atmos, is_atmos, ms12->atmos_info_change_cnt);
+    return;
+}
+
+void set_ms12_ad_mixing_enable(struct dolby_ms12_desc *ms12, int ad_mixing_enable)
+{
+    char parm[12] = "";
+    sprintf(parm, "%s %d", "-xa", ad_mixing_enable);
+    if (strlen(parm) > 0)
+        aml_ms12_update_runtime_params(ms12, parm);
+}
+
+void set_ms12_ad_mixing_level(struct dolby_ms12_desc *ms12, int mixing_level)
+{
+    char parm[12] = "";
+    sprintf(parm, "%s %d", "-xu", mixing_level);
+    if (strlen(parm) > 0)
+        aml_ms12_update_runtime_params(ms12, parm);
+}
+
+void set_dolby_ms12_runtime_pause(struct dolby_ms12_desc *ms12, int is_pause)
+{
+    char parm[12] = "";
+    sprintf(parm, "%s %d", "-pause", is_pause);
+    if ((strlen(parm) > 0) && ms12) {
+        aml_ms12_update_runtime_params(ms12, parm);
+    }
+}
+
+void set_dolby_ms12_runtime_system_mixing_enable(struct dolby_ms12_desc *ms12, int system_mixing_enable)
+{
+    char parm[12] = "";
+    sprintf(parm, "%s %d", "-xs", system_mixing_enable);
+    if ((strlen(parm) > 0) && ms12) {
+        aml_ms12_update_runtime_params(ms12, parm);
+    }
+}
+
+void set_ms12_atmos_lock(struct dolby_ms12_desc *ms12, bool is_atmos_lock_on)
+{
+    char parm[64] = "";
+    sprintf(parm, "%s %d", "-atmos_lock", is_atmos_lock_on);
+    if ((strlen(parm)) > 0 && ms12)
+        aml_ms12_update_runtime_params(ms12, parm);
 }
 
 /*
@@ -101,14 +246,18 @@ int get_the_dolby_ms12_prepared(
     , audio_channel_mask_t input_channel_mask
     , int input_sample_rate)
 {
-    ALOGD("+%s()", __FUNCTION__);
+    ALOGI("+%s()", __FUNCTION__);
     struct aml_audio_device *adev = aml_out->dev;
     struct dolby_ms12_desc *ms12 = &(adev->ms12);
     int dolby_ms12_drc_mode = DOLBY_DRC_RF_MODE;
     struct aml_stream_out *out;
-    ALOGD("\n+%s()", __FUNCTION__);
+    int drc_mode = 0;
+    int drc_cut = 0;
+    int drc_boost = 0;
+    struct aml_audio_patch *patch = adev->audio_patch;
+    ALOGI("\n+%s()", __FUNCTION__);
     pthread_mutex_lock(&ms12->lock);
-    ALOGD("++%s(), locked", __FUNCTION__);
+    ALOGI("++%s(), locked", __FUNCTION__);
     set_audio_system_format(AUDIO_FORMAT_PCM_16_BIT);
     /*
     when HDMITX send pause frame,we treated as INVALID format.
@@ -117,34 +266,24 @@ int get_the_dolby_ms12_prepared(
     if (input_format == AUDIO_FORMAT_INVALID) {
         input_format = AUDIO_FORMAT_PCM_16_BIT;
     }
+    set_audio_app_format(AUDIO_FORMAT_PCM_16_BIT);
     set_audio_main_format(input_format);
-    ALOGD("+%s() dual_decoder_support %d\n", __FUNCTION__, adev->dual_decoder_support);
-
-#ifdef DOLBY_MS12_OUTPUT_FORMAT_TEST
-    {
-        char buf[PROPERTY_VALUE_MAX];
-        int prop_ret = -1;
-        int out_format = 0;
-        prop_ret = property_get("dolby.ms12.output.format", buf, NULL);
-        if (prop_ret > 0) {
-            out_format = atoi(buf);
-            if (out_format == 0) {
-                adev->sink_format = AUDIO_FORMAT_PCM_16_BIT;
-                ALOGI("DOLBY_MS12_OUTPUT_FORMAT_TEST %d\n", (unsigned int)adev->sink_format);
-            } else if (out_format == 1) {
-                adev->sink_format = AUDIO_FORMAT_AC3;
-                ALOGI("DOLBY_MS12_OUTPUT_FORMAT_TEST %d\n", (unsigned int)adev->sink_format);
-            } else if (out_format == 2) {
-                adev->sink_format = AUDIO_FORMAT_E_AC3;
-                ALOGI("DOLBY_MS12_OUTPUT_FORMAT_TEST %d\n", (unsigned int)adev->sink_format);
-            }
-        }
-    }
-#endif
-
-    if ((input_format == AUDIO_FORMAT_AC3) || (input_format == AUDIO_FORMAT_E_AC3)) {
-        dolby_ms12_drc_mode = DOLBY_DRC_RF_MODE;
-    } else {
+    ALOGI("+%s() dual_decoder_support %d\n", __FUNCTION__, adev->dual_decoder_support);
+
+    if (0 == aml_audio_get_dolby_drc_mode(&drc_mode, &drc_cut, &drc_boost))
+        dolby_ms12_drc_mode = (drc_mode == DDPI_UDC_COMP_LINE) ? DOLBY_DRC_LINE_MODE : DOLBY_DRC_RF_MODE;
+    //for mul-pcm
+    dolby_ms12_set_drc_boost(drc_boost);
+    dolby_ms12_set_drc_cut(drc_cut);
+    //for 2-channel downmix
+    dolby_ms12_set_drc_boost_stereo(drc_boost);
+    dolby_ms12_set_drc_cut_stereo(drc_cut);
+    /*
+     * if main input is hdmi-in/dtv/other-source PCM
+     * would not go through the DRC processing
+     * DRC LineMode means to bypass DRC processing.
+     */
+    if (audio_is_linear_pcm(input_format)) {
         dolby_ms12_drc_mode = DOLBY_DRC_LINE_MODE;
     }
 
@@ -152,48 +291,55 @@ int get_the_dolby_ms12_prepared(
     if (adev->dual_decoder_support == true) {
         set_audio_associate_format(input_format);
         ALOGI("%s set_audio_associate_format %#x", __FUNCTION__, input_format);
-        dolby_ms12_set_asscociated_audio_mixing(adev->associate_audio_mixing_enable);
-        dolby_ms12_set_user_control_value_for_mixing_main_and_associated_audio(adev->mixing_level);
-        ALOGI("%s associate_audio_mixing_enable %d mixing_level set to %d\n",
-              __FUNCTION__, adev->associate_audio_mixing_enable, adev->mixing_level);
-        // fix for -xs configration
-        //int ms12_runtime_update_ret = aml_ms12_update_runtime_params(&(adev->ms12));
-        //ALOGI("aml_ms12_update_runtime_params return %d\n", ms12_runtime_update_ret);
     }
+    dolby_ms12_set_asscociated_audio_mixing(adev->associate_audio_mixing_enable);
+    dolby_ms12_set_user_control_value_for_mixing_main_and_associated_audio(adev->mixing_level);
+
     dolby_ms12_set_drc_mode(dolby_ms12_drc_mode);
+    dolby_ms12_set_dap_drc_mode(dolby_ms12_drc_mode);
     ALOGI("%s dolby_ms12_set_drc_mode %s", __FUNCTION__, (dolby_ms12_drc_mode == DOLBY_DRC_RF_MODE) ? "RF MODE" : "LINE MODE");
     int ret = 0;
 
     /*set the continous output flag*/
     set_dolby_ms12_continuous_mode((bool)adev->continuous_audio_mode);
     dolby_ms12_set_atmos_lock_flag(adev->atoms_lock_flag);
+
+    /*set the dolby ms12 debug level*/
+    dolby_ms12_enable_debug();
+
+    /*
+     *In case of AC-4 or Dolby Digital Plus input,
+     *set output DDP bitstream format DDP Atmos(5.1.2) or DDP(5.1)
+     */
+    bool is_atmos_supported = is_platform_supported_ddp_atmos(adev->hdmi_descs.ddp_fmt.atmos_supported, adev->active_outport);
+    set_ms12_out_ddp_5_1(input_format, is_atmos_supported);
+
     /* create  the ms12 output stream here */
     /*************************************/
     if (continous_mode(adev)) {
         // TODO: zz: Might have memory leak, not clear route to release this pointer
         out = (struct aml_stream_out *)calloc(1, sizeof(struct aml_stream_out));
         if (!out) {
-            ALOGE("%s malloc  stream failed failed", __func__);
-            return -ENOMEM;
+            ALOGE("%s malloc stream failed", __func__);
+            goto Err;
         }
         /* copy stream information */
         memcpy(out, aml_out, sizeof(struct aml_stream_out));
         if (adev->is_TV) {
+            out->is_tv_platform  = 1;
             out->config.channels = 8;
-            out->config.format = PCM_FORMAT_S32_LE;
+            out->config.format = PCM_FORMAT_S16_LE;
             out->tmp_buffer_8ch = malloc(out->config.period_size * 4 * 8);
             if (out->tmp_buffer_8ch == NULL) {
-                free(out);
                 ALOGE("%s cannot malloc memory for out->tmp_buffer_8ch", __func__);
-                return -ENOMEM;
+                goto Err_tmp_buf_8ch;
+
             }
             out->tmp_buffer_8ch_size = out->config.period_size * 4 * 8;
             out->audioeffect_tmp_buffer = malloc(out->config.period_size * 6);
             if (out->audioeffect_tmp_buffer == NULL) {
-                free(out->tmp_buffer_8ch);
-                free(out);
                 ALOGE("%s cannot malloc memory for audioeffect_tmp_buffer", __func__);
-                return -ENOMEM;
+                goto Err_audioeffect_tmp_buf;
             }
         }
         ALOGI("%s create ms12 stream %p,original stream %p", __func__, out, aml_out);
@@ -209,33 +355,33 @@ int get_the_dolby_ms12_prepared(
     }
     dolby_ms12_set_system_app_audio_mixing(adev->system_app_mixing_status);
 
-    //init the dolby ms12
-    if (out->dual_output_flag) {
-        int output_config = _get_ms12_output_config(adev->optical_format);
-        aml_ms12_config(ms12, input_format, input_channel_mask, input_sample_rate, output_config | MS12_OUTPUT_MASK_SPEAKER);
-    } else {
-        int output_config = _get_ms12_output_config(adev->sink_format);
-        aml_ms12_config(ms12, input_format, input_channel_mask, input_sample_rate, output_config);
+#if 0
+    int output_config = MS12_OUTPUT_MASK_SPEAKER | MS12_OUTPUT_MASK_DD | MS12_OUTPUT_MASK_DDP | MS12_OUTPUT_MASK_STEREO;
+    /*we reconfig the ms12 nodes depending on the user case when digital input case to refine ms12 perfermance*/
+    if (patch && \
+           (patch->input_src == AUDIO_DEVICE_IN_HDMI || patch->input_src == AUDIO_DEVICE_IN_SPDIF)) {
+        output_config = get_ms12_output_mask(adev->sink_format, adev->optical_format,adev->active_outport == OUTPORT_HDMI_ARC);
     }
+#else
+    // Currently we only enable max one PCM and one bitstream (DD/DDP/MAT) output
+    int output_config = get_ms12_output_mask(adev->sink_format, adev->optical_format,adev->active_outport == OUTPORT_HDMI_ARC);
+#endif
+
+    aml_ms12_config(ms12, input_format, input_channel_mask, input_sample_rate,output_config);
     if (ms12->dolby_ms12_enable) {
         //register Dolby MS12 callback
         dolby_ms12_register_output_callback(ms12_output, (void *)out);
-        ms12->device = usecase_device_adapter_with_ms12(out->device, adev->sink_format);
-        ALOGI("%s out [dual_output_flag %d] adev [format sink %#x optical %#x] ms12 [output-config %#x device %d]",
+        ms12->device = usecase_device_adapter_with_ms12(out->device,AUDIO_FORMAT_PCM_16_BIT/* adev->sink_format*/);
+        ALOGI("%s out [dual_output_flag %d] adev [format sink %#x optical %#x] ms12 [output-format %#x device %d]",
               __FUNCTION__, out->dual_output_flag, adev->sink_format, adev->optical_format, ms12->output_config, ms12->device);
         memcpy((void *) & (adev->ms12_config), (const void *) & (out->config), sizeof(struct pcm_config));
         get_hardware_config_parameters(
             &(adev->ms12_config)
-            , adev->sink_format
-            /* for tv_platform, the I2S PCM output is always 8 channel, and because there are
-             * other processing like 16->32 bit change and 2->8 channel change, the ALSA device
-             * channel number should not be related to ms12 output channelmask
-             * hard code to 8 channel firstly for tv_platform.
-             * TODO: for non_tv_platform
-             */
-            , (out->is_tv_platform) ? 8: audio_channel_count_from_out_mask(ms12->output_channelmask)
+            ,AUDIO_FORMAT_PCM_16_BIT/* adev->sink_format*/
+            , audio_channel_count_from_out_mask(ms12->output_channelmask)
             , ms12->output_samplerate
-            , out->is_tv_platform);
+            , out->is_tv_platform
+            , continous_mode(adev));
 
         if (continous_mode(adev)) {
             ms12->dolby_ms12_thread_exit = false;
@@ -246,22 +392,45 @@ int get_the_dolby_ms12_prepared(
             }
             ALOGI("%s() thread is builded, get dolby_ms12_threadID %ld\n", __FUNCTION__, ms12->dolby_ms12_threadID);
         }
+        //n bytes of dowmix output pcm frame, 16bits_per_sample / stereo, it value is 4btes.
+        ms12->nbytes_of_dmx_output_pcm_frame = nbytes_of_dolby_ms12_downmix_output_pcm_frame();
+        ms12->hdmi_format = adev->hdmi_format;
+        ms12->optical_format = adev->optical_format;
+        ms12->main_input_fmt = input_format;
+        ms12->main_input_sr = input_sample_rate;
     }
-    ALOGD("--%s(), locked", __FUNCTION__);
+    ms12->sys_audio_base_pos = adev->sys_audio_frame_written;
+    ALOGI("set ms12 sys pos =%lld", ms12->sys_audio_base_pos);
+    aml_ac3_parser_open(&ms12->ac3_parser_handle);
+    aml_ms12_bypass_open(&ms12->ms12_bypass_handle);
+    ring_buffer_init(&ms12->spdif_ring_buffer, ms12->dolby_ms12_out_max_size);
+    ms12->lpcm_temp_buffer = (unsigned char*)malloc(ms12->dolby_ms12_out_max_size);
+    if (!ms12->lpcm_temp_buffer) {
+        ALOGE("%s malloc lpcm_temp_buffer failed", __func__);
+        if (continous_mode(adev))
+            goto Err_dolby_ms12_thread;
+        else
+            goto Err;
+    }
+    ALOGI("--%s(), locked", __FUNCTION__);
     pthread_mutex_unlock(&ms12->lock);
-    ALOGD("-%s()\n\n", __FUNCTION__);
+    ALOGI("-%s()\n\n", __FUNCTION__);
     return ret;
 
 Err_dolby_ms12_thread:
     if (continous_mode(adev)) {
-        ALOGE("%s() %d exit dolby_ms12_thread\n", __FUNCTION__, __LINE__);
-        ms12->dolby_ms12_thread_exit = true;
-        ms12->dolby_ms12_threadID = 0;
-        free(out->tmp_buffer_8ch);
+        if (ms12->dolby_ms12_enable) {
+            ALOGE("%s() %d exit dolby_ms12_thread\n", __FUNCTION__, __LINE__);
+            ms12->dolby_ms12_thread_exit = true;
+            ms12->dolby_ms12_threadID = 0;
+        }
         free(out->audioeffect_tmp_buffer);
-        free(out);
     }
-
+Err_audioeffect_tmp_buf:
+    free(out->tmp_buffer_8ch);
+Err_tmp_buf_8ch:
+    free(out);
+Err:
     pthread_mutex_unlock(&ms12->lock);
     return ret;
 }
@@ -278,6 +447,119 @@ static bool is_iec61937_format(struct audio_stream_out *stream)
     */
     return (aml_out->hal_format == AUDIO_FORMAT_IEC61937);
 }
+
+bool is_bypass_ms12(struct audio_stream_out *stream) {
+    bool bypass_ms12 = false;
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+    struct aml_audio_device *adev = aml_out->dev;
+    struct dolby_ms12_desc *ms12 = &(adev->ms12);
+
+    if (adev->hdmi_format == BYPASS && ms12->optical_format == aml_out->hal_internal_format) {
+        if (aml_out->hal_internal_format == AUDIO_FORMAT_E_AC3 ||
+            aml_out->hal_internal_format == AUDIO_FORMAT_AC3) {
+            /*current we only support 48k ddp/dd bypass*/
+            if (aml_out->hal_rate == 48000) {
+                   bypass_ms12 = true;
+            }
+        }
+    }
+    return bypass_ms12;
+}
+
+static void endian16_convert(void *buf, int size)
+{
+    int i;
+    unsigned short *p = (unsigned short *)buf;
+    for (i = 0; i < size / 2; i++, p++) {
+        *p = ((*p & 0xff) << 8) | ((*p) >> 8);
+    }
+}
+
+static int scan_dolby_frame_info(const unsigned char *frame_buf,
+        int length,
+        int *frame_offset,
+        int *frame_size,
+        int *frame_numblocks,
+        int *framevalid_flag)
+{
+    int scan_frame_offset;
+    int scan_frame_size;
+    int scan_channel_num;
+    int scan_numblks;
+    int scan_timeslice_61937;
+    // int scan_framevalid_flag;
+    int ret = 0;
+    int total_channel_num  = 0;
+
+    if (!frame_buf || (length <= 0) || !frame_offset || !frame_size || !frame_numblocks || !framevalid_flag) {
+        ret = -1;
+    } else {
+        ret = parse_dolby_frame_header(frame_buf, length, &scan_frame_offset, &scan_frame_size
+                                       , &scan_channel_num, &scan_numblks,
+                                       &scan_timeslice_61937, framevalid_flag);
+
+        if (ret == 0) {
+            *frame_offset = scan_frame_offset;
+            *frame_size = scan_frame_size;
+            *frame_numblocks = scan_numblks;
+            //this scan is useful, return 0
+            return 0;
+        }
+    }
+    //this scan is useless, return -1
+    return -1;
+}
+
+/*dtv single decoder, if input data is less than one iec61937 size, and do not contain one complete frame
+ *after adding the frame_deficiency, got a complete frame without scan the frame
+ *keyword: frame_deficiency
+ */
+bool is_frame_lack_of_data_in_dtv(struct audio_stream_out *stream)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+    struct aml_audio_device *adev = aml_out->dev;
+
+    return (!adev->dual_decoder_support
+        && (is_iec61937_format(stream) || aml_out->hal_format == AUDIO_FORMAT_IEC61937)
+        && (aml_out->frame_deficiency > 0));
+}
+
+/*
+ *in continuous mode, the dolby frame will be splited into several part
+ *because of out_get_buffer_size is an stable size, but the dolby frame size is variable.
+ */
+bool is_frame_lack_of_data_in_continuous(struct audio_stream_out *stream)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+    struct aml_audio_device *adev = aml_out->dev;
+
+    bool is_lack = (adev->continuous_audio_mode == 1) \
+                    && ((aml_out->hal_format == AUDIO_FORMAT_AC3) || (aml_out->hal_format == AUDIO_FORMAT_E_AC3)) \
+                    && (aml_out->frame_deficiency > 0);
+
+    return is_lack;
+}
+
+
+int dolby_ms12_bypass_process(
+    struct audio_stream_out *stream
+    , const void *buffer
+    , size_t bytes) {
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+    struct aml_audio_device *adev = aml_out->dev;
+    struct dolby_ms12_desc *ms12 = &(adev->ms12);
+
+    if (is_bypass_ms12(stream)) {
+        /*for HDMI in IEC61937 format, we support passthrough it*/
+        if (is_iec61937_format(stream)) {
+            aml_audio_spdif_output_direct(stream, (void*)buffer, bytes, aml_out->hal_internal_format);
+            ALOGV("IEC61937 bypass out size=%d", bytes);
+        }
+    }
+    return 0;
+}
+
+
 /*
  *@brief dolby ms12 main process
  *
@@ -312,26 +594,37 @@ int dolby_ms12_main_process(
     void *associate_frame_buffer = NULL;
     int associate_frame_size = 0;
     size_t main_frame_deficiency = 0;
+    int32_t parser_used_size = 0;
+    int dependent_frame = 0;
+    int sample_rate = 48000;
+    struct ac4_parser_info ac4_info = { 0 };
 
     if (adev->debug_flag >= 2) {
         ALOGI("\n%s() in continuous %d input ms12 bytes %d input bytes %zu\n",
               __FUNCTION__, adev->continuous_audio_mode, dolby_ms12_input_bytes, input_bytes);
     }
 
+    /*this status is only updated in hw_write, continuous mode also need it*/
+    if (adev->continuous_audio_mode) {
+        if (aml_out->status != STREAM_HW_WRITING) {
+            aml_out->status = STREAM_HW_WRITING;
+        }
+    }
+
     /*I can't find where to init this, so I put it here*/
     if ((ms12->main_virtual_buf_handle == NULL) && adev->continuous_audio_mode == 1) {
         /*set the virtual buf size to 96ms*/
-        audio_virtual_buf_open(&ms12->main_virtual_buf_handle, "ms12 main input", MS12_MAIN_INPUT_BUF_NS, MS12_MAIN_INPUT_BUF_NS, MS12_MAIN_BUF_INCREASE_TIME_MS);
+        audio_virtual_buf_open(&ms12->main_virtual_buf_handle
+            , "ms12 main input"
+            , MS12_MAIN_INPUT_BUF_NS
+            , MS12_MAIN_INPUT_BUF_NS
+            , MS12_MAIN_BUF_INCREASE_TIME_MS);
     }
 
-    //dtv single decoder, if input data is less than one iec61937 size, and do not contain one complete frame
-    //after adding the frame_deficiency, got a complete frame without scan the frame
-    //keyword: frame_deficiency
-    if (!adev->dual_decoder_support
-        && (is_iec61937_format(stream) || aml_out->hal_format == AUDIO_FORMAT_IEC61937)
-        && (aml_out->frame_deficiency > 0)) {
-        //ALOGI("\n%s() frame_deficiency = %d , input bytes = %d\n",__FUNCTION__, aml_out->frame_deficiency , input_bytes);
-        if (aml_out->frame_deficiency <= input_bytes) {
+    if (is_frame_lack_of_data_in_dtv(stream)) {
+        ALOGV("\n%s() frame_deficiency = %d , input bytes = %d\n",
+            __FUNCTION__, aml_out->frame_deficiency , input_bytes);
+        if (aml_out->frame_deficiency <= (int)input_bytes) {
             main_frame_size = aml_out->frame_deficiency;
             single_decoder_used_bytes = aml_out->frame_deficiency;
             aml_out->frame_deficiency = 0;
@@ -343,6 +636,21 @@ int dolby_ms12_main_process(
         goto MAIN_INPUT;
     }
 
+    if (is_frame_lack_of_data_in_continuous(stream)) {
+        ALOGV("\n%s() frame_deficiency = %d , input bytes = %d\n",
+            __FUNCTION__, aml_out->frame_deficiency , input_bytes);
+        if (aml_out->frame_deficiency <= (int)input_bytes) {
+            main_frame_size = aml_out->frame_deficiency;
+            single_decoder_used_bytes = aml_out->frame_deficiency;
+            // aml_out->frame_deficiency = 0;
+        } else {
+            main_frame_size = input_bytes;
+            single_decoder_used_bytes = input_bytes;
+            // aml_out->frame_deficiency -= input_bytes;
+        }
+        goto MAIN_INPUT;
+    }
+
     if (ms12->dolby_ms12_enable) {
         //ms12 input main
         int dual_input_ret = 0;
@@ -376,6 +684,7 @@ int dolby_ms12_main_process(
                                    , &main_frame_deficiency);
             if (single_input_ret) {
                 ALOGE("%s used size %zu dont find the iec61937 format header, rescan next time!\n", __FUNCTION__, *use_size);
+                *use_size = bytes;
                 goto  exit;
             }
             if (main_frame_deficiency > 0) {
@@ -383,6 +692,57 @@ int dolby_ms12_main_process(
             }
             aml_out->frame_deficiency = main_frame_deficiency;
         }
+        /*
+         *continuous output with dolby atmos input, the ddp frame size is variable.
+         */
+        else if ((adev->continuous_audio_mode == 1) || (adev->hdmi_format == BYPASS)) {
+            if ((aml_out->hal_format == AUDIO_FORMAT_AC3) || (aml_out->hal_format == AUDIO_FORMAT_E_AC3)) {
+                const unsigned char *frame_buf = (const unsigned char *)main_frame_buffer;
+                // int main_frame_size = input_bytes;
+                int frame_offset = 0;
+                int frame_size = 0;
+                int frame_numblocks = 0;
+                if (adev->debug_flag) {
+                    ALOGI("%s line %d ###### frame size %d deficiency %d #####",
+                        __func__, __LINE__, aml_out->ddp_frame_size, aml_out->frame_deficiency);
+                }
+
+                struct ac3_parser_info ac3_info = { 0 };
+                aml_ac3_parser_process(ms12->ac3_parser_handle, input_buffer, bytes, &parser_used_size, &main_frame_buffer, &main_frame_size, &ac3_info);
+                ALOGV("bytes=%d, parser_used_size=%d, main_frame_size=%d", bytes, parser_used_size, main_frame_size);
+                if (main_frame_size != 0) {
+                    struct bypass_frame_info frame_info = { 0 };
+                    aml_out->ddp_frame_size    = main_frame_size;
+                    aml_out->frame_deficiency  = aml_out->ddp_frame_size;
+                    frame_info.audio_format    = aml_out->hal_format;
+                    frame_info.samplerate      = ac3_info.sample_rate;
+                    frame_info.dependency_frame = ac3_info.frame_dependent;
+                    frame_info.numblks         = ac3_info.numblks;
+                    aml_ms12_bypass_checkin_data(ms12->ms12_bypass_handle, main_frame_buffer, main_frame_size, &frame_info);
+                }
+                aml_out->ddp_frame_nblks = ac3_info.numblks;
+                aml_out->total_ddp_frame_nblks += aml_out->ddp_frame_nblks;
+                dependent_frame = ac3_info.frame_dependent;
+                sample_rate = ac3_info.sample_rate;
+                if (ac3_info.frame_size == 0) {
+                    *use_size = parser_used_size;
+                    if (parser_used_size == 0) {
+                        *use_size = bytes;
+                    }
+                    goto exit;
+                }
+
+           } else if (aml_out->hal_format == AUDIO_FORMAT_AC4) {
+                aml_ac4_parser_process(aml_out->ac4_parser_handle, input_buffer, bytes, &parser_used_size, &main_frame_buffer, &main_frame_size, &ac4_info);
+                ALOGV("frame size =%d frame rate=%d sample rate=%d used =%d", ac4_info.frame_size, ac4_info.frame_rate, ac4_info.sample_rate, parser_used_size);
+                if (main_frame_size == 0 && parser_used_size == 0) {
+                    *use_size = bytes;
+                    ALOGE("wrong ac4 frame size");
+                    goto exit;
+                }
+
+            }
+        }
 
         if (adev->dual_decoder_support == true) {
             /*if there is associate frame, send it to dolby ms12.*/
@@ -417,44 +777,78 @@ MAIN_INPUT:
                 (adev->continuous_audio_mode == 1)) {
                 //hwsync pcm, 16bits-stereo
                 main_format = AUDIO_FORMAT_PCM_16_BIT;
-                main_channel_num = 2;
+                main_channel_num = aml_out->hal_ch;
                 main_sample_rate = 48000;
             }
-            dolby_ms12_input_bytes =
-                dolby_ms12_input_main(
-                    ms12->dolby_ms12_ptr
-                    , main_frame_buffer
-                    , main_frame_size
-                    , main_format
-                    , main_channel_num
-                    , main_sample_rate);
+            /*we check whether there is enough space*/
+            if ((adev->continuous_audio_mode == 1) && is_dolby_ms12_support_compression_format(aml_out->hal_format))
+            {
+                int max_size = 0;
+                int main_avail = 0;
+                int wait_retry = 0;
+                do {
+                    main_avail = dolby_ms12_get_main_buffer_avail(&max_size);
+                    /* after flush, max_size value will be set to 0 and after write first data,
+                     * it will be initialized
+                     */
+                    if (main_avail == 0 && max_size == 0) {
+                        break;
+                    }
+                    if ((max_size - main_avail) >= main_frame_size) {
+                        break;
+                    }
+                    aml_audio_sleep(5*1000);
+                    wait_retry++;
+                    /*it cost 3s*/
+                    if (wait_retry >= MS12_MAIN_WRITE_RETIMES) {
+                        *use_size = parser_used_size;
+                        if (parser_used_size == 0) {
+                            *use_size = bytes;
+                        }
+                        ALOGE("write dolby main time out, discard data=%d main_frame_size=%d", *use_size, main_frame_size);
+                        goto exit;
+                    }
 
-            if (adev->continuous_audio_mode == 0) {
-                dolby_ms12_scheduler_run(ms12->dolby_ms12_ptr);
+                } while (aml_out->status != STREAM_STANDBY);
             }
 
-#ifdef REPLACE_OUTPUT_BUFFER_WITH_CALLBACK
-
-#else
-            //ms12 output
-            ms12_output_size =
-                dolby_ms12_output(
-                    ms12->dolby_ms12_ptr
-                    , ms12->dolby_ms12_out_data
-                    , ms12->dolby_ms12_out_max_size);
-            if (ms12_output_size > 0) {
-                audio_format_t output_format = get_output_format(stream);
-                if (0 == audio_hal_data_processing_ms12v2(stream
-                                                   , ms12->dolby_ms12_out_data
-                                                   , ms12_output_size
-                                                   , &output_buffer
-                                                   , &output_buffer_bytes
-                                                   , output_format,
-                                                   , 8)) {
-                    hw_write(stream, output_buffer, output_buffer_bytes, output_format);
+            if (is_iec61937_format(stream)) {
+                endian16_convert(main_frame_buffer, main_frame_size);
+                if (adev->debug_flag > 0)
+                    ALOGI("dolby_ms12_input_main %p format = %x", ms12, main_format);
+                dolby_ms12_input_bytes = dolby_ms12_input_main(ms12->dolby_ms12_ptr
+                                                    , main_frame_buffer
+                                                    , main_frame_size
+                                                    , main_format
+                                                    , main_channel_num
+                                                    , main_sample_rate);
+
+                dump_ms12_output_data((void*)main_frame_buffer, dolby_ms12_input_bytes, MS12_INPUT_SYS_MAIN_FILE);
+
+                if (dolby_ms12_input_bytes != main_frame_size) {
+                    ALOGE("%s: dolby_ms12_input_main does not consume all data for iec61937 format", __func__);
                 }
             }
-#endif
+            else {
+                dolby_ms12_input_bytes = dolby_ms12_input_main(
+                                                    ms12->dolby_ms12_ptr
+                                                    , main_frame_buffer
+                                                    , main_frame_size
+                                                    , main_format
+                                                    , main_channel_num
+                                                    , main_sample_rate);
+            }
+            if (adev->debug_flag >= 2)
+                ALOGI("%s line %d main_frame_size %d ret dolby_ms12 input_bytes %d",
+                    __func__, __LINE__, main_frame_size, dolby_ms12_input_bytes);
+
+            /*set the dolby ms12 debug level*/
+            dolby_ms12_enable_debug();
+
+            if (adev->continuous_audio_mode == 0) {
+                dolby_ms12_scheduler_run(ms12->dolby_ms12_ptr);
+            }
+
             if (dolby_ms12_input_bytes > 0) {
                 if (adev->dual_decoder_support == true) {
                     *use_size = dual_decoder_used_bytes;
@@ -464,42 +858,63 @@ MAIN_INPUT:
                               __FUNCTION__, adev->continuous_audio_mode, dolby_ms12_input_bytes, input_bytes, ms12->config_sample_rate, main_frame_size, single_decoder_used_bytes);
                     }
                     if (adev->continuous_audio_mode == 1) {
+                        if (aml_out->frame_deficiency >= dolby_ms12_input_bytes)
+                            aml_out->frame_deficiency -= dolby_ms12_input_bytes;
+                        else {
+                            //FIXME: if aml_out->frame_deficiency is less than dolby_ms12_input_bytes
+                            //mostly occur the ac3 parser scan as a failure
+                            //need storage the data in an temp buffer.
+                            //TODO.
+                            aml_out->frame_deficiency = aml_out->ddp_frame_size - dolby_ms12_input_bytes;
+                        }
+                        if (adev->debug_flag) {
+                            ALOGI("%s line %d frame_deficiency %d ret dolby_ms12 input_bytes %d",
+                                    __func__, __LINE__, aml_out->frame_deficiency, dolby_ms12_input_bytes);
+                        }
+
                         //FIXME, if ddp input, the size suppose as CONTINUOUS_OUTPUT_FRAME_SIZE
                         //if pcm input, suppose 2ch/16bits/48kHz
-                        int need_sleep_us = 0;
+                        //FIXME, that MAT/TrueHD input is TODO!!!
                         uint64_t input_ns = 0;
                         if ((aml_out->hal_format == AUDIO_FORMAT_AC3) || \
                             (aml_out->hal_format == AUDIO_FORMAT_E_AC3)) {
-                            /*
-                             hwsync mode,normally we write a frame payload one time.the duration is 32 ms.
-                             as we write the data into the ringbuf,we need sleep for a while to avoid
-                             audioflinger write too often and cost high cpu loading.
-                             */
-                            if (aml_out->hw_sync_mode) {
-                                need_sleep_us = 32 * 1000 / 2;
-                            } else {
-                                need_sleep_us = ((input_bytes * 32 * 1000) / aml_out->ddp_frame_size);
+                            int sample_nums = aml_out->ddp_frame_nblks * SAMPLE_NUMS_IN_ONE_BLOCK;
+                            int frame_duration = DDP_FRAME_DURATION(sample_nums*1000, DDP_OUTPUT_SAMPLE_RATE);
+                            //input_ns = (uint64_t)dolby_ms12_input_bytes * frame_duration * 1000000 / aml_out->ddp_frame_size;
+                            input_ns = (uint64_t)sample_nums * NANO_SECOND_PER_SECOND / sample_rate;
+                            ALOGV("sample_nums=%d input_ns=%lld", sample_nums, input_ns);
+                            if (dependent_frame) {
+                                input_ns = 0;
                             }
-                            need_sleep_us = need_sleep_us / 2;
-                            if (need_sleep_us > 0) {
-                                usleep(need_sleep_us);
-                                if (adev->debug_flag >= 2) {
-                                    ALOGI("%s format=%d sleep %d ms dolby_ms12_input_bytes=%d\n", __FUNCTION__, aml_out->hal_format, need_sleep_us / 1000,dolby_ms12_input_bytes);
-                                }
+                        } else if (aml_out->hal_format == AUDIO_FORMAT_AC4) {
+                            if (ac4_info.frame_rate) {
+                                input_ns = (uint64_t)NANO_SECOND_PER_SECOND * 1000 / ac4_info.frame_rate;
+                            } else {
+                                input_ns = 0;
                             }
+                            ALOGV("input ns =%lld frame rate=%d frame size=%d", input_ns, ac4_info.frame_rate, ac4_info.frame_size);
                         } else {
                             /*
                             for LPCM audio,we support it is 2 ch 48K audio.
                             */
-                            input_ns = (uint64_t)dolby_ms12_input_bytes * 1000000000LL / 4 / ms12->config_sample_rate;
-                            audio_virtual_buf_process(ms12->main_virtual_buf_handle, input_ns);
+                            if (main_channel_num == 0) {
+                                main_channel_num = 2;
+                            }
+                            input_ns = (uint64_t)dolby_ms12_input_bytes * NANO_SECOND_PER_SECOND / (2 * main_channel_num) / ms12->config_sample_rate;
                         }
+                        audio_virtual_buf_process(ms12->main_virtual_buf_handle, input_ns);
                     }
 
                     if (is_iec61937_format(stream)) {
                         *use_size = single_decoder_used_bytes;
                     } else {
                         *use_size = dolby_ms12_input_bytes;
+                        if (((adev->continuous_audio_mode == 1) || (adev->hdmi_format == BYPASS)) &&
+                            ((aml_out->hal_format == AUDIO_FORMAT_AC3) ||
+                            (aml_out->hal_format == AUDIO_FORMAT_E_AC3) ||
+                            (aml_out->hal_format == AUDIO_FORMAT_AC4))) {
+                            *use_size = parser_used_size;
+                        }
                     }
 
                 }
@@ -511,9 +926,9 @@ MAIN_INPUT:
                 *use_size = input_bytes;
             }
         }
-        ms12->is_dolby_atmos = dolby_ms12_get_input_atmos_info();
+        ms12->is_bypass_ms12 = is_bypass_ms12(stream);
 exit:
-        dump_ms12_output_data((void*)buffer, *use_size, MS12_INPUT_SYS_MAIN_FILE);
+        dump_ms12_output_data((void*)buffer, *use_size, MS12_INPUT_SYS_MAIN_FILE2);
         pthread_mutex_unlock(&ms12->main_lock);
         return 0;
     } else {
@@ -547,6 +962,9 @@ int dolby_ms12_system_process(
     int ms12_output_size = 0;
     pthread_mutex_lock(&ms12->lock);
     if (ms12->dolby_ms12_enable) {
+        /*set the dolby ms12 debug level*/
+        dolby_ms12_enable_debug();
+
         //Dual input, here get the system data
         dolby_ms12_input_bytes =
             dolby_ms12_input_system(
@@ -562,17 +980,17 @@ int dolby_ms12_system_process(
             *use_size = 0;
         }
     }
-    dump_ms12_output_data((void*)buffer, *use_size, MS12_INPUT_SYS_PCM_FILE);
+    //((void*)buffer, *use_size, MS12_INPUT_SYS_PCM_FILE);
     pthread_mutex_unlock(&ms12->lock);
 
     if (adev->continuous_audio_mode == 1) {
         uint64_t input_ns = 0;
-        input_ns = (uint64_t)(*use_size) * 1000000000LL / 4 / mixer_default_samplerate;
+        input_ns = (uint64_t)(*use_size) * NANO_SECOND_PER_SECOND / 4 / mixer_default_samplerate;
 
         if (ms12->system_virtual_buf_handle == NULL) {
             //aml_audio_sleep(input_ns/1000);
             if (input_ns == 0) {
-                input_ns = (uint64_t)(bytes) * 1000000000LL / 4 / mixer_default_samplerate;
+                input_ns = (uint64_t)(bytes) * NANO_SECOND_PER_SECOND / 4 / mixer_default_samplerate;
             }
             audio_virtual_buf_open(&ms12->system_virtual_buf_handle, "ms12 system input", input_ns/2, MS12_SYS_INPUT_BUF_NS, MS12_SYS_BUF_INCREASE_TIME_MS);
         }
@@ -582,6 +1000,61 @@ int dolby_ms12_system_process(
     return 0;
 }
 
+
+/*
+ *@brief dolby ms12 app process
+ *
+ * input parameters
+ *     stream: audio_stream_out handle
+ *     buffer: data buffer address
+ *     bytes: data size
+ * output parameters
+ *     use_size: buffer used size
+ */
+int dolby_ms12_app_process(
+    struct audio_stream_out *stream
+    , const void *buffer
+    , size_t bytes
+    , size_t *use_size)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+    struct aml_audio_device *adev = aml_out->dev;
+    struct dolby_ms12_desc *ms12 = &(adev->ms12);
+    audio_channel_mask_t mixer_default_channelmask = AUDIO_CHANNEL_OUT_STEREO;
+    int mixer_default_samplerate = 48000;
+    int dolby_ms12_input_bytes = 0;
+    int ms12_output_size = 0;
+    int ret = 0;
+
+    pthread_mutex_lock(&ms12->lock);
+    if (ms12->dolby_ms12_enable) {
+        /*set the dolby ms12 debug level*/
+        dolby_ms12_enable_debug();
+
+        //Dual input, here get the system data
+        dolby_ms12_input_bytes =
+            dolby_ms12_input_app(
+                ms12->dolby_ms12_ptr
+                , buffer
+                , bytes
+                , AUDIO_FORMAT_PCM_16_BIT
+                , audio_channel_count_from_out_mask(mixer_default_channelmask)
+                , mixer_default_samplerate);
+        if (dolby_ms12_input_bytes > 0) {
+            *use_size = dolby_ms12_input_bytes;
+            ret = 0;
+        } else {
+            *use_size = 0;
+            ret = -1;
+        }
+    }
+    dump_ms12_output_data((void*)buffer, *use_size, MS12_INPUT_SYS_APP_FILE);
+    pthread_mutex_unlock(&ms12->lock);
+
+    return ret;
+}
+
+
 /*
  *@brief get dolby ms12 cleanup
  */
@@ -596,8 +1069,8 @@ int get_dolby_ms12_cleanup(struct dolby_ms12_desc *ms12)
 
     pthread_mutex_lock(&ms12->lock);
     pthread_mutex_lock(&ms12->main_lock);
-    ALOGD("++%s(), locked", __FUNCTION__);
-    ALOGD("%s() dolby_ms12_set_quit_flag %d", __FUNCTION__, is_quit);
+    ALOGI("++%s(), locked", __FUNCTION__);
+    ALOGI("%s() dolby_ms12_set_quit_flag %d", __FUNCTION__, is_quit);
     dolby_ms12_set_quit_flag(is_quit);
 
     if (ms12->dolby_ms12_threadID != 0) {
@@ -607,21 +1080,35 @@ int get_dolby_ms12_cleanup(struct dolby_ms12_desc *ms12)
         ALOGI("%s() dolby_ms12_threadID reset to %ld\n", __FUNCTION__, ms12->dolby_ms12_threadID);
     }
     set_audio_system_format(AUDIO_FORMAT_INVALID);
+    set_audio_app_format(AUDIO_FORMAT_INVALID);
     set_audio_main_format(AUDIO_FORMAT_INVALID);
     dolby_ms12_flush_main_input_buffer();
     dolby_ms12_config_params_set_system_flag(false);
+    dolby_ms12_config_params_set_app_flag(false);
     aml_ms12_cleanup(ms12);
     ms12->output_config = 0;
     ms12->dolby_ms12_enable = false;
     ms12->is_dolby_atmos = false;
     ms12->input_total_ms = 0;
     ms12->bitsteam_cnt = 0;
+    ms12->nbytes_of_dmx_output_pcm_frame = 0;
+    ms12->is_bypass_ms12 = false;
+    ms12->last_frames_postion = 0;
     audio_virtual_buf_close(&ms12->main_virtual_buf_handle);
     audio_virtual_buf_close(&ms12->system_virtual_buf_handle);
-    ALOGD("--%s(), locked", __FUNCTION__);
+    aml_ac3_parser_close(ms12->ac3_parser_handle);
+    ms12->ac3_parser_handle = NULL;
+    ring_buffer_release(&ms12->spdif_ring_buffer);
+    if (ms12->lpcm_temp_buffer) {
+        free(ms12->lpcm_temp_buffer);
+        ms12->lpcm_temp_buffer = NULL;
+    }
+    aml_ms12_bypass_close(ms12->ms12_bypass_handle);
+    ms12->ms12_bypass_handle = NULL;
+    ALOGI("--%s(), locked", __FUNCTION__);
     pthread_mutex_unlock(&ms12->main_lock);
     pthread_mutex_unlock(&ms12->lock);
-    ALOGD("-%s()", __FUNCTION__);
+    ALOGI("-%s()", __FUNCTION__);
     return 0;
 }
 
@@ -635,15 +1122,6 @@ int set_dolby_ms12_primary_input_db_gain(struct dolby_ms12_desc *ms12, int db_ga
 
     ALOGI("+%s(): gain %ddb, ms12 enable(%d)",
           __FUNCTION__, db_gain, ms12->dolby_ms12_enable);
-    if (!ms12) {
-        return -EINVAL;
-    }
-
-    //pthread_mutex_lock(&ms12->lock);
-    if (!ms12->dolby_ms12_enable) {
-        ret = -EINVAL;
-        goto exit;
-    }
 
     gain.target = db_gain;
     gain.duration = duration;
@@ -656,7 +1134,6 @@ int set_dolby_ms12_primary_input_db_gain(struct dolby_ms12_desc *ms12, int db_ga
     //ret = aml_ms12_update_runtime_params_lite(ms12);
 
 exit:
-    //pthread_mutex_unlock(&ms12->lock);
     return ret;
 }
 
@@ -664,57 +1141,108 @@ exit:
 int ms12_output(void *buffer, void *priv_data, size_t size, aml_dec_info_t *ms12_info)
 {
     struct aml_stream_out *aml_out = (struct aml_stream_out *)priv_data;
+    struct audio_stream_out *stream_out = (struct audio_stream_out *)aml_out;
     struct aml_audio_device *adev = aml_out->dev;
     struct dolby_ms12_desc *ms12 = &(adev->ms12);
     void *output_buffer = NULL;
     size_t output_buffer_bytes = 0;
     audio_format_t output_format = (ms12_info) ? ms12_info->data_type : AUDIO_FORMAT_PCM_16_BIT;
     int ret = 0;
+    uint64_t before_time;
+    uint64_t after_time;
     ms12->bitsteam_cnt++;
-
     if (adev->debug_flag > 1) {
-        ALOGI("+%s() size %zu,dual_output = %d, optical_format = %d, sink_format = %d out total=%d main in=%d", __FUNCTION__, size, aml_out->dual_output_flag, adev->optical_format, adev->sink_format, ms12->bitsteam_cnt, ms12->input_total_ms);
+        ALOGI("+%s() output size %zu,out format 0x%x.dual_output = %d, optical_format = 0x%x, sink_format = 0x%x, out total=%d main in=%d",
+            __FUNCTION__, size,output_format, aml_out->dual_output_flag, adev->optical_format, adev->sink_format,
+            ms12->bitsteam_cnt, ms12->input_total_ms);
+    }
+    if (adev->ms12.optical_format != adev->optical_format) {
+         ALOGI("ms12 optical format change from 0x%x to  0x%x\n",adev->ms12.optical_format,adev->optical_format);
+         //get_sink_format ((struct audio_stream_out *)aml_out);
+         adev->ms12.optical_format= adev->optical_format;
+         if (audio_is_linear_pcm(adev->optical_format))
+             aml_audio_spdif_output_stop(stream_out);
     }
 
-    if (output_format != AUDIO_FORMAT_PCM_16_BIT) {
-        /* bit stream output */
-
-        /*dump ms12 bitstream output*/
-        dump_ms12_output_data(buffer, size, MS12_OUTPUT_BITSTREAM_FILE);
+    update_ms12_atmos_info(ms12);
+
+    if (!audio_is_linear_pcm(output_format)) {
+        before_time = aml_audio_get_systime();
+        if (output_format == adev->optical_format) {
+            void *output_buf = NULL;
+            int32_t out_size = 0;
+            struct bypass_frame_info frame_info = { 0 };
+            uint64_t ms12_dec_out_nframes = dolby_ms12_get_decoder_nframes_pcm_output(adev->ms12.dolby_ms12_ptr, aml_out->hal_internal_format, MAIN_INPUT_STREAM);
+            if (ms12_dec_out_nframes != 0 &&
+                (aml_out->hal_internal_format == AUDIO_FORMAT_E_AC3 || aml_out->hal_internal_format == AUDIO_FORMAT_AC3)) {
+                uint64_t consume_offset = dolby_ms12_get_decoder_n_bytes_consumed(adev->ms12.dolby_ms12_ptr, aml_out->hal_internal_format, MAIN_INPUT_STREAM);
+                aml_ms12_bypass_checkout_data(ms12->ms12_bypass_handle, &output_buf, &out_size, consume_offset, &frame_info);
+            }
+            if (adev->hdmi_format != BYPASS) {
+                ms12->is_bypass_ms12 = false;
+            }
+            if (!ms12->is_bypass_ms12) {
+                output_buf = buffer;
+                out_size   = size;
+            } else {
+                ALOGV("bypass ms12 size=%d", out_size);
+                output_format = aml_out->hal_internal_format;
+                if (ms12->is_continuous_paused) {
+                    aml_audio_spdif_output_stop(stream_out);
+                    out_size = 0;
+                }
+            }
+            if (adev->debug_flag > 1) {
+                ALOGI("hdmi format=%d bypass =%d size=%d",adev->hdmi_format, ms12->is_bypass_ms12, out_size);
+            }
+            if (out_size != 0) {
+                ret = aml_audio_spdif_output(stream_out, output_buf, out_size,output_format);
+                dump_ms12_output_data(buffer, size, MS12_OUTPUT_BITSTREAM_FILE);
+            }
 
-        if (aml_out->dual_output_flag) {
-            struct audio_stream_out *stream_out = (struct audio_stream_out *)aml_out;
-            output_format = adev->optical_format;
-            ret = aml_audio_spdif_output(stream_out, buffer, size);
-        } else {
-            output_format = adev->sink_format;
+        }
+        after_time = aml_audio_get_systime();
+    } else if (adev->active_outport == OUTPORT_HDMI_ARC || adev->dap_bypass_enable) {
+        if (ms12_info->pcm_type == NORMAL_LPCM) {
+            if (get_buffer_write_space (&ms12->spdif_ring_buffer) >= (int) size) {
+                ring_buffer_write(&ms12->spdif_ring_buffer, buffer, size, UNCOVER_WRITE);
+            }
             if (audio_hal_data_processing((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format) == 0) {
                 ret = hw_write((struct audio_stream_out *)aml_out, output_buffer, output_buffer_bytes, output_format);
             }
+            if (adev->debug_flag > 1) {
+                ALOGI("-%s() output_buffer_bytes %d ret %d", __FUNCTION__, output_buffer_bytes, ret);
+            }
         }
-
-        return ret;
-    }
-
-    /* pcm output */
-
-    /*dump ms12 pcm output*/
-    dump_ms12_output_data(buffer, size, MS12_OUTPUT_PCM_FILE);
-    if (ms12_info->output_ch == 2) {
-        if (audio_hal_data_processing((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format) == 0) {
-            ret = hw_write((struct audio_stream_out *)aml_out, output_buffer, output_buffer_bytes, output_format);
-        }
-    }
-    else {
-        if (audio_hal_data_processing_ms12v2((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format, ms12_info->output_ch) == 0) {
-            ret = hw_write((struct audio_stream_out *)aml_out, output_buffer, output_buffer_bytes, output_format);
+    } else if (!adev->dap_bypass_enable) {
+        if (ms12_info->pcm_type == NORMAL_LPCM) {
+#if 0
+{
+FILE *fp = fopen("/data/vendor/audiohal/ms12_out.pcm", "a+");
+if (fp) {
+    fwrite(buffer, 1, size, fp);
+    fclose(fp);
+}
+}
+#endif
+           /*will process spdif_ring_buf in audio_hal_data_prossing */
+            if (get_buffer_write_space (&ms12->spdif_ring_buffer) >= (int) size) {
+                ring_buffer_write(&ms12->spdif_ring_buffer, buffer, size, UNCOVER_WRITE);
+            }
+        } else if (ms12_info->pcm_type == DAP_LPCM) {
+            bool usb_pcm_in = (!adev->audio_patch) && adev->ms12_main1_dolby_dummy;
+            if (usb_pcm_in) {
+                apply_volume(CONVERT_ONEDB_TO_GAIN, buffer, sizeof(int16_t), size); //add 1db to buffer
+            }
+            if (ms12_info->output_ch == 2) {
+                if (audio_hal_data_processing((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+                    ret = hw_write((struct audio_stream_out *)aml_out, output_buffer, output_buffer_bytes, output_format);
+                }
+            } else if (audio_hal_data_processing_ms12v2((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format, ms12_info->output_ch) == 0) {
+                ret = hw_write((struct audio_stream_out *)aml_out, output_buffer, output_buffer_bytes, output_format);
+            }
         }
     }
-
-    if (adev->debug_flag > 1) {
-        ALOGI("-%s() ret %d", __FUNCTION__, ret);
-    }
-
     return ret;
 }
 #endif
@@ -735,6 +1263,10 @@ static void *dolby_ms12_threadloop(void *data)
     }
 
     prctl(PR_SET_NAME, (unsigned long)"DOLBY_MS12");
+    aml_set_thread_priority("DOLBY_MS12", ms12->dolby_ms12_threadID);
+
+    /*affinity the thread to cpu 2/3 which has few IRQ*/
+    aml_audio_set_cpu23_affinity();
 
     while ((ms12->dolby_ms12_thread_exit == false) && (ms12->dolby_ms12_enable)) {
         ALOGV("%s() goto dolby_ms12_scheduler_run", __FUNCTION__);
@@ -798,14 +1330,8 @@ int set_system_app_mixing_status(struct aml_stream_out *aml_out, int stream_stat
     dolby_ms12_set_system_app_audio_mixing(system_app_mixing_status);
 
     if (ms12->dolby_ms12_enable) {
-        char *argv_0[3] = {"ms12_runtime", "-xs", "0"};
-        char *argv_1[3] = {"ms12_runtime", "-xs", "1"};
         pthread_mutex_lock(&ms12->lock);
-        ret = aml_ms12_update_runtime_params_direct(
-            &(adev->ms12),
-            3,
-            (system_app_mixing_status == SYSTEM_APP_SOUND_MIXING_ON) ?
-                argv_1 : argv_0);
+        set_dolby_ms12_runtime_system_mixing_enable(ms12, system_app_mixing_status);
         pthread_mutex_unlock(&ms12->lock);
         ALOGI("%s return %d stream-status %d set system-app-audio-mixing %d\n",
               __func__, ret, stream_status, system_app_mixing_status);
@@ -815,3 +1341,46 @@ int set_system_app_mixing_status(struct aml_stream_out *aml_out, int stream_stat
     return 1;
 }
 
+
+static int nbytes_of_dolby_ms12_downmix_output_pcm_frame()
+{
+    int pcm_out_chanenls = 2;
+    int bytes_per_sample = 2;
+
+    return pcm_out_chanenls*bytes_per_sample;
+}
+
+
+int dolby_ms12_main_flush(struct audio_stream_out *stream) {
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+    struct aml_audio_device *adev = aml_out->dev;
+    struct dolby_ms12_desc *ms12 = &(adev->ms12);
+    dolby_ms12_flush_main_input_buffer();
+    if (ms12->ac3_parser_handle) {
+        aml_ac3_parser_reset(ms12->ac3_parser_handle);
+    }
+    if (ms12->ms12_bypass_handle) {
+        aml_ms12_bypass_reset(ms12->ms12_bypass_handle);
+    }
+    return 0;
+}
+
+void dolby_ms12_app_flush()
+{
+    dolby_ms12_flush_app_input_buffer();
+}
+
+void dolby_ms12_enable_debug()
+{
+    char buf[PROPERTY_VALUE_MAX];
+    int level = 0;
+    int ret = -1;
+
+    ret = property_get("vendor.audio.dolbyms12.debug", buf, NULL);
+    if (ret > 0)
+    {
+        level = atoi(buf);
+        dolby_ms12_set_debug_level(level);
+    }
+}
+
diff --git a/audio_hal/audio_hw_ms12.h b/audio_hal/audio_hw_ms12.h
index d8301ff..c9b6c8a 100644
--- a/audio_hal/audio_hw_ms12.h
+++ b/audio_hal/audio_hw_ms12.h
@@ -24,6 +24,15 @@
 
 #include "audio_hw.h"
 
+#define DDP_OUTPUT_SAMPLE_RATE (48000)
+#define SAMPLE_NUMS_IN_ONE_BLOCK (256)
+#define DDP_FRAME_DURATION(sample_nums, sample_rate) ((sample_nums) / (sample_rate))
+
+#define MAIN_INPUT_STREAM 1
+#define ASSOC_INPUT_STREAM 0
+#define SYSTEM_INPUT_STREAM 0
+#define RESERVED_LENGTH 31
+
 /*
  *@brief get dolby ms12 prepared
  */
@@ -66,14 +75,37 @@ int dolby_ms12_system_process(
     , size_t bytes
     , size_t *used_size);
 
+enum MS12_PCM_TYPE {
+    NORMAL_LPCM = 0,
+    DAP_LPCM = 1,
+};
+
 typedef struct aml_dec_info {
     int output_sr ;   /** the decoded data samplerate*/
     int output_ch ;   /** the decoded data channels*/
     int output_bitwidth; /**the decoded sample bit width*/
     int data_type;
-    int reserved[32];
+    enum MS12_PCM_TYPE pcm_type;
+    int reserved[RESERVED_LENGTH];
 } aml_dec_info_t;
 
+
+/*
+ *@brief dolby ms12 app process
+ *
+ * input parameters
+ *     stream: audio_stream_out handle
+ *     buffer: data buffer address
+ *     bytes: data size
+ * output parameters
+ *     used_size: buffer used size
+ */
+int dolby_ms12_app_process(
+    struct audio_stream_out *stream
+    , const void *buffer
+    , size_t bytes
+    , size_t *used_size);
+
 /*
  *@brief get dolby ms12 cleanup
  */
@@ -93,8 +125,62 @@ int set_dolby_ms12_primary_input_db_gain(struct dolby_ms12_desc *ms12,
 int set_system_app_mixing_status(struct aml_stream_out *aml_out, int stream_status);
 
 /*
- *@brief an callback for dolby ms12 pcm output
+ *@brief an callback for dolby ms12 output
  */
 int ms12_output(void *buffer, void *priv_data, size_t size, aml_dec_info_t *ms12_info);
 
+/*
+ *@brief dolby ms12 flush the main related buffer
+ */
+int dolby_ms12_main_flush(struct audio_stream_out *stream);
+
+/*
+ *@brief dolby ms12 flush the app related buffer
+ */
+void dolby_ms12_app_flush();
+
+/*
+ *@brief dolby ms12 enable to debug by the property 'vendor.audio.dolbyms12.debug'
+ */
+void dolby_ms12_enable_debug();
+
+/*
+ *@brief check that dolby ms12 output ddp atmos(5.1.2)/ddp(5.1) is suitable or not.
+ */
+bool is_ms12_out_ddp_5_1_suitable(bool is_ddp_atmos);
+
+/*
+ *@brief bypass iec61937 audio data
+ */
+int dolby_ms12_bypass_process();
+
+/*
+ *@brief set dolby ms12 ad mixing enable
+ */
+void set_ms12_ad_mixing_enable(struct dolby_ms12_desc *ms12, int ad_mixing_enable);
+
+/*
+ *@brief set dolby ms12 mixing level
+ */
+void set_ms12_ad_mixing_level(struct dolby_ms12_desc *ms12, int mixing_level);
+
+/*
+ *@brief set dolby ms12 pause
+ */
+void set_dolby_ms12_runtime_pause(struct dolby_ms12_desc *ms12, int is_pause);
+
+/*
+ *@brief set dolby ms12 system mixing enable
+ */
+void set_dolby_ms12_runtime_system_mixing_enable(struct dolby_ms12_desc *ms12, int sys_mixing_enable);
+bool is_bypass_ms12(struct audio_stream_out *stream);
+
+void set_ms12_atmos_lock(struct dolby_ms12_desc *ms12, bool is_atmos_lock_on);
+
+/*
+ *@brief get the platform's capability of DDP-ATMOS.
+ */
+bool is_platform_supported_ddp_atmos(bool atmos_supported, enum OUT_PORT current_out_port);
+
+
 #endif //end of _AUDIO_HW_MS12_H_
diff --git a/audio_hal/audio_hw_profile.c b/audio_hal/audio_hw_profile.c
index f1a3af7..b0ccb68 100644
--- a/audio_hal/audio_hw_profile.c
+++ b/audio_hal/audio_hw_profile.c
@@ -113,12 +113,16 @@ char*  get_hdmi_sink_cap(const char *keys,audio_format_t format,struct aml_arc_h
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_E_AC3");
                 p_hdmi_descs->ddp_fmt.is_support = 1;
             }
+            if (mystrstr(infobuf, "ATMOS")) {
+                size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_E_AC3_JOC");
+            }
             if (mystrstr(infobuf, "AC-3")) {
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_AC3");
                 p_hdmi_descs->dd_fmt.is_support = 1;
             }
             if (mystrstr(infobuf, "DTS-HD")) {
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_DTS|AUDIO_FORMAT_DTS_HD");
+                p_hdmi_descs->dts_fmt.is_support = 1;
             } else if (mystrstr(infobuf, "DTS")) {
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_DTS");
                 p_hdmi_descs->dts_fmt.is_support = 1;
@@ -141,15 +145,15 @@ char*  get_hdmi_sink_cap(const char *keys,audio_format_t format,struct aml_arc_h
                 (mystrstr(infobuf, "Dobly_Digital+") && format == AUDIO_FORMAT_E_AC3) ||
                 (mystrstr(infobuf, "DTS-HD") && format == AUDIO_FORMAT_DTS_HD)        ||
                 (mystrstr(infobuf, "MAT") && (format == AUDIO_FORMAT_DOLBY_TRUEHD     ||
-                                              format == AUDIO_FORMAT_MAT))            ||
+                                              format == AUDIO_FORMAT_MAT))      ||
                 format == AUDIO_FORMAT_IEC61937) {
-                size += sprintf(aud_cap + size, "|%s", "AUDIO_CHANNEL_OUT_5POINT1|AUDIO_CHANNEL_OUT_7POINT1");
+                size += sprintf(aud_cap + size, "|%s", "AUDIO_CHANNEL_OUT_PENTA|AUDIO_CHANNEL_OUT_5POINT1|AUDIO_CHANNEL_OUT_7POINT1");
             } else if (/*(!alsa_device_is_auge() && mystrstr(infobuf, "PCM, 6 ch")) ||*/
                        (mystrstr(infobuf, "AC-3") && format == AUDIO_FORMAT_AC3) ||
                        /* backward compatibility for dd, if TV only supports dd+ */
                        (mystrstr(infobuf, "Dobly_Digital+") && format == AUDIO_FORMAT_AC3)||
                        (mystrstr(infobuf, "DTS") && format == AUDIO_FORMAT_DTS)) {
-                size += sprintf(aud_cap + size, "|%s", "AUDIO_CHANNEL_OUT_5POINT1");
+                size += sprintf(aud_cap + size, "|%s", "AUDIO_CHANNEL_OUT_PENTA|AUDIO_CHANNEL_OUT_5POINT1");
             }
         } else if (strstr(keys, AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES)) {
             ALOGD("query hdmi sample_rate...\n");
@@ -170,8 +174,8 @@ char*  get_hdmi_sink_cap(const char *keys,audio_format_t format,struct aml_arc_h
                     size += sprintf(aud_cap + size, "|%s", "192000");
                 }
             } else {
-              if((mystrstr(infobuf, "Dobly_Digital+") || mystrstr(infobuf, "DTS-HD") ||
-                  mystrstr(infobuf, "MAT")) && format == AUDIO_FORMAT_IEC61937) {
+              if (/*(mystrstr(infobuf, "Dobly_Digital+") || mystrstr(infobuf, "DTS-HD") ||
+                  mystrstr(infobuf, "MAT")) && */format == AUDIO_FORMAT_IEC61937) {
                   size += sprintf(aud_cap + size, "|%s", "128000|176400|192000");
               }
             }
@@ -187,15 +191,14 @@ char*  get_hdmi_sink_cap(const char *keys,audio_format_t format,struct aml_arc_h
     }
     return aud_cap;
 fail:
-    if (aud_cap) {
+    /*if (aud_cap) {
         free(aud_cap);
-    }
+    }*/
     if (infobuf) {
         free(infobuf);
     }
     return NULL;
 }
-
 char*  get_hdmi_arc_cap(unsigned *ad, int maxsize, const char *keys)
 {
     int i = 0;
@@ -232,7 +235,7 @@ char*  get_hdmi_arc_cap(unsigned *ad, int maxsize, const char *keys)
         if (ad[i] != 0) {
             format = (ad[i] >> 19) & 0xf;
             ch = (ad[i] >> 16) & 0x7;
-            sr = (ad[i] > 8) & 0xf;
+            sr = (ad[i] >> 8) & 0xf;
             ALOGI("ad %x,format %d,ch %d,sr %d\n", ad[i], format, ch, sr);
             /* check the format cap */
             if (strstr(keys, AUDIO_PARAMETER_STREAM_SUP_FORMATS)) {
@@ -289,9 +292,9 @@ char*  get_hdmi_arc_cap(unsigned *ad, int maxsize, const char *keys)
     }
     return aud_cap;
 fail:
-    if (aud_cap) {
+    /*if (aud_cap) {
         free(aud_cap);
-    }
+    }*/
     return NULL;
 }
 
@@ -311,6 +314,7 @@ char *strdup_hdmi_arc_cap_default(const char *keys, audio_format_t format)
         switch (format) {
         case AUDIO_FORMAT_E_AC3:
             strcat(ch_mask, "|AUDIO_CHANNEL_OUT_7POINT1");
+            break;
         case AUDIO_FORMAT_IEC61937:
         case AUDIO_FORMAT_AC3:
             strcat(ch_mask, "|AUDIO_CHANNEL_OUT_5POINT1");
@@ -352,3 +356,56 @@ char *strdup_hdmi_arc_cap_default(const char *keys, audio_format_t format)
 
     return cap;
 }
+
+char *strdup_a2dp_cap_default(const char *keys, audio_format_t format)
+{
+    char fmt[] = "sup_formats=AUDIO_FORMAT_PCM_16_BIT|AUDIO_FORMAT_AC3|AUDIO_FORMAT_E_AC3";
+    char ch_mask[128] = "sup_channels=AUDIO_CHANNEL_OUT_STEREO";
+    char sr[64] = "sup_sampling_rates=48000|44100";
+    char *cap = NULL;
+
+    /* check the format cap */
+    if (strstr(keys, AUDIO_PARAMETER_STREAM_SUP_FORMATS)) {
+        cap = strdup(fmt);
+    } else if (strstr(keys, AUDIO_PARAMETER_STREAM_SUP_CHANNELS)) {
+        /* take the 2ch suppported as default */
+        switch (format) {
+        case AUDIO_FORMAT_E_AC3:
+            strcat(ch_mask, "|AUDIO_CHANNEL_OUT_7POINT1");
+            break;
+        case AUDIO_FORMAT_AC3:
+            strcat(ch_mask, "|AUDIO_CHANNEL_OUT_5POINT1");
+            cap = strdup(ch_mask);
+            break;
+        case AUDIO_FORMAT_PCM_16_BIT:
+            cap = strdup(ch_mask);
+            break;
+        default:
+            ALOGE("%s, unsupport format: %#x", __FUNCTION__, format);
+            break;
+        }
+    } else if (strstr(keys, AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES)) {
+        /* take the 48 khz suppported as default */
+        switch (format) {
+        case AUDIO_FORMAT_E_AC3:
+            cap = strdup(sr);
+            break;
+        case AUDIO_FORMAT_PCM_16_BIT:
+        case AUDIO_FORMAT_AC3:
+            strcat(sr, "|32000");
+            cap = strdup(sr);
+            break;
+        default:
+            ALOGE("%s, unsupport format: %#x", __FUNCTION__, format);
+            break;
+        }
+    } else {
+        ALOGE("NOT support yet");
+    }
+
+    if (!cap) {
+        cap = strdup("");
+    }
+
+    return cap;
+}
diff --git a/audio_hal/audio_hw_profile.h b/audio_hal/audio_hw_profile.h
index 05efaa4..dc14630 100644
--- a/audio_hal/audio_hw_profile.h
+++ b/audio_hal/audio_hw_profile.h
@@ -23,4 +23,5 @@ int get_external_card(int type);
 char*  get_hdmi_sink_cap(const char *keys,audio_format_t format,struct aml_arc_hdmi_desc *p_hdmi_descs);
 char*  get_hdmi_arc_cap(unsigned *ad, int maxsize, const char *keys);
 char *strdup_hdmi_arc_cap_default(const char *keys, audio_format_t format);
+char *strdup_a2dp_cap_default(const char *keys, audio_format_t format);
 #endif
diff --git a/audio_hal/audio_hw_utils.c b/audio_hal/audio_hw_utils.c
index 25d44da..45a65a6 100644
--- a/audio_hal/audio_hw_utils.c
+++ b/audio_hal/audio_hw_utils.c
@@ -18,6 +18,7 @@
 
 #define LOG_TAG "audio_hw_utils"
 //#define LOG_NDEBUG 0
+#define __USE_GNU
 
 #include <errno.h>
 #include <pthread.h>
@@ -39,11 +40,16 @@
 #include <tinyalsa/asoundlib.h>
 
 #include "audio_hw_utils.h"
-
+#include "audio_hw_ms12.h"
 #include "audio_hwsync.h"
 #include "audio_hw.h"
 #include "amlAudioMixer.h"
 #include <audio_utils/primitives.h>
+#include "audio_a2dp_hw.h"
+#include "aml_audio_avsync_table.h"
+#include "dolby_lib_api.h"
+#include "audio_hw_dtv.h"
+
 
 #ifdef LOG_NDEBUG_FUNCTION
 #define LOGFUNC(...) ((void)0)
@@ -51,6 +57,231 @@
 #define LOGFUNC(...) (ALOGD(__VA_ARGS__))
 #endif
 
+#define DD_MUTE_FRAME_SIZE 1536
+#define DDP_MUTE_FRAME_SIZE 6144
+
+// add array of dd/ddp mute frame for mute function
+static const unsigned int muted_frame_dd[DD_MUTE_FRAME_SIZE] = {
+ 0x4e1ff872, 0x8000001, 0xb49e0b77, 0x43e10840, 0x10806f0, 0x21010808,
+ 0x571f0104, 0xf9f33e7c, 0x9f3ee7cf, 0xfe757cfb, 0xf3e77cf9, 0x3e7ccf9f,
+ 0x9d5ff8ff, 0xf9f33e7c, 0x9f3ee7cf, 0x24432ff, 0x8920, 0xb5f30001,
+ 0x9b6de7cf, 0x6f1eb6db, 0x3c00, 0x9f3e0daf, 0x6db67cdb, 0xf1e1db78,
+ 0x8000, 0xd7cf0006, 0x6db69f3e, 0xbc78db6d, 0xf000, 0x7cf936be,
+ 0xb6dbf36d, 0xc7866de3,0x0, 0x5f3e001b, 0xb6db7cf9, 0xf1e36db6,
+ 0xc000, 0xf3e7daf9, 0xdb6dcdb6, 0x1e18b78f, 0x0, 0x7cf9006d,
+ 0xdb6df3e6, 0xc78fb6db, 0x30000, 0xcf9f6be7, 0x6db636db, 0x7860de3c,
+ 0x0, 0xf3e701b5, 0x6db6cf9b, 0x1e3cdb6f, 0xd0000, 0x3e7caf9f, 0xb6dbdb6d,
+ 0xe18078f1, 0x0, 0xcf9f06d7, 0xb6db3e6d, 0x78f06dbc, 0x360000, 0xf9f3be7c,
+ 0xdb6d6db6, 0x8000e3c7,0x0, 0xe2560000
+};
+
+static const unsigned int muted_frame_ddp[DDP_MUTE_FRAME_SIZE] = {
+    0x4e1ff872,  0xbe40715,  0x5f10b77, 0xfffa3f67,   0x484900,    0x40000,    0x80000, 0x6186e100,
+    0xff3a1861, 0xf9f3be7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7,
+    0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c,
+    0xfceae7df, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f,
+    0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3,
+    0xf3ab9f7f, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c,
+    0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf,
+    0xceaf7dff, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3,
+    0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e,
+    0x3abef7ff, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf,
+    0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9,
+    0xeb94dffc, 0x137ef8e0, 0xc3c7c280, 0x3bbb8f1e, 0xb800bbbb,          0,          0,          0,
+             0,          0,   0x770000, 0x6db67777, 0xb7cfdb6d, 0xb5ad9ad6, 0x3e7c6b5f, 0xe7cff9f3,
+    0x7cf99f3e, 0xcfb9f3e7, 0x27d33873, 0xe3c778f1, 0x77777777,          0,          0,          0,
+             0,          0,          0, 0xeeed0eee, 0x6db6b6db, 0x5ad6f9f3, 0x6be7b5ad, 0x3e7ccf9f,
+    0xe7cff9f3, 0x7cf99f3e, 0xf21bf0d9, 0x1e3c876f, 0xeeee78ee,     0xeee0,          0,          0,
+             0,          0,          0, 0xdddd0001, 0xdb6dddb6, 0x3e6bb6df, 0xb5ad5ad6, 0xf3e77cf9,
+    0x3e7ccf9f, 0xe7cff9f3, 0xe4e19f3e, 0x4de3cc9f, 0x1dddc78f, 0xdc00dddd,          0,          0,
+             0,          0,          0,   0x3b0000, 0xb6dbbbbb, 0xdbe76db6, 0x5ad6cd6b, 0x9f3eb5af,
+    0xf3e77cf9, 0x3e7ccf9f, 0xe7c3f9f3, 0x6e1d67c8, 0xf1e3bc78, 0xbbbbbbbb,     0x8000,          0,
+             0,          0,          0,          0, 0x77760777, 0xb6dbdb6d, 0xad6b7cf9, 0xb5f35ad6,
+    0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xffc0f804, 0x90008077, 0x614009bf, 0xc78f61e3, 0xdddd1ddd,
+        0xdc00,          0,          0,          0,          0,          0, 0xbbbb003b, 0x6db6b6db,
+    0xcd6bdbe7, 0xb5af5ad6, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9c39e7dc, 0xbc7893e9, 0xbbbbf1e3,
+    0x8000bbbb,          0,          0,          0,          0,          0,  0x7770000, 0xdb6d7776,
+    0x7cf9b6db, 0x5ad6ad6b, 0xe7cfb5f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf86c3e7c, 0xc3b7f90d, 0x3c778f1e,
+    0x77707777,          0,          0,          0,          0,          0,          0, 0xeedbeeee,
+    0xdb6f6db6, 0xad6b9f35, 0xbe7c5ad6, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xe64f7270, 0xe3c7a6f1,
+    0xeeee8eee,     0xee00,          0,          0,          0,          0,          0, 0xdddd001d,
+    0xb6dbdb6d, 0xe6b56df3, 0x5ad7ad6b, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xb3e4f3e1, 0xde3c370e,
+    0xdddd78f1, 0xc000dddd,          0,          0,          0,          0,          0,  0x3bb0000,
+    0x6db6bbbb, 0xbe7cdb6d, 0xad6bd6b5, 0xf3e75af9, 0x3e7ccf9f, 0xe7cff9f3, 0x7c029f3e, 0x403b7fe0,
+    0xfa00c800,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,    0x20000, 0x50186fd8, 0xe3c778f1, 0x77777777,          0,          0,
+             0,          0,          0,          0, 0xeeed0eee, 0x6db6b6db, 0x5ad6f9f3, 0x6be7b5ad,
+    0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e,  0xe64f727, 0x1e3cfa6f, 0xeeee78ee,     0xeee0,          0,
+             0,          0,          0,          0, 0xdddd0001, 0xdb6dddb6, 0x3e6bb6df, 0xb5ad5ad6,
+    0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x1b3e9f3e, 0xede34370, 0x1dddc78f, 0xdc00dddd,          0,
+             0,          0,          0,          0,   0x3b0000, 0xb6dbbbbb, 0xdbe76db6, 0x5ad6cd6b,
+    0x9f3eb5af, 0xf3e77cf9, 0x3e7ccf9f, 0xe7dcf9f3, 0x93e99c39, 0xf1e3bc78, 0xbbbbbbbb,     0x8000,
+             0,          0,          0,          0,          0, 0x77760777, 0xb6dbdb6d, 0xad6b7cf9,
+    0xb5f35ad6, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xf90df86c, 0x8f1ec3b7, 0x77773c77,     0x7770,
+             0,          0,          0,          0,          0, 0xeeee0000, 0x6db6eedb, 0x9f35db6f,
+    0x5ad6ad6b, 0xf9f3be7c, 0x9f3ee7cf, 0xf3e77cf9,   0x9fcf9f,  0xef2f810, 0x37ec0001, 0x3c78280c,
+    0xbbbbf1e3, 0x8000bbbb,          0,          0,          0,          0,          0,  0x7770000,
+    0xdb6d7776, 0x7cf9b6db, 0x5ad6ad6b, 0xe7cfb5f3, 0x7cf99f3e, 0xcf9ff3e7, 0xfb933e7c, 0x7d378732,
+    0x3c778f1e, 0x77707777,          0,          0,          0,          0,          0,          0,
+    0xeedbeeee, 0xdb6f6db6, 0xad6b9f35, 0xbe7c5ad6, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0x21b80d9f,
+    0xe3c776f1, 0xeeee8eee,     0xee00,          0,          0,          0,          0,          0,
+    0xdddd001d, 0xb6dbdb6d, 0xe6b56df3, 0x5ad7ad6b, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0x4e1cf3ee,
+    0xde3cc9f4, 0xdddd78f1, 0xc000dddd,          0,          0,          0,          0,          0,
+    0x3bb0000, 0x6db6bbbb, 0xbe7cdb6d, 0xad6bd6b5, 0xf3e75af9, 0x3e7ccf9f, 0xe7cff9f3, 0x7c369f3e,
+    0xe1db7c86, 0x1e3bc78f, 0xbbb8bbbb,          0,          0,          0,          0,          0,
+             0, 0x776d7777, 0x6db7b6db, 0xd6b5cf9a, 0x5f3ead6b, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3,
+    0xfc08804f,      0x779, 0x14069bf6, 0x78f11e3c, 0xdddddddd,     0xc000,          0,          0,
+             0,          0,          0, 0xbbbb03bb, 0xdb6d6db6, 0xd6b5be7c, 0x5af9ad6b, 0xcf9ff3e7,
+    0xf9f33e7c, 0x9f3ee7cf, 0xc3997dc9, 0xc78f3e9b, 0xbbbb1e3b,     0xbbb8,          0,          0,
+             0,          0,          0, 0x77770000, 0xb6db776d, 0xcf9a6db7, 0xad6bd6b5, 0x7cf95f3e,
+    0xcf9ff3e7, 0xf9f33e7c, 0x86cfe7cf, 0x3b7890dc, 0xc777f1e3, 0x77007777,          0,          0,
+             0,          0,          0,    0xe0000, 0xedb6eeee, 0xb6f9db6d, 0xd6b5f35a, 0xe7cfad6b,
+    0x7cf99f3e, 0xcf9ff3e7, 0xf9f73e7c, 0x64fa270e, 0x3c786f1e, 0xeeeeeeee,     0xe000,          0,
+             0,          0,          0,          0, 0xdddd01dd, 0x6db6b6db, 0x6b5adf3e, 0xad7cd6b5,
+    0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0x3e433e1b, 0xe3c770ed, 0xdddd8f1d,     0xdddc,          0,
+             0,          0,          0,          0, 0x3bbb0000, 0xdb6dbbb6, 0xe7cdb6db, 0xd6b56b5a,
+    0x3e7caf9f, 0xe7cff9f3, 0x7cf99f3e, 0xc027f3e7,  0x3bcfe04, 0x4dfb8000,  0xf1e0a03, 0xeeee3c78,
+    0xe000eeee,          0,          0,          0,          0,          0,  0x1dd0000, 0xb6dbdddd,
+    0xdf3e6db6, 0xd6b56b5a, 0xf9f3ad7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3ee4cf9f, 0x9f4de1cc, 0x8f1de3c7,
+    0xdddcdddd,          0,          0,          0,          0,          0,          0, 0xbbb63bbb,
+    0xb6dbdb6d, 0x6b5ae7cd, 0xaf9fd6b5, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0xc86ec367, 0x78f11dbc,
+    0xbbbbe3bb,     0xbb80,          0,          0,          0,          0,          0, 0x77770007,
+    0x6db676db, 0xf9addb7c, 0xd6b56b5a, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0x93877cfb, 0x378f327d,
+    0x77771e3c, 0x70007777,          0,          0,          0,          0,          0,   0xee0000,
+    0xdb6deeee, 0x6f9fb6db, 0x6b5a35ad, 0x7cf9d6be, 0xcf9ff3e7, 0xf9f33e7c, 0x9f0de7cf, 0xb8769f21,
+    0xc78ef1e3, 0xeeeeeeee,          0,          0,          0,          0,          0,          0,
+    0xdddb1ddd, 0xdb6d6db6, 0xb5adf3e6, 0xd7cf6b5a, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0xff02e013,
+         0x1de,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,    0x30000,  0x8a1e6a4,          0,          0,          0,          0,          0,
+
+};
+
+static const unsigned int muted_frame_atmos[DDP_MUTE_FRAME_SIZE] = {
+    0x4e1ff872,  0xbe40715,  0x5f10b77, 0xfffa3f67, 0x41014900, 0x20000f01, 0x10000000, 0x23840000,
+    0x18610186, 0xeaf987fc, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3,
+    0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e,
+    0xcf9ff3e7, 0xabe77ff3, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf,
+    0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9,
+    0x3e7dcf9f, 0xaf9fffce, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e,
+    0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7,
+    0xf9f73e7c, 0xbe7cff3a, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9,
+    0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f,
+    0xe7dff9f3, 0xf9f3fcea, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7,
+    0xf9f33e7c, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c,
+    0x9f7fe7cf, 0x53e3f3ae,   0x7f87fe, 0x1e3c80ef, 0xeeee78ee,     0xeee0,          0,          0,
+             0,          0,          0, 0xdddd0001, 0xdb6dddb6, 0x3e6bb6df, 0xb5ad5ad6, 0xf3e77cf9,
+    0x3e7ccf9f, 0xe7cff9f3,  0x23f9f3e, 0x1de3e040, 0x1dddc78f, 0xdc00dddd,          0,          0,
+             0,          0,          0,   0x3b0000, 0xb6dbbbbb, 0xdbe76db6, 0x5ad6cd6b, 0x9f3eb5af,
+    0xf3e77cf9, 0x3e7ccf9f, 0xe7c0f9f3,    0x30400, 0xf1e3bc78, 0xbbbbbbbb,     0x8000,          0,
+             0,          0,          0,          0, 0x77760777, 0xb6dbdb6d, 0xad6b7cf9, 0xb5f35ad6,
+    0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0x8000f801, 0x8f1e4077, 0x77773c77,     0x7770,          0,
+             0,          0,          0,          0, 0xeeee0000, 0x6db6eedb, 0x9f35db6f, 0x5ad6ad6b,
+    0xf9f3be7c, 0x9f3ee7cf, 0xf3e77cf9,   0x30cf9f,  0xef10008, 0x8eeee3c7, 0xee00eeee,          0,
+             0,          0,          0,          0,   0x1d0000, 0xdb6ddddd, 0x6df3b6db, 0xad6be6b5,
+    0xcf9f5ad7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e07cf9,  0xb0657fb,  0x3ff1e40, 0xc077003f, 0x3c778f1e,
+    0x77707777,          0,          0,          0,          0,          0,          0, 0xeedbeeee,
+    0xdb6f6db6, 0xad6b9f35, 0xbe7c5ad6, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0xf020011f, 0xe3c70ef1,
+    0xeeee8eee,     0xee00,          0,          0,          0,          0,          0, 0xdddd001d,
+    0xb6dbdb6d, 0xe6b56df3, 0x5ad7ad6b, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e,  0x200f3e0, 0xde3c0001,
+    0xdddd78f1, 0xc000dddd,          0,          0,          0,          0,          0,  0x3bb0000,
+    0x6db6bbbb, 0xbe7cdb6d, 0xad6bd6b5, 0xf3e75af9, 0x3e7ccf9f, 0xe7cff9f3, 0x7c009f3e, 0x203bc000,
+    0x1e3bc78f, 0xbbb8bbbb,          0,          0,          0,          0,          0,          0,
+    0x776d7777, 0x6db7b6db, 0xd6b5cf9a, 0x5f3ead6b, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3,    0x48018,
+    0xf1e30778, 0x7777c777,     0x7700,          0,          0,          0,          0,          0,
+    0xeeee000e, 0xdb6dedb6, 0xf35ab6f9, 0xad6bd6b5, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0x2bfdf9f0,
+     0xf208583, 0x583803e8,  0x86900ce,     0x81c0, 0x5e000c04, 0x2000b83f, 0x8443481f, 0xa27fe000,
+    0x40ffbe80, 0x81df3f00,  0x3fc0201,  0xa100402, 0x41501f80,  0x20a81f4, 0x20108400, 0x1f900074,
+     0x384008f, 0xa9a90161, 0xa9a9a9a9, 0xa9a9a9a9, 0xa9a9a9a9,     0xa800, 0x60180001,     0x5954,
+       0x90000, 0x88dad018,    0xc0000,     0x1600,  0x3050000,     0x8000,          0,          0,
+             0,          0,          0, 0x4492000c,     0x8000,          0,          0,          0,
+             0,          0,          0, 0xb2d00030,          0,          0,          0,          0,
+             0,          0,     0x182c,          0, 0x61750002, 0x21802d12, 0xcdcdcdcd, 0xcdcdcdcd,
+    0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd,
+    0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd,
+    0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd,
+    0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd,
+    0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd,
+    0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd,
+    0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd,
+    0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd,
+    0xcdcdcdcd, 0xcdcdcdcd, 0xcdcdcdcd, 0xffc0cd00, 0x1de30ff0, 0x1dddc78f, 0xdc00dddd,          0,
+             0,          0,          0,          0,   0x3b0000, 0xb6dbbbbb, 0xdbe76db6, 0x5ad6cd6b,
+    0x9f3eb5af, 0xf3e77cf9, 0x3e7ccf9f, 0xe7c0f9f3,  0x80347fc, 0xf1e3bc78, 0xbbbbbbbb,     0x8000,
+             0,          0,          0,          0,          0, 0x77760777, 0xb6dbdb6d, 0xad6b7cf9,
+    0xb5f35ad6, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f, 0x8000f800, 0x8f1e0077, 0x77773c77,     0x7770,
+             0,          0,          0,          0,          0, 0xeeee0000, 0x6db6eedb, 0x9f35db6f,
+    0x5ad6ad6b, 0xf9f3be7c, 0x9f3ee7cf, 0xf3e77cf9,   0x30cf9f,  0xef10008, 0x8eeee3c7, 0xee00eeee,
+             0,          0,          0,          0,          0,   0x1d0000, 0xdb6ddddd, 0x6df3b6db,
+    0xad6be6b5, 0xcf9f5ad7, 0xf9f33e7c, 0x9f3ee7cf, 0xf3e07cf9,  0x1010600, 0x78f1de3c, 0xdddddddd,
+        0xc000,          0,          0,          0,          0,          0, 0xbbbb03bb, 0xdb6d6db6,
+    0xd6b5be7c, 0x5af9ad6b, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf, 0xff617c0a, 0xc80060c3,  0x7f87fe0,
+    0xe3c70ef1, 0xeeee8eee,     0xee00,          0,          0,          0,          0,          0,
+    0xdddd001d, 0xb6dbdb6d, 0xe6b56df3, 0x5ad7ad6b, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf99f3e, 0x23fef3e0,
+    0xde3c0401, 0xdddd78f1, 0xc000dddd,          0,          0,          0,          0,          0,
+     0x3bb0000, 0x6db6bbbb, 0xbe7cdb6d, 0xad6bd6b5, 0xf3e75af9, 0x3e7ccf9f, 0xe7cff9f3, 0x7c009f3e,
+      0x3b4000, 0x1e3bc78f, 0xbbb8bbbb,          0,          0,          0,          0,          0,
+             0, 0x776d7777, 0x6db7b6db, 0xd6b5cf9a, 0x5f3ead6b, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3,
+       0x48018, 0xf1e30778, 0x7777c777,     0x7700,          0,          0,          0,          0,
+             0, 0xeeee000e, 0xdb6dedb6, 0xf35ab6f9, 0xad6bd6b5, 0x9f3ee7cf, 0xf3e77cf9, 0x3e7ccf9f,
+     0x300f9f0, 0xef1e0080, 0xeeee3c78, 0xe000eeee,          0,          0,          0,          0,
+              0,  0x1dd0000, 0xb6dbdddd, 0xdf3e6db6, 0xd6b56b5a, 0xf9f3ad7c, 0x9f3ee7cf, 0xf3e77cf9,
+    0x3e05cf9f, 0xb0617fb0, 0x3ff0e400,  0x77803fc, 0xc777f1e3, 0x77007777,          0,          0,
+             0,          0,          0,    0xe0000, 0xedb6eeee, 0xb6f9db6d, 0xd6b5f35a, 0xe7cfad6b,
+    0x7cf99f3e, 0xcf9ff3e7, 0xf9f03e7c,  0x20011ff, 0x3c78ef1e, 0xeeeeeeee,     0xe000,          0,
+             0,          0,          0,          0, 0xdddd01dd, 0x6db6b6db, 0x6b5adf3e, 0xad7cd6b5,
+    0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7, 0x20003e00, 0xe3c7001d, 0xdddd8f1d,     0xdddc,          0,
+             0,          0,          0,          0, 0x3bbb0000, 0xdb6dbbb6, 0xe7cdb6db, 0xd6b56b5a,
+    0x3e7caf9f, 0xe7cff9f3, 0x7cf99f3e, 0xc00cf3e7,  0x3bc0002, 0xe3bb78f1, 0xbb80bbbb,          0,
+             0,          0,          0,          0,    0x70000, 0x76db7777, 0xdb7c6db6, 0x6b5af9ad,
+    0xf3e7d6b5, 0x3e7ccf9f, 0xe7cff9f3, 0x7cf89f3e,   0x400180, 0x1e3c778f, 0x77777777,     0x7000,
+             0,          0,          0,          0,          0, 0xeeee00ee, 0xb6dbdb6d, 0x35ad6f9f,
+    0xd6be6b5a, 0xf3e77cf9, 0x3e7ccf9f, 0xe7cff9f3, 0xbfd89f02, 0xf2005830,  0x1fe1ff8, 0x78f103bc,
+    0xbbbbe3bb,     0xbb80,          0,          0,          0,          0,          0, 0x77770007,
+    0x6db676db, 0xf9addb7c, 0xd6b56b5a, 0xcf9ff3e7, 0xf9f33e7c, 0x9f3ee7cf,  0x8ff7cf8, 0x778f8100,
+    0x77771e3c, 0x70007777,          0,          0,          0,          0,          0,   0xee0000,
+    0xdb6deeee, 0x6f9fb6db, 0x6b5a35ad, 0x7cf9d6be, 0xcf9ff3e7, 0xf9f33e7c, 0x9f00e7cf,    0xe1000,
+    0xc78ef1e3, 0xeeeeeeee,          0,          0,          0,          0,          0,          0,
+    0xdddb1ddd, 0xdb6d6db6, 0xb5adf3e6, 0xd7cf6b5a, 0x7cf99f3e, 0xcf9ff3e7, 0xf9f33e7c,    0x1e006,
+    0x3c7801de, 0xddddf1dd,     0xddc0,          0,          0,          0,          0,          0,
+    0xbbbb0003, 0xb6dbbb6d, 0x7cd66dbe, 0x6b5ab5ad, 0xe7cff9f3, 0x7cf99f3e, 0xcf9ff3e7,   0xc03e7c,
+    0x3bc70020, 0x3bbb8f1e, 0xb800bbbb,          0,          0,          0,          0,          0,
+      0x770000, 0x6db67777, 0xb7cfdb6d, 0xb5ad9ad6, 0x3e7c6b5f, 0xe7cff9f3, 0x7cf99f3e, 0xcf81f3e7,
+    0x2c185fec,     0x7800,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,          0,          0,          0,          0,          0,          0,          0,
+             0,    0x30000, 0x19b76198,          0,          0,          0,          0,          0,
+};
+
+//DRC Mode
+#define DDPI_UDC_COMP_LINE 2
+#define DRC_MODE_BIT  0
+#define DRC_HIGH_CUT_BIT 3
+#define DRC_LOW_BST_BIT 16
+static const char *str_compmode[] = {"custom mode, analog dialnorm","custom mode, digital dialnorm",
+                            "line out mode","RF remod mode"};
+
 int64_t aml_gettime(void)
 {
     struct timeval tv;
@@ -59,14 +290,16 @@ int64_t aml_gettime(void)
 }
 int get_sysfs_uint(const char *path, uint *value)
 {
-    int fd;
+    int fd, nread;
     char valstr[64];
     uint val = 0;
     fd = open(path, O_RDONLY);
     if (fd >= 0) {
         memset(valstr, 0, 64);
-        read(fd, valstr, 64 - 1);
-        valstr[strlen(valstr)] = '\0';
+        nread = read(fd, valstr, 64 - 1);
+        if (nread > 0) {
+            valstr[nread] = '\0';
+        }
         close(fd);
     } else {
         ALOGE("unable to open file %s\n", path);
@@ -95,32 +328,16 @@ int sysfs_set_sysfs_str(const char *path, const char *val)
     return -1;
 }
 
-int  sysfs_get_sysfs_str(const char *path, char *valstr, int size)
-{
-    int fd;
-    fd = open(path, O_RDONLY);
-    if (fd >= 0) {
-        memset(valstr,0,size);
-        read(fd, valstr, size - 1);
-        valstr[strlen(valstr)] = '\0';
-        close(fd);
-    } else {
-        ALOGE("unable to open file %s,err: %s", path, strerror(errno));
-        sprintf(valstr, "%s", "fail");
-        return -1;
-    };
-    //LOGI("get_sysfs_str=%s\n", valstr);
-    return 0;
-}
-
 int get_sysfs_int(const char *path)
 {
-    int val = 0;
+    int val = 0, nread;
     int fd = open(path, O_RDONLY);
     if (fd >= 0) {
         char bcmd[16];
-        read(fd, bcmd, sizeof(bcmd));
-        val = strtol(bcmd, NULL, 10);
+        nread = read(fd, bcmd, sizeof(bcmd));
+        if (nread > 0) {
+            val = strtol(bcmd, NULL, 10);
+        }
         close(fd);
     } else {
         ALOGD("[%s]open %s node failed! return 0\n", path, __FUNCTION__);
@@ -168,6 +385,7 @@ unsigned char codec_type_is_raw_data(int type)
     case TYPE_DTS:
     case TYPE_DTS_HD:
     case TYPE_DTS_HD_MA:
+    case TYPE_AC4:
         return 1;
     default:
         return 0;
@@ -191,6 +409,8 @@ int get_codec_type(int format)
     case AUDIO_FORMAT_AC4:
         return TYPE_AC4;
     case AUDIO_FORMAT_PCM:
+    case AUDIO_FORMAT_PCM_16_BIT:
+    case AUDIO_FORMAT_PCM_32_BIT:
         return TYPE_PCM;
     default:
         return TYPE_PCM;
@@ -442,15 +662,50 @@ int aml_audio_dump_audio_bitstreams(const char *path, const void *buf, size_t by
 
     return 0;
 }
-int aml_audio_get_arc_latency_offset(int aformat)
+
+int aml_audio_get_ms12_latency_offset(int b_raw)
 {
     char buf[PROPERTY_VALUE_MAX];
     int ret = -1;
     int latency_ms = 0;
     char *prop_name = NULL;
-	(void)aformat;
-    prop_name = "media.audio.hal.arc_latency.ddp";
-    latency_ms = -40;
+
+    if (b_raw == 0) {
+        /*for non tunnel ddp2h/heaac case:netlfix AL1 case */
+        prop_name = AVSYNC_MS12_NONTUNNEL_PCM_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_NONTUNNEL_PCM_LATENCY;
+    }else {
+        /*for non tunnel dolby ddp5.1 case:netlfix AL1 case*/
+        prop_name = AVSYNC_MS12_NONTUNNEL_RAW_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_NONTUNNEL_RAW_LATENCY;
+    }
+
+    ret = property_get(prop_name, buf, NULL);
+    if (ret > 0) {
+        latency_ms = atoi(buf);
+    }
+    /*because the caller use add fucntion, instead of minus, so we return the minus value*/
+    return -latency_ms;
+}
+int aml_audio_get_ms12_tunnel_latency_offset(int b_raw)
+{
+    char buf[PROPERTY_VALUE_MAX];
+    int ret = -1;
+    int latency_ms = 0;
+    char *prop_name = NULL;
+    /*tunnle mode case*/
+    latency_ms = 0;
+
+    if (b_raw == 0) {
+        /*for non tunnel ddp2h/heaac case:netlfix AL1 case */
+        prop_name = AVSYNC_MS12_TUNNEL_PCM_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_TUNNEL_PCM_LATENCY;
+    } else {
+        /*for non tunnel dolby ddp5.1 case:netlfix AL1 case*/
+        prop_name = AVSYNC_MS12_TUNNEL_RAW_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_TUNNEL_RAW_LATENCY;
+    }
+
     ret = property_get(prop_name, buf, NULL);
     if (ret > 0) {
         latency_ms = atoi(buf);
@@ -458,20 +713,26 @@ int aml_audio_get_arc_latency_offset(int aformat)
     return latency_ms;
 }
 
-int aml_audio_get_hwsync_latency_offset(void)
+int aml_audio_get_ms12_atmos_latency_offset(int tunnel)
 {
-	char buf[PROPERTY_VALUE_MAX];
-	int ret = -1;
-	int latency_ms = 0;
-	char *prop_name = NULL;
-
-	prop_name = "media.audio.hal.hwsync_latency.ddp";
-	latency_ms = 0;
-	ret = property_get(prop_name, buf, NULL);
-	if (ret > 0) {
-		latency_ms = atoi(buf);
-	}
-	return latency_ms;
+    char buf[PROPERTY_VALUE_MAX];
+    int ret = -1;
+    int latency_ms = 0;
+    char *prop_name = NULL;
+    if (tunnel) {
+        /*tunnel atmos case*/
+        prop_name = AVSYNC_MS12_TUNNEL_ATMOS_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_TUNNEL_ATMOS_LATENCY;
+    }else {
+        /*non tunnel atmos case*/
+        prop_name = AVSYNC_MS12_NONTUNNEL_ATMOS_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_NONTUNNEL_ATMOS_LATENCY;
+    }
+    ret = property_get(prop_name, buf, NULL);
+    if (ret > 0) {
+        latency_ms = atoi(buf);
+    }
+    return latency_ms;
 }
 
 int aml_audio_get_ddp_frame_size()
@@ -489,7 +750,7 @@ int aml_audio_get_ddp_frame_size()
 
 bool is_stream_using_mixer(struct aml_stream_out *out)
 {
-    return is_inport_valid(out->port_index);
+    return is_inport_valid(out->enInputPortType);
 }
 
 uint32_t out_get_outport_latency(const struct audio_stream_out *stream)
@@ -500,6 +761,12 @@ uint32_t out_get_outport_latency(const struct audio_stream_out *stream)
     struct amlAudioMixer *audio_mixer = sm->mixerData;
     int frames = 0, latency_ms = 0;
 
+#ifdef ENABLE_BT_A2DP
+    if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+        return a2dp_out_get_latency(stream);
+    }
+#endif
+
     if (is_stream_using_mixer(out)) {
         int outport_latency_frames = mixer_get_outport_latency_frames(audio_mixer);
 
@@ -517,7 +784,7 @@ uint32_t out_get_outport_latency(const struct audio_stream_out *stream)
 static int get_fmt_rate(int codec_type)
 {
     int rate = 1;
-    if ((codec_type == TYPE_EAC3) ||
+    if( (codec_type == TYPE_EAC3) ||
         (codec_type == TYPE_DTS_HD_MA) ||
         (codec_type == TYPE_DTS_HD))
         rate = 4;
@@ -532,8 +799,6 @@ uint32_t out_get_latency_frames(const struct audio_stream_out *stream)
     snd_pcm_sframes_t frames = 0;
     uint32_t whole_latency_frames;
     int ret = 0;
-    //TODO: hal_internal_format may not be the final format to ALSA side (with MS12)
-    //should we use sink and optical format?
     int codec_type = get_codec_type(out->hal_internal_format);
     int mul = 1;
     if (out->dual_output_flag) {
@@ -553,6 +818,62 @@ uint32_t out_get_latency_frames(const struct audio_stream_out *stream)
     return frames / mul;
 }
 
+uint32_t out_get_ms12_latency_frames(const struct audio_stream_out *stream)
+{
+    const struct aml_stream_out *hal_out = (const struct aml_stream_out *)stream;
+    snd_pcm_sframes_t frames = 0;
+    struct snd_pcm_status status;
+    uint32_t whole_latency_frames;
+    int ret = 0;
+    struct aml_audio_device *adev = hal_out->dev;
+    struct aml_stream_out *ms12_out = adev->ms12_out;
+    struct pcm_config *config = &adev->ms12_config;
+    int mul = 1;
+
+    if (ms12_out == NULL) {
+        return 0;
+    }
+    if (adev->sink_format == AUDIO_FORMAT_E_AC3) {
+        mul = 4;
+    }
+
+    whole_latency_frames = config->start_threshold;
+    if (!ms12_out->pcm || !pcm_is_ready(ms12_out->pcm)) {
+        return whole_latency_frames / mul;
+    }
+
+    ret = pcm_ioctl(ms12_out->pcm, SNDRV_PCM_IOCTL_STATUS, &status);
+    if (ret < 0) {
+        return whole_latency_frames / mul;
+    }
+    if (status.state != PCM_STATE_RUNNING && status.state != PCM_STATE_DRAINING) {
+        return whole_latency_frames / mul;
+    }
+
+    ret = pcm_ioctl(ms12_out->pcm, SNDRV_PCM_IOCTL_DELAY, &frames);
+    if (ret < 0) {
+        return whole_latency_frames / mul;
+    }
+    return frames / mul;
+}
+
+int aml_audio_get_ms12_passthrough_latency(struct audio_stream_out *stream)
+{
+    char *prop_name = AUDIO_ATMOS_HDMI_PASSTHROUGH_PROPERTY;
+    char buf[PROPERTY_VALUE_MAX];
+    int latency_ms = 0;
+    int ret = -1;
+    if(is_bypass_ms12(stream))
+    {
+        latency_ms = VENDOR_AUDIO_MS12_PASSTHROUGH_LATENCY;
+        ret = property_get(prop_name, buf, NULL);
+        if (ret > 0) {
+            latency_ms = atoi(buf);
+        }
+    }
+    return latency_ms;
+}
+
 int aml_audio_get_spdif_tuning_latency(void)
 {
     char *prop_name = "persist.vendor.audio.hal.spdif_ltcy_ms";
@@ -567,29 +888,99 @@ int aml_audio_get_spdif_tuning_latency(void)
 
     return latency_ms;
 }
-
-int aml_audio_get_arc_tuning_latency(audio_format_t arc_fmt)
+int aml_audio_get_speaker_latency_offset(audio_format_t fmt)
 {
     char *prop_name = NULL;
     char buf[PROPERTY_VALUE_MAX];
     int latency_ms = 0;
     int ret = -1;
 
-    switch (arc_fmt) {
+    switch (fmt) {
+    case AUDIO_FORMAT_PCM_16_BIT:
+        prop_name = AVSYNC_SPEAKER_PCM_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_SPEAKER_PCM_LATENCY;
+        break;
+    case AUDIO_FORMAT_AC3:
+        prop_name = AVSYNC_SPEAKER_DD_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_SPEAKER_DD_LATENCY;
+        break;
+    case AUDIO_FORMAT_E_AC3:
+        prop_name = AVSYNC_SPEAKER_DDP_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_SPEAKER_DDP_LATENCY;
+        break;
+    case AUDIO_FORMAT_AC4:
+        prop_name = AVSYNC_SPEAKER_AC4_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_SPEAKER_AC4_LATENCY;
+        break;
+
+    case AUDIO_FORMAT_MAT:
+        prop_name = AVSYNC_SPEAKER_MAT_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_SPEAKER_MAT_LATENCY;
+    break;
+
+    default:
+        ALOGE("%s(), unsupported audio format : %#x", __func__, fmt);
+        return 0;
+    }
+
+    ret = property_get(prop_name, buf, NULL);
+    if (ret > 0) {
+        latency_ms = atoi(buf);
+    }
+
+    return latency_ms;
+}
+
+
+int aml_audio_get_atmos_hdmi_latency_offset(audio_format_t fmt,int bypass)
+{
+    char *prop_name = AUDIO_ATMOS_HDMI_LANTCY_PROPERTY;
+    char buf[PROPERTY_VALUE_MAX];
+    int latency_ms = 0;
+    int ret = -1;
+    if (!bypass&&fmt)
+    {
+        latency_ms = AUDIO_ATMOS_HDMI_AUTO_LATENCY;
+        ret = property_get(prop_name, buf, NULL);
+        if (ret > 0)
+        {
+            latency_ms = atoi(buf);
+        }
+    }
+    return latency_ms;
+}
+
+int aml_audio_get_hdmi_latency_offset(audio_format_t fmt)
+{
+    char *prop_name = NULL;
+    char buf[PROPERTY_VALUE_MAX];
+    int latency_ms = 0;
+    int ret = -1;
+    switch (fmt) {
     case AUDIO_FORMAT_PCM_16_BIT:
-        prop_name = "persist.audio.arc_ltcy.pcm";
+        prop_name = AVSYNC_HDMI_PCM_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_HDMI_PCM_LATENCY;
         break;
     case AUDIO_FORMAT_AC3:
-        prop_name = "persist.audio.arc_ltcy.dd";
+        prop_name = AVSYNC_HDMI_DD_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_HDMI_DD_LATENCY;
         break;
     case AUDIO_FORMAT_E_AC3:
-        prop_name = "persist.audio.arc_ltcy.ddp";
+        prop_name = AVSYNC_HDMI_DDP_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_HDMI_DDP_LATENCY;
         break;
     case AUDIO_FORMAT_MAT:
-        prop_name = "persist.audio.arc_ltcy.mat";
+        prop_name = AVSYNC_HDMI_MAT_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_HDMI_MAT_LATENCY;
+        break;
+
+    case  AUDIO_FORMAT_AC4:
+        prop_name = AVSYNC_HDMI_AC4_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_HDMI_AC4_LATENCY;
         break;
+
     default:
-        ALOGE("%s(), unsupported audio arc_fmt: %#x", __func__, arc_fmt);
+        ALOGE("%s(), unsupported audio format : %#x", __func__, fmt);
         return 0;
     }
 
@@ -601,7 +992,7 @@ int aml_audio_get_arc_tuning_latency(audio_format_t arc_fmt)
     return latency_ms;
 }
 
-int aml_audio_get_src_tune_latency(enum patch_src_assortion patch_src) {
+int aml_audio_get_tvsrc_tune_latency(enum patch_src_assortion patch_src) {
     char *prop_name = NULL;
     char buf[PROPERTY_VALUE_MAX];
     int latency_ms = 0;
@@ -681,7 +1072,7 @@ int cpy_16bit_data_with_gain(int16_t *dst, int16_t *src, int size_in_bytes, floa
 
 static inline uint64_t timespec_ns(struct timespec tspec)
 {
-    return (tspec.tv_sec * 1000000000 + tspec.tv_nsec);
+    return ((uint64_t)tspec.tv_sec * 1000000000 + tspec.tv_nsec);
 }
 
 uint64_t get_systime_ns(void)
@@ -693,25 +1084,6 @@ uint64_t get_systime_ns(void)
     return timespec_ns(tval);
 }
 
-int aml_audio_get_hdmi_latency_offset(int aformat)
-{
-    char buf[PROPERTY_VALUE_MAX];
-    char *prop_name = NULL;
-    int ret = -1;
-    int latency_ms = 0;
-
-    (void)aformat;
-    // PCM latency
-    prop_name = "media.audio.hal.hdmi_latency.pcm";
-    latency_ms = -52;
-    ret = property_get(prop_name, buf, NULL);
-    if (ret > 0)
-    {
-        latency_ms = atoi(buf);
-    }
-
-    return latency_ms;
-}
 
 // tval_new *must* later than tval_old
 uint32_t tspec_diff_to_us(struct timespec tval_old,
@@ -721,6 +1093,23 @@ uint32_t tspec_diff_to_us(struct timespec tval_old,
             + (tval_new.tv_nsec - tval_old.tv_nsec) / 1000;
 }
 
+int aml_set_thread_priority(char *pName, pthread_t threadId)
+{
+    struct sched_param  params = {0};
+    int                 ret = 0;
+    int                 policy = SCHED_FIFO; /* value:1 [pthread.h] */
+    params.sched_priority = 5;
+    ret = pthread_setschedparam(threadId, SCHED_FIFO, &params);
+    if (ret != 0) {
+        ALOGW("[%s:%d] set scheduled param error, ret:%#x", __func__, __LINE__, ret);
+    }
+    ret = pthread_getschedparam(threadId, &policy, &params);
+    ALOGD("[%s:%d] thread:%s set priority, ret:%d policy:%d priority:%d",
+            __func__, __LINE__, pName, ret, policy, params.sched_priority);
+    return ret;
+}
+
+
 void aml_audio_switch_output_mode(int16_t *buf, size_t bytes, AM_AOUT_OutputMode_t mode)
 {
     int16_t tmp;
@@ -749,3 +1138,115 @@ void aml_audio_switch_output_mode(int16_t *buf, size_t bytes, AM_AOUT_OutputMode
     }
 }
 
+void * aml_audio_get_muteframe(audio_format_t output_format, int * frame_size, int bAtmos) {
+    if (output_format == AUDIO_FORMAT_AC3) {
+        *frame_size = sizeof(muted_frame_dd);
+        return (void*)muted_frame_dd;
+    } else if (output_format == AUDIO_FORMAT_E_AC3) {
+        if (bAtmos) {
+            *frame_size = sizeof(muted_frame_atmos);
+            return (void*)muted_frame_atmos;
+        } else {
+            *frame_size = sizeof(muted_frame_ddp);
+            return (void*)muted_frame_ddp;
+        }
+    } else {
+        *frame_size = 0;
+        return NULL;
+    }
+}
+
+
+int aml_audio_get_dolby_drc_mode(int *drc_mode, int *drc_cut, int *drc_boost)
+{
+    char cEndpoint[PROPERTY_VALUE_MAX];
+    int ret = 0;
+    unsigned ac3_drc_control = (DDPI_UDC_COMP_LINE<<DRC_MODE_BIT)|(100<<DRC_HIGH_CUT_BIT)|(100<<DRC_LOW_BST_BIT);
+    ac3_drc_control = get_sysfs_int("/sys/class/audiodsp/ac3_drc_control");
+
+    if (!drc_mode || !drc_cut || !drc_boost)
+        return -1;
+    *drc_mode = ac3_drc_control&3;
+    ALOGI("drc mode from sysfs %s\n",str_compmode[*drc_mode]);
+    ret = property_get("ro.dolby.drcmode",cEndpoint,"");
+    if (ret > 0) {
+        *drc_mode = atoi(cEndpoint)&3;
+        ALOGI("drc mode from prop %s\n",str_compmode[*drc_mode]);
+    }
+    *drc_cut  = (ac3_drc_control>>DRC_HIGH_CUT_BIT)&0xff;
+    *drc_boost  = (ac3_drc_control>>DRC_LOW_BST_BIT)&0xff;
+    ALOGI("dd+ drc mode %s,high cut %d pct,low boost %d pct\n",
+        str_compmode[*drc_mode],*drc_cut, *drc_boost);
+    return 0;
+}
+
+
+void aml_tinymix_set_spdif_format(audio_format_t output_format,struct aml_stream_out *stream)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device *aml_dev = aml_out->dev;
+    int aml_spdif_format = AML_STEREO_PCM;
+    int spdif_mute = 0;
+    if (output_format == AUDIO_FORMAT_AC3) {
+        aml_spdif_format = AML_DOLBY_DIGITAL;
+#ifdef ENABLE_DTV_PATCH
+        audio_set_spdif_clock(stream, AML_DOLBY_DIGITAL);
+#endif
+    } else if (output_format == AUDIO_FORMAT_E_AC3) {
+        aml_spdif_format = AML_DOLBY_DIGITAL_PLUS;
+#ifdef ENABLE_DTV_PATCH
+        audio_set_spdif_clock(stream, AML_DOLBY_DIGITAL_PLUS);
+#endif
+        // for BOX with ms12 continous mode, need DDP output
+        if ((eDolbyMS12Lib == aml_dev->dolby_lib_type) && aml_dev->continuous_audio_mode && !aml_dev->is_TV) {
+            // do nothing
+        } else {
+            spdif_mute = 1;
+        }
+    } else if (output_format == AUDIO_FORMAT_MAT) {
+        aml_spdif_format = AML_TRUE_HD;
+#ifdef ENABLE_DTV_PATCH
+        audio_set_spdif_clock(stream, AML_TRUE_HD);
+#endif
+        if ((eDolbyMS12Lib == aml_dev->dolby_lib_type) && aml_dev->continuous_audio_mode && !aml_dev->is_TV) {
+            // do nothing
+        } else {
+            spdif_mute = 1;
+        }
+    } else if (output_format == AUDIO_FORMAT_DTS) {
+        aml_spdif_format = AML_DTS;
+#ifdef ENABLE_DTV_PATCH
+        audio_set_spdif_clock(stream, AML_DTS);
+#endif
+    } else {
+        aml_spdif_format = AML_STEREO_PCM;
+#ifdef ENABLE_DTV_PATCH
+        audio_set_spdif_clock(stream, AML_STEREO_PCM);
+#endif
+    }
+    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_FORMAT, aml_spdif_format);
+    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_EARC_AUDIO_TYPE,aml_spdif_format);
+    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_MUTE, spdif_mute);
+    ALOGI("%s tinymix AML_MIXER_ID_SPDIF_FORMAT %d,spdif mute %d",
+          __FUNCTION__, aml_spdif_format, spdif_mute);
+}
+
+
+void aml_audio_set_cpu23_affinity()
+{
+    cpu_set_t cpuSet;
+    CPU_ZERO(&cpuSet);
+    CPU_SET(2, &cpuSet);
+    CPU_SET(3, &cpuSet);
+    int status = sched_setaffinity(0, sizeof(cpu_set_t), &cpuSet);
+    if (status) {
+        ALOGW("%s(), failed to set cpu affinity", __FUNCTION__);
+    }
+}
+int aml_audio_get_video_latency(void)
+{
+    int latency_ms = 0;
+    latency_ms = get_sysfs_int("/sys/class/video/video_display_latency");
+    latency_ms = latency_ms/1000000;
+    return latency_ms;
+}
diff --git a/audio_hal/audio_hw_utils.h b/audio_hal/audio_hw_utils.h
index 19f1fdb..28724f9 100644
--- a/audio_hal/audio_hw_utils.h
+++ b/audio_hal/audio_hw_utils.h
@@ -23,6 +23,18 @@
 #include "aml_audio_types_def.h"
 #include "aml_audio_stream.h"
 
+#define ENUM_TYPE_STR_MAX_LEN                           (100)
+
+#define ENUM_TYPE_TO_STR(x, offset, pStr)                   \
+case x: {                                                   \
+    pStr = #x;                                              \
+    pStr += offset;                                         \
+    if (strlen(#x) - offset > 70) {                         \
+        pStr += 70;                                         \
+    }                                                       \
+    break;                                                  \
+}
+
 int64_t aml_gettime(void);
 int get_sysfs_uint(const char *path, uint *value);
 int sysfs_set_sysfs_str(const char *path, const char *val);
@@ -40,23 +52,39 @@ int is_txl_chip();
 int aml_audio_get_debug_flag();
 int aml_audio_debug_set_optical_format();
 int aml_audio_dump_audio_bitstreams(const char *path, const void *buf, size_t bytes);
-int aml_audio_get_arc_latency_offset(int format);
-int aml_audio_get_hwsync_latency_offset(void);
+int aml_audio_get_ms12_latency_offset(int b_raw);
+int aml_audio_get_ms12_tunnel_latency_offset(int b_raw);
+int aml_audio_get_ms12_atmos_latency_offset(int tunnel);
+
 int aml_audio_get_ddp_frame_size();
 bool is_stream_using_mixer(struct aml_stream_out *out);
 uint32_t out_get_outport_latency(const struct audio_stream_out *stream);
 uint32_t out_get_latency_frames(const struct audio_stream_out *stream);
 int aml_audio_get_spdif_tuning_latency(void);
-int aml_audio_get_arc_tuning_latency(audio_format_t arc_afmt);
-int aml_audio_get_src_tune_latency(enum patch_src_assortion patch_src);
-int sysfs_get_sysfs_str(const char *path, char *val, int len);
+int aml_audio_get_tvsrc_tune_latency(enum patch_src_assortion patch_src);
+int sysfs_get_sysfs_str(const char *path, const char *val, int len);
 void audio_fade_func(void *buf,int fade_size,int is_fadein);
 void ts_wait_time_us(struct timespec *ts, uint32_t time_us);
 int cpy_16bit_data_with_gain(int16_t *dst, int16_t *src, int size_in_bytes, float vol);
 uint64_t get_systime_ns(void);
-int aml_audio_get_hdmi_latency_offset(int aformat);
+int aml_audio_get_hdmi_latency_offset(audio_format_t  fmt);
+int aml_audio_get_speaker_latency_offset(audio_format_t fmt);
 uint32_t tspec_diff_to_us(struct timespec tval_old,
         struct timespec tval_new);
 void aml_audio_switch_output_mode(int16_t *buf, size_t bytes, AM_AOUT_OutputMode_t mode);
+void * aml_audio_get_muteframe(audio_format_t output_format, int * frame_size, int bAtmos);
+uint32_t out_get_ms12_latency_frames(const struct audio_stream_out *stream);
+int aml_audio_get_ms12_latency_offset(int b_raw);
+int aml_audio_get_dolby_drc_mode(int *drc_mode, int *drc_cut, int *drc_boost);
+
+int aml_audio_get_video_latency(void);
+int aml_set_thread_priority(char *pName, pthread_t threadId);
+
+void aml_tinymix_set_spdif_format(audio_format_t output_format,  struct aml_stream_out *stream);
+
+void aml_audio_set_cpu23_affinity();
+
 
+int aml_audio_get_ms12_passthrough_latency(struct audio_stream_out *stream);
+int aml_audio_get_atmos_hdmi_latency_offset(audio_format_t fmt, int bypass);
 #endif
diff --git a/audio_hal/audio_hwsync.c b/audio_hal/audio_hwsync.c
index 360c3ab..ef7ca0d 100644
--- a/audio_hal/audio_hwsync.c
+++ b/audio_hal/audio_hwsync.c
@@ -33,6 +33,8 @@
 #include "audio_hw_utils.h"
 #include "audio_hwsync.h"
 #include "audio_hw.h"
+#include "dolby_lib_api.h"
+
 
 void aml_hwsync_set_tsync_pause(void)
 {
@@ -72,6 +74,7 @@ int aml_hwsync_get_tsync_pts_by_handle(int fd, uint32_t *pts)
 {
     char valstr[64];
     uint val = 0;
+    int nread;
 
     if (!pts) {
         ALOGE("%s(), NULL pointer", __func__);
@@ -81,8 +84,11 @@ int aml_hwsync_get_tsync_pts_by_handle(int fd, uint32_t *pts)
     if (fd >= 0) {
         memset(valstr, 0, 64);
         lseek(fd, 0, SEEK_SET);
-        read(fd, valstr, 64 - 1);
-        valstr[strlen(valstr)] = '\0';
+        nread = read(fd, valstr, 64 - 1);
+        if (nread < 0) {
+            nread = 0;
+        }
+        valstr[nread] = '\0';
     } else {
         ALOGE("invalid fd\n");
         return -EINVAL;
@@ -117,7 +123,7 @@ int aml_hwsync_reset_tsync_pcrscr(uint32_t pts)
 
 static int aml_audio_hwsync_get_pcr(audio_hwsync_t *p_hwsync, uint *value)
 {
-    int fd = -1;
+    int fd = -1, nread;
     char valstr[64];
     uint val = 0;
     off_t offset;
@@ -135,8 +141,11 @@ static int aml_audio_hwsync_get_pcr(audio_hwsync_t *p_hwsync, uint *value)
     if (fd >= 0) {
         memset(valstr, 0, 64);
         offset = lseek(fd, 0, SEEK_SET);
-        read(fd, valstr, 64 - 1);
-        valstr[strlen(valstr)] = '\0';
+        nread = read(fd, valstr, 64 - 1);
+        if (nread < 0) {
+            nread = 0;
+        }
+        valstr[nread] = '\0';
     } else {
         ALOGE("%s unable to open file %s\n", __func__, TSYNC_PCRSCR);
         return -1;
@@ -157,6 +166,7 @@ void aml_audio_hwsync_init(audio_hwsync_t *p_hwsync, struct aml_stream_out  *out
     p_hwsync->first_apts_flag = false;
     p_hwsync->hw_sync_state = HW_SYNC_STATE_HEADER;
     p_hwsync->hw_sync_header_cnt = 0;
+    p_hwsync->hw_sync_frame_size = 0;
     p_hwsync->bvariable_frame_size = 0;
     p_hwsync->version_num = 0;
     memset(p_hwsync->pts_tab, 0, sizeof(apts_tab_t)*HWSYNC_APTS_NUM);
@@ -168,6 +178,7 @@ void aml_audio_hwsync_init(audio_hwsync_t *p_hwsync, struct aml_stream_out  *out
         p_hwsync->tsync_fd = fd;
         ALOGI("%s open tsync fd %d", __func__, fd);
     }
+    out->tsync_status = TSYNC_STATUS_INIT;
     ALOGI("%s done", __func__);
     return;
 }
@@ -190,12 +201,14 @@ int aml_audio_hwsync_find_frame(audio_hwsync_t *p_hwsync,
     uint8_t *p = (uint8_t *)in_buffer;
     uint64_t time_diff = 0;
     int pts_found = 0;
-    struct aml_audio_device *adev = p_hwsync->aout->dev;
+    struct aml_audio_device *adev;
     size_t  v2_hwsync_header = HW_AVSYNC_HEADER_SIZE_V2;
-    int debug_enable = (adev->debug_flag > 8);
+    int debug_enable;
     if (p_hwsync == NULL || in_buffer == NULL) {
         return 0;
     }
+    adev = p_hwsync->aout->dev;
+    debug_enable = (adev->debug_flag > 8);
 
     //ALOGI(" --- out_write %d, cache cnt = %d, body = %d, hw_sync_state = %d", out_frames * frame_size, out->body_align_cnt, out->hw_sync_body_cnt, out->hw_sync_state);
     while (remain > 0) {
@@ -209,7 +222,7 @@ int aml_audio_hwsync_find_frame(audio_hwsync_t *p_hwsync,
                 if (!hwsync_header_valid(&p_hwsync->hw_sync_header[0])) {
                     //ALOGE("!!!!!!hwsync header out of sync! Resync.should not happen????");
                     p_hwsync->hw_sync_state = HW_SYNC_STATE_HEADER;
-                    memcpy(p_hwsync->hw_sync_header, p_hwsync->hw_sync_header + 1, HW_SYNC_VERSION_SIZE - 1);
+                    memmove(p_hwsync->hw_sync_header, p_hwsync->hw_sync_header + 1, HW_SYNC_VERSION_SIZE - 1);
                     p_hwsync->hw_sync_header_cnt--;
                     continue;
                 }
@@ -344,10 +357,10 @@ int aml_audio_hwsync_set_first_pts(audio_hwsync_t *p_hwsync, uint64_t pts)
         }
         break;
     }
-
+    ALOGI("wait video ready cnt =%d", delay_count);
     if (aml_hwsync_set_tsync_start_pts(pts32) < 0)
         return -EINVAL;
-
+    p_hwsync->aout->tsync_status = TSYNC_STATUS_RUNNING;
     return 0;
 }
 /*
@@ -365,17 +378,25 @@ int aml_audio_hwsync_audio_process(audio_hwsync_t *p_hwsync, size_t offset, int
     int gap_ms = 0;
     int debug_enable = 0;
     char tempbuf[32] = {0};
+    struct aml_audio_device *adev = NULL;
+    int32_t latency_frames = 0;
+    struct audio_stream_out *stream = NULL;
+    uint32_t latency_pts = 0;
+    struct aml_stream_out  *out;
+    int b_raw = 0;
 
     // add protection to avoid NULL pointer.
     if (p_hwsync == NULL) {
         ALOGE("%s,p_hwsync == NULL", __func__);
         return 0;
     }
+    out = p_hwsync->aout;
 
     if (p_hwsync->aout == NULL) {
         ALOGE("%s,p_hwsync->aout == NULL", __func__);
+        return  0;
     } else {
-        struct aml_audio_device *adev = p_hwsync->aout->dev;
+        adev = p_hwsync->aout->dev;
         if (adev == NULL) {
             ALOGE("%s,adev == NULL", __func__);
         } else {
@@ -383,15 +404,62 @@ int aml_audio_hwsync_audio_process(audio_hwsync_t *p_hwsync, size_t offset, int
         }
     }
 
+    /*when it is ddp 2ch/heaac we need use different latency control*/
+    if (audio_is_linear_pcm(out->hal_internal_format)) {
+        b_raw = 0;
+    }else {
+        b_raw = 1;
+    }
+
     ret = aml_audio_hwsync_lookup_apts(p_hwsync, offset, &apts);
+
+    /*get MS12 pipe line delay + alsa delay*/
+    stream = (struct audio_stream_out *)p_hwsync->aout;
+    if (stream) {
+        if (adev && adev->continuous_audio_mode && (eDolbyMS12Lib == adev->dolby_lib_type)) {
+            /*we need get the correct ms12 out pcm */
+            latency_frames = out_get_ms12_latency_frames(stream);
+            //ALOGI("latency_frames =%d", latency_frames);
+            latency_frames += aml_audio_get_ms12_tunnel_latency_offset(b_raw)*48; // add 60ms delay for ms12, 32ms pts offset, other is ms12 delay
+
+            if ((adev->ms12.is_dolby_atmos && adev->ms12_main1_dolby_dummy == false) || adev->atoms_lock_flag) {
+                int tunnel = 1;
+                int atmos_tunning_frame = aml_audio_get_ms12_atmos_latency_offset(tunnel) * 48;
+                latency_frames += atmos_tunning_frame;
+            }
+            if (adev->active_outport == OUTPORT_HDMI_ARC) {
+                int arc_latency_ms = 0;
+                arc_latency_ms = aml_audio_get_hdmi_latency_offset(adev->sink_format);
+                /*the latency is minus, so we minus it*/
+                latency_frames -= arc_latency_ms * 48;
+            }
+        } else {
+            latency_frames = out_get_latency_frames(stream);
+        }
+
+        if (latency_frames < 0) {
+            latency_frames = 0;
+        }
+
+        latency_pts = latency_frames / 48 * 90;
+    }
+
+
     if (ret) {
         ALOGE("%s lookup failed", __func__);
         return 0;
     }
-    if (p_hwsync->first_apts_flag == false && offset > 0) {
-        ALOGI("%s,aml_audio_hwsync_set_first_pts, apts = 0x%x (%d ms)", __FUNCTION__, apts, apts / 90);
-        aml_audio_hwsync_set_first_pts(p_hwsync, apts);
+    if (p_hwsync->first_apts_flag == false && offset > 0 && (apts >= latency_pts)) {
+        ALOGI("%s apts = 0x%x (%d ms) latency=0x%x (%d ms)", __FUNCTION__, apts, apts / 90, latency_pts, latency_pts/90);
+        ALOGI("%s aml_audio_hwsync_set_first_pts = 0x%x (%d ms)", __FUNCTION__, apts - latency_pts, (apts - latency_pts)/90);
+        aml_audio_hwsync_set_first_pts(p_hwsync, apts - latency_pts);
     } else  if (p_hwsync->first_apts_flag) {
+        if (apts >= latency_pts) {
+            apts -= latency_pts;
+        } else {
+            ALOGE("wrong PTS =0x%x delay pts=0x%x",apts, latency_pts);
+            return 0;
+        }
         ret = aml_audio_hwsync_get_pcr(p_hwsync, &pcr);
         if (ret == 0) {
             gap = get_pts_gap(pcr, apts);
@@ -399,9 +467,17 @@ int aml_audio_hwsync_audio_process(audio_hwsync_t *p_hwsync, size_t offset, int
             if (debug_enable) {
                 ALOGI("%s pcr 0x%x,apts 0x%x,gap 0x%x,gap duration %d ms", __func__, pcr, apts, gap, gap_ms);
             }
+
             if (gap > APTS_DISCONTINUE_THRESHOLD_MIN && gap < APTS_DISCONTINUE_THRESHOLD_MAX) {
                 if (apts > pcr) {
-                    *p_adjust_ms = gap_ms;
+                    /*during video stop, pcr has been reset by video
+                      we need ignore such pcr value*/
+                    if (pcr != 0) {
+                        *p_adjust_ms = gap_ms;
+                        ALOGE("%s *p_adjust_ms %d\n", __func__, *p_adjust_ms);
+                    } else {
+                        ALOGE("pcr has been reset\n");
+                    }
                 } else {
                     ALOGI("tsync -> reset pcrscr 0x%x -> 0x%x, %s big,diff %"PRIx64" ms",
                           pcr, apts, apts > pcr ? "apts" : "pcr", get_pts_gap(apts, pcr) / 90);
@@ -417,19 +493,23 @@ int aml_audio_hwsync_audio_process(audio_hwsync_t *p_hwsync, size_t offset, int
             }
         }
     }
+
     return ret;
 }
 int aml_audio_hwsync_checkin_apts(audio_hwsync_t *p_hwsync, size_t offset, unsigned apts)
 {
     int i = 0;
     int ret = -1;
-    struct aml_audio_device *adev = p_hwsync->aout->dev;
-    int debug_enable = (adev->debug_flag > 8);
+    struct aml_audio_device *adev;
+    int debug_enable;
     apts_tab_t *pts_tab = NULL;
     if (!p_hwsync) {
         ALOGE("%s null point", __func__);
         return -1;
     }
+
+    adev = p_hwsync->aout->dev;
+    debug_enable = (adev->debug_flag > 8);
     if (debug_enable) {
         ALOGI("++ %s checkin ,offset %zu,apts 0x%x", __func__, offset, apts);
     }
diff --git a/audio_hal/audio_hwsync.h b/audio_hal/audio_hwsync.h
index 0b3ffcd..3c7a248 100644
--- a/audio_hal/audio_hwsync.h
+++ b/audio_hal/audio_hwsync.h
@@ -19,7 +19,6 @@
 #ifndef _AUDIO_HWSYNC_H_
 #define _AUDIO_HWSYNC_H_
 
-#include <pthread.h>
 #include <stdbool.h>
 
 #define TSYNC_FIRSTAPTS "/sys/class/tsync/firstapts"
@@ -49,6 +48,7 @@
 #define APTS_DISCONTINUE_THRESHOLD_MAX    (5*90000)
 
 #define HWSYNC_APTS_NUM     512
+/*6 ch 16 bit  he-aac  size  6*2*2048 */
 #define  HWSYNC_MAX_BODY_SIZE  (6*2*2048)
 
 enum hwsync_status {
@@ -57,6 +57,13 @@ enum hwsync_status {
     RESYNC,        // pts need resync
 };
 
+enum tsync_status {
+    TSYNC_STATUS_INIT,
+    TSYNC_STATUS_RUNNING,
+    TSYNC_STATUS_PAUSED,
+    TSYNC_STATUS_STOP
+};
+
 typedef struct apts_tab {
     int  valid;
     size_t offset;
@@ -64,14 +71,13 @@ typedef struct apts_tab {
 } apts_tab_t;
 
 typedef struct  audio_hwsync {
-    uint8_t hw_sync_header[HW_AVSYNC_HEADER_SIZE_V2];
+    uint8_t hw_sync_header[HW_AVSYNC_MAX_HEADER_SIZE];
     size_t hw_sync_header_cnt;
     int hw_sync_state;
     uint32_t hw_sync_body_cnt;
     uint32_t hw_sync_frame_size;
-    int bvariable_frame_size;
-    //uint8_t hw_sync_body_buf[8192];  // 4096
-    uint8_t hw_sync_body_buf[24576];    // 6144*4 for EAC3 worst case
+    int      bvariable_frame_size;
+    uint8_t hw_sync_body_buf[HWSYNC_MAX_BODY_SIZE];
     uint8_t body_align[64];
     uint8_t body_align_cnt;
     bool first_apts_flag;//flag to indicate set first apts
diff --git a/audio_hal/audio_port.c b/audio_hal/audio_port.c
index 2130653..732d3ee 100644
--- a/audio_hal/audio_port.c
+++ b/audio_hal/audio_port.c
@@ -19,9 +19,7 @@
 
 #include <errno.h>
 #include <stdlib.h>
-#include <string.h>
 #include <cutils/log.h>
-#include <cutils/list.h>
 #include <linux/ioctl.h>
 #include <sound/asound.h>
 #include <tinyalsa/asoundlib.h>
@@ -31,15 +29,26 @@
 #include "audio_hw_utils.h"
 #include "audio_hwsync.h"
 
-#ifndef list_for_each_safe
-#define list_for_each_safe(node, n, list) \
-    for (node = (list)->next, n = node->next; \
-         node != (list); \
-         node = n, n = node->next)
-#endif
+#define BUFF_CNT                    (4)
+#define SYS_BUFF_CNT                (4)
+
+#define ENUM_INPUT_PORT_TYPE_TO_STR(x, pStr)              ENUM_TYPE_TO_STR(x, strlen("AML_MIXER_INPUT_PORT_"), pStr)
+
+const char *inportType2Str(aml_mixer_input_port_type_e enInportType)
+{
+    static char acTypeStr[ENUM_TYPE_STR_MAX_LEN];
+    char *pStr = "INVALID";
+    switch (enInportType) {
+        ENUM_INPUT_PORT_TYPE_TO_STR(AML_MIXER_INPUT_PORT_INVAL, pStr)
+        ENUM_INPUT_PORT_TYPE_TO_STR(AML_MIXER_INPUT_PORT_PCM_SYSTEM, pStr)
+        ENUM_INPUT_PORT_TYPE_TO_STR(AML_MIXER_INPUT_PORT_PCM_DIRECT, pStr)
+        ENUM_INPUT_PORT_TYPE_TO_STR(AML_MIXER_INPUT_PORT_PCM_MMAP, pStr)
+        ENUM_INPUT_PORT_TYPE_TO_STR(AML_MIXER_INPUT_PORT_BUTT, pStr)
+    }
+    sprintf(acTypeStr, "[%d]%s", enInportType, pStr);
+    return acTypeStr;
+}
 
-#define BUFF_CNT 4
-#define SYS_BUFF_CNT 4
 static ssize_t input_port_write(struct input_port *port, const void *buffer, int bytes)
 {
     unsigned char *data = (unsigned char *)buffer;
@@ -48,10 +57,10 @@ static ssize_t input_port_write(struct input_port *port, const void *buffer, int
 
     written = ring_buffer_write(port->r_buf, data, bytes_to_write, UNCOVER_WRITE);
     if (getprop_bool("media.audiohal.inport")) {
-        if (port->port_index == MIXER_INPUT_PORT_PCM_SYSTEM)
+        if (port->enInPortType == AML_MIXER_INPUT_PORT_PCM_SYSTEM)
             aml_audio_dump_audio_bitstreams("/data/audio/inportSys.raw", buffer, written);
-        else if (port->port_index == MIXER_INPUT_PORT_PCM_DIRECT)
-            aml_audio_dump_audio_bitstreams("/data/audio/inportDirect.raw", buffer, written);
+        //else if (port->port_index == AML_MIXER_INPUT_PORT_PCM_DIRECT)
+            //aml_audio_dump_audio_bitstreams("/data/audio/inportDirect.raw", buffer, written);
     }
 
     ALOGV("%s() written %d", __func__, written);
@@ -79,7 +88,7 @@ bool ring_buf_ready(struct input_port *port)
 
     if (0) {
         ALOGI("%s, port index %d, avail %d, chunk len %d",
-            __func__, port->port_index, read_avail, port->data_len_bytes);
+            __func__, port->enInPortType, read_avail, port->data_len_bytes);
     }
 
     return (read_avail >= (int)port->data_len_bytes);
@@ -94,16 +103,16 @@ uint32_t inport_get_latency_frames(struct input_port *port) {
     uint32_t latency_frames = inport_buffer_level(port) / frame_size;
     // return full frames latency when no data in ring buffer
     if (latency_frames == 0)
-        return port->rbuf_size / frame_size;
+        return port->r_buf->size / frame_size;
 
     return latency_frames;
 }
 
-enum MIXER_INPUT_PORT get_input_port_index(struct audio_config *config,
+aml_mixer_input_port_type_e get_input_port_index(struct audio_config *config,
         audio_output_flags_t flags)
 {
     int channel_cnt = 2;
-    enum MIXER_INPUT_PORT port_index = MIXER_INPUT_PORT_PCM_SYSTEM;
+    aml_mixer_input_port_type_e enPortType = AML_MIXER_INPUT_PORT_PCM_SYSTEM;
 
     channel_cnt = audio_channel_count_from_out_mask(config->channel_mask);
     switch (config->format) {
@@ -113,10 +122,12 @@ enum MIXER_INPUT_PORT get_input_port_index(struct audio_config *config,
             if (1) {
                 ALOGI("%s(), samplerate %d", __func__, config->sample_rate);
                 // FIXME: remove channel check when PCM_SYSTEM_SOUND supports multi-channel
-                if (is_direct_flags(flags) || channel_cnt > 2) {
-                    port_index = MIXER_INPUT_PORT_PCM_DIRECT;
+                if (AUDIO_OUTPUT_FLAG_MMAP_NOIRQ & flags) {
+                    enPortType = AML_MIXER_INPUT_PORT_PCM_MMAP;
+                } else if (is_direct_flags(flags) || channel_cnt > 2) {
+                    enPortType = AML_MIXER_INPUT_PORT_PCM_DIRECT;
                 } else {
-                    port_index = MIXER_INPUT_PORT_PCM_SYSTEM;
+                    enPortType = AML_MIXER_INPUT_PORT_PCM_SYSTEM;
                 }
                 break;
             }
@@ -130,7 +141,7 @@ enum MIXER_INPUT_PORT get_input_port_index(struct audio_config *config,
                     __func__, config->format);
     }
 
-    return port_index;
+    return enPortType;
 }
 
 void inport_reset(struct input_port *port)
@@ -177,7 +188,7 @@ struct port_message *get_inport_message(struct input_port *port)
     if (!list_empty(&port->msg_list)) {
         item = list_head(&port->msg_list);
         p_msg = node_to_item(item, struct port_message, list);
-        ALOGD("%s(), msg: %s", __func__, port_msg_to_str(p_msg->msg_what));
+        ALOGI("%s(), msg: %s", __func__, port_msg_to_str(p_msg->msg_what));
     }
     pthread_mutex_unlock(&port->msg_lock);
     return p_msg;
@@ -233,7 +244,7 @@ static int inport_padding_zero(struct input_port *port, size_t bytes)
 {
     char *feed_mem = NULL;
     ALOGI("%s(), padding size %d 0s to inport %d",
-            __func__, bytes, port->port_index);
+            __func__, bytes, port->enInPortType);
     feed_mem = calloc(1, bytes);
     if (!feed_mem) {
         ALOGE("%s(), no memory", __func__);
@@ -253,7 +264,7 @@ int set_inport_padding_size(struct input_port *port, size_t bytes)
 }
 
 struct input_port *new_input_port(
-        //enum MIXER_INPUT_PORT port_index,
+        //aml_mixer_input_port_type_e port_index,
         //audio_format_t format//,
         size_t buf_frames,
         struct audio_config *config,
@@ -263,10 +274,11 @@ struct input_port *new_input_port(
 {
     struct input_port *port = NULL;
     struct ring_buffer *ringbuf = NULL;
-    enum MIXER_INPUT_PORT port_index;
+    aml_mixer_input_port_type_e enPortType;
     int channel_cnt = 2;
     char *data = NULL;
-    int rbuf_size = 0, thunk_size = 0;
+    int input_port_rbuf_size = 0;
+    int thunk_size = 0;
     int ret = 0;
 
     port = calloc(1, sizeof(struct input_port));
@@ -289,28 +301,25 @@ struct input_port *new_input_port(
         goto err_rbuf;
     }
 
-    port_index = get_input_port_index(config, flags);
+    enPortType = get_input_port_index(config, flags);
     // system buffer larger than direct to cache more for mixing?
-    if (port_index == MIXER_INPUT_PORT_PCM_SYSTEM) {
-        rbuf_size = thunk_size * SYS_BUFF_CNT;
+    if (enPortType == AML_MIXER_INPUT_PORT_PCM_SYSTEM) {
+        input_port_rbuf_size = thunk_size * SYS_BUFF_CNT;
     } else {
-        rbuf_size = thunk_size * BUFF_CNT;
+        input_port_rbuf_size = thunk_size * BUFF_CNT;
     }
 
-    ALOGD("%s(), index:%d, rbuf size:%d, direct_on:%d",
-            __func__, port_index, rbuf_size, direct_on);
-    ALOGD("%s(), fmt %#x, rate %d",
-            __func__, port->cfg.format, port->cfg.sampleRate);
-    ret = ring_buffer_init(ringbuf, rbuf_size);
+    ALOGD("[%s:%d] inport:%s, rbuf size:%d, direct_on:%d, format:%#x, rate:%d", __func__, __LINE__,
+        inportType2Str(enPortType), input_port_rbuf_size, direct_on, port->cfg.format, port->cfg.sampleRate);
+    ret = ring_buffer_init(ringbuf, input_port_rbuf_size);
     if (ret) {
-        ALOGE("init ring buffer fail, buffer_size = %d", rbuf_size);
+        ALOGE("init ring buffer fail, buffer_size = %d", input_port_rbuf_size);
         goto err_rbuf_init;
     }
 
-    port->port_index = port_index;
+    port->enInPortType = enPortType;
     //port->format = config->format;
     port->r_buf = ringbuf;
-    port->rbuf_size = rbuf_size;
     port->data_valid = 0;
     port->data = data;
     port->data_buf_frame_cnt = buf_frames;
@@ -326,8 +335,8 @@ struct input_port *new_input_port(
     list_init(&port->msg_list);
     //TODO
     //set_inport_hwsync(port);
-    //if (port_index == MIXER_INPUT_PORT_PCM_SYSTEM && !direct_on) {
-    //if (port_index == MIXER_INPUT_PORT_PCM_SYSTEM) {
+    //if (port_index == AML_MIXER_INPUT_PORT_PCM_SYSTEM && !direct_on) {
+    //if (port_index == AML_MIXER_INPUT_PORT_PCM_SYSTEM) {
     //    inport_padding_zero(port, rbuf_size);
     //}
     return port;
@@ -405,16 +414,6 @@ err_rbuf_init:
     return ret;
 }
 
-void set_inport_hwsync(struct input_port *port)
-{
-    ALOGD("%s()", __func__);
-    port->is_hwsync = true;
-}
-bool is_inport_hwsync(struct input_port *port)
-{
-    return port->is_hwsync;
-}
-
 void set_inport_volume(struct input_port *port, float vol)
 {
     ALOGD("%s(), volume %f", __func__, vol);
@@ -446,7 +445,7 @@ int set_port_meta_data_cbk(struct input_port *port,
         meta_data_cbk_t meta_data_cbk,
         void *data)
 {
-    if (!is_inport_hwsync(port)) {
+    if (false == port->is_hwsync) {
         ALOGE("%s(), can't set meta data callback", __func__);
         return -EINVAL;
     }
@@ -484,6 +483,7 @@ static ssize_t output_port_start(struct output_port *port)
     pcm_cfg.rate = cfg.sampleRate;
     pcm_cfg.period_size = DEFAULT_PLAYBACK_PERIOD_SIZE;
     pcm_cfg.period_count = DEFAULT_PLAYBACK_PERIOD_CNT;
+    pcm_cfg.start_threshold = pcm_cfg.period_size * pcm_cfg.period_count / 4;
     //pcm_cfg.stop_threshold = pcm_cfg.period_size * pcm_cfg.period_count - 128;
     //pcm_cfg.silence_threshold = pcm_cfg.stop_threshold;
     //pcm_cfg.silence_size = 1024;
@@ -496,18 +496,13 @@ static ssize_t output_port_start(struct output_port *port)
         ALOGE("%s(), unsupport", __func__);
         pcm_cfg.format = PCM_FORMAT_S16_LE;
     }
-    ALOGI("%s(), port:%p open ALSA hw:%d,%d", __func__, port, card, device);
+    ALOGI("%s(), open ALSA hw:%d,%d", __func__, card, device);
     pcm = pcm_open(card, device, PCM_OUT | PCM_MONOTONIC, &pcm_cfg);
     if ((pcm == NULL) || !pcm_is_ready(pcm)) {
         ALOGE("cannot open pcm_out driver: %s", pcm_get_error(pcm));
         pcm_close(pcm);
         return -EINVAL;
     }
-    if (!pcm_is_ready (pcm) ) {
-        ALOGE ("cannot open pcm_out driver: %s", pcm_get_error (pcm) );
-        pcm_close (pcm);
-        return -EINVAL;
-    }
     port->pcm_handle = pcm;
     port->port_status = ACTIVE;
 
@@ -516,14 +511,16 @@ static ssize_t output_port_start(struct output_port *port)
 
 static int output_port_standby(struct output_port *port)
 {
-    if (port && port->pcm_handle) {
+    struct pcm *pcm = port->pcm_handle;
+    if (pcm) {
         ALOGI("%s()", __func__);
-        pcm_close(port->pcm_handle);
-        port->pcm_handle = NULL;
+        pthread_mutex_lock(&port->lock);
+        pcm_close(pcm);
+        pcm = NULL;
         port->port_status = STOPPED;
-        return 0;
+        pthread_mutex_unlock(&port->lock);
     }
-    return -EINVAL;
+    return 0;
 }
 
 int outport_stop_pcm(struct output_port *port)
@@ -537,6 +534,12 @@ int outport_stop_pcm(struct output_port *port)
     return 0;
 }
 
+int outport_set_dummy(struct output_port *port, bool en)
+{
+    port->dummy = en;
+    return 0;
+}
+
 static ssize_t output_port_write(struct output_port *port, void *buffer, int bytes)
 {
     int bytes_to_write = bytes;
@@ -557,9 +560,17 @@ static ssize_t output_port_write_alsa(struct output_port *port, void *buffer, in
 {
     int bytes_to_write = bytes;
     int ret = 0;
+
+    // dummy means we abandon the data.
+    if (port->dummy) {
+        usleep(5000);
+        return bytes;
+    }
+
     if (port->sound_track_mode == 3)
            port->sound_track_mode = AM_AOUT_OUTPUT_LRMIX;
     aml_audio_switch_output_mode((int16_t *)buffer, bytes, port->sound_track_mode);
+    pthread_mutex_lock(&port->lock);
     do {
         int written = 0;
         ALOGV("%s(), line %d", __func__, __LINE__);
@@ -567,10 +578,8 @@ static ssize_t output_port_write_alsa(struct output_port *port, void *buffer, in
         if (ret == 0) {
            written += bytes;
         } else {
-           ALOGE("pcm_write port:%p failed ret = %d, pcm_get_error(out->pcm):%s",
-                port, ret, pcm_get_error(port->pcm_handle));
-           if (errno == EBADF)
-               return 0;
+           ALOGE("pcm_write failed ret = %d, pcm_get_error(out->pcm):%s",
+                ret, pcm_get_error(port->pcm_handle));
            pcm_stop(port->pcm_handle);
            usleep(1000);
         }
@@ -579,6 +588,7 @@ static ssize_t output_port_write_alsa(struct output_port *port, void *buffer, in
         }
         bytes_to_write -= written;
     } while (bytes_to_write > 0);
+    pthread_mutex_unlock(&port->lock);
 
     return bytes;
 }
@@ -606,10 +616,8 @@ struct output_port *new_output_port(
         size_t buf_frames)
 {
     struct output_port *port = NULL;
-    struct ring_buffer *ringbuf = NULL;
     char *data = NULL;
     int rbuf_size = buf_frames * cfg.frame_size;
-    int ret = 0;
 
     port = calloc(1, sizeof(struct output_port));
     if (!port) {
@@ -622,39 +630,20 @@ struct output_port *new_output_port(
         ALOGE("%s(), no memory", __func__);
         goto err_data;
     }
-    /* not used */
-    ringbuf = calloc(1, sizeof(struct ring_buffer));
-    if (!ringbuf) {
-        ALOGE("%s(), no memory", __func__);
-        goto err_rbuf;
-    }
-    ret = ring_buffer_init(ringbuf, rbuf_size *2);
-    if (ret) {
-        ALOGE("init ring buffer fail, buffer_size = %d", rbuf_size*2);
-        goto err_rbuf_init;
-    }
-    //ret = pthread_create(&port->out_port_tid, NULL, port_threadloop, port);
-    //if (ret < 0)
-    //    ALOGE("%s() thread run failed.", __func__);
 
-    port->port_index = port_index;
+    port->enOutPortType = port_index;
     port->cfg = cfg;
-    port->r_buf = ringbuf;
     port->data_buf_frame_cnt = buf_frames;
     port->data_buf_len = rbuf_size;
     port->data_buf = data;
     port->start = output_port_start;
     port->standby = output_port_standby;
-    //port->write = output_port_write;
     port->write = output_port_write_alsa;
     port->port_status = STOPPED;
 
     return port;
-
-err_rbuf_init:
-    free(ringbuf);
-err_rbuf:
-    free(data);
+/*err_rbuf:
+    free(data);*/
 err_data:
     free(port);
 err:
@@ -668,12 +657,6 @@ int free_output_port(struct output_port *port)
         return -EINVAL;
     }
 
-    ALOGI("%s(), %d port:%p", __func__, __LINE__, port);
-    if (port->port_status != STOPPED &&
-            port->port_status != IDLE)
-        pcm_close(port->pcm_handle);
-    ring_buffer_release(port->r_buf);
-    free(port->r_buf);
     free(port->data_buf);
     free(port);
 
@@ -708,9 +691,9 @@ err_data:
     return ret;
 }
 
-bool is_inport_valid(enum MIXER_INPUT_PORT index)
+bool is_inport_valid(aml_mixer_input_port_type_e index)
 {
-    return (index >= 0 && index < MIXER_INPUT_PORT_NUM);
+    return (index >= AML_MIXER_INPUT_PORT_PCM_SYSTEM && index < AML_MIXER_INPUT_PORT_BUTT);
 }
 
 bool is_outport_valid(enum MIXER_OUTPUT_PORT index)
diff --git a/audio_hal/audio_port.h b/audio_hal/audio_port.h
index 3f46f1a..bd3282b 100644
--- a/audio_hal/audio_port.h
+++ b/audio_hal/audio_port.h
@@ -44,13 +44,15 @@ enum PORT_MSG {
 };
 const char *port_msg_to_str(enum PORT_MSG msg);
 
-enum MIXER_INPUT_PORT {
-    MIXER_INPUT_PORT_INVAL          = -1,
-    MIXER_INPUT_PORT_PCM_SYSTEM     = 0,
-    MIXER_INPUT_PORT_PCM_DIRECT     = 1,
-    //MIXER_INPUT_PORT_BITSTREAM_RAW  = 2,
-    MIXER_INPUT_PORT_NUM
-};
+typedef enum AML_MIXER_INPUT_PORT_TYPE{
+    AML_MIXER_INPUT_PORT_INVAL          = -1,
+    AML_MIXER_INPUT_PORT_PCM_SYSTEM     = 0,
+    AML_MIXER_INPUT_PORT_PCM_DIRECT     = 1,
+    AML_MIXER_INPUT_PORT_PCM_MMAP       = 2,
+    //AML_MIXER_INPUT_PORT_BITSTREAM_RAW  = 3,
+
+    AML_MIXER_INPUT_PORT_BUTT           = 3,
+} aml_mixer_input_port_type_e;
 
 struct fade_out {
     float vol;
@@ -73,21 +75,19 @@ typedef int (*meta_data_cbk_t)(void *cookie,
             int *diff_ms);
 
 struct input_port {
-    enum MIXER_INPUT_PORT port_index;
+    aml_mixer_input_port_type_e enInPortType;
     struct audioCfg cfg;
-    struct ring_buffer *r_buf;
-    size_t rbuf_frames;
-    size_t rbuf_size;
-    char *data;
-    size_t data_buf_frame_cnt;
-    size_t data_len_bytes;
+
+    struct ring_buffer *r_buf;              /* input port ring buffer. */
+    char *data;                             /* input port temp buffer. */
+    size_t data_buf_frame_cnt;              /* input port temp buffer, data frames for one cycle. */
+    size_t data_len_bytes;                  /* input port temp buffer, data size for one cycle. */
+
     int data_valid;
-    size_t bytes_to_insert;
-    size_t bytes_to_skip;
+    size_t bytes_to_insert;                 /* insert 0 data count index. Units: Byte */
+    size_t bytes_to_skip;                   /* drop data count index. Units: Byte */
     bool is_hwsync;
     size_t consumed_bytes;
-    audio_format_t format;
-    size_t frame_size;
     enum port_state port_status;
     ssize_t (*write)(struct input_port *port, const void *buffer, int bytes);
     ssize_t (*read)(struct input_port *port, void *buffer, int bytes);
@@ -98,16 +98,12 @@ struct input_port {
     void *input_avail_cbk_data;
     int (*on_input_avail_cbk)(void *data);
     void *meta_data_cbk_data;
-    //int (*meta_data_cbk)(void *cookie,
-    //        uint32_t offset,
-    //        struct hw_avsync_header *header,
-    //        int *diff_ms);
+
     meta_data_cbk_t meta_data_cbk;
     float volume;
     struct fade_out fout;
     struct listnode msg_list;
     pthread_mutex_t msg_lock;
-    //nsecs_t last_write_nsec;
     struct timespec timestamp;
     /* get from out stream when init */
     uint64_t initial_frames;
@@ -126,9 +122,8 @@ enum MIXER_OUTPUT_PORT {
 };
 
 struct output_port {
-    enum MIXER_OUTPUT_PORT port_index;
+    enum MIXER_OUTPUT_PORT enOutPortType;
     struct audioCfg cfg;
-    struct ring_buffer *r_buf;
     // data buf to hold tmp out data
     char *data_buf;
     size_t buf_frames;
@@ -137,8 +132,6 @@ struct output_port {
     size_t data_buf_frame_cnt;
     size_t data_buf_len;
     struct pcm *pcm_handle;
-    //audio_format_t format;
-    //size_t frame_size;
     enum port_state port_status;
     pthread_mutex_t lock;
     pthread_cond_t cond;
@@ -147,11 +140,13 @@ struct output_port {
     int (*standby)(struct output_port *port);
     struct timespec tval_last;
     int sound_track_mode;
+    // not sending audio data to ALSA
+    bool dummy;
 };
-bool is_inport_valid(enum MIXER_INPUT_PORT index);
+bool is_inport_valid(aml_mixer_input_port_type_e index);
 bool is_outport_valid(enum MIXER_OUTPUT_PORT index);
 
-enum MIXER_INPUT_PORT get_input_port_index(struct audio_config *config,
+aml_mixer_input_port_type_e get_input_port_index(struct audio_config *config,
         audio_output_flags_t flags);
 
 struct input_port *new_input_port(
@@ -196,4 +191,7 @@ int outport_get_latency_frames(struct output_port *port);
 int set_inport_pts_valid(struct input_port *in_port, bool valid);
 bool is_inport_pts_valid(struct input_port *in_port);
 int outport_stop_pcm(struct output_port *port);
+int outport_set_dummy(struct output_port *port, bool en);
+const char *inportType2Str(aml_mixer_input_port_type_e enInportType);
+
 #endif /* _AUDIO_PORT_H_ */
diff --git a/audio_hal/audio_virtual_buf.c b/audio_hal/audio_virtual_buf.c
index 476f56e..61f252b 100644
--- a/audio_hal/audio_virtual_buf.c
+++ b/audio_hal/audio_virtual_buf.c
@@ -66,10 +66,12 @@ int audio_virtual_buf_open(void ** pphandle, char * buf_name, uint64_t buf_ns_be
         }
 
         strncpy(phandle->buf_name, buf_name, name_length);
-        phandle->buf_name[name_length + 1] = '\0';
+        phandle->buf_name[name_length] = '\0';
 
     } else {
         ALOGE("buf name is NULL\n");
+        free(phandle);
+        phandle = NULL;
         return -1;
     }
     phandle->state = VIRTUAL_BUF_IDLE;
@@ -178,7 +180,7 @@ int audio_virtual_buf_process(void *phandle, uint64_t frame_ns)
         if (t >= 1.0) {
             buf_ns_cur = virtual_handle->buf_ns_target;
         } else {
-            buf_ns_cur = (virtual_handle->buf_ns_target - virtual_handle->buf_ns_begin) * t * t + virtual_handle->buf_ns_begin;
+            buf_ns_cur = (virtual_handle->buf_ns_target - virtual_handle->buf_ns_begin) * t + virtual_handle->buf_ns_begin;
         }
         virtual_handle->buf_ns_cur = buf_ns_cur;
     }
@@ -192,7 +194,7 @@ int audio_virtual_buf_process(void *phandle, uint64_t frame_ns)
         } else {
             sleep_ns = delay_ns - buf_ns;
         }
-        //ALOGD("%s buffered ns =%lld buf_size_ns=%lld gap=%lld read=%lld write=%lld sleep=%lld",
+        // ALOGD("%s buffered ns =%lld buf_size_ns=%lld gap=%lld read=%lld write=%lld sleep=%lld",
         //  virtual_handle->buf_name,delay_ns, buf_ns, process_gap, read_ns, write_ns, sleep_ns);
 
     } else {
@@ -213,5 +215,21 @@ int audio_virtual_buf_process(void *phandle, uint64_t frame_ns)
     return 0;
 }
 
+int audio_virtual_buf_reset(void *phandle) {
+    audio_virtual_buf_t *virtual_handle = NULL;
+
+    if (phandle == NULL) {
+        return -1;
+    }
+    virtual_handle = (audio_virtual_buf_t *)phandle;
+
+    virtual_handle->state = VIRTUAL_BUF_IDLE;
+    virtual_handle->buf_write_ns = 0;
+    virtual_handle->buf_read_ns  = 0;
+    virtual_handle->last_process_ns = 0;
+    ALOGI("reset virtual buf");
+
+    return 0;
+}
 
 
diff --git a/audio_hal/audio_virtual_buf.h b/audio_hal/audio_virtual_buf.h
index 24a3bc3..76175f0 100644
--- a/audio_hal/audio_virtual_buf.h
+++ b/audio_hal/audio_virtual_buf.h
@@ -29,4 +29,5 @@ int audio_virtual_buf_close(void **pphandle);
 
 int audio_virtual_buf_process(void *phandle, uint64_t frame_ns);
 
+int audio_virtual_buf_reset(void *phandle);
 #endif
diff --git a/audio_hal/dolby_lib_api.c b/audio_hal/dolby_lib_api.c
index 57f012e..86e7f0d 100644
--- a/audio_hal/dolby_lib_api.c
+++ b/audio_hal/dolby_lib_api.c
@@ -35,9 +35,7 @@
 #endif
 
 
-#define DOLBY_MS12_LIB_PATH_A "/vendor/lib/libdolbyms12.so"
-#define DOLBY_MS12_LIB_PATH_B "/system/vendor/lib/libdolbyms12.so"
-
+#define DOLBY_MS12_LIB_PATH "/vendor/lib/libdolbyms12.so"
 #define DOLBY_DCV_LIB_PATH_A "/vendor/lib/libHwAudio_dcvdec.so"
 
 
@@ -58,78 +56,29 @@ static int file_accessible(char *path)
 /*
  *@brief detect_dolby_lib_type
  */
-enum eDolbyLibType detect_dolby_lib_type(void) {
-    enum eDolbyLibType retVal;
-
-    void *hDolbyMS12LibHanle = NULL;
-    void *hDolbyDcvLibHanle = NULL;
-
-    hDolbyMS12LibHanle = dlopen(DOLBY_MS12_LIB_PATH_A, RTLD_NOW);
-    if (!hDolbyMS12LibHanle)
-    {
-        hDolbyMS12LibHanle = dlopen(DOLBY_MS12_LIB_PATH_B, RTLD_NOW);
-        if (!hDolbyMS12LibHanle) {
-            ALOGI("%s, failed to load libdolbyms12 lib %s\n", __FUNCTION__, dlerror());
-        }
-    }
-
-    // the priority would be "MS12 > DCV" lib
-    if (RET_OK == file_accessible(DOLBY_MS12_LIB_PATH_A))
-    {
-        retVal = eDolbyMS12Lib;
-    } else if (RET_OK == file_accessible(DOLBY_MS12_LIB_PATH_B))
-    {
-        retVal = eDolbyMS12Lib;
-    } else if (RET_OK == file_accessible(DOLBY_DCV_LIB_PATH_A))
-    {
-        retVal = eDolbyDcvLib;
-    } else {
-        retVal = eDolbyNull;
-    }
-
-    // MS12 is first priority
-    if (eDolbyMS12Lib == retVal)
-    {
-        //try to open lib see if it's OK?
-        hDolbyMS12LibHanle = dlopen(DOLBY_MS12_LIB_PATH_A, RTLD_NOW);
-        if (!hDolbyMS12LibHanle) {
-            ALOGI("%s, failed to load libdolbyms12 lib from %s (%s)\n",
-                __FUNCTION__, DOLBY_MS12_LIB_PATH_A, dlerror());
+enum eDolbyLibType detect_dolby_lib_type(void)
+{
+    void *handle;
 
-            hDolbyMS12LibHanle = dlopen(DOLBY_MS12_LIB_PATH_B, RTLD_NOW);
-            if (!hDolbyMS12LibHanle) {
-                ALOGI("%s, failed to load libdolbyms12 lib from %s (%s)\n",
-                    __FUNCTION__, DOLBY_MS12_LIB_PATH_B, dlerror());
-            }
-        }
-    }
-    if (hDolbyMS12LibHanle != NULL)
-    {
-        dlclose(hDolbyMS12LibHanle);
-        hDolbyMS12LibHanle = NULL;
-        ALOGI("%s,FOUND libdolbyms12 lib %s\n", __FUNCTION__, dlerror());
+    handle = dlopen(DOLBY_MS12_LIB_PATH, RTLD_NOW);
+    if (handle) {
+        ALOGI("%s, FOUND libdolbyms12 lib", __FUNCTION__);
+        dlclose(handle);
         return eDolbyMS12Lib;
+    } else {
+        ALOGI("%s, failed to detect libdolbyms12 lib: %s", __FUNCTION__, dlerror());
     }
 
-    // dcv is second priority
-    if (eDolbyDcvLib == retVal)
-    {
-        //try to open lib see if it's OK?
-        hDolbyDcvLibHanle  = dlopen(DOLBY_DCV_LIB_PATH_A, RTLD_NOW);
-        if (!hDolbyDcvLibHanle) {
-            ALOGI("%s, failed to load libHwAudio_dcvdec.so, %s\n", __FUNCTION__, dlerror());
-        }
-    }
-    if (hDolbyDcvLibHanle != NULL)
-    {
-        dlclose(hDolbyDcvLibHanle);
-        hDolbyDcvLibHanle = NULL;
-        ALOGI("%s,FOUND libHwAudio_dcvdec lib %s\n", __FUNCTION__, dlerror());
+    handle = dlopen(DOLBY_DCV_LIB_PATH_A, RTLD_NOW);
+    if (handle) {
+        ALOGI("%s, FOUND libHwAudio_dcvdec lib\n", __FUNCTION__); 
+        dlclose(handle);
         return eDolbyDcvLib;
+    } else {
+        ALOGI("%s, failed to detect libHwAudio_dcvdec libi: %s", __FUNCTION__, dlerror());
     }
 
-    ALOGE("%s, failed to FIND libdolbyms12.so and libHwAudio_dcvdec.so, %s\n", __FUNCTION__, dlerror());
+    ALOGI("%s, No Dolby libs are found", __FUNCTION__);
     return eDolbyNull;
 }
 
-
diff --git a/audio_hal/hw_avsync.c b/audio_hal/hw_avsync.c
index 2a0e74c..368c37d 100644
--- a/audio_hal/hw_avsync.c
+++ b/audio_hal/hw_avsync.c
@@ -285,12 +285,8 @@ ssize_t header_extractor_write(struct hw_avsync_header_extractor *header_extract
             size_t bytes_to_copy = min(bytes_remaining,
                     hwsync_header_get_frame_size(sync_header) - header_extractor->sync_frame_written);
             ALOGV("%s() writing body_bytes= %d,data_size_bytes= %d",
-                    __func__, bytes_to_copy, header_extractor->data_size_bytes);
+		    __func__, bytes_to_copy, header_extractor->data_size_bytes);
 
-            if (header_extractor->data_size_bytes + bytes_to_copy > HW_AVSYNC_FRAME_SIZE) {
-                ALOGE("%s() buffer overflow", __func__);
-                return bytes;
-            }
             memcpy(header_extractor->data + header_extractor->data_size_bytes, data, bytes_to_copy);
             header_extractor->data_size_bytes += bytes_to_copy;
             bytes_remaining -= bytes_to_copy;
diff --git a/audio_hal/hw_avsync.h b/audio_hal/hw_avsync.h
index b9ea9b5..704eaeb 100644
--- a/audio_hal/hw_avsync.h
+++ b/audio_hal/hw_avsync.h
@@ -48,7 +48,7 @@ typedef int (*consume_output_data_t)(void *cookie,
 struct hw_avsync_header_extractor {
     struct hw_avsync_header avsync_header;
     int8_t data[HW_AVSYNC_FRAME_SIZE];
-    unsigned int data_size_bytes;
+    uint data_size_bytes;
     ssize_t (*write)(struct hw_avsync_header_extractor *header_extractor,
             const void *buffer, size_t bytes);
     consume_meta_data_t consume_meta_data;
diff --git a/audio_hal/hw_avsync_callbacks.c b/audio_hal/hw_avsync_callbacks.c
index ed0b17a..71f3203 100644
--- a/audio_hal/hw_avsync_callbacks.c
+++ b/audio_hal/hw_avsync_callbacks.c
@@ -96,15 +96,13 @@ int on_meta_data_cbk(void *cookie,
         ALOGV("%s(), frame_size %d, pts %lldms",
                     __func__, header->frame_size, header->pts/1000000);
     }
-#if 0 //For HW sync the frame size is not necessariy constant, do not need this check
     if (offset != mdata_list->mdata.payload_offset) {
         ALOGV("%s(), offset %lld not equal payload offset %lld, try next time",
                     __func__, offset, mdata_list->mdata.payload_offset);
         ret = -EAGAIN;
         goto err_lock;
     }
-#endif
-    pts32 = (uint32_t)(header->pts *9 / 100000);
+    pts32 = (uint32_t)(header->pts / 1000000 * 90);
     list_remove(&mdata_list->list);
     pthread_mutex_unlock(&out->mdata_lock);
     free(mdata_list);
@@ -115,7 +113,7 @@ int on_meta_data_cbk(void *cookie,
         int delay_count = 0;
         hwsync_header_construct(header);
         pts32 -= latency*90;
-        ALOGI("%s(), set tsync start pts %d, latency %d, last position %lld",
+        ALOGD("%s(), set tsync start pts %d, latency %d, last position %lld",
             __func__, pts32, latency, out->last_frames_postion);
         while (delay_count < 10) {
             vframe_ready_cnt = get_sysfs_int("/sys/class/video/vframe_ready_cnt");
@@ -159,8 +157,11 @@ int on_meta_data_cbk(void *cookie,
             ALOGD("%s(): audio pts %dms, pcr %dms, latency %lldms, pcr leads %dms",
                 __func__, pts32/90, pcr/90, latency/90, (int)(pcr - pts32)/90);
         apts_gap = get_pts_gap(pcr, pts32);
-        //sync_status = pcm_check_hwsync_status(apts_gap);
-        sync_status = pcm_check_hwsync_status1(pcr, pts32);
+        if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+            sync_status = pcm_check_hwsync_status(apts_gap);
+        } else {
+            sync_status = pcm_check_hwsync_status1(pcr, pts32);
+        }
         // limit the gap handle to 0.5~5 s.
         if (sync_status == ADJUSTMENT) {
             // two cases: apts leading or pcr leading
diff --git a/audio_hal/sub_mixing_factory.c b/audio_hal/sub_mixing_factory.c
index 628a4c3..cd7c478 100644
--- a/audio_hal/sub_mixing_factory.c
+++ b/audio_hal/sub_mixing_factory.c
@@ -13,7 +13,6 @@ Description:
 #define __USE_GNU
 
 #include <errno.h>
-#include <sched.h>
 #include <cutils/log.h>
 #include <system/audio.h>
 #include <inttypes.h>
@@ -27,8 +26,11 @@ Description:
 #include "../libms12v2/include/aml_audio_ms12.h"
 #include "dolby_lib_api.h"
 #include "alsa_device_parser.h"
+#include "audio_a2dp_hw.h"
 
 //#define DEBUG_TIME
+
+#define SUBMIX_USECASE_MASK            (0xffffff7e)  /* PCM_NORMAL(0) and PCM_MMAP(7) have been cleared*/
 static int on_notify_cbk(void *data);
 static int on_input_avail_cbk(void *data);
 static ssize_t out_write_subMixingPCM(struct audio_stream_out *stream,
@@ -116,10 +118,10 @@ static ssize_t aml_out_write_to_mixer(struct audio_stream_out *stream, const voi
     do {
         ssize_t written = 0;
         ALOGV("%s(), stream usecase: %s, written_total %d, bytes %d",
-            __func__,  usecase_to_str(out->usecase), written_total, bytes);
+            __func__,  usecase2Str(out->usecase), written_total, bytes);
 
         written = mixer_write_inport(audio_mixer,
-                out->port_index, data, bytes - written_total);
+                out->enInputPortType, data, bytes - written_total);
         if (written < 0) {
             ALOGE("%s(), write failed, errno = %d", __func__, written);
             return written;
@@ -136,7 +138,7 @@ static ssize_t aml_out_write_to_mixer(struct audio_stream_out *stream, const voi
             //pthread_mutex_unlock(&out->lock);
         }
         ALOGV("%s(), portindex(%d) written(%d), written_total(%d), bytes(%d)",
-            __func__, out->port_index, written, written_total, bytes);
+            __func__, out->enInputPortType, written, written_total, bytes);
 
         if (written_total >= bytes) {
             ALOGV("%s(), exit", __func__);
@@ -184,7 +186,7 @@ static int consume_meta_data(void *cookie,
                 __func__, frame_size, pts/1000000, offset);
     }
     if (get_mixer_hwsync_frame_size(audio_mixer) != frame_size) {
-        ALOGV("%s(), resize frame_size %d", __func__, frame_size);
+        ALOGI("%s(), resize frame_size %d", __func__, frame_size);
         set_mixer_hwsync_frame_size(audio_mixer, frame_size);
     }
     pthread_mutex_lock(&out->mdata_lock);
@@ -244,7 +246,7 @@ static int consume_output_data(void *cookie, const void* buffer, size_t bytes)
     }
 
     clock_gettime(CLOCK_MONOTONIC, &new_tval);
-    us_since_last_write = (new_tval.tv_sec - out->timestamp.tv_sec) * 1000000 +
+    us_since_last_write = (uint64_t)(new_tval.tv_sec - out->timestamp.tv_sec) * 1000000 +
             (new_tval.tv_nsec - out->timestamp.tv_nsec) / 1000;
     //out->timestamp = new_tval;
 
@@ -285,8 +287,14 @@ exit:
     out->lasttimestamp.tv_nsec = out->timestamp.tv_nsec;
     if (written >= 0) {
         //TODO
-        latency_frames = mixer_get_inport_latency_frames(audio_mixer, out->port_index);
-                + mixer_get_outport_latency_frames(audio_mixer);
+#ifdef ENABLE_BT_A2DP
+        if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP)
+            latency_frames = mixer_get_inport_latency_frames(audio_mixer, out->enInputPortType)
+                    + a2dp_out_get_latency(stream);
+        else
+#endif
+            latency_frames = mixer_get_inport_latency_frames(audio_mixer, out->enInputPortType)
+                    + mixer_get_outport_latency_frames(audio_mixer);
         out->frame_write_sum += written / frame_size;
 
         if (out->frame_write_sum > latency_frames)
@@ -329,12 +337,6 @@ static ssize_t out_write_hwsync_lpcm(struct audio_stream_out *stream, const void
     struct timespec ts;
     memset(&ts, 0, sizeof(struct timespec));
 
-    ALOGV("++%s() out(%p)", __func__, out);
-    if (!is_stream_using_mixer(out)) {
-        ALOGE("%s(), stream must be mixing stream", __func__);
-        return -EINVAL;
-    }
-
     if (out->standby) {
         ALOGI("%s(), start hwsync lpcm stream: %p", __func__, out);
         set_thread_affinity();
@@ -346,8 +348,8 @@ static ssize_t out_write_hwsync_lpcm(struct audio_stream_out *stream, const void
         init_mixer_input_port(sm->mixerData, &out->audioCfg, out->flags,
             on_notify_cbk, out, on_input_avail_cbk, out,
             on_meta_data_cbk, out, out->volume_l);
-        out->port_index = get_input_port_index(&out->audioCfg, out->flags);
-        ALOGI("%s(), hwsync port index = %d", __func__, out->port_index);
+        out->enInputPortType = get_input_port_index(&out->audioCfg, out->flags);
+        ALOGI("%s(), hwsync port index = %d", __func__, out->enInputPortType);
         out->standby = false;
         mixer_set_continuous_output(sm->mixerData, false);
     }
@@ -359,7 +361,7 @@ static ssize_t out_write_hwsync_lpcm(struct audio_stream_out *stream, const void
     ALOGV("%s() bytes %d, out->last_frames_postion %lld frame_sum %lld",
             __func__, bytes, out->last_frames_postion, out->frame_write_sum);
 
-    if (getprop_bool("media.audiohal.hwsync")) {
+    if (getprop_bool("media.audiohal.hwsync") && written_total > 0) {
         aml_audio_dump_audio_bitstreams("/data/audio/audiomain.raw", buffer, written_total);
     }
 
@@ -420,10 +422,10 @@ static ssize_t out_write_system(struct audio_stream_out *stream, const void *buf
         clock_gettime(CLOCK_MONOTONIC, &new_tval);
         if (tval.tv_sec > new_tval.tv_sec)
             ALOGE("%s(), FATAL ERROR", __func__);
-        ALOGV("++%s() bytes %d, out->port_index %d", __func__, bytes, out->port_index);
+        ALOGV("++%s() bytes %d, out->port_index %d", __func__, bytes, out->enInputPortType);
         //ALOGD(" %lld us, %lld", new_tval.tv_sec, tval.tv_sec);
 
-        us_since_last_write = (new_tval.tv_sec - out->timestamp.tv_sec) * 1000000 +
+        us_since_last_write = (uint64_t)(new_tval.tv_sec - out->timestamp.tv_sec) * 1000000 +
                 (new_tval.tv_nsec - out->timestamp.tv_nsec) / 1000;
         //out->timestamp = new_tval;
 
@@ -468,7 +470,7 @@ exit:
     out->lasttimestamp.tv_sec = out->timestamp.tv_sec;
     out->lasttimestamp.tv_nsec = out->timestamp.tv_nsec;
     if (written >= 0) {
-        uint32_t latency_frames = mixer_get_inport_latency_frames(audio_mixer, out->port_index);
+        uint32_t latency_frames = mixer_get_inport_latency_frames(audio_mixer, out->enInputPortType);
                 //+ mixer_get_outport_latency_frames(audio_mixer);
         if (out->frame_write_sum > latency_frames)
             out->last_frames_postion = out->frame_write_sum - latency_frames;
@@ -499,23 +501,14 @@ static ssize_t out_write_direct_pcm(struct audio_stream_out *stream, const void
     int64_t throttle_timeus = 0;//aml_audio_get_throttle_timeus(bytes);
 
     if (out->standby) {
-        ALOGI("%s(), direct %p", __func__, out);
         init_mixer_input_port(sm->mixerData, &out->audioCfg, out->flags,
             on_notify_cbk, out, on_input_avail_cbk, out,
             NULL, NULL, 1.0);
-        out->port_index = get_input_port_index(&out->audioCfg, out->flags);
-        ALOGI("%s(), direct port index = %d", __func__, out->port_index);
+        out->enInputPortType = get_input_port_index(&out->audioCfg, out->flags);
+        ALOGI("[%s:%d] direct port:%s", __func__, __LINE__, inportType2Str(out->enInputPortType));
         out->standby = false;
     }
 
-    if (bytes == 0) {
-        ALOGW("%s(), inval to write bytes 0", __func__);
-        usleep(512 * 1000 / 48 / frame_size);
-        written = 0;
-        goto exit;
-        //return 0;
-    }
-
     clock_gettime(CLOCK_MONOTONIC, &tval);
     //begain_time = get_systime_ns();
     written = aml_out_write_to_mixer(stream, buffer, bytes);
@@ -528,10 +521,10 @@ static ssize_t out_write_direct_pcm(struct audio_stream_out *stream, const void
         clock_gettime(CLOCK_MONOTONIC, &new_tval);
         if (tval.tv_sec > new_tval.tv_sec)
             ALOGE("%s(), FATAL ERROR", __func__);
-        ALOGV("++%s() bytes %d, out->port_index %d", __func__, bytes, out->port_index);
+        ALOGV("++%s() bytes %d, out->port_index %d", __func__, bytes, out->enInputPortType);
         //ALOGD(" %lld us, %lld", new_tval.tv_sec, tval.tv_sec);
 
-        us_since_last_write = (new_tval.tv_sec - out->timestamp.tv_sec) * 1000000 +
+        us_since_last_write = (uint64_t)(new_tval.tv_sec - out->timestamp.tv_sec) * 1000000 +
                 (new_tval.tv_nsec - out->timestamp.tv_nsec) / 1000;
         //out->timestamp = new_tval;
 
@@ -576,7 +569,7 @@ exit:
     out->lasttimestamp.tv_sec = out->timestamp.tv_sec;
     out->lasttimestamp.tv_nsec = out->timestamp.tv_nsec;
     if (written >= 0) {
-        uint32_t latency_frames = mixer_get_inport_latency_frames(audio_mixer, out->port_index);
+        uint32_t latency_frames = mixer_get_inport_latency_frames(audio_mixer, out->enInputPortType);
                 //+ mixer_get_outport_latency_frames(audio_mixer);
         if (out->frame_write_sum > latency_frames)
             out->last_frames_postion = out->frame_write_sum - latency_frames;
@@ -594,7 +587,6 @@ exit:
 static int on_notify_cbk(void *data)
 {
     struct aml_stream_out *out = data;
-    ALOGD("%s(), line %d", __func__, __LINE__);
     pthread_cond_broadcast(&out->cond);
     return 0;
 }
@@ -602,11 +594,6 @@ static int on_notify_cbk(void *data)
 static int on_input_avail_cbk(void *data)
 {
     struct aml_stream_out *out = data;
-    ALOGV("%s(), line %d", __func__, __LINE__);
-    //if (out->pause_status) {
-    //    ALOGI("%s(), in pause status, exit", __func__);
-    //    return 0;
-    //}
     pthread_cond_broadcast(&out->cond);
     return 0;
 }
@@ -627,12 +614,16 @@ static int out_get_presentation_position_port(
         return -EINVAL;
     }
 
-    if (!adev->audio_patching) {
+    if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+        *frames = frames_written_hw;
+        *timestamp = out->timestamp;
+    } else if (!adev->audio_patching) {
         ret = mixer_get_presentation_position(audio_mixer,
-                out->port_index, frames, timestamp);
+                out->enInputPortType, frames, timestamp);
         if (ret == 0) {
             out->last_frames_postion = *frames;
         } else {
+            *frames = out->last_frames_postion;
             ALOGV("%s(), pts not valid yet", __func__);
         }
     } else {
@@ -693,6 +684,22 @@ static int deleteSubMixingInputPcm(struct aml_stream_out *out)
     ALOGI("%s(), cnt_stream_using_mixer %d",
             __func__, sm->cnt_stream_using_mixer);
     //delete_mixer_input_port(audio_mixer, out->port_index);
+
+    struct meta_data_list *mdata_list;
+    struct listnode *item;
+
+    if (out->hw_sync_mode) {
+        pthread_mutex_lock(&out->mdata_lock);
+        while (!list_empty(&out->mdata_list)) {
+            item = list_head(&out->mdata_list);
+            mdata_list = node_to_item(item, struct meta_data_list, list);
+            list_remove(item);
+            //ALOGI("free medata list=%p", mdata_list);
+            free(mdata_list);
+        }
+        pthread_mutex_unlock(&out->mdata_lock);
+    }
+
     if (hwsync_lpcm) {
         ALOGI("%s(), lpcm case", __func__);
         mixer_set_continuous_output(sm->mixerData, false);
@@ -703,8 +710,8 @@ static int deleteSubMixingInputPcm(struct aml_stream_out *out)
 int initSubMixingInput(struct aml_stream_out *out,
         struct audio_config *config)
 {
-    struct aml_audio_device *adev = out->dev;
-    struct subMixing *sm = adev->sm;
+    struct aml_audio_device *adev;
+    struct subMixing *sm;
     int ret = 0;
 
     if (out == NULL || config == NULL) {
@@ -712,6 +719,8 @@ int initSubMixingInput(struct aml_stream_out *out,
         return -EINVAL;
     }
     ALOGI("++%s()", __func__);
+    adev = out->dev;
+    sm = adev->sm;
 
     if (sm->type == MIXER_LPCM) {
         ret = initSubMixingInputPcm(config, out);
@@ -726,8 +735,8 @@ int initSubMixingInput(struct aml_stream_out *out,
 
 int deleteSubMixingInput(struct aml_stream_out *out)
 {
-    struct aml_audio_device *adev = out->dev;
-    struct subMixing *sm = adev->sm;
+    struct aml_audio_device *adev;
+    struct subMixing *sm;
     int ret = 0;
 
     ALOGI("++%s()", __func__);
@@ -735,6 +744,8 @@ int deleteSubMixingInput(struct aml_stream_out *out)
         ALOGE("%s(), null pointer", __func__);
         return -EINVAL;
     }
+    adev = out->dev;
+    sm = adev->sm;
 
     if (sm->type == MIXER_LPCM) {
         ret = deleteSubMixingInputPcm(out);
@@ -752,7 +763,7 @@ int subMixerWriteInport(
         struct subMixing *sm,
         void *buf,
         size_t bytes,
-        enum MIXER_INPUT_PORT port_index)
+        aml_mixer_input_port_type_e port_index)
 {
     int ret = 0;
     if (sm->type == MIXER_LPCM) {
@@ -879,7 +890,9 @@ int initHalSubMixing(struct subMixing **smixer,
     ALOGI("%s(), type %d, isTV %d", __func__, type, isTV);
     if (smixer == NULL) {
         ALOGE("%s(), NULL pointer", __func__);
+        goto err;
     }
+    memset(&outCfg, 0, sizeof(struct audioCfg));
     initAudioConfig(&outCfg, isTV);
     ret = newSubMixingFactory(smixer, type, outCfg, NULL);
     if (ret < 0) {
@@ -939,6 +952,20 @@ int subWrite(
 }
 #endif
 
+#ifdef ENABLE_BT_A2DP
+void a2dp_switch(struct audio_stream_out *stream) {
+    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
+
+    if (aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
+        ALOGD("a2dp_switch: output: %p, a2dp_out=%p", aml_out, aml_out->a2dp_out);
+        if (aml_out->a2dp_out == NULL)
+            a2dp_output_enable(stream);
+    } else {
+        a2dp_output_disable(stream);
+    }
+}
+#endif
+
 int outSubMixingWrite(
             struct audio_stream_out *stream,
             const void *buf,
@@ -956,61 +983,45 @@ int outSubMixingWrite(
 ssize_t mixer_main_buffer_write_sm (struct audio_stream_out *stream, const void *buffer,
                                  size_t bytes)
 {
-    ALOGV ("%s write in %zu!\n", __FUNCTION__, bytes);
-    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
-    struct aml_audio_device *adev = aml_out->dev;
-    struct aml_stream_out *ms12_out = (struct aml_stream_out *)adev->ms12_out;
-    struct dolby_ms12_desc *ms12 = &(adev->ms12);
-    //struct aml_audio_patch *patch = adev->audio_patch;
-    int case_cnt;
-    int ret = -1;
-    void *output_buffer = NULL;
-    size_t output_buffer_bytes = 0;
-    bool need_reconfig_output = false;
-    void   *write_buf = NULL;
-    ssize_t  write_bytes = 0;
-    size_t  hwsync_cost_bytes = 0;
-    int total_write = 0;
-    size_t used_size = 0;
-    int write_retry = 0;
-    audio_hwsync_t *hw_sync = aml_out->hwsync;
+    struct aml_stream_out       *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device     *adev = aml_out->dev;
+    ssize_t                     write_bytes = 0;
+
+    if (buffer == NULL || bytes == 0) {
+        ALOGW("[%s:%d] stream:%p, buffer is null, or bytes:%d invalid", __func__, __LINE__, stream, bytes);
+        return -1;
+    }
 
     if (adev->debug_flag) {
-        ALOGI("%s write in %zu!, format = 0x%x\n", __FUNCTION__, bytes, aml_out->hal_internal_format);
+        ALOGD("[%s:%d] stream:%p, out_device:%#x, bytes:%d, format:%#x, hw_sync_mode:%d", __func__, __LINE__,
+            stream, aml_out->out_device, bytes, aml_out->hal_internal_format, aml_out->hw_sync_mode);
     }
-    int return_bytes = bytes;
 
-    if (buffer == NULL) {
-        ALOGE ("%s() invalid buffer %p\n", __FUNCTION__, buffer);
-        return -1;
+    if (adev->out_device != aml_out->out_device) {
+        ALOGD("[%s:%d] stream:%p, switch from device:%#x to device:%#x", __func__, __LINE__,
+                stream, adev->out_device, aml_out->out_device);
+        aml_out->out_device = adev->out_device;
+#ifdef ENABLE_BT_A2DP
+        a2dp_switch(stream);
+#endif
     }
 
-    case_cnt = popcount(adev->usecase_masks & 0xfffffffe);
-    if (case_cnt > 1) {
-        ALOGE ("%s usemask %x,we do not support two direct stream output at the same time.TO CHECK CODE FLOW!!!!!!",__func__,adev->usecase_masks);
-        return return_bytes;
+    if (popcount(adev->usecase_masks & SUBMIX_USECASE_MASK) > 1) {
+        ALOGE("[%s:%d] usemask:%#x, not support two direct stream", __func__, __LINE__, adev->usecase_masks);
+        return bytes;
     }
 
     /* handle HWSYNC audio data*/
     if (aml_out->hw_sync_mode) {
-        ALOGV("hwsync mode %s", __func__);
         write_bytes = out_write_hwsync_lpcm(stream, buffer, bytes);
     } else {
-        ALOGV("direct %s", __func__);
         write_bytes = out_write_direct_pcm(stream, buffer, bytes);
-        if (write_bytes < 0) {
-            ALOGE("%s(), write failed, err = %d", __func__, write_bytes);
-        }
-        //write_buf = (void *)buffer;
-        //write_bytes = bytes;
     }
 
-    aml_out->input_bytes_size += write_bytes;
-
-    if (adev->debug_flag) {
-        ALOGI("%s return %zu!\n", __FUNCTION__, bytes);
+    if (write_bytes > 0) {
+        aml_out->input_bytes_size += write_bytes;
     }
-    return return_bytes;
+    return bytes;
 }
 
 static const struct pcm_config config_bt = {
@@ -1173,14 +1184,12 @@ bool is_sco_port(enum OUT_PORT outport)
 ssize_t mixer_aux_buffer_write_sm(struct audio_stream_out *stream, const void *buffer,
                                size_t bytes)
 {
-    struct aml_stream_out *aml_out = (struct aml_stream_out *) stream;
-    struct aml_audio_device *adev = aml_out->dev;
-    struct subMixing *sm = adev->sm;
-    struct aml_bt_output *bt = &adev->bt_output;
-    size_t frame_size = audio_stream_out_frame_size(stream);
-    size_t in_frames = bytes / frame_size;
-    size_t bytes_remaining = bytes;
-    ssize_t bytes_written = 0;
+    struct aml_stream_out       *aml_out = (struct aml_stream_out *) stream;
+    struct aml_audio_device     *adev = aml_out->dev;
+    struct subMixing            *sm = adev->sm;
+    struct aml_bt_output        *bt = &adev->bt_output;
+    size_t                      in_frames = bytes / audio_stream_out_frame_size(stream);
+    ssize_t                     bytes_written = 0;
 #ifdef DEBUG_TIME
     uint64_t us_since_last_write = 0;
     struct timespec tval_begin, tval_end;
@@ -1188,7 +1197,16 @@ ssize_t mixer_aux_buffer_write_sm(struct audio_stream_out *stream, const void *b
     clock_gettime(CLOCK_MONOTONIC, &tval_begin);
 #endif
 
-    ALOGV("++%s", __func__);
+    if (buffer == NULL || bytes == 0) {
+        ALOGW("[%s:%d] stream:%p, buffer is null, or bytes:%d invalid", __func__, __LINE__, stream, bytes);
+        return -1;
+    }
+
+    if (adev->debug_flag) {
+        ALOGD("[%s:%d] stream:%p, out_device:%#x, bytes:%d", __func__, __LINE__,
+            stream, aml_out->out_device, bytes);
+    }
+
     if (is_sco_port(adev->active_outport)) {
         int ret = 0;
         if (!bt->active) {
@@ -1202,6 +1220,18 @@ ssize_t mixer_aux_buffer_write_sm(struct audio_stream_out *stream, const void *b
         bt->active = false;
     }
 
+    if (adev->out_device != aml_out->out_device) {
+        ALOGD("%s:%p device:%x,%x", __func__, stream, aml_out->out_device, adev->out_device);
+        aml_out->out_device = adev->out_device;
+#ifdef ENABLE_BT_A2DP
+        a2dp_switch(stream);
+#endif
+        aml_out->stream.common.standby(&aml_out->stream.common);
+        goto exit;
+    } else if (aml_out->out_device == 0) {
+        goto exit;
+    }
+
     if (aml_out->standby) {
         char *padding_buf = NULL;
         int padding_bytes = 512 * 4 * 8;
@@ -1211,9 +1241,9 @@ ssize_t mixer_aux_buffer_write_sm(struct audio_stream_out *stream, const void *b
             on_notify_cbk, aml_out, on_input_avail_cbk, aml_out,
             NULL, NULL, 1.0);
 
-        aml_out->port_index = get_input_port_index(&aml_out->audioCfg, aml_out->flags);
-        ALOGI("%s(), primary %p port index = %d",
-            __func__, aml_out, aml_out->port_index);
+        aml_out->enInputPortType = get_input_port_index(&aml_out->audioCfg, aml_out->flags);
+        ALOGI("[%s:%d] stream %p input port:%s", __func__, __LINE__, stream,
+            inportType2Str(aml_out->enInputPortType));
         aml_out->standby = false;
         /* start padding zero to fill buffer */
         padding_buf = calloc(1, 512 * 4);
@@ -1221,32 +1251,23 @@ ssize_t mixer_aux_buffer_write_sm(struct audio_stream_out *stream, const void *b
             ALOGE("%s(), no memory", __func__);
             return -ENOMEM;
         }
-        mixer_set_padding_size(sm->mixerData, aml_out->port_index, padding_bytes);
+        mixer_set_padding_size(sm->mixerData, aml_out->enInputPortType, padding_bytes);
         while (padding_bytes > 0) {
-            ALOGD("padding_bytes %d", padding_bytes);
+            ALOGI("padding_bytes %d", padding_bytes);
             aml_out_write_to_mixer(stream, padding_buf, 512 * 4);
             padding_bytes -= 512 * 4;
         }
         free(padding_buf);
     }
-
-    if (bytes == 0) {
-        ALOGW("%s(), write bytes 0, quickly feed ringbuf", __func__);
-        bytes_written = 0;
-        goto exit;
-    }
-
     bytes_written = aml_out_write_to_mixer(stream, buffer, bytes);
-    if (bytes_written < 0) {
-        ALOGE("%s(), write failed, err = %d", __func__, bytes_written);
-    }
+
 #ifdef DEBUG_TIME
     clock_gettime(CLOCK_MONOTONIC, &tval_end);
     us_since_last_write = (tval_end.tv_sec - aml_out->timestamp.tv_sec) * 1000000 +
             (tval_end.tv_nsec - aml_out->timestamp.tv_nsec) / 1000;
     int used_this_write = (tval_end.tv_sec - tval_begin.tv_sec) * 1000000 +
             (tval_end.tv_nsec - tval_begin.tv_nsec) / 1000;
-    int target_us = bytes * 1000 / frame_size / 48;
+    int target_us = in_frames * 1000 / 48;
 
     ALOGV("time spent on write %lld us, written %d", us_since_last_write, bytes_written);
     ALOGV("used_this_write %d us, target %d us", used_this_write, target_us);
@@ -1262,8 +1283,7 @@ ssize_t mixer_aux_buffer_write_sm(struct audio_stream_out *stream, const void *b
             ALOGV("%lld us, but un-throttle", throttle_timeus);
         }
     } else if (throttle_timeus != 0) {
-        ALOGV("invalid throttle time %lld us, us since last %lld us", throttle_timeus, us_since_last_write);
-        ALOGV("\n\n");
+        ALOGV("invalid throttle time %lld us, us since last %lld us \n\n", throttle_timeus, us_since_last_write);
     }
     aml_out->us_used_last_write = us_since_last_write;
 #endif
@@ -1278,6 +1298,47 @@ exit:
     return bytes;
 }
 
+
+ssize_t mixer_mmap_buffer_write_sm(struct audio_stream_out *stream, const void *buffer, size_t bytes)
+{
+   struct aml_stream_out    *aml_out = (struct aml_stream_out *) stream;
+   struct aml_audio_device  *adev = aml_out->dev;
+   struct subMixing         *pstSubMixing = adev->sm;
+   ssize_t                  bytes_written = 0;
+
+   if (adev->debug_flag) {
+       ALOGD("[%s:%d] stream:%p, out_device:%#x, bytes:%d", __func__, __LINE__,
+           stream, aml_out->out_device, bytes);
+   }
+
+   if (adev->out_device != aml_out->out_device) {
+       ALOGD("[%s:%d] stream:%p, switch from device:%#x to device:%#x", __func__, __LINE__,
+            stream, adev->out_device, aml_out->out_device);
+       aml_out->out_device = adev->out_device;
+       aml_out->stream.common.standby(&aml_out->stream.common);
+       return bytes;
+   } else if (aml_out->out_device == 0) {
+       ALOGW("[%s:%d] output device is none", __func__, __LINE__);
+       return bytes;
+   }
+
+   if (aml_out->standby) {
+       init_mixer_input_port(pstSubMixing->mixerData, &aml_out->audioCfg, aml_out->flags,
+           on_notify_cbk, aml_out, on_input_avail_cbk, aml_out, NULL, NULL, 1.0);
+       aml_out->enInputPortType = get_input_port_index(&aml_out->audioCfg, aml_out->flags);
+       ALOGI("[%s:%d] stream:%p, port_index:%s", __func__, __LINE__, aml_out, inportType2Str(aml_out->enInputPortType));
+       aml_out->standby = false;
+   }
+
+   bytes_written = aml_out_write_to_mixer(stream, buffer, bytes);
+   if (bytes_written != (ssize_t)bytes) {
+       ALOGW("[%s:%d] write to mixer error, written:%d, bytes:%d", __func__, __LINE__, bytes_written, bytes);
+   }
+
+exit:
+   return bytes_written;
+}
+
 /* must be called with hw device mutexes locked */
 int usecase_change_validate_l_sm(struct aml_stream_out *aml_out, bool is_standby)
 {
@@ -1287,9 +1348,8 @@ int usecase_change_validate_l_sm(struct aml_stream_out *aml_out, bool is_standby
     bool hw_mix;
 
     if (is_standby) {
-        ALOGI("++%s(), dev usecase masks = %#x, is_standby = %d, out usecase %s",
-              __func__, aml_dev->usecase_masks, is_standby,
-              aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? usecase_to_str(aml_out->usecase) : "STREAM_USECASE_INVAL");
+        ALOGI("++[%s:%d], dev masks:%#x, is_standby:%d, out usecase:%s", __func__,  __LINE__,
+              aml_dev->usecase_masks, is_standby, usecase2Str(aml_out->usecase));
         /**
          * If called by standby, reset out stream's usecase masks and clear the aml_dev usecase masks.
          * So other active streams could know that usecase have been changed.
@@ -1298,9 +1358,8 @@ int usecase_change_validate_l_sm(struct aml_stream_out *aml_out, bool is_standby
         aml_out->dev_usecase_masks = 0;
         aml_out->write = NULL;
         aml_dev->usecase_masks &= ~(1 << aml_out->usecase);
-        ALOGI("--%s(), dev usecase masks = %#x, is_standby = %d, out usecase %s",
-              __func__, aml_dev->usecase_masks, is_standby,
-              aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? usecase_to_str(aml_out->usecase) : "STREAM_USECASE_INVAL");
+        ALOGI("--[%s:%d], dev masks:%#x, is_standby:%d, out usecase:%s", __func__,  __LINE__,
+              aml_dev->usecase_masks, is_standby, usecase2Str(aml_out->usecase));
         return 0;
     }
 
@@ -1309,33 +1368,31 @@ int usecase_change_validate_l_sm(struct aml_stream_out *aml_out, bool is_standby
         return 0;
     }
 
-    ALOGI("++%s: dev usecase masks = %#x, out usecase_masks = %#x, out usecase %s",
-           __func__, aml_dev->usecase_masks, aml_out->dev_usecase_masks, usecase_to_str(aml_out->usecase));
+    ALOGV("++[%s:%d] dev masks:%#x, out masks:%#x, out usecase:%s", __func__,  __LINE__,
+           aml_dev->usecase_masks, aml_out->dev_usecase_masks, usecase2Str(aml_out->usecase));
 
     /* check the usecase validation */
-    if (popcount(aml_dev->usecase_masks & 0xfffffffe) > 1) {
-        ALOGE("%s(), invalid usecase masks = %#x, out usecase %s!",
-              __func__, aml_dev->usecase_masks, usecase_to_str(aml_out->usecase));
+    if (popcount(aml_dev->usecase_masks & SUBMIX_USECASE_MASK) > 1) {
+        ALOGE("[%s:%d], invalid dev masks:%#x, out usecase %s!", __func__,  __LINE__,
+              aml_dev->usecase_masks, usecase2Str(aml_out->usecase));
         return -EINVAL;
     }
 
     if (((aml_dev->continuous_audio_mode == 1) && (aml_dev->debug_flag > 1)) || \
         (aml_dev->continuous_audio_mode == 0))
-        ALOGI("++++%s(),continuous_audio_mode %d dev usecase masks = %#x, out usecase_masks = %#x, out usecase %s",
-              __func__, aml_dev->continuous_audio_mode, aml_dev->usecase_masks, aml_out->dev_usecase_masks,
-              aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? usecase_to_str(aml_out->usecase) : "STREAM_USECASE_INVAL");
+        ALOGI("++++[%s:%d],continuous:%d dev masks:%#x, out masks:%#x, out usecase %s", __func__,  __LINE__,
+            aml_dev->continuous_audio_mode, aml_dev->usecase_masks, aml_out->dev_usecase_masks, usecase2Str(aml_out->usecase));
 
     /* new output case entered, so no masks has been set to the out stream */
     if (!aml_out->dev_usecase_masks) {
         if ((1 << aml_out->usecase) & aml_dev->usecase_masks) {
-            ALOGE("%s(), usecase: %s already exists!!", __func__,
-                aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? usecase_to_str(aml_out->usecase) : "STREAM_USECASE_INVAL");
+            ALOGE("[%s:%d], usecase: %s already exists!!", __func__,  __LINE__, usecase2Str(aml_out->usecase) );
             return -EINVAL;
         }
 
-        if (popcount((aml_dev->usecase_masks | (1 << aml_out->usecase)) & 0xfffffffe) > 1) {
-            ALOGE("%s(), usecase masks = %#x, couldn't add new out usecase %s!",
-                  __func__, aml_dev->usecase_masks, usecase_to_str(aml_out->usecase));
+        if (popcount((aml_dev->usecase_masks | (1 << aml_out->usecase)) & SUBMIX_USECASE_MASK) > 1) {
+            ALOGE("[%s:%d], usecase masks:%#x, couldn't add new out usecase %s!", __func__,  __LINE__,
+                  aml_dev->usecase_masks, usecase2Str(aml_out->usecase));
             return -EINVAL;
         }
 
@@ -1343,26 +1400,28 @@ int usecase_change_validate_l_sm(struct aml_stream_out *aml_out, bool is_standby
         aml_dev->usecase_masks |= 1 << aml_out->usecase;
     }
 
-    if (aml_out->is_normal_pcm) {
+    if (STREAM_PCM_NORMAL == aml_out->usecase) {
         if (aml_dev->audio_patching) {
-            ALOGI("%s(), tv patching, mixer_aux_buffer_write!", __FUNCTION__);
+            ALOGV("%s(), tv patching, mixer_aux_buffer_write!", __FUNCTION__);
             aml_out->write = mixer_aux_buffer_write;
         } else {
             aml_out->write = mixer_aux_buffer_write_sm;
             ALOGI("%s(), mixer_aux_buffer_write_sm !", __FUNCTION__);
         }
+    } else if (STREAM_PCM_MMAP == aml_out->usecase) {
+        aml_out->write = mixer_mmap_buffer_write_sm;
+        ALOGV("%s(), mixer_mmap_buffer_write_sm !", __FUNCTION__);
     } else {
         aml_out->write = mixer_main_buffer_write_sm;
-        ALOGI("%s(), mixer_main_buffer_write_sm !", __FUNCTION__);
+        ALOGV("%s(), mixer_main_buffer_write_sm !", __FUNCTION__);
     }
 
     /* store the new usecase masks in the out stream */
     aml_out->dev_usecase_masks = aml_dev->usecase_masks;
     if (((aml_dev->continuous_audio_mode == 1) && (aml_dev->debug_flag > 1)) || \
         (aml_dev->continuous_audio_mode == 0))
-        ALOGI("----%s(), continuous_audio_mode %d dev usecase masks = %#x, out usecase_masks = %#x, out usecase %s",
-              __func__, aml_dev->continuous_audio_mode, aml_dev->usecase_masks, aml_out->dev_usecase_masks,
-              aml_out->usecase < STREAM_USECASE_MAX && aml_out->usecase >= STREAM_PCM_NORMAL ? usecase_to_str(aml_out->usecase) : "STREAM_USECASE_INVAL");
+        ALOGI("----[%s:%d], continuous:%d dev masks:%#x, out masks:%#x, out usecase %s", __func__,  __LINE__,
+            aml_dev->continuous_audio_mode, aml_dev->usecase_masks, aml_out->dev_usecase_masks, usecase2Str(aml_out->usecase));
     return 0;
 }
 
@@ -1396,10 +1455,10 @@ static ssize_t out_write_subMixingPCM(struct audio_stream_out *stream,
     //if (aml_out->write) {
     //    write_func_p = aml_out->write;
     //}
-    if (adev->rawtopcm_flag) {
+    if (adev->raw_to_pcm_flag) {
         mixer_stop_outport_pcm(audio_mixer);
-        adev->rawtopcm_flag = false;
-        ALOGI("rawtopcm_flag disable !!!");
+        adev->raw_to_pcm_flag = false;
+        ALOGI("raw_to_pcm_flag disable !!!");
     }
     pthread_mutex_unlock(&adev->lock);
     if (aml_out->write) {
@@ -1424,13 +1483,14 @@ int out_standby_subMixingPCM(struct audio_stream *stream)
     struct amlAudioMixer *audio_mixer = sm->mixerData;
     ssize_t ret = 0;
 
-    ALOGD("%s: out_stream(%p) usecase: %s", __func__, stream, usecase_to_str(aml_out->usecase));
+    ALOGD("%s: out_stream(%p) usecase: %s", __func__, stream, usecase2Str(aml_out->usecase));
     /**
      * deal with the device output changes
      * pthread_mutex_lock(&aml_out->lock);
      * out_device_change_validate_l(aml_out);
      * pthread_mutex_unlock(&aml_out->lock);
      */
+
     pthread_mutex_lock(&adev->lock);
     if (aml_out->standby) {
         goto exit;
@@ -1443,8 +1503,12 @@ int out_standby_subMixingPCM(struct audio_stream *stream)
     }
     aml_out->status = STREAM_STANDBY;
     aml_out->standby = true;
-    aml_out->exiting = true;
-    delete_mixer_input_port(audio_mixer, aml_out->port_index);
+    delete_mixer_input_port(audio_mixer, aml_out->enInputPortType);
+
+#ifdef ENABLE_BT_A2DP
+    if ((aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) && aml_out->a2dp_out)
+        a2dp_out_standby(stream);
+#endif
 
     if (adev->debug_flag > 1) {
         ALOGI("-%s() ret %zd,%p %"PRIu64"\n", __func__, ret, stream, aml_out->total_write_size);
@@ -1466,7 +1530,7 @@ static int out_pause_subMixingPCM(struct audio_stream_out *stream)
             aml_out,
             aml_out->standby,
             aml_out->pause_status,
-            usecase_to_str(aml_out->usecase));
+            usecase2Str(aml_out->usecase));
     if (aml_out->standby || aml_out->pause_status) {
         ALOGW("%s(), stream already paused", __func__);
         return INVALID_STATE;
@@ -1478,9 +1542,13 @@ static int out_pause_subMixingPCM(struct audio_stream_out *stream)
     }
 
     audio_mixer = sm->mixerData;
-    send_mixer_inport_message(audio_mixer, aml_out->port_index, MSG_PAUSE);
+    send_mixer_inport_message(audio_mixer, aml_out->enInputPortType, MSG_PAUSE);
 
     aml_out->pause_status = true;
+#ifdef ENABLE_BT_A2DP
+    if (aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP)
+        a2dp_out_standby(&stream->common);
+#endif
     ALOGI("-%s()", __func__);
     return 0;
 }
@@ -1493,12 +1561,12 @@ static int out_resume_subMixingPCM(struct audio_stream_out *stream)
     struct amlAudioMixer *audio_mixer = NULL;
     int ret = 0;
 
-    ALOGD("+%s(), stream %p, standby %d, pause status %d, usecase: %s",
+    ALOGI("+%s(), stream %p, standby %d, pause status %d, usecase: %s",
             __func__,
             aml_out,
             aml_out->standby,
             aml_out->pause_status,
-            usecase_to_str(aml_out->usecase));
+            usecase2Str(aml_out->usecase));
 
     if (!aml_out->pause_status) {
         ALOGW("%s(), steam not in pause status", __func__);
@@ -1511,10 +1579,10 @@ static int out_resume_subMixingPCM(struct audio_stream_out *stream)
     }
 
     audio_mixer = sm->mixerData;
-    send_mixer_inport_message(audio_mixer, aml_out->port_index, MSG_RESUME);
+    send_mixer_inport_message(audio_mixer, aml_out->enInputPortType, MSG_RESUME);
 
     aml_out->pause_status = false;
-    ALOGD("-%s()", __func__);
+    ALOGI("-%s()", __func__);
     return 0;
 }
 
@@ -1532,7 +1600,7 @@ static int out_flush_subMixingPCM(struct audio_stream_out *stream)
             aml_out,
             aml_out->standby,
             aml_out->pause_status,
-            usecase_to_str(aml_out->usecase));
+            usecase2Str(aml_out->usecase));
 
     if (sm->type != MIXER_LPCM) {
         ALOGW("%s(), sub mixing type not pcm, type is %d", __func__, sm->type);
@@ -1561,7 +1629,7 @@ static int out_flush_subMixingPCM(struct audio_stream_out *stream)
             pthread_mutex_unlock(&aml_out->mdata_lock);
         }
         audio_mixer = sm->mixerData;
-        send_mixer_inport_message(audio_mixer, aml_out->port_index, MSG_FLUSH);
+        send_mixer_inport_message(audio_mixer, aml_out->enInputPortType, MSG_FLUSH);
         if (!aml_out->standby)
             flush_hw_avsync_header_extractor(aml_out->hwsync_extractor);
         //mixer_set_inport_state(audio_mixer, out->port_index, FLUSHING);
@@ -1580,28 +1648,39 @@ static int out_flush_subMixingPCM(struct audio_stream_out *stream)
 
 int switchNormalStream(struct aml_stream_out *aml_out, bool on)
 {
-    ALOGI("+%s() stream %p, on = %d", __func__, aml_out, on);
-    if (!aml_out) {
-        ALOGE("%s(), no stream", __func__);
-        return -EINVAL;
+    struct aml_audio_device *aml_dev = aml_out->dev;
+    struct subMixing *sm = aml_dev->sm;
+    struct amlAudioMixer *audio_mixer = sm->mixerData;
 
-    }
+    ALOGI("+%s() stream %p, on = %d", __func__, aml_out, on);
     if (!aml_out->is_normal_pcm) {
         ALOGE("%s(), not normal pcm stream", __func__);
         return -EINVAL;
     }
     if (on) {
         initSubMixingInputPcm(&aml_out->out_cfg, aml_out);
-        aml_out->stream.write = mixer_aux_buffer_write_sm;
+        aml_out->stream.write = out_write_subMixingPCM;
         aml_out->stream.common.standby = out_standby_subMixingPCM;
         out_standby_subMixingPCM((struct audio_stream *)aml_out);
+        mixer_output_dummy(audio_mixer, 0);
     } else {
         aml_out->stream.write = mixer_aux_buffer_write;
         aml_out->stream.common.standby = out_standby_new;
         deleteSubMixingInputPcm(aml_out);
         out_standby_new((struct audio_stream *)aml_out);
+        mixer_output_dummy(audio_mixer, 1);
+        mixer_output_standby(audio_mixer);
     }
 
     return 0;
 }
 
+void subMixingDump(int s32Fd, const struct aml_audio_device *pstAmlDev)
+{
+    if (NULL == pstAmlDev) {
+        dprintf(s32Fd, "[AML_HAL] %s:%d device is NULL !\n", __func__, __LINE__);
+        return;
+    }
+    dprintf(s32Fd, "[AML_HAL]\n");
+    mixer_dump(s32Fd, pstAmlDev);
+}
diff --git a/audio_hal/sub_mixing_factory.h b/audio_hal/sub_mixing_factory.h
index ac32481..c2f0893 100644
--- a/audio_hal/sub_mixing_factory.h
+++ b/audio_hal/sub_mixing_factory.h
@@ -89,4 +89,7 @@ int usecase_change_validate_l_sm(struct aml_stream_out *out, bool is_standby);
 int out_standby_subMixingPCM(struct audio_stream *stream);
 int switchNormalStream(struct aml_stream_out *aml_out, bool on);
 
+void subMixingDump(int s32Fd, const struct aml_audio_device *pstAmlDev);
+
+
 #endif /* _SUB_MIXING_FACTORY_H_ */
diff --git a/include/utils/ac3_parser_utils.h b/include/utils/ac3_parser_utils.h
index 26f5f1d..37e8234 100644
--- a/include/utils/ac3_parser_utils.h
+++ b/include/utils/ac3_parser_utils.h
@@ -21,6 +21,8 @@
 #define ISDD(bsid)       ((bsid) <= BS_STD)
 #define BS_AXE           16
 #define ISDDP(bsid)      ((bsid) <= BS_AXE && (bsid) > 10)
+#define BS_MAT           32
+#define ISMAT(bsid)      ((bsid) <= BS_MAT && (bsid) > 16)
 
 
 /*
diff --git a/include/utils/aml_alsa_mixer.h b/include/utils/aml_alsa_mixer.h
index 4960b65..e1af7df 100644
--- a/include/utils/aml_alsa_mixer.h
+++ b/include/utils/aml_alsa_mixer.h
@@ -17,12 +17,13 @@
 #ifndef _AML_ALSA_MIXER_H_
 #define _AML_ALSA_MIXER_H_
 
-#include <pthread.h>
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+#include <pthread.h>
+#include <tinyalsa/asoundlib.h>
+
 /*
  *  Value of the Alsa Mixer Control Point
  **/
@@ -46,6 +47,7 @@ typedef enum MIXER_AUDIO_IN_SOURCE {
     AUDIOIN_SRC_ATV     = 1,
     AUDIOIN_SRC_HDMI    = 2,
     AUDIOIN_SRC_SPDIFIN = 3,
+    AUDIOIN_SRC_HDMI_ARC_IN = 4,
     AUDIOIN_SRC_MAX,
 } eMixerAudioInSrc;
 
@@ -102,6 +104,26 @@ struct aml_mixer_ctrl {
     char ctrl_name[50];
 };
 
+/* the same as toddr source*/
+typedef enum ResampleSource {
+    RESAMPLE_FROM_TDMIN_A     = 0,
+    RESAMPLE_FROM_TDMIN_B     = 1,
+    RESAMPLE_FROM_TDMIN_C     = 2,
+    RESAMPLE_FROM_SPDIFIN     = 3,
+    RESAMPLE_FROM_PDMIN       = 4,
+    RESAMPLE_FROM_FRATV       = 5,
+    RESAMPLE_FROM_TDBIN_LB    = 6,
+    RESAMPLE_FROM_LOOPBACK_A  = 7,
+    RESAMPLE_FROM_FRHDMIRX    = 8,
+    RESAMPLE_FROM_LOOPBACK_B  = 9,
+    RESAMPLE_FROM_SPDIFIN_LB  = 10,
+    RESAMPLE_FROM_EARCRX_DMAC = 11,
+    RESAMPLE_FROM_RESERVED_0  = 12,
+    RESAMPLE_FROM_RESERVED_1  = 13,
+    RESAMPLE_FROM_RESERVED_2  = 14,
+    RESAMPLE_FROM_VAD         = 15,
+} eMixerAudioResampleSource;
+
 /*
  *  Alsa Mixer Control Command List
  **/
@@ -110,7 +132,12 @@ typedef enum AML_MIXER_CTRL_ID {
     AML_MIXER_ID_SPDIF_MUTE,
     AML_MIXER_ID_HDMI_OUT_AUDIO_MUTE,
     AML_MIXER_ID_HDMI_ARC_AUDIO_ENABLE,
+	/* eARC latency and CDS */
     AML_MIXER_ID_HDMI_EARC_AUDIO_ENABLE,
+    AML_MIXER_ID_EARCRX_LATENCY,
+    AML_MIXER_ID_EARCTX_LATENCY,
+    AML_MIXER_ID_EARCRX_CDS, /* Capability Data Structure */
+    AML_MIXER_ID_EARCTX_CDS,
     AML_MIXER_ID_AUDIO_IN_SRC,
     AML_MIXER_ID_I2SIN_AUDIO_TYPE,
     AML_MIXER_ID_SPDIFIN_AUDIO_TYPE,
@@ -136,7 +163,19 @@ typedef enum AML_MIXER_CTRL_ID {
     AML_MIXER_ID_AED_MULTI_DRC_ENABLE,
     AML_MIXER_ID_AED_FULL_DRC_ENABLE,
     AML_MIXER_ID_SPDIF_IN_SAMPLERATE,
+    AML_MIXER_ID_HW_RESAMPLE_SOURCE,
+    AML_MIXER_ID_AUDIO_HAL_FORMAT,
+    AML_MIXER_ID_EARCRX_ATTENDED_TYPE,
+    AML_MIXER_ID_EARCRX_AUDIO_CODING_TYPE,
+    AML_MIXER_ID_EARCRX_CS_MUTE,
+    AML_MIXER_ID_EARCRX_AUDIO_SAMPLERATE,
+    AML_MIXER_ID_EARCRX_AUDIO_BIT_DEPTH,
+    AML_MIXER_ID_EARCRX_CHANNEL_MAP,
+    AML_MIXER_ID_EARCRX_CA,
     AML_MIXER_ID_EARC_AUDIO_TYPE,
+    AML_MIXER_ID_EARC_RX_ATTENDED_TYPE,//TODO-find which one to use tinymix "eARC_RX attended type "
+    AML_MIXER_ID_HDMIIN_AUDIO_EDID,
+    AML_MIXER_ID_EARC_TX_ATTENDED_TYPE,//TODO-find which one to use tinymix "eARC_TX attended type"
     AML_MIXER_ID_MAX,
 } eMixerCtrlID;
 
@@ -169,6 +208,8 @@ struct aml_mixer_handle {
 int open_mixer_handle(struct aml_mixer_handle *mixer_handle);
 int close_mixer_handle(struct aml_mixer_handle *mixer_handle);
 
+int aml_mixer_ctrl_get_count(struct aml_mixer_handle *mixer_handle, int mixer_id);
+
 /*
  * get interface
  **/
@@ -187,6 +228,12 @@ int aml_mixer_get_spdifin_type(int mixer_id);
  **/
 int aml_mixer_ctrl_set_int(struct aml_mixer_handle *mixer_handle, int mixer_id, int value);
 int aml_mixer_ctrl_set_str(struct aml_mixer_handle *mixer_handle, int mixer_id, char *value);
+int aml_mixer_ctrl_set_array(struct aml_mixer_handle *mixer_handle, int mixer_id, void *array, int count);
+
+int mixer_get_int(struct mixer *pMixer, int mixer_id);
+int mixer_set_int(struct mixer *pMixer, int mixer_id, int value);
+int mixer_get_array(struct mixer *pMixer, int mixer_id, void *array, int count);
+int mixer_set_array(struct mixer *pMixer, int mixer_id, void *array, int count);
 
 #ifdef __cplusplus
 }
diff --git a/include/utils/aml_audio_parser.h b/include/utils/aml_audio_parser.h
index aeb8a94..8f3b4b4 100644
--- a/include/utils/aml_audio_parser.h
+++ b/include/utils/aml_audio_parser.h
@@ -18,6 +18,16 @@
 #define _AML_AUDIO_PARSER_
 #include "aml_audio_types_def.h"
 
+
+typedef enum AML_AUDIO_DECODER_TYPE{
+    AML_AUDIO_DECODER_TYPE_NONE         = 0,
+    AML_AUDIO_DECODER_TYPE_DOLBY        = 1,
+    AML_AUDIO_DECODER_TYPE_DTS          = 2,
+
+    AML_AUDIO_DECODER_TYPE_BUTT         = 3,
+} aml_audio_decoder_type_e;
+
+
 struct aml_audio_parser {
     struct audio_hw_device *dev;
     ring_buffer_t aml_ringbuffer;
@@ -36,7 +46,8 @@ struct aml_audio_parser {
     struct resample_para aml_resample;
     int data_ready;
     struct pcm_info pcm_out_info;
-    struct audio_stream_in *stream;
+    struct aml_stream_in *in;
+    aml_audio_decoder_type_e    enCurDecType;
 };
 
 
diff --git a/include/utils/aml_conf_parser.h b/include/utils/aml_conf_parser.h
index ec00d39..0758681 100644
--- a/include/utils/aml_conf_parser.h
+++ b/include/utils/aml_conf_parser.h
@@ -18,6 +18,7 @@
 #define _PARSER_H_
 
 #define MAX_INI_FILE_LINE_LEN (512)
+#define MAX_PASER_NAME_LEN (256)
 
 /*
  * example.conf
@@ -72,7 +73,7 @@ typedef struct _SECTION {
  ** Parser
  **/
 struct parser {
-    char    mpFileName[256];                  // path of config file
+    char    mpFileName[MAX_PASER_NAME_LEN];                  // path of config file
     FILE    *m_pIniFile;                      // handle
     LINE    *mpFirstLine;                     // first line in this config file
     SECTION *mpFirstSection;                  // first section in this config file
@@ -81,7 +82,7 @@ struct parser {
 /* load from */
 #define AML_PARAM_AUDIO_HAL_SYSTEM "/system/etc/tvaudiohal.conf"
 /* save to */
-#define AML_PARAM_AUDIO_HAL_PARAM  "/mnt/vendor/param/tvaudiohal.conf"
+#define AML_PARAM_AUDIO_HAL_PARAM  "/data/vendor/pq/tvaudiohal.conf"
 
 #define AML_SECTION_AUDIO_HAL      "AUDIO_HAL"
 
diff --git a/include/utils/aml_malloc_debug.h b/include/utils/aml_malloc_debug.h
new file mode 100644
index 0000000..df689f1
--- /dev/null
+++ b/include/utils/aml_malloc_debug.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2019 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef _AML_MALLOC_DEBUG_H
+#define _AML_MALLOC_DEBUG_H
+#include <stdlib.h>
+
+
+//#define AML_MALLOC_DEBUG
+#ifdef AML_MALLOC_DEBUG
+
+#define aml_audio_malloc(x) aml_audio_debug_malloc(x, __FILE__, __LINE__)
+#define aml_audio_free(x)   aml_audio_debug_free(x)
+#define aml_audio_realloc(x, y) aml_audio_debug_realloc(x, y, __FILE__, __LINE__)
+#define aml_audio_calloc(x, y) aml_audio_debug_calloc(x, y, __FILE__, __LINE__)
+#else
+#define aml_audio_malloc(x) malloc(x)
+#define aml_audio_free(x)   free(x)
+#define aml_audio_realloc(x, y) realloc(x, y)
+#define aml_audio_calloc(x, y) calloc(x, y)
+#endif
+
+void aml_audio_debug_malloc_open(void);
+void aml_audio_debug_malloc_close(void);
+void* aml_audio_debug_malloc(size_t size, char * file_name, uint32_t line);
+void* aml_audio_debug_realloc(void* pointer, size_t bytes, char * file_name, uint32_t line);
+void* aml_audio_debug_calloc(size_t nmemb, size_t bytes, char * file_name, uint32_t line);
+void aml_audio_debug_free(void* pointer);
+void aml_audio_debug_malloc_showinfo(uint32_t level);
+
+#endif
diff --git a/include/utils/aml_ringbuffer.h b/include/utils/aml_ringbuffer.h
index af61c41..5c0d483 100644
--- a/include/utils/aml_ringbuffer.h
+++ b/include/utils/aml_ringbuffer.h
@@ -44,7 +44,7 @@ int ring_buffer_reset_size(struct ring_buffer *rbuffer, int buffer_size);
 int get_buffer_read_space(struct ring_buffer *rbuffer);
 int get_buffer_write_space(struct ring_buffer *rbuffer);
 void ring_buffer_dump(struct ring_buffer *rbuffer);
-
+int ring_buffer_seek(struct ring_buffer *rbuffer, int bytes);
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/utils/earc_utils.h b/include/utils/earc_utils.h
new file mode 100644
index 0000000..4136b10
--- /dev/null
+++ b/include/utils/earc_utils.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2019 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _EARC_UTILS_H_
+#define _EARC_UTILS_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <cutils/log.h>
+#include <aml_alsa_mixer.h>
+
+int earcrx_config_latency(struct mixer *pMixer, int latency);
+int earctx_fetch_latency(struct mixer * pMixer);
+int earcrx_config_cds(struct mixer *pMixer, char *cds_str);
+int earcrx_fetch_cds(struct mixer *pMixer, char *cds_str);
+int earctx_fetch_cds(struct mixer *pMixer, char *cds_str);
+
+#endif
diff --git a/include/utils/spdifenc_wrap.h b/include/utils/spdifenc_wrap.h
index ceb7832..0e21c36 100644
--- a/include/utils/spdifenc_wrap.h
+++ b/include/utils/spdifenc_wrap.h
@@ -25,6 +25,7 @@ int spdifenc_init(struct pcm *mypcm, audio_format_t format);
 int spdifenc_write(const void *buffer, size_t numBytes);
 uint64_t  spdifenc_get_total(void);
 int spdifenc_set_mute(bool mute);
+audio_format_t  spdifenc_get_format(void);
 
 //#ifdef __cplusplus
 //}
diff --git a/libms12v2/CMakeLists.txt b/libms12v2/CMakeLists.txt
index a185e6b..ee77d04 100644
--- a/libms12v2/CMakeLists.txt
+++ b/libms12v2/CMakeLists.txt
@@ -15,7 +15,7 @@ add_library(ms12v2 SHARED
 	src/DolbyMS12Status.cpp
 )
 
-add_definitions(-DREPLACE_OUTPUT_BUFFER_WITH_CALLBACK)
+add_definitions(-DNDEBUG -DREPLACE_OUTPUT_BUFFER_WITH_CALLBACK)
 
 set_target_properties(ms12v2 PROPERTIES
 	VERSION ${PROJECT_VERSION}
@@ -23,7 +23,8 @@ set_target_properties(ms12v2 PROPERTIES
 
 target_include_directories(ms12v2 PRIVATE
 	./include
-	${PROJECT_SOURCE_DIR}/include)
+	${PROJECT_SOURCE_DIR}/include
+	${PROJECT_SOURCE_DIR}/include/utils)
 
 target_link_libraries(ms12v2
 	-lcutils -llog -lpthread -ldl -lstdc++)
diff --git a/libms12v2/include/DolbyMS12.h b/libms12v2/include/DolbyMS12.h
index 837b1ac..50f2ab2 100644
--- a/libms12v2/include/DolbyMS12.h
+++ b/libms12v2/include/DolbyMS12.h
@@ -23,6 +23,13 @@
 
 #ifdef __cplusplus
 
+typedef enum  {
+    MS12_CONFIG_MAIN_VOLUME,
+}ms12_config_type_t;
+
+typedef union ms12_config {
+    float main_volume;
+}ms12_config_t;
 struct aml_audio_info{
     int is_dolby_atmos;
     int reserved_a;
@@ -71,8 +78,17 @@ public:
         , int audio_stream_out_channel_num
         , int audio_stream_out_sample_rate
     );
+    virtual int     DolbyMS12InputApp(
+        void *dolbyMS12_pointer
+        , const void *audio_stream_out_buffer //ms12 input buffer
+        , size_t audio_stream_out_buffer_size //ms12 input buffer size
+        , int audio_stream_out_format
+        , int audio_stream_out_channel_num
+        , int audio_stream_out_sample_rate
+    );
 
 #ifdef REPLACE_OUTPUT_BUFFER_WITH_CALLBACK
+
     virtual int     DolbyMS12RegisterOutputCallback(output_callback callback, void *priv_data);
 
 #else
@@ -103,9 +119,11 @@ public:
 
     virtual void    DolbyMS12FlushMainInputBuffer(void);
 
+    virtual void    DolbyMS12FlushAppInputBuffer(void);
+
     virtual void    DolbyMS12SetMainDummy(int type, int dummy);
 
-    virtual unsigned long long DolbyMS12GetNBytesConsumedOfUDC(void);
+    virtual unsigned long long DolbyMS12GetDecoderNBytesConsumed(void *ms12_pointer, int format, int is_main);
 
     virtual void    DolbyMS12GetPCMOutputSize(unsigned long long *all_output_size, unsigned long long *ms12_generate_zero_size);
 
@@ -119,8 +137,16 @@ public:
 
     virtual int     DolbyMS12GetGain(int);
 
+    virtual int     DolbyMS12SetMainVolume(float volume);
     virtual int     DolbyMS12GetInputISDolbyAtmos();
 
+    virtual unsigned long long DolbyMS12GetDecoderNFramesPcmOutput(void *ms12_pointer, int format, int is_main);
+
+    virtual void DolbyMS12SetDebugLevel(int);
+
+    virtual unsigned long long DolbyMS12GetNBytesConsumedSysSound(void);
+
+    virtual int DolbyMS12GetTotalNFramesDelay(void *);
     // protected:
 
 
diff --git a/libms12v2/include/DolbyMS12ConfigParams.h b/libms12v2/include/DolbyMS12ConfigParams.h
index f7f4fa1..5b03952 100644
--- a/libms12v2/include/DolbyMS12ConfigParams.h
+++ b/libms12v2/include/DolbyMS12ConfigParams.h
@@ -25,19 +25,45 @@
 
 #include "dolby_ms12_config_parameter_struct.h"
 #include "dolby_ms12_output_mask.h"
+#include "dolby_ms12_input_mask.h"
+
 
 //@@@DDPlus input file
+// do not change file names, the pattern are used by MS12 lib
+// to determine node input types
 #define DEFAULT_MAIN_DDP_FILE_NAME "/data/main.ac3"
 #define DEFAULT_MAIN2_DDP_FILE_NAME "/data/main2.ac3"
 #define DEFAULT_ASSOCIATE_DDP_FILE_NAME "/data/associate.ac3"
 
+//#define DEFAULT_DUMMY_DDP_FILE_NAME "dummy_main.ac3"
+//#define DEFAULT_DUMMY2_DDP_FILE_NAME "dummy_main2.ac3"
 #define DEFAULT_DUMMY_DDP_FILE_NAME "dummy.ac3"
+#define DEFAULT_DUMMY2_DDP_FILE_NAME "dummy.ac3"
 #define DEFAULT_DAP_TUNING_FILE_NAME "/vendor/etc/ms12_tuning.dat"
 
+
 #ifdef __cplusplus
 namespace android
 {
 
+#define MS12_INPUT_MAIN   0
+#define MS12_INPUT_MAIN2  1
+#define MS12_INPUT_SYSTEM 2
+#define MS12_INPUT_APP    3
+#define MS12_INPUT_UI     4
+#define MS12_INPUT_MAX    5
+
+#define MIN_USER_CONTROL_VALUES (-32)
+#define MAX_USER_CONTROL_VALUES (32)
+
+#define MAX_MS12_INPUT_CMD_LEN 16
+
+typedef struct ms12InputNameMaskTable_t {
+char fileTypeCmd[MAX_MS12_INPUT_CMD_LEN];
+int mask;
+}
+ms12InputTable_t;
+
 class DolbyMS12ConfigParams
 {
 
@@ -66,10 +92,12 @@ public:
 #if 0
     virtual int SetPCMSwitchesRuntime(char **ConfigParams, int *row_index);
 #endif
+
     virtual int SetAc4Switches(char **ConfigParams, int *row_index);
     virtual int SetHEAACSwitches(char **ConfigParams, int *row_index);
     virtual int SetDAPDeviceSwitches(char **ConfigParams, int *row_index, int is_runtime);
     virtual int SetDAPContentSwitches(char **ConfigParams, int *row_index);
+    virtual char *QueryDapParameters(const char *key);
     virtual char **GetDolbyMS12ConfigParams(int *argc);
 #if 0
     virtual char **GetDolbyMS12RuntimeConfigParams(int *argc);
@@ -94,7 +122,7 @@ public:
     }
     virtual audio_channel_mask_t GetDolbyConfigOutputChannelMask(void)
     {
-        return mDolbyMS12OutChannelMask;
+        return mDolbyMS12OutChannelMask[MS12_INPUT_MAIN];
     }
     virtual void ResetConfigParams(void);
     //associate flags
@@ -120,8 +148,22 @@ public:
         ALOGI("%s() mHasSystemInput %d\n", __FUNCTION__, mHasSystemInput);
         return mHasSystemInput;
     }
-    virtual int APPSoundChannelMaskConvertToChannelConfiguration(audio_channel_mask_t channel_mask);
-    virtual int SystemSoundChannelMaskConvertToChannelConfiguration(audio_channel_mask_t channel_mask);
+
+    //app flags
+    virtual void setAppFlag(bool flag)
+    {
+        ALOGI("%s() App flag %d\n", __FUNCTION__, flag);
+        mHasAppInput = flag;
+        mAppSoundFlags = flag;
+    }
+    virtual int getAppFlag(void)
+    {
+        ALOGI("%s() mHasAppInput %d\n", __FUNCTION__, mHasAppInput);
+        return mHasAppInput;
+    }
+
+    virtual int ChannelMask2ChannelConfig(audio_channel_mask_t channel_mask);
+    virtual int ChannelMask2LFEConfig(audio_channel_mask_t channel_mask);
 
     //*Begin||Add the APT to set the params*//
     //Functional Switches
@@ -142,13 +184,17 @@ public:
     {
         mDRCCutStereo = val;
     }
-    virtual void setChannelConfigOfAppSoundsInput(audio_channel_mask_t channel_mask)
+    virtual void setChannelMaskOfAppSoundsInput(audio_channel_mask_t channel_mask)
+    {
+        mDolbyMS12OutChannelMask[MS12_INPUT_APP] = channel_mask;
+    }
+    virtual void setChannelMaskOfSystemSoundsInput(audio_channel_mask_t channel_mask)
     {
-        mChannelConfAppSoundsIn = APPSoundChannelMaskConvertToChannelConfiguration(channel_mask);
+        mDolbyMS12OutChannelMask[MS12_INPUT_SYSTEM] = channel_mask;
     }
-    virtual void setChannelConfigOfSystemSoundsInput(audio_channel_mask_t channel_mask)
+    virtual void setChannelMaskOfUiSoundsInput(audio_channel_mask_t channel_mask)
     {
-        mChannelConfSystemIn = SystemSoundChannelMaskConvertToChannelConfiguration(channel_mask);
+        mDolbyMS12OutChannelMask[MS12_INPUT_UI] = channel_mask;
     }
     virtual void setDAPV2InitialisationMode(int val)
     {
@@ -174,10 +220,6 @@ public:
     {
         mEvaluationMode = val;    // 0 or 1
     }
-    virtual void setLFEpresentInAPPSoundsIn(int val)
-    {
-        mLFEPresentInAppSoundIn = val;    // 0 or 1
-    }
     virtual void setLFEpresetInSystemSoundsIn(int val)
     {
         mLFEPresentInSystemSoundIn = val;    // 0 or 1
@@ -308,14 +350,6 @@ public:
     }
 
     //PCM SWITCHES
-    virtual void setChnanelConfOfExternalPCMInput(audio_channel_mask_t channel_mask)
-    {
-        mChannelConfigInExtPCMInput = APPSoundChannelMaskConvertToChannelConfiguration(channel_mask);
-    }
-    virtual void setLFEpresentInExternalPCMInput(int val)
-    {
-        mLFEPresentInExtPCMInput = val;
-    }
     virtual void setPCMCompressorProfile(int val)
     {
         mCompressorProfile = val;
@@ -354,6 +388,10 @@ public:
             memcpy(&DeviceDAPSurroundVirtualizer, dapVirtualizerParamters, sizeof(DeviceDAPSurroundVirtualizer));
         }
     }
+    virtual int getDAPSurroundVirtualizer(void)
+    {
+        return DeviceDAPSurroundVirtualizer.virtualizer_enable;
+    }
     virtual void setDAPGraphicEQ(DAPGraphicEQ *dapGraphicEQParamters)
     {
         if (dapGraphicEQParamters) {
@@ -399,6 +437,17 @@ public:
         }
     }
 
+    virtual void setDualOutputFlag(bool need_dual_output)
+    {
+        mDualOutputFlag = need_dual_output;
+        ALOGI("%s() set mDualOutputFlag %d", __FUNCTION__, mDualOutputFlag);
+    }
+
+    virtual bool getDualOutputFlag(void)
+    {
+        return mDualOutputFlag;
+    }
+
     /*OTT Processing Graph Begin*/
     virtual int SetOTTProcessingGraphSwitches(char **ConfigParams, int *row_index);
 
@@ -458,7 +507,7 @@ public:
     virtual void setDolbyMain2NameAsDummy(bool is_dummy)
     {
         if (is_dummy) {
-            memcpy(mDolbyMain2FileName, DEFAULT_DUMMY_DDP_FILE_NAME, sizeof(DEFAULT_DUMMY_DDP_FILE_NAME));
+            memcpy(mDolbyMain2FileName, DEFAULT_DUMMY2_DDP_FILE_NAME, sizeof(DEFAULT_DUMMY_DDP_FILE_NAME));
         } else {
             memcpy(mDolbyMain2FileName, DEFAULT_MAIN2_DDP_FILE_NAME, sizeof(DEFAULT_MAIN2_DDP_FILE_NAME));
         }
@@ -482,6 +531,39 @@ public:
     }
     /*OTT Processing Graph End*/
 
+    virtual void setLegacyDDPOut(bool isLegacyDDPOut)
+    {
+        mIsLegecyDDPOut = isLegacyDDPOut;
+        ALOGI("%s() mIsLegecyDDPOut %d\n", __FUNCTION__, mIsLegecyDDPOut);
+    }
+
+    virtual bool getLegacyDDPOut(void)
+    {
+        return mIsLegecyDDPOut;
+    }
+
+    virtual void setInputCMDMask(const char *input_cmd);
+
+    virtual int getInputCMDMask(void)
+    {
+        return mDolbyInputCMDMask;
+    }
+
+    virtual bool isAssociatedAudioControlSuitable(void)
+    {
+        int curMask = getInputCMDMask();
+        int ddp_dual_input = MS12_INPUT_MASK_MAIN_DDP|MS12_INPUT_MASK_ASSOCIATE;
+
+        bool is_ac4_single = ((curMask & MS12_INPUT_MASK_MAIN_AC4) == MS12_INPUT_MASK_MAIN_AC4);
+        bool is_ddp_dual_input = ((curMask & ddp_dual_input) == ddp_dual_input);
+
+        if (is_ac4_single || is_ddp_dual_input)
+            return true;
+        else
+            return false;
+    }
+
+
     //*End||Add the APT to set the params*//
 
 
@@ -495,21 +577,17 @@ private:
     // DolbyMS12ConfigParams& operator = (const DolbyMS12ConfigParams&);
     // static DolbyMS12ConfigParams *gInstance;
     // static android::Mutex mLock;
-    static std::mutex mLock;
     // audio_devices_t mAudioSteamOutDevices;
     int mParamNum;
 
     //dolby ms12 input
     audio_output_flags_t mAudioOutFlags;
     audio_format_t mAudioStreamOutFormat;
-    audio_channel_mask_t mAudioStreamOutChannelMask;
-    int mAudioSteamOutSampleRate;
+    audio_channel_mask_t mDolbyMS12OutChannelMask[MS12_INPUT_MAX];
 
     //dolby ms12 output
-
     int mDolbyMS12OutConfig;
     int mDolbyMS12OutSampleRate;
-    audio_channel_mask_t mDolbyMS12OutChannelMask;
     char **mConfigParams;//[MAX_ARGC][MAX_ARGV_STRING_LEN];
 
 
@@ -519,8 +597,6 @@ private:
     int mDRCCut;
     int mDRCBoostStereo;
     int mDRCCutStereo;
-    int mChannelConfAppSoundsIn;
-    int mChannelConfSystemIn;
     bool mMainFlags;//has dd/ddp/he-aac audio
     bool mAppSoundFlags;
     bool mSystemSoundFlags;
@@ -531,7 +607,6 @@ private:
     int mDAPDRCMode;//for multi-ch and dap output[default is 0]
     int mDownmixMode;//Lt/Rt[val=0, default] or Lo/Ro
     int mEvaluationMode;//default is 0
-    int mLFEPresentInAppSoundIn;//default is 1[means on]
     int mLFEPresentInSystemSoundIn;//default is 0[means off]
     int mDonwnmix71PCMto51;//default 0[means off]
     int mLockingChannelModeENC;//0 default, auto; 1 locked as 5.1 channel mode.
@@ -573,10 +648,14 @@ private:
     //DDPLUS SWITCHES
 
     //PCM SWITCHES
-    int mChannelConfigInExtPCMInput;//Channel configuration of external PCM input, default is 7;
-    bool mLFEPresentInExtPCMInput = true;//LFE present in external PCM input
     int mCompressorProfile;//[pcm] Compressor profile
 
+    //HE-AAC SWITCHES
+    int mAssocInstanse;//[he-aac] Associated instance restricted to 2 channels
+    int mDefDialnormVal;//[he-aac] Default dialnorm value (dB/4),  0 - 127; Default = 108 (-27dB)
+    int mDualMonoreproductionMode;//[he-aac] Dual-mono reproduction mode, 0:Stereo(default), 1:Left/first, 2:Right/second
+    int mAribChannelMappingFlag;//[he-aac] ARIB channel mapping flag, 0:standard(default), 1:ARIB (w/o attenuation)
+
     //AC4 SWITCHES
     char mAC4Lang[4];
     char mAC4Lang2[4];
@@ -586,18 +665,13 @@ private:
     int mAC4De;//[ac4] Dialogue Enhancement gain [0-12], default 0
     int mAC4ShortProgId;//[ac4] The short program identifier as 16 bit unsigned value or -1 for no program (default)
 
-    //HE-AAC SWITCHES
-    int mAssocInstanse;//[he-aac] Associated instance restricted to 2 channels
-    int mDefDialnormVal;//[he-aac] Default dialnorm value (dB/4),  0 - 127; Default = 108 (-27dB)
-    int mDualMonoreproductionMode;//[he-aac] Dual-mono reproduction mode, 0:Stereo(default), 1:Left/first, 2:Right/second
-    int mAribChannelMappingFlag;//[he-aac] ARIB channel mapping flag, 0:standard(default), 1:ARIB (w/o attenuation)
-
     //DAP SWITCHES (device specific)
     const char *mDAPTuningFile;
     int mDAPGains = 0;//postgain (-2080...480, def: 0)
     bool mDAPSurDecEnable = true;//DAP surround decoder enable flag (Default 1)
     bool mHasAssociateInput = false;
     bool mHasSystemInput = false;
+    bool mHasAppInput = false;
     DAPSurroundVirtualizer DeviceDAPSurroundVirtualizer = {
         .virtualizer_enable = 1,
         .surround_boost = 96,
@@ -645,9 +719,9 @@ private:
         .de_amount = 0,
     };
 
+    bool mDualOutputFlag;
+
     bool mActivateOTTSignal;
-    int mChannelConfOTTSoundsIn;
-    int mLFEPresentInOTTSoundIn;
     bool mAtmosLock;
     bool mPause;
 
@@ -661,6 +735,8 @@ private:
         .duration = 0,
         .shape = 0,
     };//System sound mixer gain values for System Sounds input
+    bool mIsLegecyDDPOut;
+    int mDolbyInputCMDMask;
 }; //class DolbyMS12ConfigParams
 
 
diff --git a/libms12v2/include/DolbyMS12Status.h b/libms12v2/include/DolbyMS12Status.h
index 6ea61e5..86be15e 100644
--- a/libms12v2/include/DolbyMS12Status.h
+++ b/libms12v2/include/DolbyMS12Status.h
@@ -152,6 +152,17 @@ public:
      */
     virtual audio_format_t getAudioSystemFormat(void);
 
+    /*
+     *@brief set Audio Hal App format
+     */
+    virtual void setAudioAppFormat(audio_format_t format);
+
+    /*
+     *@brief get Audio Hal App format
+     */
+    virtual audio_format_t getAudioAppFormat(void);
+
+
     /*
      *@brief set dd support flag
      */
@@ -232,6 +243,7 @@ private:
     audio_format_t mAudioMainFormat;
     audio_format_t mAudioAssociateFormat;
     audio_format_t mAudioSystemFormat;
+    audio_format_t mAudioAppFormat;
 
     //for dd(ac3) support
     bool mDDSupportFlag;
diff --git a/libms12v2/include/aml_audio_ms12.h b/libms12v2/include/aml_audio_ms12.h
index a73a202..13dc506 100644
--- a/libms12v2/include/aml_audio_ms12.h
+++ b/libms12v2/include/aml_audio_ms12.h
@@ -20,6 +20,7 @@
 #include "dolby_ms12_status.h"
 #include <system/audio.h>
 #include <time.h>
+#include "aml_ringbuffer.h"
 
 
 
@@ -65,6 +66,7 @@ struct dolby_ms12_desc {
     int device;//alsa_device_t
     struct timespec timestamp; //zzz
     uint64_t last_frames_postion;
+    uint64_t last_ms12_pcm_out_position;
     /*
     latency frame is maintained by the whole device output.
     whatever what bistream is outputed we need use this latency frames.
@@ -82,6 +84,28 @@ struct dolby_ms12_desc {
     int bitsteam_cnt;
     void * main_virtual_buf_handle;
     void * system_virtual_buf_handle;
+    ring_buffer_t spdif_ring_buffer;
+    unsigned char *lpcm_temp_buffer;
+
+    /*
+     *-ac4_de             * <int> [ac4] Dialogue Enhancement gain that will be applied in the decoder
+     *                      Range: 0 to 12 dB (in 1 dB steps, default is 0 dB)
+     */
+    int ac4_de;
+    int nbytes_of_dmx_output_pcm_frame;
+    void * ac3_parser_handle;
+    int hdmi_format;
+    audio_format_t  optical_format;
+    struct timespec  sys_audio_timestamp;
+    uint64_t  sys_audio_frame_pos;
+    uint64_t  sys_audio_base_pos;
+    uint64_t  last_sys_audio_cost_pos;
+    /*ms12 main input information */
+    audio_format_t main_input_fmt;
+    unsigned int   main_input_sr;
+    void * ms12_bypass_handle;
+    bool   is_bypass_ms12;
+    int    atmos_info_change_cnt;
 };
 
 /*
diff --git a/libms12v2/include/dolby_ms12.h b/libms12v2/include/dolby_ms12.h
index 1cfefe1..35b1799 100644
--- a/libms12v2/include/dolby_ms12.h
+++ b/libms12v2/include/dolby_ms12.h
@@ -26,7 +26,7 @@ extern "C" {
 #include <stddef.h>
 
 
-//get the handle of dlopen "/system/lib/libdolbyms12.so"
+//get the handle of dlopen "/vendor/lib/libdolbyms12.so"
 int get_libdolbyms12_handle(void);
 
 //release the handle of dlopen
@@ -109,6 +109,13 @@ int dolby_ms12_input_system(void *dolby_mS12_pointer
                             , int audio_stream_out_channel_num
                             , int audio_stream_out_sample_rate);
 
+int dolby_ms12_input_app(void *dolby_mS12_pointer
+                            , const void *audio_stream_out_buffer
+                            , size_t audio_stream_out_buffer_size
+                            , int audio_stream_out_format
+                            , int audio_stream_out_channel_num
+                            , int audio_stream_out_sample_rate);
+
 
 #ifdef REPLACE_OUTPUT_BUFFER_WITH_CALLBACK
 
@@ -119,6 +126,7 @@ int dolby_ms12_input_system(void *dolby_mS12_pointer
     @void *priv_data //priv data
 */
 int dolby_ms12_register_output_callback(void *callback, void *priv_data);
+
 #else
 /*@@
     @brief Get output data
@@ -172,10 +180,14 @@ int dolby_ms12_set_quit_flag(int is_quit);
 void dolby_ms12_flush_input_buffer(void);
 
 void dolby_ms12_flush_main_input_buffer(void);
+
+void dolby_ms12_flush_app_input_buffer(void);
+
 /*@@
-    @brief get the n bytes consumed of payload(OTT audio or DD/DD+ stream)
+    @brief get the n bytes consumed by ms12 decoder
 */
-unsigned long long dolby_ms12_get_consumed_payload(void);
+unsigned long long dolby_ms12_get_decoder_n_bytes_consumed(void *ms12_pointer, int format, int is_main);
+
 
 /*@@
     @brief get the pcm output size
@@ -218,6 +230,35 @@ int dolby_ms12_get_gain(int idx);
 */
 int dolby_ms12_get_input_atmos_info();
 
+
+/*@@
+    @brief set the main audio volume
+*/
+int dolby_ms12_set_main_volume(float volume);
+
+/*@@
+    @brief get PCM's nframes which outputed by decoder
+*/
+unsigned long long dolby_ms12_get_decoder_nframes_pcm_output(void *ms12_pointer, int format, int is_main);
+
+
+/*@@
+    @brief set dolby-ms12's debug level
+*/
+void dolby_ms12_set_debug_level(int level);
+
+/*@@
+    @brief get the sys consumed size
+*/
+unsigned long long dolby_ms12_get_consumed_sys_audio();
+
+/*@@
+    @brief get the total delay(which means frame nums)
+*/
+
+int dolby_ms12_get_total_nframes_delay(void *ms12_pointer);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/libms12v2/include/dolby_ms12_config_params.h b/libms12v2/include/dolby_ms12_config_params.h
index 4717627..0b4ff5f 100644
--- a/libms12v2/include/dolby_ms12_config_params.h
+++ b/libms12v2/include/dolby_ms12_config_params.h
@@ -45,6 +45,16 @@ void dolby_ms12_config_params_set_system_flag(bool flag);
  */
 bool dolby_ms12_config_params_get_system_flag(void);
 
+/**
+ * @brief Set app flag
+ */
+void dolby_ms12_config_params_set_app_flag(bool flag);
+
+/**
+ * @brief Get app flag
+ */
+bool dolby_ms12_config_params_get_app_flag(void);
+
 /**
  * @brief Set input&output parameters
 
@@ -61,6 +71,27 @@ void dolby_ms12_config_params_set_audio_stream_out_params(
     , int sample_rate
     , int output_config);
 
+/**
+ * @brief Set channel mask for application sound input
+ *
+ * @mask channel mask to set
+ */
+void dolby_ms12_config_params_set_channel_mask_app(audio_channel_mask_t mask);
+
+/**
+ * @brief Set channel mask for system sound input
+ *
+ * @mask channel mask to set
+ */
+void dolby_ms12_config_params_set_channel_mask_system(audio_channel_mask_t mask);
+
+/**
+ * @brief Set channel mask for UI(OTT) sound input
+ *
+ * @mask channel mask to set
+ */
+void dolby_ms12_config_params_set_channel_mask_ui(audio_channel_mask_t mask);
+
 // /*config params begin*/
 // /**/
 // int dolby_ms12_config_params_set_input_output_file_name(char **ConfigParams, int *row_index);
@@ -73,6 +104,14 @@ void dolby_ms12_config_params_set_audio_stream_out_params(
 // int dolby_ms12_config_params_set_dap_content_switches(char **ConfigParams, int *row_index);
 // /*config params end*/
 
+/**
+ * @brief Get MS12 DAP runtime parameters
+ * @key query dap parameter name
+ *
+ * @return an allocated string for settings
+ */
+char *dolby_ms12_query_dap_parameters(const char *key);
+
 /**
  * @brief Get the dolby_ms12_init() input params
  * @int *argc //dolby_ms12_init *argc
@@ -169,12 +208,17 @@ void dolby_ms12_set_drc_cut_stereo(int val);
 /**
  * @brief Channel configuration of Application Sounds input
  */
-void dolby_ms12_set_channel_config_of_app_sound_input(audio_channel_mask_t channel_mask);
+void dolby_ms12_set_channel_mask_of_app_sound_input(audio_channel_mask_t channel_mask);
 
 /**
  * @brief Channel configuration of System Sounds input
  */
-void dolby_ms12_set_channel_config_of_system_sound_input(audio_channel_mask_t channel_mask);
+void dolby_ms12_set_channel_mask_of_system_sound_input(audio_channel_mask_t channel_mask);
+
+/**
+ * @brief Channel configuration of UI(OTT) Sounds input
+ */
+void dolby_ms12_set_channel_mask_of_ui_sound_input(audio_channel_mask_t channel_mask);
 
 /**
  * @brief DAPv2 initialisation mode
@@ -222,20 +266,6 @@ void dolby_ms12_set_downmix_modes(int val);
  */
 void dolby_ms12_set_evalution_mode(int val);
 
-/**
- * @brief LFE present in Application Sounds input
- * 0 = off
- * 1 = on (default)
- */
-void dolby_ms12_set_lfe_present_in_app_sounds_in(int val);
-
-/**
- * @brief LFE present in System Sounds input
- * 0 = off
- * 1 = on (default)
- */
-void dolby_ms12_set_lfe_present_in_system_sounds_in(int val);
-
 /**
  * @brief Downmix 7.1 PCM signal to 5.1 on the multichannel outputs
  * 0 = off(default)
@@ -387,23 +417,6 @@ void dolby_ms12_set_ac4_de(int val);
 void dolby_ms12_set_ac4_shortprogid(int val);
 
 //PCM SWITCHES
-/**
- * @brief Channel configuration of external PCM input
- * 0 = reserved
- * 1 = 1/0 (C)
- * 2 = 2/0 (L, R)
- * 7 = 3/2 (L, C, R, l, r) (default)
- * 21 = 3/2/2 (L, C, R, l, r, Lrs, Rrs)
- */
-void dolby_ms12_set_channel_config_of_external_pcm_input(int val);
-
-/**
- * @brief LFE present in external PCM input
- * 0 = off
- * 1 = on (default)
- */
-void dolby_ms12_set_lfe_present_in_external_pcm_input(int val);
-
 /**
  * @brief [pcm] Compressor profile
  * 0 [clipping protection only]
@@ -441,6 +454,7 @@ void dolby_ms12_set_heaac_dualmono_reproduction_mode(int val);
  * @brief [he-aac] Set ARIB channel mapping flag
  * 0 = Standard channel mapping (Default)
  * 1 = ARIB channel mapping (without attenuation)
+ *
  */
 void dolby_ms12_set_heaac_arib_channel_mapping_flag(int val);
 
@@ -467,6 +481,12 @@ void dolby_ms12_set_dap_surround_decoder_enable(bool val);
  */
 void dolby_ms12_set_dap_surround_virtuallizer(DAPSurroundVirtualizer *dapVirtualizerParamters);
 
+/**
+ * @brief Virtualizer Parameter
+ * - virtualizer_enable (0,1, def: 1)
+ */
+int dolby_ms12_get_dap_surround_virtuallizer(void);
+
 /**
  * @brief dap graphic eq
  * - eq_enable (0,1, def: 0)
@@ -511,9 +531,8 @@ void dolby_ms12_set_dap_mi_streering(DAPMISteering *dapMiSteeringParamters);
 
 /**
  * @brief dap leveler
- * - leveler_enable (0,1, def: 0)
- * - leveler_amount (0...10, def: 7)
- * - leveler_ignore_il (0, 1, def: 0)
+ * - leveler_enable (0,1,2, def: 0)
+ * - leveler_amount (0...10, def: 4)
  */
 void dolby_ms12_set_dap_leveler(DAPLeveler *dapLevelerParameters);
 
@@ -607,6 +626,25 @@ void dolby_ms12_set_ott_sound_input_enable(bool flag);
  * @brief get ott sound input enable
  */
 bool dolby_ms12_get_ott_sound_input_enable(void);
+
+/**
+ * @brief set the ms12 ddp(5.1) out parameter
+ *-legacy_ddplus_out  <int>   Downmix Atmos signals rendered from 5.1.2 to 5.1
+ *                            before reencoding to Dolby Digital Plus to connect legacy AVRs.
+ *                            In case of AC-4 or Dolby Digital Plus input,
+ *                            the decoder is configured to directly output 5.1 to save computational complexity.
+ *                            0 = off (default) (output 5.1.2 DDP with Atmos)
+ *                            1 = on (output 5.1 DDP)
+ */
+void dolby_ms12_set_ddp_5_1_out(bool flag);
+
+/**
+ * @brief get the status of ms12 out ddp(5.1)
+ *        return true  when OUT ddp(5.1)
+ *               false when OUT ddp-atmos(5.1.2)
+ */
+bool dolby_ms12_get_ddp_5_1_out(void);
+
 /*End*/
 
 #ifdef __cplusplus
diff --git a/libms12v2/include/dolby_ms12_input_mask.h b/libms12v2/include/dolby_ms12_input_mask.h
new file mode 100644
index 0000000..fe21346
--- /dev/null
+++ b/libms12v2/include/dolby_ms12_input_mask.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DOLBY_MS12_INPUT_MASK_H_
+#define DOLBY_MS12_INPUT_MASK_H_
+
+/*
+ *-im  *           <str>  Main program input filename [REQUIRED]
+ *-im2 *           <str>  2nd Main program input filename
+ *-iui *           <str>  UI sounds input filename
+ *-ia              <str>  Associated program input filename
+ *-is              <str>  System Sounds input filename
+ *-ias             <str>  Application Sounds input filename
+ *-it              <str>  Use case input type (DDP|AAC|AC4|PCM|MAT|MLP)
+ *                        default: derived from -im filename extension
+ *                       can be used to select the codec in mp4 container files
+ */
+#define MS12_INPUT_MASK_MAIN_DDP            0x0001 /*dolby format as main input*/
+#define MS12_INPUT_MASK_MAIN2               0x0002
+#define MS12_INPUT_MASK_UI_SOUND            0x0004
+#define MS12_INPUT_MASK_ASSOCIATE           0x0008
+#define MS12_INPUT_MASK_SYSTEM              0x0010
+#define MS12_INPUT_MASK_INPUT_TYPE          0x0020
+#define MS12_INPUT_MASK_MAIN_PCM            0x0040 /*pcm format as main inut, such as pcm&hdmi-in*/
+#define MS12_INPUT_MASK_MAIN_AC4            0x0080
+#define MS12_INPUT_MASK_MAIN_MAT            0x0100
+#define MS12_INPUT_MASK_MAIN_MLP            0x0200
+#define MS12_INPUT_MASK_MAIN_HEAAC          0x0400
+
+
+
+#endif
+
diff --git a/libms12v2/include/dolby_ms12_status.h b/libms12v2/include/dolby_ms12_status.h
index 5a1fab5..b57ae7d 100644
--- a/libms12v2/include/dolby_ms12_status.h
+++ b/libms12v2/include/dolby_ms12_status.h
@@ -89,6 +89,17 @@ void set_audio_system_format(audio_format_t format);
  */
 audio_format_t get_audio_system_format(void);
 
+/*
+ *@brief set Audio Hal App format
+ */
+void set_audio_app_format(audio_format_t format);
+
+/*
+ *@brief get Audio Hal App format
+ */
+audio_format_t get_audio_app_format(void);
+
+
 /*
  *@brief set TV audio main format
  */
diff --git a/libms12v2/src/DolbyMS12.cpp b/libms12v2/src/DolbyMS12.cpp
index 66c4032..3291df1 100644
--- a/libms12v2/src/DolbyMS12.cpp
+++ b/libms12v2/src/DolbyMS12.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12v2"
+#define LOG_TAG "libms12"
 //#define LOG_NDEBUG 0
 //#define LOG_NALOGV 0
 
@@ -28,8 +28,7 @@
 #include "DolbyMS12.h"
 #include "DolbyMS12ConfigParams.h"
 
-#define DOLBY_MS12_LIB_PATH_A "/vendor/lib/libdolbyms12.so"
-#define DOLBY_MS12_LIB_PATH_B "/system/vendor/lib/libdolbyms12.so"
+#define DOLBY_MS12_LIB_PATH "/vendor/lib/libdolbyms12.so"
 
 namespace android
 {
@@ -41,6 +40,7 @@ void (*FuncDolbyMS12Release)(void *);
 int (*FuncDolbyMS12InputMain)(void *, const void *, size_t, int, int, int);
 int (*FuncDolbyMS12InputAssociate)(void *, const void *, size_t, int, int, int);
 int (*FuncDolbyMS12InputSystem)(void *, const void *, size_t, int, int, int);
+int (*FuncDolbyMS12InputApp)(void *, const void *, size_t, int, int, int);
 
 #ifdef REPLACE_OUTPUT_BUFFER_WITH_CALLBACK
 int (*FuncDolbyMS12RegisterOutputCallback)(output_callback , void *);
@@ -54,9 +54,10 @@ int (*FuncDolbyMS12SchedulerRun)(void *);
 void (*FuncDolbyMS12SetQuitFlag)(int);
 void (*FuncDolbyMS12FlushInputBuffer)(void);
 void (*FuncDolbyMS12FlushMainInputBuffer)(void);
+void (*FuncDolbyMS12FlushAppInputBuffer)(void);
 void (*FuncDolbyMS12SetMainDummy)(int, int);
-unsigned long long (*FuncDolbyMS12GetNBytesConsumedOfUDC)(void);
-unsigned long long (*FuncDolbyMS12GetNBytesPcmOutOfUDC)(void);
+unsigned long long (*FuncDolbyMS12GetNBytesConsumed)(void *, int, int);
+unsigned long long (*FuncDolbyMS12GetNFramesPCMOutput)(void *, int, int);
 void (*FuncDolbyMS12GetPCMOutputSize)(unsigned long long *, unsigned long long *);
 void (*FuncDolbyMS12GetBitstreamOutputSize)(unsigned long long *, unsigned long long *);
 
@@ -65,8 +66,11 @@ int (*FuncDolbyMS12GetAssociateBufferAvail)(void);
 int (*FuncDolbyMS12GetSystemBufferAvail)(int *);
 
 int (*FuncDolbyMS12GetGain)(int);
+int (*FuncDolbyMS12Config)(ms12_config_type_t, ms12_config_t *);
 int (*FuncDolbyMS12GetAudioInfo)(struct aml_audio_info *);
-
+void (*FuncDolbyMS12SetDebugLevel)(int);
+unsigned long long (*FuncDolbyMS12GetNBytesConsumedSysSound)(void);
+int (*FuncDolbyMS12GetTotalNFramesDelay)(void *);
 
 DolbyMS12::DolbyMS12() :
     mDolbyMS12LibHanle(NULL)
@@ -86,14 +90,10 @@ int DolbyMS12::GetLibHandle(void)
     ALOGD("+%s()", __FUNCTION__);
     //ReleaseLibHandle();
 
-    //here there are two paths, "the DOLBY_MS12_LIB_PATH_A/B", where could exit that dolby ms12 libary.
-    mDolbyMS12LibHanle = dlopen(DOLBY_MS12_LIB_PATH_A, RTLD_NOW);
+    mDolbyMS12LibHanle = dlopen(DOLBY_MS12_LIB_PATH, RTLD_NOW);
     if (!mDolbyMS12LibHanle) {
-        mDolbyMS12LibHanle = dlopen(DOLBY_MS12_LIB_PATH_B, RTLD_NOW);
-        if (!mDolbyMS12LibHanle) {
-            ALOGE("%s, failed to load libdolbyms12 lib %s\n", __FUNCTION__, dlerror());
-            goto ERROR;
-        }
+        ALOGE("%s, failed to load libdolbyms12 lib %s\n", __FUNCTION__, dlerror());
+        goto ERROR;
     }
 
     FuncGetMS12OutputMaxSize = (int (*)(void)) dlsym(mDolbyMS12LibHanle, "get_ms12_output_max_size");
@@ -132,10 +132,22 @@ int DolbyMS12::GetLibHandle(void)
         goto ERROR;
     }
 
+    FuncDolbyMS12InputApp = (int (*)(void *, const void *, size_t, int, int, int)) dlsym(mDolbyMS12LibHanle, "ms12_input_app");
+    if (!FuncDolbyMS12InputApp) {
+        ALOGE("%s, dlsym ms12_input_app fail\n", __FUNCTION__);
+        goto ERROR;
+    }
+
+    FuncDolbyMS12FlushAppInputBuffer = (void (*)(void))  dlsym(mDolbyMS12LibHanle, "ms12_flush_app_input_buffer");
+    if (!FuncDolbyMS12FlushAppInputBuffer) {
+        ALOGE("%s, dlsym FuncDolbyMS12FlushAppInputBuffer fail\n", __FUNCTION__);
+        goto ERROR;
+    }
+
 #ifdef REPLACE_OUTPUT_BUFFER_WITH_CALLBACK
     FuncDolbyMS12RegisterOutputCallback = (int (*)(output_callback , void *)) dlsym(mDolbyMS12LibHanle, "ms12_register_output_callback");
     if (!FuncDolbyMS12RegisterOutputCallback) {
-        ALOGE("%s, dlsym ms12_register_output_callback fail\n", __FUNCTION__);
+        ALOGE("%s, dlsym ms12_output_register_output_callback fail\n", __FUNCTION__);
         goto ERROR;
     }
 #else
@@ -180,14 +192,20 @@ int DolbyMS12::GetLibHandle(void)
         ALOGE("%s, dlsym ms12_flush_main_input_buffer fail\n", __FUNCTION__);
         goto ERROR;
     }
+    FuncDolbyMS12FlushAppInputBuffer = (void (*)(void))  dlsym(mDolbyMS12LibHanle, "ms12_flush_app_input_buffer");
+    if (!FuncDolbyMS12FlushAppInputBuffer) {
+        ALOGE("%s, dlsym FuncDolbyMS12FlushAppInputBuffer fail\n", __FUNCTION__);
+        goto ERROR;
+    }
     FuncDolbyMS12SetMainDummy = (void (*)(int, int))  dlsym(mDolbyMS12LibHanle, "ms12_set_main_dummy");
     if (!FuncDolbyMS12SetMainDummy) {
         ALOGE("%s, dlsym ms12_set_main_dummy fail\n", __FUNCTION__);
         goto ERROR;
     }
-    FuncDolbyMS12GetNBytesConsumedOfUDC = (unsigned long long (*)(void))  dlsym(mDolbyMS12LibHanle, "get_n_bytes_consumed_of_udc");
-    if (!FuncDolbyMS12GetNBytesConsumedOfUDC) {
-        ALOGE("%s, dlsym get_n_bytes_consumed_of_udc fail\n", __FUNCTION__);
+
+    FuncDolbyMS12GetNBytesConsumed = (unsigned long long (*)(void *, int, int))  dlsym(mDolbyMS12LibHanle, "get_decoder_n_bytes_consumed");
+    if (!FuncDolbyMS12GetNBytesConsumed) {
+        ALOGE("%s, dlsym get_decoder_n_bytes_consumed fail\n", __FUNCTION__);
         goto ERROR;
     }
 
@@ -227,12 +245,37 @@ int DolbyMS12::GetLibHandle(void)
         goto ERROR;
     }
 
+    FuncDolbyMS12Config = (int (*)(ms12_config_type_t, ms12_config_t *))  dlsym(mDolbyMS12LibHanle, "ms12_audio_config");
+    if (!FuncDolbyMS12Config) {
+        ALOGE("%s, dlsym ms12_audio_config\n", __FUNCTION__);
+    }
+
     FuncDolbyMS12GetAudioInfo = (int (*)(struct aml_audio_info *))  dlsym(mDolbyMS12LibHanle, "get_audio_info");
     if (!FuncDolbyMS12GetAudioInfo) {
         ALOGE("%s, dlsym get_audio_info fail\n", __FUNCTION__);
         goto ERROR;
     }
 
+    FuncDolbyMS12GetNFramesPCMOutput = (unsigned long long (*)(void *, int, int))  dlsym(mDolbyMS12LibHanle, "get_decoder_n_frames_pcm_output");
+    if (!FuncDolbyMS12GetNFramesPCMOutput) {
+        ALOGE("%s, dlsym get_decoder_nframes_pcm_output fail\n", __FUNCTION__);
+    }
+
+    FuncDolbyMS12SetDebugLevel = (void (*)(int))  dlsym(mDolbyMS12LibHanle, "set_dolbyms12_debug_level");
+    if (!FuncDolbyMS12SetDebugLevel) {
+        ALOGE("%s, dlsym get_system_buffer_avail fail\n", __FUNCTION__);
+    }
+
+    FuncDolbyMS12GetNBytesConsumedSysSound= (unsigned long long (*)(void))  dlsym(mDolbyMS12LibHanle, "get_n_bytes_consumed_of_sys_sound");
+    if (!FuncDolbyMS12GetNBytesConsumedSysSound) {
+        ALOGW("%s, dlsym FuncDolbyMS12GetNBytesConsumedSysSound fail,ingore it as version difference\n", __FUNCTION__);
+    }
+
+    FuncDolbyMS12GetTotalNFramesDelay= (int (*)(void *))  dlsym(mDolbyMS12LibHanle, "get_ms12_total_nframes_delay");
+    if (!FuncDolbyMS12GetTotalNFramesDelay) {
+        ALOGW("%s, dlsym get_ms12_total_delay fail, ingore it as version difference\n", __FUNCTION__);
+    }
+
     ALOGD("-%s() line %d get libdolbyms12 success!", __FUNCTION__, __LINE__);
     return 0;
 
@@ -261,14 +304,19 @@ void DolbyMS12::ReleaseLibHandle(void)
     FuncDolbyMS12SchedulerRun = NULL;
     FuncDolbyMS12SetQuitFlag = NULL;
     FuncDolbyMS12FlushInputBuffer = NULL;
-    FuncDolbyMS12GetNBytesConsumedOfUDC = NULL;
+    FuncDolbyMS12GetNBytesConsumed = NULL;
     FuncDolbyMS12GetPCMOutputSize = NULL;
     FuncDolbyMS12GetBitstreamOutputSize = NULL;
     FuncDolbyMS12GetMainBufferAvail = NULL;
     FuncDolbyMS12GetAssociateBufferAvail = NULL;
     FuncDolbyMS12GetSystemBufferAvail = NULL;
     FuncDolbyMS12SetMainDummy = NULL;
+    FuncDolbyMS12Config = NULL;
     FuncDolbyMS12GetAudioInfo = NULL;
+    FuncDolbyMS12GetNFramesPCMOutput = NULL;
+    FuncDolbyMS12SetDebugLevel = NULL;
+    FuncDolbyMS12GetNBytesConsumedSysSound = NULL;
+    FuncDolbyMS12GetTotalNFramesDelay = NULL;
 
     if (mDolbyMS12LibHanle != NULL) {
         dlclose(mDolbyMS12LibHanle);
@@ -402,6 +450,34 @@ int DolbyMS12::DolbyMS12InputSystem(
     return ret;
 }
 
+int DolbyMS12::DolbyMS12InputApp(
+    void *DolbyMS12Pointer
+    , const void *audio_stream_out_buffer //ms12 input buffer
+    , size_t audio_stream_out_buffer_size //ms12 input buffer size
+    , int audio_stream_out_format
+    , int audio_stream_out_channel_num
+    , int audio_stream_out_sample_rate
+)
+{
+    ALOGV("+%s()", __FUNCTION__);
+    int ret = 0;
+
+    if (!FuncDolbyMS12InputApp) {
+        ALOGE("%s(), pls load lib first.\n", __FUNCTION__);
+        return -1;
+    }
+
+    ret = (*FuncDolbyMS12InputApp)(DolbyMS12Pointer
+                                      , audio_stream_out_buffer //ms12 input buffer
+                                      , audio_stream_out_buffer_size //ms12 input buffer size
+                                      , audio_stream_out_format
+                                      , audio_stream_out_channel_num
+                                      , audio_stream_out_sample_rate);
+    ALOGV("-%s() ret %d", __FUNCTION__, ret);
+    return ret;
+}
+
+
 #ifdef REPLACE_OUTPUT_BUFFER_WITH_CALLBACK
 int DolbyMS12::DolbyMS12RegisterOutputCallback(output_callback callback, void *priv_data)
 {
@@ -412,7 +488,7 @@ int DolbyMS12::DolbyMS12RegisterOutputCallback(output_callback callback, void *p
         return -1;
     }
 
-    ret = (*FuncDolbyMS12RegisterOutputCallback)(callback , priv_data);
+    ret = (*FuncDolbyMS12RegisterOutputCallback)(callback, priv_data);
     ALOGV("-%s() ret %d", __FUNCTION__, ret);
     return ret;
 }
@@ -522,6 +598,20 @@ void DolbyMS12::DolbyMS12FlushMainInputBuffer(void)
     return ;
 }
 
+void DolbyMS12::DolbyMS12FlushAppInputBuffer(void)
+{
+    int ret = 0;
+    ALOGV("+%s()", __FUNCTION__);
+    if (!FuncDolbyMS12FlushAppInputBuffer) {
+        ALOGE("%s(), pls load lib first.\n", __FUNCTION__);
+        return ;
+    }
+
+    (*FuncDolbyMS12FlushAppInputBuffer)();
+    ALOGV("-%s() ret %d", __FUNCTION__, ret);
+    return ;
+}
+
 void DolbyMS12::DolbyMS12SetMainDummy(int type, int dummy)
 {
     int ret = 0;
@@ -536,16 +626,16 @@ void DolbyMS12::DolbyMS12SetMainDummy(int type, int dummy)
     return ;
 }
 
-unsigned long long DolbyMS12::DolbyMS12GetNBytesConsumedOfUDC(void)
+unsigned long long DolbyMS12::DolbyMS12GetDecoderNBytesConsumed(void *ms12_pointer, int format, int is_main)
 {
     unsigned long long ret = 0;
     ALOGV("+%s()", __FUNCTION__);
-    if (!FuncDolbyMS12GetNBytesConsumedOfUDC) {
+    if (!FuncDolbyMS12GetNBytesConsumed) {
         ALOGE("%s(), pls load lib first.\n", __FUNCTION__);
         return ret;
     }
 
-    ret = (*FuncDolbyMS12GetNBytesConsumedOfUDC)();
+    ret = (*FuncDolbyMS12GetNBytesConsumed)(ms12_pointer, format, is_main);
     ALOGV("-%s() ret %llu", __FUNCTION__, ret);
     return ret;
 }
@@ -638,6 +728,20 @@ int DolbyMS12::DolbyMS12GetSystemBufferAvail(int * max_size)
     return ret;
 }
 
+int DolbyMS12::DolbyMS12SetMainVolume(float volume)
+{
+    int ret = 0;
+    ALOGV("+%s()", __FUNCTION__);
+    if (!FuncDolbyMS12Config) {
+        ALOGE("%s(), pls load lib first.\n", __FUNCTION__);
+        return ret;
+    }
+
+    ret = (*FuncDolbyMS12Config)(MS12_CONFIG_MAIN_VOLUME, (ms12_config_t *)&volume);
+    ALOGV("-%s() ret %d", __FUNCTION__, ret);
+    return ret;
+}
+
 int DolbyMS12::DolbyMS12GetInputISDolbyAtmos()
 {
     int ret = 0;
@@ -649,9 +753,61 @@ int DolbyMS12::DolbyMS12GetInputISDolbyAtmos()
     }
 
     ret = (*FuncDolbyMS12GetAudioInfo)(&p_aml_audio_info);
-    ALOGV("-%s() ret %d", __FUNCTION__, ret);
+    ALOGV("-%s() ret %d atmos Detected %d", __FUNCTION__, ret, p_aml_audio_info.is_dolby_atmos);
     return p_aml_audio_info.is_dolby_atmos;
 }
 
+unsigned long long DolbyMS12::DolbyMS12GetDecoderNFramesPcmOutput(void *ms12_pointer, int format, int is_main)
+{
+    int ret = 0;
+    ALOGV("+%s()", __FUNCTION__);
+    if (!FuncDolbyMS12GetNFramesPCMOutput) {
+        ALOGE("%s(), pls load lib first.\n", __FUNCTION__);
+        return ret;
+    }
+
+    ret = (*FuncDolbyMS12GetNFramesPCMOutput)(ms12_pointer, format, is_main);
+    ALOGV("-%s() ret %d", __FUNCTION__, ret);
+    return ret;
+}
+
+void DolbyMS12::DolbyMS12SetDebugLevel(int level)
+{
+    ALOGV("+%s()", __FUNCTION__);
+    if (!FuncDolbyMS12SetDebugLevel) {
+        ALOGE("%s(), pls load lib first.\n", __FUNCTION__);
+    }
+    else
+        (*FuncDolbyMS12SetDebugLevel)(level);
+}
+
+unsigned long long DolbyMS12::DolbyMS12GetNBytesConsumedSysSound(void)
+{
+    unsigned long long ret = 0;
+    ALOGV("+%s()", __FUNCTION__);
+    if (!FuncDolbyMS12GetNBytesConsumedSysSound) {
+        return ret;
+    }
+
+    ret = (*FuncDolbyMS12GetNBytesConsumedSysSound)();
+    ALOGV("-%s() ret %llu", __FUNCTION__, ret);
+    return ret;
+}
+
+
+int DolbyMS12::DolbyMS12GetTotalNFramesDelay(void *ms12_pointer)
+{
+    int ret = 0;
+    ALOGV("+%s()", __FUNCTION__);
+    if (!FuncDolbyMS12GetTotalNFramesDelay) {
+        return -1;
+    }
+
+    ret = (*FuncDolbyMS12GetTotalNFramesDelay)(ms12_pointer);
+    ALOGV("-%s() ret %d", __FUNCTION__, ret);
+    return ret;
+}
+
+
 /*--------------------------------------------------------------------------*/
 }   // namespace android
diff --git a/libms12v2/src/DolbyMS12ConfigParams.cpp b/libms12v2/src/DolbyMS12ConfigParams.cpp
index 79fcaca..06f4818 100644
--- a/libms12v2/src/DolbyMS12ConfigParams.cpp
+++ b/libms12v2/src/DolbyMS12ConfigParams.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12v2"
+#define LOG_TAG "libms12"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
@@ -42,12 +42,14 @@ namespace android
 #define MAX_ARGV_STRING_LEN 256
 
 //here the file path is fake
+//@@pcm [main pcm sounds]
+#define DEFAULT_MAIN_PCM_FILE_NAME "/data/main48000Hz.wav"
 //@@pcm [application sounds]
-#define DEFAULT_APPLICATION_PCM_FILE_NAME "/data/application"
+#define DEFAULT_APPLICATION_PCM_FILE_NAME "/data/app48000Hz.wav"
 //@@pcm [system sounds]
-#define DEFAULT_SYSTEM_PCM_FILE_NAME "/data/system48kHz.wav"
+#define DEFAULT_SYSTEM_PCM_FILE_NAME "/data/system48000Hz.wav"
 //@@pcm [ott sounds]
-#define DEFAULT_OTT_PCM_FILE_NAME "/data/ott48kHz.wav"
+#define DEFAULT_OTT_PCM_FILE_NAME "/data/ott48000Hz.wav"
 //@@HE-AAC input file
 #define DEFAULT_MAIN_HEAAC_V1_FILE_NAME "/data/main.loas"
 #define DEFAULT_ASSOCIATE_HEAAC_V1_FILE_NAME "/data/associate.loas"
@@ -60,6 +62,7 @@ namespace android
 
 //@@@MAT input file
 #define DEFAULT_MAIN_MAT_FILE_NAME "/data/main.mat"
+#define DEFAULT_ASSOCIATE_MAT_FILE_NAME "/data/associate.wav"
 //@@@MLP input file
 #define DEFAULT_MAIN_MLP_FILE_NAME "/data/main.mlp"
 //@@@AC4 input file
@@ -71,9 +74,7 @@ namespace android
 #define DEFAULT_OUTPUT_DD_FILE_NAME "/data/output.ac3"
 #define DEFAULT_OUTPUT_DDP_FILE_NAME "/data/output.ec3"
 #define DEFAULT_OUTPUT_MAT_FILE_NAME "/data/output.mat"
-
-#define DEFAULT_APP_SOUNDS_CHANNEL_cONFIGURATION 7//means 3/2 (L, R, C, l, r)
-#define DEFAULT_SYSTEM_SOUNDS_CHANNEL_cONFIGURATION 2//means 2/0 (L, R)
+#define DEFAULT_SOUNDS_CHANNEL_CONFIGURATION 2//means 2/0 (L, R)
 
 //DRC Mode
 #define DDPI_UDC_COMP_LINE 2
@@ -81,6 +82,9 @@ namespace android
 #define DRC_HIGH_CUT_BIT 3
 #define DRC_LOW_BST_BIT 16
 
+//dap leveler
+#define MAX_DAP_LEVELER 10
+#define MIN_DAP_LEVELER 0
 
 DolbyMS12ConfigParams::DolbyMS12ConfigParams():
     // mDolbyMS12GetOutProfile(NULL)
@@ -88,21 +92,20 @@ DolbyMS12ConfigParams::DolbyMS12ConfigParams():
     mParamNum(0)
     , mAudioOutFlags(AUDIO_OUTPUT_FLAG_NONE)
     , mAudioStreamOutFormat(AUDIO_FORMAT_PCM_16_BIT)
-    , mAudioStreamOutChannelMask(AUDIO_CHANNEL_OUT_STEREO)
-    , mAudioSteamOutSampleRate(48000)
     // , mAudioSteamOutDevices(AUDIO_DEVICE_OUT_SPEAKER)
+    , mDolbyMS12OutChannelMask{AUDIO_CHANNEL_OUT_STEREO,
+                               AUDIO_CHANNEL_OUT_STEREO,
+                               AUDIO_CHANNEL_OUT_STEREO,
+                               AUDIO_CHANNEL_OUT_STEREO,
+                               AUDIO_CHANNEL_OUT_STEREO}
     , mDolbyMS12OutConfig(MS12_OUTPUT_MASK_DD)
     , mDolbyMS12OutSampleRate(48000)
-    , mDolbyMS12OutChannelMask(AUDIO_CHANNEL_OUT_7POINT1)
-    //, mDolbyMS12OutChannelMask(AUDIO_CHANNEL_OUT_STEREO)
     , mConfigParams(NULL)
     // , mMultiOutputFlag(true)
     , mDRCBoost(100)
     , mDRCCut(100)
     , mDRCBoostStereo(100)
     , mDRCCutStereo(100)
-    , mChannelConfAppSoundsIn(7)//5.1
-    , mChannelConfSystemIn(2)//2.0
     , mMainFlags(true)
     //, mMainFlags(false) // always have mMainFlags on? zz
     , mAppSoundFlags(false)
@@ -114,21 +117,17 @@ DolbyMS12ConfigParams::DolbyMS12ConfigParams():
     , mDAPDRCMode(0)
     , mDownmixMode(0)
     , mEvaluationMode(0)
-    , mLFEPresentInAppSoundIn(1)
-    , mLFEPresentInSystemSoundIn(0)
     , mDonwnmix71PCMto51(0)
     , mLockingChannelModeENC(1)//Encoder Channel Mode Locking Mode as 5.1
     , mRISCPrecisionFlag(1)
     , mDualMonoReproMode(0)
-    , mVerbosity(2)
+    , mVerbosity(0)
     , mOutputBitDepth(16)//use 16 bit per sample
     , mAssociatedAudioMixing(1)
     , mSystemAPPAudioMixing(1)
     , mUserControlVal(0)
 
     //DDPLUS SWITCHES
-    , mChannelConfigInExtPCMInput(7)
-    , mLFEPresentInExtPCMInput(true)
     , mCompressorProfile(0)
 
     //HE-AAC SWITCHES
@@ -152,19 +151,22 @@ DolbyMS12ConfigParams::DolbyMS12ConfigParams():
     , mDAPSurDecEnable(true)
     , mHasAssociateInput(false)
     , mHasSystemInput(false)
+    , mHasAppInput(false)
+    , mDualOutputFlag(false)
     , mActivateOTTSignal(false)
-    , mChannelConfOTTSoundsIn(2)//2.0 if mActivateOTTSignal is true
-    , mLFEPresentInOTTSoundIn(0)//on(default) if mActivateOTTSignal is true
     , mAtmosLock(false)//off(default) if mActivateOTTSignal is true
     , mPause(false)//Unpause(default) if mActivateOTTSignal is true
     , mMain1IsDummy(false)
     , mOTTSoundInputEnable(false)
+    , mIsLegecyDDPOut(false)
+    , mDolbyInputCMDMask(0)
 {
-    ALOGD("+%s() mAudioOutFlags %d mAudioStreamOutFormat %#x mDolbyMS12OutChannelMask=%#x mHasAssociateInput %d mHasSystemInput %d\n",
-          __FUNCTION__, mAudioOutFlags, mAudioStreamOutFormat, mDolbyMS12OutChannelMask, mHasAssociateInput, mHasSystemInput);
+    ALOGD("+%s() mAudioOutFlags %d mAudioStreamOutFormat %#x mHasAssociateInput %d mHasSystemInput %d AppInput %d\n",
+          __FUNCTION__, mAudioOutFlags, mAudioStreamOutFormat, mHasAssociateInput, mHasSystemInput, mHasAppInput);
     mConfigParams = PrepareConfigParams(MAX_ARGC, MAX_ARGV_STRING_LEN);
     if (!mConfigParams) {
         ALOGD("%s() line %d prepare the array fail", __FUNCTION__, __LINE__);
+		return;
     }
     memset(mDolbyMain1FileName, 0, sizeof(mDolbyMain1FileName));
     memcpy(mDolbyMain1FileName, DEFAULT_MAIN_DDP_FILE_NAME, sizeof(DEFAULT_MAIN_DDP_FILE_NAME));
@@ -179,8 +181,15 @@ DolbyMS12ConfigParams::DolbyMS12ConfigParams():
     if ((access(mDAPTuningFile, F_OK)) != -1) {
         mDAPInitMode = 2;
     }
-
     ALOGD("-%s() main1 %s main2 %s DAPInitMode %d", __FUNCTION__, mDolbyMain1FileName, mDolbyMain2FileName, mDAPInitMode);
+
+    char *vb = getenv("ms12_verbose");
+    if (vb) {
+        int level = atoi(vb);
+        if ((level >= 0) && (level <= 3)) {
+            mVerbosity = level;
+        }
+    }
 }
 
 DolbyMS12ConfigParams::~DolbyMS12ConfigParams()
@@ -201,20 +210,7 @@ void DolbyMS12ConfigParams::SetAudioStreamOutParams(
     ALOGD("+%s()", __FUNCTION__);
     mAudioOutFlags = flags;
     mAudioStreamOutFormat = input_format;
-    mAudioStreamOutChannelMask = channel_mask;
-    if ((input_format == AUDIO_FORMAT_PCM_16_BIT) || (input_format == AUDIO_FORMAT_PCM_32_BIT)) {
-        if (mHasSystemInput != false) {
-            mChannelConfAppSoundsIn = APPSoundChannelMaskConvertToChannelConfiguration(mAudioStreamOutChannelMask);
-        } else {
-            if (mActivateOTTSignal == true) {
-                mChannelConfOTTSoundsIn = SystemSoundChannelMaskConvertToChannelConfiguration(mAudioStreamOutChannelMask);
-            } else {
-                mChannelConfSystemIn = SystemSoundChannelMaskConvertToChannelConfiguration(mAudioStreamOutChannelMask);
-            }
-        }
-    }
-
-    mAudioSteamOutSampleRate = sample_rate;
+    mDolbyMS12OutChannelMask[MS12_INPUT_MAIN] = channel_mask;
     mDolbyMS12OutConfig = output_config & MS12_OUTPUT_MASK_PUBLIC;
 
     // speaker output w/o a DAP tuning file will use downmix output instead
@@ -225,16 +221,42 @@ void DolbyMS12ConfigParams::SetAudioStreamOutParams(
             mDolbyMS12OutConfig |= MS12_OUTPUT_MASK_STEREO;
         }
     }
-
     ALOGD("-%s() AudioStreamOut Flags %x Format %#x InputChannelMask %x SampleRate %d OutputConfig %#x\n",
-          __FUNCTION__, mAudioOutFlags, mAudioStreamOutFormat, mAudioStreamOutChannelMask,
-          mAudioSteamOutSampleRate, mDolbyMS12OutConfig);
+          __FUNCTION__, mAudioOutFlags, mAudioStreamOutFormat, channel_mask,
+          sample_rate, mDolbyMS12OutConfig);
 }
 
+static const ms12InputTable_t ms12InTable[] {
+    {"-imddp",          MS12_INPUT_MASK_MAIN_DDP  },
+    {"-impcm",          MS12_INPUT_MASK_MAIN_PCM  },
+    {"-imac4",          MS12_INPUT_MASK_MAIN_AC4  },
+    {"-immat",          MS12_INPUT_MASK_MAIN_MAT  },
+    {"-immlp",          MS12_INPUT_MASK_MAIN_MLP  },
+    {"-imheaac",        MS12_INPUT_MASK_MAIN_HEAAC},
+    {"-im2",            MS12_INPUT_MASK_MAIN2     },
+    {"-iui",            MS12_INPUT_MASK_UI_SOUND  },
+    {"-ia",             MS12_INPUT_MASK_ASSOCIATE },
+    {"-is",             MS12_INPUT_MASK_SYSTEM    },
+    {"-it",             MS12_INPUT_MASK_INPUT_TYPE},
+
+};
+
+void DolbyMS12ConfigParams::setInputCMDMask(const char *input_cmd)
+{
+    int cnt = sizeof(ms12InTable)/sizeof(ms12InputTable_t);
+    int num = 0;
+
+    for (num = 0; num < cnt; num++) {
+        if (strncmp(ms12InTable[num].fileTypeCmd, input_cmd, sizeof(ms12InTable[num].fileTypeCmd)) == 0) {
+            mDolbyInputCMDMask = mDolbyInputCMDMask | ms12InTable[num].mask;
+        }
+    }
+}
 //input and output
 int DolbyMS12ConfigParams::SetInputOutputFileName(char **ConfigParams, int *row_index)
 {
     ALOGV("+%s() line %d\n", __FUNCTION__, __LINE__);
+    mDolbyInputCMDMask = 0;
 
     if (mActivateOTTSignal == false) {
         if (mHasAssociateInput == false) {
@@ -246,24 +268,28 @@ int DolbyMS12ConfigParams::SetInputOutputFileName(char **ConfigParams, int *row_
                 mMainFlags = true;
                 mAppSoundFlags = false;
                 mSystemSoundFlags = false;
+                setInputCMDMask("-imddp");
             } else if (mAudioStreamOutFormat == AUDIO_FORMAT_MAT) {
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_MAT_FILE_NAME);
                 (*row_index)++;
                 mMainFlags = true;
                 mAppSoundFlags = false;
                 mSystemSoundFlags = false;
+                setInputCMDMask("-immat");
             } else if (mAudioStreamOutFormat == AUDIO_FORMAT_DOLBY_TRUEHD) {
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_MLP_FILE_NAME);
                 (*row_index)++;
                 mMainFlags = true;
                 mAppSoundFlags = false;
                 mSystemSoundFlags = false;
+                setInputCMDMask("-immlp");
             } else if (mAudioStreamOutFormat == AUDIO_FORMAT_AC4) {
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_AC4_FILE_NAME);
                 (*row_index)++;
                 mMainFlags = true;
                 mAppSoundFlags = false;
                 mSystemSoundFlags = false;
+                setInputCMDMask("-imac4");
             } else if ((mAudioStreamOutFormat == AUDIO_FORMAT_AAC) || (mAudioStreamOutFormat == AUDIO_FORMAT_HE_AAC_V1)) {
                 //fixme, which he-aac format is allowed to this flow.
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_HEAAC_V1_FILE_NAME);
@@ -271,6 +297,7 @@ int DolbyMS12ConfigParams::SetInputOutputFileName(char **ConfigParams, int *row_
                 mMainFlags = true;
                 mAppSoundFlags = false;
                 mSystemSoundFlags = false;
+                setInputCMDMask("-imheaac");
             } else if (mAudioStreamOutFormat == AUDIO_FORMAT_HE_AAC_V2) {
                 //fixme, which he-aac format is allowed to this flow.
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_HEAAC_V2_FILE_NAME);
@@ -278,36 +305,76 @@ int DolbyMS12ConfigParams::SetInputOutputFileName(char **ConfigParams, int *row_
                 mMainFlags = true;
                 mAppSoundFlags = false;
                 mSystemSoundFlags = false;
+                setInputCMDMask("-imheaac");
             } else { //others the format is pcm
-                sprintf(ConfigParams[*row_index], "%s%d%s", DEFAULT_APPLICATION_PCM_FILE_NAME, mAudioSteamOutSampleRate, "kHz.wav");
+                sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_PCM_FILE_NAME);
                 (*row_index)++;
                 mMainFlags = true;
-                mAppSoundFlags = false;
+                mAppSoundFlags = true;
                 mSystemSoundFlags = true;
+                setInputCMDMask("-impcm");
             }
         } else {
 
             if ((mAudioStreamOutFormat == AUDIO_FORMAT_AC3) || (mAudioStreamOutFormat == AUDIO_FORMAT_E_AC3)) {
                 sprintf(ConfigParams[*row_index], "%s", "-im");
+                setInputCMDMask("-imddp");
                 (*row_index)++;
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_DDP_FILE_NAME);
                 (*row_index)++;
 
                 sprintf(ConfigParams[*row_index], "%s", "-ia");
+                setInputCMDMask("-ia");
                 (*row_index)++;
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_ASSOCIATE_DDP_FILE_NAME);
                 (*row_index)++;
 
+                mMainFlags = true;
+                mAppSoundFlags = false;
+                mSystemSoundFlags = false;
+            } else if (mAudioStreamOutFormat == AUDIO_FORMAT_MAT) {
+                sprintf(ConfigParams[*row_index], "%s", "-im");
+                setInputCMDMask("-immat");
+                (*row_index)++;
+                sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_MAT_FILE_NAME);
+                (*row_index)++;
+
+                sprintf(ConfigParams[*row_index], "%s", "-ia");
+                setInputCMDMask("-ia");
+                (*row_index)++;
+                sprintf(ConfigParams[*row_index], "%s", DEFAULT_ASSOCIATE_MAT_FILE_NAME); //TODO:Need to confirm if MAT supports Associated
+                (*row_index)++;
+
+                mMainFlags = true;
+                mAppSoundFlags = false;
+                mSystemSoundFlags = false;
+            } else if (mAudioStreamOutFormat == AUDIO_FORMAT_DOLBY_TRUEHD) {
+                sprintf(ConfigParams[*row_index], "%s", "-im");
+                setInputCMDMask("-immlp");
+                (*row_index)++;
+                sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_MLP_FILE_NAME);
+                (*row_index)++;
+                mMainFlags = true;
+                mAppSoundFlags = false;
+                mSystemSoundFlags = false;
+            } else if (mAudioStreamOutFormat == AUDIO_FORMAT_AC4) {
+                sprintf(ConfigParams[*row_index], "%s", "-im");
+                setInputCMDMask("-imac4");
+                (*row_index)++;
+                sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_AC4_FILE_NAME);
+                (*row_index)++;
                 mMainFlags = true;
                 mAppSoundFlags = false;
                 mSystemSoundFlags = false;
             } else if ((mAudioStreamOutFormat == AUDIO_FORMAT_AAC) || (mAudioStreamOutFormat == AUDIO_FORMAT_HE_AAC_V1)) {
                 sprintf(ConfigParams[*row_index], "%s", "-im");
+                setInputCMDMask("-imheaac");
                 (*row_index)++;
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_HEAAC_V1_FILE_NAME);
                 (*row_index)++;
 
                 sprintf(ConfigParams[*row_index], "%s", "-ia");
+                setInputCMDMask("-ia");
                 (*row_index)++;
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_ASSOCIATE_HEAAC_V1_FILE_NAME);
                 (*row_index)++;
@@ -317,11 +384,13 @@ int DolbyMS12ConfigParams::SetInputOutputFileName(char **ConfigParams, int *row_
                 mSystemSoundFlags = false;
             } else if (mAudioStreamOutFormat == AUDIO_FORMAT_HE_AAC_V2) {
                 sprintf(ConfigParams[*row_index], "%s", "-im");
+                setInputCMDMask("-imheaac");
                 (*row_index)++;
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_HEAAC_V2_FILE_NAME);
                 (*row_index)++;
 
                 sprintf(ConfigParams[*row_index], "%s", "-ia");
+                setInputCMDMask("-ia");
                 (*row_index)++;
                 sprintf(ConfigParams[*row_index], "%s", DEFAULT_ASSOCIATE_HEAAC_V2_FILE_NAME);
                 (*row_index)++;
@@ -335,48 +404,56 @@ int DolbyMS12ConfigParams::SetInputOutputFileName(char **ConfigParams, int *row_
 
     // have active OTT signal,then configure input Main program input filename? zz
     if (mActivateOTTSignal == true) {
-        if ((mAudioStreamOutFormat == AUDIO_FORMAT_AC3) || (mAudioStreamOutFormat == AUDIO_FORMAT_E_AC3)) {
+        if ((mAudioStreamOutFormat == AUDIO_FORMAT_AC3) || (mAudioStreamOutFormat == AUDIO_FORMAT_E_AC3) || mMain1IsDummy){
             sprintf(ConfigParams[*row_index], "%s", "-im");
+            setInputCMDMask("-imddp");
             (*row_index)++;
             sprintf(ConfigParams[*row_index], "%s", mDolbyMain1FileName);
             (*row_index)++;
 
             sprintf(ConfigParams[*row_index], "%s", "-im2");
+            setInputCMDMask("-im2");
             (*row_index)++;
             sprintf(ConfigParams[*row_index], "%s", mDolbyMain2FileName);
             (*row_index)++;
             ALOGD("%s() main1 %s main2 %s", __FUNCTION__, mDolbyMain1FileName, mDolbyMain2FileName);
         } else if (mAudioStreamOutFormat == AUDIO_FORMAT_MAT) {
             sprintf(ConfigParams[*row_index], "%s", "-im");
+            setInputCMDMask("-immat");
             (*row_index)++;
             sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_MAT_FILE_NAME);
             (*row_index)++;
 
             sprintf(ConfigParams[*row_index], "%s", "-im2");
+            setInputCMDMask("-im2");
             (*row_index)++;
             sprintf(ConfigParams[*row_index], "%s", mDolbyMain2FileName);
             (*row_index)++;
             ALOGD("%s() main1 %s main2 %s", __FUNCTION__, mDolbyMain1FileName, mDolbyMain2FileName);
         } else if (mAudioStreamOutFormat == AUDIO_FORMAT_DOLBY_TRUEHD) {
             sprintf(ConfigParams[*row_index], "%s", "-im");
+            setInputCMDMask("-immlp");
             (*row_index)++;
             sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_MLP_FILE_NAME);
             (*row_index)++;
 
             sprintf(ConfigParams[*row_index], "%s", "-im2");
+            setInputCMDMask("-im2");
             (*row_index)++;
             sprintf(ConfigParams[*row_index], "%s", mDolbyMain2FileName);
             (*row_index)++;
             ALOGD("%s() main1 %s main2 %s", __FUNCTION__, mDolbyMain1FileName, mDolbyMain2FileName);
         } else if (mAudioStreamOutFormat == AUDIO_FORMAT_AC4) {
             sprintf(ConfigParams[*row_index], "%s", "-im");
+            setInputCMDMask("-imac4");
             (*row_index)++;
             sprintf(ConfigParams[*row_index], "%s", DEFAULT_MAIN_AC4_FILE_NAME);
             (*row_index)++;
             ALOGD("%s() main1 %s", __FUNCTION__, mDolbyMain1FileName);
         }
-        if (mOTTSoundInputEnable == true) {
+        if (mOTTSoundInputEnable == true && mAudioStreamOutFormat != AUDIO_FORMAT_AC4) {
             sprintf(ConfigParams[*row_index], "%s", "-iui");
+            setInputCMDMask("-iui");
             (*row_index)++;
             sprintf(ConfigParams[*row_index], "%s", DEFAULT_OTT_PCM_FILE_NAME);
             (*row_index)++;
@@ -385,11 +462,19 @@ int DolbyMS12ConfigParams::SetInputOutputFileName(char **ConfigParams, int *row_
 
     if (mHasSystemInput == true) {
         sprintf(ConfigParams[*row_index], "%s", "-is");
+        setInputCMDMask("-is");
         (*row_index)++;
         sprintf(ConfigParams[*row_index], "%s", DEFAULT_SYSTEM_PCM_FILE_NAME);
         (*row_index)++;
     }
 
+    if (mHasAppInput == true) {
+        sprintf(ConfigParams[*row_index], "%s", "-ias");
+        setInputCMDMask("-ias");
+        (*row_index)++;
+        sprintf(ConfigParams[*row_index], "%s", DEFAULT_APPLICATION_PCM_FILE_NAME);
+        (*row_index)++;
+    }
 
     if (mDolbyMS12OutConfig & MS12_OUTPUT_MASK_DD) {
         sprintf(ConfigParams[*row_index], "%s", "-od");
@@ -437,37 +522,34 @@ int DolbyMS12ConfigParams::SetInputOutputFileName(char **ConfigParams, int *row_
     return 0;
 }
 
-int DolbyMS12ConfigParams::APPSoundChannelMaskConvertToChannelConfiguration(audio_channel_mask_t channel_mask)
+int DolbyMS12ConfigParams::ChannelMask2ChannelConfig(audio_channel_mask_t channel_mask)
 {
     ALOGV("+%s() line %d\n", __FUNCTION__, __LINE__);
-    int ChannelConfiguration = 0;
-    switch (channel_mask) {
-    case AUDIO_CHANNEL_OUT_MONO:
-        ChannelConfiguration = 1;// L
+    int ChannelConfiguration;
+    switch (channel_mask & ~AUDIO_CHANNEL_OUT_LOW_FREQUENCY) {
+    case AUDIO_CHANNEL_OUT_MONO: // C
+        ChannelConfiguration = 1;
         break;
-    case AUDIO_CHANNEL_OUT_STEREO:// L,R
+    case AUDIO_CHANNEL_OUT_STEREO: // L, R
         ChannelConfiguration = 2;
         break;
-    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_FRONT_CENTER):// L,R,C
+    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_FRONT_CENTER): // L, R, C
         ChannelConfiguration = 3;
         break;
-    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_BACK_LEFT):// L, R, l
+    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_BACK_CENTER): // L, R, S
         ChannelConfiguration = 4;
         break;
-    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_FRONT_CENTER | AUDIO_CHANNEL_OUT_BACK_LEFT):// L, R, C, l
+    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_FRONT_CENTER | AUDIO_CHANNEL_OUT_BACK_CENTER):// L, R, C, S
         ChannelConfiguration = 5;
         break;
-    case AUDIO_CHANNEL_OUT_5POINT1:// L, R, C, l
+    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT):// L, R, LS, RS
         ChannelConfiguration = 6;
         break;
-    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_FRONT_CENTER | AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT):// L, R, C, l
+    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_FRONT_CENTER | AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT):// L, R, C, LS, RS
         ChannelConfiguration = 7;
         break;
-    case  AUDIO_CHANNEL_OUT_7POINT1:// (L, C, R, l, r, Lrs, Rrs)
-        ChannelConfiguration = 21;
-        break;
     default:
-        ChannelConfiguration = DEFAULT_APP_SOUNDS_CHANNEL_cONFIGURATION;
+        ChannelConfiguration = DEFAULT_SOUNDS_CHANNEL_CONFIGURATION;
         break;
     }
 
@@ -475,42 +557,9 @@ int DolbyMS12ConfigParams::APPSoundChannelMaskConvertToChannelConfiguration(audi
     return ChannelConfiguration;
 }
 
-int DolbyMS12ConfigParams::SystemSoundChannelMaskConvertToChannelConfiguration(audio_channel_mask_t channel_mask)
+int DolbyMS12ConfigParams::ChannelMask2LFEConfig(audio_channel_mask_t channel_mask)
 {
-    ALOGV("+%s() line %d\n", __FUNCTION__, __LINE__);
-    int ChannelConfiguration = 0;
-    switch (channel_mask) {
-    case AUDIO_CHANNEL_OUT_MONO:
-        ChannelConfiguration = 1;// L
-        break;
-    case AUDIO_CHANNEL_OUT_STEREO:// L,R
-        ChannelConfiguration = 2;
-        break;
-    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_FRONT_CENTER):// L,R,C
-        ChannelConfiguration = 3;
-        break;
-    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_BACK_LEFT):// L, R, l
-        ChannelConfiguration = 4;
-        break;
-    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_FRONT_CENTER | AUDIO_CHANNEL_OUT_BACK_LEFT):// L, R, C, l
-        ChannelConfiguration = 5;
-        break;
-    case AUDIO_CHANNEL_OUT_5POINT1:// L, R, C, l
-        ChannelConfiguration = 6;
-        break;
-    case (AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_FRONT_CENTER | AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT):// L, R, C, l
-        ChannelConfiguration = 7;
-        break;
-    case  AUDIO_CHANNEL_OUT_7POINT1:// (L, C, R, l, r, Lrs, Rrs)
-        ChannelConfiguration = 21;
-        break;
-    default:
-        ChannelConfiguration = DEFAULT_SYSTEM_SOUNDS_CHANNEL_cONFIGURATION;
-        break;
-    }
-
-    ALOGV("-%s() line %d ChannelConfiguration %d\n", __FUNCTION__, __LINE__, ChannelConfiguration);
-    return ChannelConfiguration;
+    return (channel_mask & AUDIO_CHANNEL_OUT_LOW_FREQUENCY) ? 1 : 0;
 }
 
 //functional switches
@@ -533,14 +582,13 @@ int DolbyMS12ConfigParams::SetFunctionalSwitches(char **ConfigParams, int *row_i
         }
     }
 
-#if 0
-    if (mMultiOutputFlag == false) {
-        sprintf(ConfigParams[*row_index], "%s", "-mc");
-        (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", 0);
-        (*row_index)++;
-    }
-#endif
+    // //fixme, not use this params
+    // if (mMultiOutputFlag == true) {
+    //     sprintf(ConfigParams[*row_index], "%s", "-mc");
+    //     (*row_index)++;
+    //     sprintf(ConfigParams[*row_index], "%d", 1);
+    //     (*row_index)++;
+    // }
 
     if ((mDRCBoost >= 0) && (mDRCBoost <= 100)) {
         sprintf(ConfigParams[*row_index], "%s", "-b");
@@ -556,11 +604,10 @@ int DolbyMS12ConfigParams::SetFunctionalSwitches(char **ConfigParams, int *row_i
         (*row_index)++;
     }
 
-
     if (mAppSoundFlags == true) {
         sprintf(ConfigParams[*row_index], "%s", "-chas");
         (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", mChannelConfAppSoundsIn);
+        sprintf(ConfigParams[*row_index], "%d", ChannelMask2ChannelConfig(mDolbyMS12OutChannelMask[MS12_INPUT_APP]));
         (*row_index)++;
     }
 
@@ -568,7 +615,7 @@ int DolbyMS12ConfigParams::SetFunctionalSwitches(char **ConfigParams, int *row_i
     if ((mActivateOTTSignal == true) && (mMain1IsDummy == true) && (mOTTSoundInputEnable == true)) {
         sprintf(ConfigParams[*row_index], "%s", "-chui");
         (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", mChannelConfOTTSoundsIn);
+        sprintf(ConfigParams[*row_index], "%d", ChannelMask2ChannelConfig(mDolbyMS12OutChannelMask[MS12_INPUT_UI]));
         (*row_index)++;
     }
 
@@ -576,7 +623,7 @@ int DolbyMS12ConfigParams::SetFunctionalSwitches(char **ConfigParams, int *row_i
     if (mHasSystemInput == true) {
         sprintf(ConfigParams[*row_index], "%s", "-chs");
         (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", mChannelConfSystemIn);
+        sprintf(ConfigParams[*row_index], "%d", ChannelMask2ChannelConfig(mDolbyMS12OutChannelMask[MS12_INPUT_SYSTEM]));
         (*row_index)++;
     }
 
@@ -629,29 +676,27 @@ int DolbyMS12ConfigParams::SetFunctionalSwitches(char **ConfigParams, int *row_i
         (*row_index)++;
     }
 
-    if (mLFEPresentInAppSoundIn == 0) {
+    {
         sprintf(ConfigParams[*row_index], "%s", "-las");
         (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", mLFEPresentInAppSoundIn);
+        sprintf(ConfigParams[*row_index], "%d", ChannelMask2LFEConfig(mDolbyMS12OutChannelMask[MS12_INPUT_APP]));
         (*row_index)++;
     }
 
-    if (mLFEPresentInSystemSoundIn == 1) {
+    {
         sprintf(ConfigParams[*row_index], "%s", "-ls");
         (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", mLFEPresentInSystemSoundIn);
+        sprintf(ConfigParams[*row_index], "%d", ChannelMask2LFEConfig(mDolbyMS12OutChannelMask[MS12_INPUT_SYSTEM]));
         (*row_index)++;
     }
 
-#if 0
     // LFE present in OTT Sounds input
     if ((mActivateOTTSignal == true) && (mMain1IsDummy == true) && (mOTTSoundInputEnable == true)) {
-        sprintf(ConfigParams[*row_index], "%s", "-los");
+        sprintf(ConfigParams[*row_index], "%s", "-lui");
         (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", mLFEPresentInOTTSoundIn);
+        sprintf(ConfigParams[*row_index], "%d", ChannelMask2LFEConfig(mDolbyMS12OutChannelMask[MS12_INPUT_UI]));
         (*row_index)++;
     }
-#endif
 
     //TODO: when ms12 HDMI mode is set to FULL or eARC, the downstream sink
     // supports Dolby MAT and if the output mode is set to DD+ output then
@@ -659,10 +704,11 @@ int DolbyMS12ConfigParams::SetFunctionalSwitches(char **ConfigParams, int *row_i
     // will be disabled, unless another legacy_ddplus_out=0 is set explicitly.
     // Need provide an API to allow audio HAL to specify whether legacy output
     // is needed from DDP output.
-    if (1) {
+
+    if (mDolbyMS12OutConfig & (MS12_OUTPUT_MASK_DD|MS12_OUTPUT_MASK_DDP)) {
         sprintf(ConfigParams[*row_index], "%s", "-legacy_ddplus_out");
         (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", 0);
+        sprintf(ConfigParams[*row_index], "%d", mIsLegecyDDPOut);
         (*row_index)++;
     }
 
@@ -708,7 +754,7 @@ int DolbyMS12ConfigParams::SetFunctionalSwitches(char **ConfigParams, int *row_i
         (*row_index)++;
     }
 
-    if ((mAssociatedAudioMixing == 0) && (mHasAssociateInput == true)) {
+    if (isAssociatedAudioControlSuitable()) {
         sprintf(ConfigParams[*row_index], "%s", "-xa");
         (*row_index)++;
         sprintf(ConfigParams[*row_index], "%d", mAssociatedAudioMixing);
@@ -723,7 +769,7 @@ int DolbyMS12ConfigParams::SetFunctionalSwitches(char **ConfigParams, int *row_i
         (*row_index)++;
     }
 
-    if (mHasAssociateInput == true) { //set this params when dual input.
+    if (isAssociatedAudioControlSuitable()) { //set this params when dual input.
         if (mUserControlVal > 32) {
             mUserControlVal = 32;
         } else if (mUserControlVal < -32) {
@@ -788,46 +834,42 @@ int DolbyMS12ConfigParams::SetFunctionalSwitches(char **ConfigParams, int *row_i
 int DolbyMS12ConfigParams::SetFunctionalSwitchesRuntime(char **ConfigParams, int *row_index)
 {
     ALOGV("+%s() line %d\n", __FUNCTION__, __LINE__);
-    if (mStereoOutputFlag == true) {
-        if ((mDRCBoost >= 0) && (mDRCBoost <= 100)) {
-            sprintf(ConfigParams[*row_index], "%s", "-bs");
-            (*row_index)++;
-            sprintf(ConfigParams[*row_index], "%d", mDRCBoostSystem);
-            (*row_index)++;
-        }
 
-        if ((mDRCCut >= 0) && (mDRCCut <= 100)) {
-            sprintf(ConfigParams[*row_index], "%s", "-cs");
-            (*row_index)++;
-            sprintf(ConfigParams[*row_index], "%d", mDRCCutSystem);
-            (*row_index)++;
-        }
+    if (mDualMonoReproMode != 0) {
+        sprintf(ConfigParams[*row_index], "%s", "-u");
+        (*row_index)++;
+        sprintf(ConfigParams[*row_index], "%d", mDualMonoReproMode);
+        (*row_index)++;
     }
 
-#if 0
-    if (mMultiOutputFlag == false) {
-        sprintf(ConfigParams[*row_index], "%s", "-mc");
+    if (mDRCBoostStereo != 100) {
+        sprintf(ConfigParams[*row_index], "%s", "-bs");
         (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", 0);
+        sprintf(ConfigParams[*row_index], "%d", mDRCBoostStereo);
         (*row_index)++;
     }
-#endif
 
-    if ((mDRCBoost >= 0) && (mDRCBoost <= 100)) {
+    if (mDRCCutStereo != 100) {
+        sprintf(ConfigParams[*row_index], "%s", "-cs");
+        (*row_index)++;
+        sprintf(ConfigParams[*row_index], "%d", mDRCCutStereo);
+        (*row_index)++;
+    }
+
+    if (mDRCBoostStereo != 100) {
         sprintf(ConfigParams[*row_index], "%s", "-b");
         (*row_index)++;
         sprintf(ConfigParams[*row_index], "%d", mDRCBoost);
         (*row_index)++;
     }
 
-    if ((mDRCCut >= 0) && (mDRCCut <= 100)) {
+    if (mDRCCut != 100) {
         sprintf(ConfigParams[*row_index], "%s", "-c");
         (*row_index)++;
         sprintf(ConfigParams[*row_index], "%d", mDRCCut);
         (*row_index)++;
     }
 
-
     if (mAppSoundFlags == true) {
         sprintf(ConfigParams[*row_index], "%s", "-chas");
         (*row_index)++;
@@ -884,21 +926,12 @@ int DolbyMS12ConfigParams::SetFunctionalSwitchesRuntime(char **ConfigParams, int
         (*row_index)++;
     }
 
-#if 0
     if ((mActivateOTTSignal == true) && (mMain1IsDummy == true) && (mOTTSoundInputEnable == true)) {
-        sprintf(ConfigParams[*row_index], "%s", "-los");
+        sprintf(ConfigParams[*row_index], "%s", "-lui");
         (*row_index)++;
         sprintf(ConfigParams[*row_index], "%d", mLFEPresentInOTTSoundIn);
         (*row_index)++;
     }
-#endif
-
-    if (mDualMonoReproMode != 0) {
-        sprintf(ConfigParams[*row_index], "%s", "-u");
-        (*row_index)++;
-        sprintf(ConfigParams[*row_index], "%d", mDualMonoReproMode);
-        (*row_index)++;
-    }
 
     if ((mAssociatedAudioMixing == 0) && (mHasAssociateInput == true)) {
         sprintf(ConfigParams[*row_index], "%s", "-xa");
@@ -944,7 +977,7 @@ int DolbyMS12ConfigParams::SetFunctionalSwitchesRuntime(char **ConfigParams, int
     }
 
     if ((mActivateOTTSignal == true) && (mMain1IsDummy == true) && (mOTTSoundInputEnable == true)) {
-        sprintf(ConfigParams[*row_index], "%s", "-ott_mixgain");
+        sprintf(ConfigParams[*row_index], "%s", "-ui_mixgain");
         (*row_index)++;
         sprintf(ConfigParams[*row_index], "%d,%d,%d", mOTTMixGain.target, mOTTMixGain.duration, mOTTMixGain.shape);
         (*row_index)++;
@@ -989,7 +1022,7 @@ int DolbyMS12ConfigParams::SetFunctionalSwitchesRuntime_lite(char **ConfigParams
     sprintf(ConfigParams[*row_index], "%d,%d,%d", mMain2MixGain.target, mMain2MixGain.duration, mMain2MixGain.shape);//choose mid-val
     (*row_index)++;
 
-    sprintf(ConfigParams[*row_index], "%s", "-ott_mixgain");
+    sprintf(ConfigParams[*row_index], "%s", "-ui_mixgain");
     (*row_index)++;
     sprintf(ConfigParams[*row_index], "%d,%d,%d", mOTTMixGain.target, mOTTMixGain.duration, mOTTMixGain.shape);
     (*row_index)++;
@@ -1019,21 +1052,18 @@ int DolbyMS12ConfigParams::SetFunctionalSwitchesRuntime_lite(char **ConfigParams
 //PCM switches
 int DolbyMS12ConfigParams::SetPCMSwitches(char **ConfigParams, int *row_index)
 {
-    ALOGV("+%s() line %d\n", __FUNCTION__, __LINE__);
-    if ((mSystemSoundFlags == true) || (mAppSoundFlags == true)) {
-        mChannelConfigInExtPCMInput = APPSoundChannelMaskConvertToChannelConfiguration(mAudioStreamOutChannelMask);
+    if ((mAudioStreamOutFormat & AUDIO_FORMAT_MAIN_MASK) == AUDIO_FORMAT_PCM) {
         {
             sprintf(ConfigParams[*row_index], "%s", "-chp");
             (*row_index)++;
-            sprintf(ConfigParams[*row_index], "%d", mChannelConfigInExtPCMInput);
+            sprintf(ConfigParams[*row_index], "%d", ChannelMask2ChannelConfig(mDolbyMS12OutChannelMask[MS12_INPUT_MAIN]));
             (*row_index)++;
         }
 
-        if ((mChannelConfigInExtPCMInput == 1) || (mChannelConfigInExtPCMInput == 2)) {
-            mLFEPresentInExtPCMInput = false;
+        {
             sprintf(ConfigParams[*row_index], "%s", "-lp");
             (*row_index)++;
-            sprintf(ConfigParams[*row_index], "%d", 0);
+            sprintf(ConfigParams[*row_index], "%d", ChannelMask2LFEConfig(mDolbyMS12OutChannelMask[MS12_INPUT_MAIN]));
             (*row_index)++;
         }
 
@@ -1057,7 +1087,7 @@ int DolbyMS12ConfigParams::SetPCMSwitchesRuntime(char **ConfigParams, int *row_i
 {
     ALOGV("+%s() line %d\n", __FUNCTION__, __LINE__);
     if ((mSystemSoundFlags == true) || (mAppSoundFlags == true)) {
-        mChannelConfigInExtPCMInput = APPSoundChannelMaskConvertToChannelConfiguration(mAudioStreamOutChannelMask);
+        mChannelConfigInExtPCMInput = APPSoundChannelMaskConvertToChannelConfiguration(mDolbyMS12OutChannelMask);
         {
             sprintf(ConfigParams[*row_index], "%s", "-chp");
             (*row_index)++;
@@ -1219,7 +1249,6 @@ int DolbyMS12ConfigParams::SetOTTProcessingGraphSwitches(char **ConfigParams, in
             (*row_index)++;
         }
 #endif
-
         if ((mPause == true) || (mPause == false)) {
             sprintf(ConfigParams[*row_index], "%s", "-pause");
             (*row_index)++;
@@ -1241,8 +1270,8 @@ int DolbyMS12ConfigParams::SetOTTProcessingGraphSwitchesRuntime(char **ConfigPar
         // no matter mAtmosLock == true or mAtmosLock == false
         // we all need to set -atmos_locking flag
         // otherwise atmos_locking function can not perform correctly.
-#if 0
         //if (mAtmosLock == true)
+#if 0
         {
             // MS1.3.2 use "atmos_locking" instead of "atmos_lock"
             // if we use "atmos_lock" we will get following error log from ms12:
@@ -1261,6 +1290,7 @@ int DolbyMS12ConfigParams::SetOTTProcessingGraphSwitchesRuntime(char **ConfigPar
             (*row_index)++;
         }
 #endif
+
         if ((mPause == true) || (mPause == false)) {
             sprintf(ConfigParams[*row_index], "%s", "-pause");
             (*row_index)++;
@@ -1277,7 +1307,7 @@ int DolbyMS12ConfigParams::SetOTTProcessingGraphSwitchesRuntime(char **ConfigPar
 //all run-time
 int DolbyMS12ConfigParams::SetDAPDeviceSwitches(char **ConfigParams, int *row_index, int is_runtime)
 {
-    char tmpParam[32];
+    std::string tmpParam;
     ALOGV("+%s() line %d\n", __FUNCTION__, __LINE__);
     if (mDAPTuningFile && !is_runtime) {
         sprintf(ConfigParams[*row_index], "%s", "-dap_tuning");
@@ -1299,8 +1329,8 @@ int DolbyMS12ConfigParams::SetDAPDeviceSwitches(char **ConfigParams, int *row_in
         sprintf(ConfigParams[*row_index], "%d", mDAPSurDecEnable);
         (*row_index)++;
     }
-
-    if (DeviceDAPSurroundVirtualizer.virtualizer_enable == 1) {
+    /*virtualizer_mode: 0:OFF  1:ON  2:AUTO*/
+    if (DeviceDAPSurroundVirtualizer.virtualizer_enable <= 2) {
         sprintf(ConfigParams[*row_index], "%s", "-dap_surround_virtualizer");
         (*row_index)++;
         sprintf(ConfigParams[*row_index], "%d,%d", DeviceDAPSurroundVirtualizer.virtualizer_enable,
@@ -1312,18 +1342,25 @@ int DolbyMS12ConfigParams::SetDAPDeviceSwitches(char **ConfigParams, int *row_in
         sprintf(ConfigParams[*row_index], "%s", "-dap_graphic_eq");
         (*row_index)++;
         sprintf(ConfigParams[*row_index], "%d,%d", DeviceDAPGraphicEQ.eq_enable, DeviceDAPGraphicEQ.eq_nb_bands);
+        //tmpParam += String8::format("%s", ConfigParams[*row_index]);
+        tmpParam += ConfigParams[*row_index];
         int i = 0;
         for (i = 0; i < DeviceDAPGraphicEQ.eq_nb_bands; i++) {
-            snprintf(tmpParam, sizeof(tmpParam)-1, ",%d", DeviceDAPGraphicEQ.eq_band_center[i]);
-            strcat(ConfigParams[*row_index], tmpParam);
+            sprintf(ConfigParams[*row_index], ",%d", DeviceDAPGraphicEQ.eq_band_center[i]);
+            //tmpParam += String8::format("%s", ConfigParams[*row_index]);
+            tmpParam += ConfigParams[*row_index];
         }
 
         for (i = 0; i < DeviceDAPGraphicEQ.eq_nb_bands; i++) {
-            snprintf(tmpParam, sizeof(tmpParam)-1, ",%d", DeviceDAPGraphicEQ.eq_band_target[i]);
-            strcat(ConfigParams[*row_index], tmpParam);
+            sprintf(ConfigParams[*row_index], ",%d", DeviceDAPGraphicEQ.eq_band_target[i]);
+            //tmpParam += String8::format("%s", ConfigParams[*row_index]);
+            tmpParam += ConfigParams[*row_index];
         }
+        //memcpy(ConfigParams[*row_index], tmpParam.string(), strlen(tmpParam.string()));
+		memcpy(ConfigParams[*row_index], tmpParam.c_str(), tmpParam.size());
         (*row_index)++;
     }
+    tmpParam.clear();
 
     if (DeviceDAPBassEnhancer.bass_enable == 1) {
         sprintf(ConfigParams[*row_index], "%s", "-dap_bass_enhancer");
@@ -1360,8 +1397,8 @@ int DolbyMS12ConfigParams::SetDAPContentSwitches(char **ConfigParams, int *row_i
         sprintf(ConfigParams[*row_index], "%d", ContentDAPMISteering.mi_enable);
         (*row_index)++;
     }
-
-    if (ContentDAPLeveler.leveler_enable == 1) {
+    /*leveler_setting: 0:OFF 1:ON 2:AUTO*/
+    if (ContentDAPLeveler.leveler_enable <= 2) {
         sprintf(ConfigParams[*row_index], "%s", "-dap_leveler");
         (*row_index)++;
         sprintf(ConfigParams[*row_index], "%d,%d", ContentDAPLeveler.leveler_enable, ContentDAPLeveler.leveler_amount);
@@ -1404,12 +1441,95 @@ int DolbyMS12ConfigParams::SetDAPContentSwitches(char **ConfigParams, int *row_i
     ALOGV("-%s() line %d\n", __FUNCTION__, __LINE__);
     return 0;
 }
+char *DolbyMS12ConfigParams::QueryDapParameters(const char *key)
+{
+    std::ostringstream s;
+    std::istringstream key_str(key);
+    std::string token_str;
+
+    // key is a set of parmaeters with comma as seperator
+    while (std::getline(key_str, token_str, ';')) {
+        const char *token = token_str.c_str();
+        if (!strcmp(token, "dap_surround_decoder_enable")) {
+            s << "dap_surround_decoder_enable="
+              << mDAPSurDecEnable
+              << ";";
+        } else if (!strcmp(token, "dap_drc")) {
+            s << "dap_drc="
+              << mDAPDRCMode
+              << ";";
+        } else if (!strcmp(token, "dap_bass_enhancer")) {
+            s << "dap_bass_enhancer="
+              << DeviceDAPBassEnhancer.bass_enable
+              << "," << DeviceDAPBassEnhancer.bass_boost
+              << "," << DeviceDAPBassEnhancer.bass_cutoff
+              << "," << DeviceDAPBassEnhancer.bass_width
+              << ";";
+        } else if (!strcmp(token, "dap_dialogue_enhancer")) {
+            s << "dap_dialogue_enhancer="
+              << ContenDAPDialogueEnhancer.de_enable
+              << "," << ContenDAPDialogueEnhancer.de_amount
+              << ";";
+        } else if (!strcmp(token, "dap_graphic_eq")) {
+            s << "dap_graphic_eq="
+              << DeviceDAPGraphicEQ.eq_enable
+              << "," << DeviceDAPGraphicEQ.eq_nb_bands;
+            for (int i = 0; i < DeviceDAPGraphicEQ.eq_nb_bands; i++)
+                s << "," << DeviceDAPGraphicEQ.eq_band_center[i];
+            for (int i = 0; i < DeviceDAPGraphicEQ.eq_nb_bands; i++)
+                s << "," << DeviceDAPGraphicEQ.eq_band_target[i];
+            s << ";";
+        } else if (!strcmp(token, "dap_ieq")) {
+            s << "dap_ieq="
+              << ContentDAPIEQ.ieq_enable
+              << "," << ContentDAPIEQ.ieq_amount
+              << "," << ContentDAPIEQ.ieq_nb_bands;
+            for (int i = 0; i < ContentDAPIEQ.ieq_nb_bands; i++)
+                s << "," << ContentDAPIEQ.ieq_band_center[i];
+            for (int i = 0; i < ContentDAPIEQ.ieq_nb_bands; i++)
+                s << "," << ContentDAPIEQ.ieq_band_target[i];
+            s << ";";
+        } else if (!strcmp(token, "dap_gains")) {
+            s << "dap_gains="
+              << mDAPGains
+              << ";";
+        } else if (!strcmp(token, "dap_leveler")) {
+            s << "dap_leveler="
+              << ContentDAPLeveler.leveler_enable
+              << "," << ContentDAPLeveler.leveler_amount
+              << ";";
+        } else if (!strcmp(token, "dap_mi_steering")) {
+            s << "dap_mi_steering="
+              << ContentDAPMISteering.mi_enable
+              << ";";
+        } else if (!strcmp(token, "dap_surround_virtualizer")) {
+            s << "dap_surround_virtualizer="
+              << DeviceDAPSurroundVirtualizer.virtualizer_enable
+              << "," << DeviceDAPSurroundVirtualizer.surround_boost
+              << ";";
+        }
+    }
+
+    std::string ret = s.str();
+    if (ret.empty()) {
+        return strdup("");
+    }
+
+    // remove last ';'
+    ret.resize(ret.size() - 1);
+
+    // return an alloced c_str, which will be freed out of this function.
+    return strdup(ret.c_str());
+}
 
 //get dolby ms12 config params
 char **DolbyMS12ConfigParams::GetDolbyMS12ConfigParams(int *argc)
 {
     ALOGD("+%s()\n", __FUNCTION__);
 
+    *argc = 0;
+    mParamNum = 0;
+
     if (argc && mConfigParams) {
         char params_bin[] = "ms12_exec";
         sprintf(mConfigParams[mParamNum++], "%s", params_bin);
@@ -1479,14 +1599,14 @@ int DolbyMS12ConfigParams::ms_get_int_from_str(char **p_csv_string, int *p_vals)
 }
 
 #if 0
-char **DolbyMS12ConfigParams::GetDolbyMS12RuntimeConfigParams(int *argc)
+char **DolbyMS12ConfigParams::GetDolbyMS12RuntimeConfigParams(int *argc, char *cmd)
 {
     ALOGD("+%s()", __FUNCTION__);
 
     if (argc && mConfigParams) {
-        char params_bin[] = "ms12_exec";
+        char params_bin[] = "ms12_runtime";
         sprintf(mConfigParams[mParamNum++], "%s", params_bin);
-        SetFunctionalSwitchesRuntime(mConfigParams, &mParamNum);
+        GetFunctionalSwitchesRuntime(mConfigParams, &mParamNum);
         SetDdplusSwitches(mConfigParams, &mParamNum);
         SetPCMSwitchesRuntime(mConfigParams, &mParamNum);
         SetOTTProcessingGraphSwitchesRuntime(mConfigParams, &mParamNum);
@@ -1594,6 +1714,18 @@ char **DolbyMS12ConfigParams::UpdateDolbyMS12RuntimeConfigParams(int *argc, char
                 ALOGI("-at AC4Ac: %d", val);
                 mAC4Ac = val;
             }
+        } else if (strcmp(opt, "xa") == 0) {
+            val = atoi(mConfigParams[index]);
+            if ((val >= 0) && (val <= 1)) {
+                ALOGI("-xa Associated audio mixing: %d", val);
+                mAssociatedAudioMixing = val;
+            }
+        } else if (strcmp(opt, "xu") == 0) {
+            val = atoi(mConfigParams[index]);
+            if ((val >= MIN_USER_CONTROL_VALUES) && (val <= MAX_USER_CONTROL_VALUES)) {
+                ALOGI("-xu User control values:[-32 (mute assoc) to 32 (mute main)] %d", val);
+                mUserControlVal = val;
+            }
         } else if (strcmp(opt, "pat") == 0) {
             val = atoi(mConfigParams[index]);
             if ((val >= 0) && (val <= 1)) {
@@ -1608,9 +1740,9 @@ char **DolbyMS12ConfigParams::UpdateDolbyMS12RuntimeConfigParams(int *argc, char
             strncpy(mAC4Lang2, mConfigParams[index], 3);
         } else if (strcmp(opt, "ac4_de") == 0) {
             val = atoi(mConfigParams[index]);
-            if ((val >= 0) && (val <= 1)) {
-                ALOGI("-ac4_de AC4Ac: %d", val);
-                mAC4Ac = val;
+            if ((val >= 0) && (val <= 12)) {
+                ALOGI("-ac4_de mAC4De: %d", val);
+                mAC4De = val;
             }
         } else if (strcmp(opt, "ac4_pres_group_idx") == 0) {
             val = atoi(mConfigParams[index]);
@@ -1708,7 +1840,7 @@ char **DolbyMS12ConfigParams::UpdateDolbyMS12RuntimeConfigParams(int *argc, char
                 &param[0], &param[1]) == 2) {
                 if ((param[0] >= 0) && (param[0] <= 2))
                     ContentDAPLeveler.leveler_enable = param[0];
-                if ((param[1] >= 0) && (param[1] <= 16))
+                if ((param[1] >= MIN_DAP_LEVELER) && (param[1] <= MAX_DAP_LEVELER))
                     ContentDAPLeveler.leveler_amount = param[1];
                 ALOGI("-dap_leveler: %d %d", param[0], param[1]);
             }
@@ -1728,6 +1860,10 @@ char **DolbyMS12ConfigParams::UpdateDolbyMS12RuntimeConfigParams(int *argc, char
                     DeviceDAPSurroundVirtualizer.surround_boost = param[1];
                 ALOGI("-dap_surround_virtualizer: %d %d", param[0], param[1]);
             }
+        } else if (strcmp(opt, "atmos_lock") == 0) {
+            val = atoi(mConfigParams[index]);
+            mAtmosLock = val ? true : false;
+            ALOGI("-atmos_lock: %d", mAtmosLock);
         }
 eq_error:
         index++;
diff --git a/libms12v2/src/DolbyMS12Status.cpp b/libms12v2/src/DolbyMS12Status.cpp
index 908acae..4b6f436 100644
--- a/libms12v2/src/DolbyMS12Status.cpp
+++ b/libms12v2/src/DolbyMS12Status.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12v2"
+#define LOG_TAG "libms12"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
@@ -41,14 +41,26 @@ namespace android
 DolbyMS12Status::DolbyMS12Status() :
     mDoblyMS12StatusInputPCM(MIXER_PLAYBACK_START)
     , mDolbyMS12StatusInputRaw(DIRECT_0R_OFFLOAD_PLAYBACK_STOP)
+    , mMixerAudioStreamOutformat(AUDIO_FORMAT_INVALID)
+    , mMixerAudioChannelMask(AUDIO_CHANNEL_NONE)
+    , mMixerAudioStreamOutSampleRate(0)
+    , mMixerOutDevices(AUDIO_DEVICE_NONE)
+    , mDirectOrOffloadAudioStreamOutformat(AUDIO_FORMAT_INVALID)
+    , mDirectOrOffloadAudioChannelMask(AUDIO_CHANNEL_NONE)
+    , mDirectOrOffloadAudioStreamOutSampleRate(0)
+    , mDirectOrOffloadOutDevices(AUDIO_DEVICE_NONE)
     , mOffloadPlaybackDolbyMS12Outputformat(AUDIO_FORMAT_DEFAULT)
     //, mForceUse(AUDIO_POLICY_FORCE_NONE)
-    , mForceUse(0)
+    , mOffloadPlaybackAudioStreamOutformat(AUDIO_FORMAT_INVALID)
     , mAudioMainFormat(AUDIO_FORMAT_INVALID)
     , mAudioAssociateFormat(AUDIO_FORMAT_INVALID)
     , mAudioSystemFormat(AUDIO_FORMAT_INVALID)
+    , mAudioAppFormat(AUDIO_FORMAT_INVALID)
     , mDDSupportFlag(false)
+    , mDDMaxAudioChannelMask(AUDIO_CHANNEL_NONE)
     , mDDPSupportFlag(false)
+    , mDDPMaxAudioChannelMask(AUDIO_CHANNEL_NONE)
+    , mMaxFormatByUserSetting(AUDIO_FORMAT_DEFAULT)
 {
     ALOGD("%s()", __FUNCTION__);
 }
@@ -108,6 +120,23 @@ audio_format_t DolbyMS12Status::getAudioSystemFormat(void)
     return mAudioSystemFormat;
 }
 
+/*
+ *@brief set Audio Hal App format
+ */
+void DolbyMS12Status::setAudioAppFormat(audio_format_t format)
+{
+    mAudioAppFormat = format;
+}
+
+/*
+ *@brief get Audio Hal App format
+ */
+audio_format_t DolbyMS12Status::getAudioAppFormat(void)
+{
+    return mAudioAppFormat;
+}
+
+
 /*
  *@brief set dd support flag
  */
diff --git a/libms12v2/src/aml_audio_ms12.c b/libms12v2/src/aml_audio_ms12.c
index b212122..90a325b 100644
--- a/libms12v2/src/aml_audio_ms12.c
+++ b/libms12v2/src/aml_audio_ms12.c
@@ -9,7 +9,7 @@
  */
 
 
-#define LOG_TAG "libms12v2"
+#define LOG_TAG "libms12"
 // #define LOG_NDEBUG 0
 
 #include <cutils/log.h>
@@ -22,6 +22,7 @@
 
 #define DOLBY_SAMPLE_SIZE 4//2ch x 2bytes(16bits) = 4 bytes
 
+
 int get_dolby_ms12_output_details(struct dolby_ms12_desc *ms12_desc)
 {
     ms12_desc->dolby_ms12_init_argv = dolby_ms12_config_params_get_config_params(&ms12_desc->dolby_ms12_init_argc);
@@ -88,7 +89,7 @@ int aml_ms12_config(struct dolby_ms12_desc *ms12_desc
                     , int config_sample_rate
                     , int output_config)
 {
-    ALOGD("+%s() %d\n", __FUNCTION__, __LINE__);
+    ALOGI("+%s() %d\n", __FUNCTION__, __LINE__);
     ms12_desc->input_config_format = config_format;
     ms12_desc->config_channel_mask = config_channel_mask;
     ms12_desc->config_sample_rate = config_sample_rate;
@@ -99,7 +100,14 @@ int aml_ms12_config(struct dolby_ms12_desc *ms12_desc
     if (get_audio_system_format() == AUDIO_FORMAT_PCM_16_BIT) {
         dolby_ms12_config_params_set_system_flag(true);
     }
-    if ((get_audio_associate_format() == AUDIO_FORMAT_AC3) || (get_audio_associate_format() == AUDIO_FORMAT_E_AC3)) {
+
+    if (get_audio_app_format() == AUDIO_FORMAT_PCM_16_BIT) {
+        dolby_ms12_config_params_set_app_flag(true);
+    }
+
+
+    if ((get_audio_associate_format() == AUDIO_FORMAT_AC3) || (get_audio_associate_format() == AUDIO_FORMAT_E_AC3) ||
+        (get_audio_associate_format() == AUDIO_FORMAT_MAT)) {
         dolby_ms12_config_params_set_associate_flag(true);
     }
     dolby_ms12_config_params_set_audio_stream_out_params(
@@ -111,7 +119,7 @@ int aml_ms12_config(struct dolby_ms12_desc *ms12_desc
     get_dolby_ms12_output_details(ms12_desc);
 
     get_dolby_ms12_init(ms12_desc);
-    ALOGD("-%s() %d\n", __FUNCTION__, __LINE__);
+    ALOGI("-%s() %d\n", __FUNCTION__, __LINE__);
     return 0;
 }
 
@@ -119,15 +127,7 @@ int aml_ms12_lib_preload() {
     int ret = 0;
     void * dolby_ms12_ptr = NULL;
     ALOGD("+%s()\n", __FUNCTION__);
-    ret = get_libdolbyms12_handle();
-    if (ret == 0) {
-        dolby_ms12_ptr = dolby_ms12_init(1, NULL);
-        if (dolby_ms12_ptr) {
-            dolby_ms12_release(dolby_ms12_ptr);
-        }
-    }
-    ALOGD("-%s()\n", __FUNCTION__);
-    return 0;
+    return get_libdolbyms12_handle();
 }
 
 int aml_ms12_lib_release() {
@@ -171,7 +171,13 @@ int aml_ms12_update_runtime_params(struct dolby_ms12_desc *ms12_desc, char *cmd)
         if (get_audio_system_format() == AUDIO_FORMAT_PCM_16_BIT) {
             dolby_ms12_config_params_set_system_flag(true);
         }
-        if ((get_audio_associate_format() == AUDIO_FORMAT_AC3) || (get_audio_associate_format() == AUDIO_FORMAT_E_AC3)) {
+
+        if (get_audio_app_format() == AUDIO_FORMAT_PCM_16_BIT) {
+            dolby_ms12_config_params_set_app_flag(true);
+        }
+
+        if ((get_audio_associate_format() == AUDIO_FORMAT_AC3) || (get_audio_associate_format() == AUDIO_FORMAT_E_AC3) ||
+            (get_audio_associate_format() == AUDIO_FORMAT_MAT)) {
             dolby_ms12_config_params_set_associate_flag(true);
         }
         ms12_desc->dolby_ms12_init_argv = dolby_ms12_config_params_update_runtime_config_params(&ms12_desc->dolby_ms12_init_argc, cmd);
@@ -213,4 +219,3 @@ int aml_ms12_update_runtime_params_lite(struct dolby_ms12_desc *ms12_desc)
     return ret;
 }
 #endif
-
diff --git a/libms12v2/src/dolby_ms12.cpp b/libms12v2/src/dolby_ms12.cpp
index 6bfe6e1..22f01ea 100644
--- a/libms12v2/src/dolby_ms12.cpp
+++ b/libms12v2/src/dolby_ms12.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12v2"
+#define LOG_TAG "libms12"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
@@ -177,6 +177,30 @@ extern "C" int dolby_ms12_input_system(void *dolbyMS12_pointer
     }
 }
 
+extern "C" int dolby_ms12_input_app(void *dolbyMS12_pointer
+                                       , const void *audio_stream_out_buffer //ms12 input buffer
+                                       , size_t audio_stream_out_buffer_size //ms12 input buffer size
+                                       , int audio_stream_out_format
+                                       , int audio_stream_out_channel_num
+                                       , int audio_stream_out_sample_rate
+                                      )
+{
+    android::DolbyMS12* dolby_ms12_instance = getInstance();
+    if (dolby_ms12_instance)
+        return dolby_ms12_instance->DolbyMS12InputApp(dolbyMS12_pointer
+                , audio_stream_out_buffer //ms12 input buffer
+                , audio_stream_out_buffer_size //ms12 input buffer size
+                , audio_stream_out_format
+                , audio_stream_out_channel_num
+                , audio_stream_out_sample_rate
+                                                        );
+    else {
+        return -1;
+    }
+}
+
+
+
 #ifdef REPLACE_OUTPUT_BUFFER_WITH_CALLBACK
 extern "C" int dolby_ms12_register_output_callback(void *callback, void *priv_data)
 {
@@ -267,6 +291,15 @@ extern "C" void dolby_ms12_flush_main_input_buffer(void)
     }
 }
 
+extern "C" void dolby_ms12_flush_app_input_buffer(void)
+{
+    ALOGI("%s()\n", __FUNCTION__);
+    android::DolbyMS12* dolby_ms12_instance = getInstance();
+    if (dolby_ms12_instance) {
+        dolby_ms12_instance->DolbyMS12FlushAppInputBuffer();
+    }
+}
+
 extern "C" void dolby_ms12_set_main_dummy(int type, int dummy)
 {
     ALOGI("%s()\n", __FUNCTION__);
@@ -277,12 +310,12 @@ extern "C" void dolby_ms12_set_main_dummy(int type, int dummy)
 }
 
 
-extern "C" unsigned long long dolby_ms12_get_consumed_payload(void)
+extern "C" unsigned long long dolby_ms12_get_decoder_n_bytes_consumed(void *ms12_pointer, int format, int is_main)
 {
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12* dolby_ms12_instance = getInstance();
     if (dolby_ms12_instance) {
-        return dolby_ms12_instance->DolbyMS12GetNBytesConsumedOfUDC();
+        return dolby_ms12_instance->DolbyMS12GetDecoderNBytesConsumed(ms12_pointer, format, is_main);
     } else {
         return -1;
     }
@@ -356,6 +389,15 @@ extern "C" int dolby_ms12_get_system_buffer_avail(int * max_size)
     }
 }
 
+extern "C" int dolby_ms12_set_main_volume(float volume)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12* dolby_ms12_instance = getInstance();
+    if (dolby_ms12_instance) {
+        return dolby_ms12_instance->DolbyMS12SetMainVolume(volume);
+    }
+    return -1;
+}
 
 extern "C" int dolby_ms12_get_input_atmos_info()
 {
@@ -367,3 +409,48 @@ extern "C" int dolby_ms12_get_input_atmos_info()
         return -1;
     }
 }
+
+
+extern "C" unsigned long long dolby_ms12_get_decoder_nframes_pcm_output(void *ms12_pointer, int format, int is_main)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12* dolby_ms12_instance = getInstance();
+    if (dolby_ms12_instance) {
+        return dolby_ms12_instance->DolbyMS12GetDecoderNFramesPcmOutput(ms12_pointer, format, is_main);
+    } else {
+        return -1;
+    }
+}
+
+extern "C" void dolby_ms12_set_debug_level(int level)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12* dolby_ms12_instance = getInstance();
+    if (dolby_ms12_instance) {
+        dolby_ms12_instance->DolbyMS12SetDebugLevel(level);
+    }
+}
+
+extern "C" unsigned long long dolby_ms12_get_consumed_sys_audio(void)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12* dolby_ms12_instance = getInstance();
+    if (dolby_ms12_instance) {
+        return dolby_ms12_instance->DolbyMS12GetNBytesConsumedSysSound();
+    } else {
+        return -1;
+    }
+}
+
+extern "C" int dolby_ms12_get_total_nframes_delay(void *ms12_pointer)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12* dolby_ms12_instance = getInstance();
+    if (dolby_ms12_instance) {
+        return dolby_ms12_instance->DolbyMS12GetTotalNFramesDelay(ms12_pointer);
+    } else {
+        return -1;
+    }
+}
+
+
diff --git a/libms12v2/src/dolby_ms12_config_params.cpp b/libms12v2/src/dolby_ms12_config_params.cpp
index b02be5a..1dc1eb5 100644
--- a/libms12v2/src/dolby_ms12_config_params.cpp
+++ b/libms12v2/src/dolby_ms12_config_params.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12v2"
+#define LOG_TAG "libms12"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
@@ -108,6 +108,26 @@ extern "C" bool dolby_ms12_config_params_get_system_flag(void)
     }
 }
 
+extern "C" void dolby_ms12_config_params_set_app_flag(bool flag)
+{
+    ALOGV("%s() system flag %d\n", __FUNCTION__, flag);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        config_param->setAppFlag(flag);
+    }
+}
+
+extern "C" bool dolby_ms12_config_params_get_app_flag(void)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        return config_param->getAppFlag();
+    } else {
+        return false;
+    }
+}
+
 extern "C" void dolby_ms12_config_params_set_audio_stream_out_params(
     audio_output_flags_t flags
     , audio_format_t input_format
@@ -122,6 +142,33 @@ extern "C" void dolby_ms12_config_params_set_audio_stream_out_params(
     }
 }
 
+extern "C" void dolby_ms12_config_params_set_channel_mask_app(int mask)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        config_param->setChannelMaskOfAppSoundsInput(mask);
+    }
+}
+
+extern "C" void dolby_ms12_config_params_set_channel_mask_system(int mask)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        config_param->setChannelMaskOfSystemSoundsInput(mask);
+    }
+}
+
+extern "C" void dolby_ms12_config_params_set_channel_mask_ui(int mask)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        config_param->setChannelMaskOfUiSoundsInput(mask);
+    }
+}
+
 /*config params begin*/
 /**/
 extern "C" int dolby_ms12_config_params_set_input_output_file_name(char **ConfigParams, int *row_index)
@@ -208,6 +255,16 @@ extern "C" int dolby_ms12_config_params_set_dap_content_switches(char **ConfigPa
 /**/
 /*config params end*/
 
+extern "C" char *dolby_ms12_query_dap_parameters(const char *key)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        return config_param->QueryDapParameters(key);
+    } else {
+        return NULL;
+    }
+}
 extern "C" char **dolby_ms12_config_params_get_config_params(int *argc)
 {
     ALOGV("%s()\n", __FUNCTION__);
@@ -272,7 +329,7 @@ extern "C" void dolby_ms12_config_params_cleanup_config_params(char **ConfigPara
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
     if (config_param) {
-        return config_param->CleanupConfigParams(ConfigParams, max_raw_size);
+        config_param->CleanupConfigParams(ConfigParams, max_raw_size);
     }
 }
 extern "C" int dolby_ms12_config_params_get_dobly_config_output_config(void)
@@ -313,7 +370,7 @@ extern "C" void dolby_ms12_config_params_reset_config_params(void)
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
     if (config_param) {
-        return config_param->ResetConfigParams();
+        config_param->ResetConfigParams();
     }
 }
 
@@ -330,7 +387,7 @@ extern "C" void dolby_ms12_set_drc_boost(int val)
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
     if (config_param) {
-        return config_param->setDRCboostVal(val);
+        config_param->setDRCboostVal(val);
     }
 }
 
@@ -339,11 +396,11 @@ extern "C" void dolby_ms12_set_drc_cut(int val)
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
     if (config_param) {
-        return config_param->setDRCcutVal(val);
+        config_param->setDRCcutVal(val);
     }
 }
 
-extern "C" void dolby_ms12_set_drc_boost_system(int val)
+extern "C" void dolby_ms12_set_drc_boost_stereo(int val)
 {
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
@@ -361,21 +418,30 @@ extern "C" void dolby_ms12_set_drc_cut_stereo(int val)
     }
 }
 
-extern "C" void dolby_ms12_set_channel_config_of_app_sound_input(audio_channel_mask_t channel_mask)
+extern "C" void dolby_ms12_set_channel_mask_of_app_sound_input(audio_channel_mask_t channel_mask)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        config_param->setChannelMaskOfAppSoundsInput(channel_mask);
+    }
+}
+
+extern "C" void dolby_ms12_set_channel_mask_of_system_sound_input(audio_channel_mask_t channel_mask)
 {
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
     if (config_param) {
-        config_param->setChannelConfigOfAppSoundsInput(channel_mask);
+        config_param->setChannelMaskOfSystemSoundsInput(channel_mask);
     }
 }
 
-extern "C" void dolby_ms12_set_channel_config_of_system_sound_input(audio_channel_mask_t channel_mask)
+extern "C" void dolby_ms12_set_channel_mask_of_ui_sound_input(audio_channel_mask_t channel_mask)
 {
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
     if (config_param) {
-        config_param->setChannelConfigOfSystemSoundsInput(channel_mask);
+        config_param->setChannelMaskOfUiSoundsInput(channel_mask);
     }
 }
 
@@ -433,23 +499,6 @@ extern "C" void dolby_ms12_set_evalution_mode(int val)
     }
 }
 
-extern "C" void dolby_ms12_set_lfe_present_in_app_sounds_in(int val)
-{
-    ALOGV("%s()\n", __FUNCTION__);
-    android::DolbyMS12ConfigParams *config_param = getInstance();
-    if (config_param) {
-        config_param->setLFEpresentInAPPSoundsIn(val);
-    }
-}
-
-extern "C" void dolby_ms12_set_lfe_present_in_system_sounds_in(int val)
-{
-    ALOGV("%s()\n", __FUNCTION__);
-    android::DolbyMS12ConfigParams *config_param = getInstance();
-    if (config_param) {
-        config_param->setLFEpresetInSystemSoundsIn(val);
-    }
-}
 
 extern "C" void dolby_ms12_set_donwmix_51_pcm_to_51_on_multi_outputs(int val)
 {
@@ -571,25 +620,18 @@ extern "C" void dolby_ms12_set_system_sound_mixer_gain_values_for_system_sounds_
 }
 
 //DDPLUS SWITCHES
-
-//PCM SWITCHES
-extern "C" void dolby_ms12_set_channel_config_of_external_pcm_input(audio_channel_mask_t channel_mask)
+#if 0
+extern "C" void dolby_ms12_set_ddp_associated_substream_selection(int val)
 {
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
     if (config_param) {
-        config_param->setChnanelConfOfExternalPCMInput(channel_mask);
+        config_param->setDDPAssociatedSubstreamSelection(val);
     }
 }
+#endif
 
-extern "C" void dolby_ms12_set_lfe_present_in_external_pcm_input(int val)
-{
-    ALOGV("%s()\n", __FUNCTION__);
-    android::DolbyMS12ConfigParams *config_param = getInstance();
-    if (config_param) {
-        config_param->setLFEpresentInExternalPCMInput(val);
-    }
-}
+//PCM SWITCHES
 
 extern "C" void dolby_ms12_set_pcm_compressor_profile(int val)
 {
@@ -688,7 +730,7 @@ extern "C" void dolby_ms12_set_heaac_dualmono_reproduction_mode(int val)
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
     if (config_param) {
-        return config_param->setDualMonoreproductionMode(val);
+        config_param->setDualMonoreproductionMode(val);
     }
 }
 
@@ -697,10 +739,11 @@ extern "C" void dolby_ms12_set_heaac_arib_channel_mapping_flag(int val)
     ALOGV("%s()\n", __FUNCTION__);
     android::DolbyMS12ConfigParams *config_param = getInstance();
     if (config_param) {
-        return config_param->setAribChannelMappingFlag(val);
+        config_param->setAribChannelMappingFlag(val);
     }
 }
 
+
 //DAP SWITCHES (device specific)
 extern "C" void dolby_ms12_set_dap_gains(int val)
 {
@@ -731,6 +774,18 @@ extern "C" void dolby_ms12_set_dap_surround_virtuallizer(DAPSurroundVirtualizer
 }
 
 
+extern "C" int dolby_ms12_get_dap_surround_virtuallizer(void)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        return config_param->getDAPSurroundVirtualizer();
+    } else {
+        return -1;
+    }
+}
+
+
 extern "C" void dolby_ms12_set_dap_graphic_eq(DAPGraphicEQ *dapGraphicEQParamters)
 {
     ALOGV("%s()\n", __FUNCTION__);
@@ -796,6 +851,15 @@ extern "C" void dolby_ms12_set_dap_dialogue_enhancer(DAPDialogueEnhancer *dapDia
     }
 }
 
+extern "C" void dolby_ms12_set_dual_output_flag(bool need_dual_output)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        config_param->setDualOutputFlag(need_dual_output);
+    }
+}
+
 extern "C" void set_dolby_ms12_continuous_mode(bool flag)
 {
     ALOGV("%s()\n", __FUNCTION__);
@@ -906,6 +970,32 @@ extern "C" bool dolby_ms12_get_ott_sound_input_enable(void)
     }
 }
 
+extern "C" void dolby_ms12_set_ddp_5_1_out(bool flag)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        config_param->setLegacyDDPOut(flag);
+    }
+    else {
+        ALOGW("Found the config_param handle illegal\n");
+    }
+}
+
+
+extern "C" bool dolby_ms12_get_ddp_5_1_out(void)
+{
+    ALOGV("%s()\n", __FUNCTION__);
+    android::DolbyMS12ConfigParams *config_param = getInstance();
+    if (config_param) {
+        return config_param->getLegacyDDPOut();
+    } else {
+        ALOGW("Found the config_param handle illegal\n");
+        return false;
+    }
+}
+
+
 /*****************************************************************************************************************/
 /*END*/
 /*****************************************************************************************************************/
diff --git a/libms12v2/src/dolby_ms12_status.cpp b/libms12v2/src/dolby_ms12_status.cpp
index 641bc64..6e62523 100644
--- a/libms12v2/src/dolby_ms12_status.cpp
+++ b/libms12v2/src/dolby_ms12_status.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12v2"
+#define LOG_TAG "libms12"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
@@ -253,6 +253,30 @@ extern "C" audio_format_t get_audio_system_format(void)
     }
 }
 
+/*
+ *@brief set Audio Hal App format
+ */
+extern "C" void set_audio_app_format(audio_format_t format)
+{
+    android::DolbyMS12Status* dolby_ms12_status_instance = getInstance();
+    if (dolby_ms12_status_instance) {
+        return dolby_ms12_status_instance->setAudioAppFormat(format);
+    }
+}
+
+/*
+ *@brief get Audio Hal App format
+ */
+extern "C" audio_format_t get_audio_app_format(void)
+{
+    android::DolbyMS12Status* dolby_ms12_status_instance = getInstance();
+    if (dolby_ms12_status_instance) {
+        return dolby_ms12_status_instance->getAudioAppFormat();
+    } else {
+        return AUDIO_FORMAT_INVALID;
+    }
+}
+
 
 /*
  *@brief set TV audio main format
diff --git a/utils/SPDIFEncoderAD.cpp b/utils/SPDIFEncoderAD.cpp
index f41edbd..84c7b24 100755
--- a/utils/SPDIFEncoderAD.cpp
+++ b/utils/SPDIFEncoderAD.cpp
@@ -62,7 +62,9 @@ public:
             memcpy((void *)iec61937_buffer, (const void*)buffer, actual_write_size);
         else
             return -1;
+#if 0
         if (actual_write_size > 0) {
+#endif
             outBufCurrentPos += actual_write_size;
             mTotalBytes += actual_write_size;
             ALOGV("%s() actual_write_size %zu outBufCurrentPos %zu\n", __FUNCTION__, actual_write_size, outBufCurrentPos);
@@ -79,9 +81,11 @@ public:
             }
 #endif
             return actual_write_size;
+#if 0
         }
         else
             return -1;
+#endif
     }
     /*
      *@brief get current iec61937 data size
diff --git a/utils/ac3_parser_utils.c b/utils/ac3_parser_utils.c
index 95c6a7b..b17cb04 100755
--- a/utils/ac3_parser_utils.c
+++ b/utils/ac3_parser_utils.c
@@ -200,8 +200,8 @@ int parse_dolby_frame_header
         //ALOGV("dolby head:0x%x 0x%x 0x%x 0x%x 0x%x 0x%x \n",
         //    inheader[0],inheader[1],inheader[2], inheader[3],inheader[4],inheader[5]);
         int bsid = (inheader[5] >> 3) & 0x1f;//bitstream_id,bit[40,44]
-        if (bsid > 16)
-            goto error;//invalid bitstream_id
+        /*if (bsid > 32)
+            goto error;//invalid bitstream_id*/
         if (bsid <= 8)
             nIsEc3 = 0;
         else if ( (bsid <= 16) && (bsid > 10) )
@@ -252,27 +252,25 @@ int parse_dolby_frame_header
             lfeOn = inheader[4] &0x1;
             numblkscod = (sr_code == 0x3) ? 0x3 : ( (inheader[4] >> 4) & 0x3);
             numblk_per_frame = (numblkscod == 0x3) ? 6 : (numblkscod + 1);
-
+            ALOGV("%s() ec3 numblkscod %d numblk_per_frame %d substreamid %d strmtyp %d\n",
+                __FUNCTION__, numblkscod, numblk_per_frame, substreamid, strmtyp);
             if (substreamid == 0 && strmtyp == 0) {
                 if (*framevalid_flag == 0) {
                     *timeslice_61937 = 0;
-                    *numblks += numblk_per_frame;
                     *framevalid_flag = 1;
                 } else if (*framevalid_flag == 1) {
                     if (*numblks  == 6) {
                         *timeslice_61937 = 1;
-                        *numblks = numblk_per_frame;
                     } else if (*numblks  > 6) {
                         *timeslice_61937 = 2;
-                        *numblks = numblk_per_frame;
                     } else {
                         *timeslice_61937 = 0;
-                        *numblks += numblk_per_frame;
                     }
                 }
             } else if (strmtyp == 1) {
                 *timeslice_61937 = 3;
             }
+            *numblks = numblk_per_frame;
 
         }
         // ALOGV("%s acmod %d lfeOn %d\n", nIsEc3==0?"ac3":"ec3",acmod, lfeOn);
diff --git a/utils/alsa_device_parser.c b/utils/alsa_device_parser.c
index 788c39f..0f29e93 100644
--- a/utils/alsa_device_parser.c
+++ b/utils/alsa_device_parser.c
@@ -135,6 +135,7 @@ int alsa_device_get_card_index()
 			p_aml_alsa_info = calloc(1, sizeof(struct alsa_info));
 			if (!p_aml_alsa_info) {
 				ALOGE ("NOMEM for alsa info\n");
+				fclose(mCardFile);
 				return -1;
 			}
 		}
@@ -209,7 +210,9 @@ void alsa_device_parser_pcm_string(struct alsa_info *p_info, char *InputBuffer)
 			memcpy(mStreamName, Rch, 256);
 			PortName = strstr(mStreamName, "alsaPORT-");
 			if (PortName) {
-				memcpy(mAudioDeviceDescriptor->name, PortName, strlen(PortName));
+				int len = strlen(PortName) > NAME_LEN - 1 ? NAME_LEN - 1 : strlen(PortName);
+				memcpy(mAudioDeviceDescriptor->name, PortName, len);
+				mAudioDeviceDescriptor->name[len] = 0;
 
 				if (!strncmp(PortName, ALSAPORT_PCM, strlen(ALSAPORT_PCM)))
 					p_info->pcm_descrpt = mAudioDeviceDescriptor;
@@ -235,13 +238,22 @@ void alsa_device_parser_pcm_string(struct alsa_info *p_info, char *InputBuffer)
 					p_info->lpbk_descrpt = mAudioDeviceDescriptor;
 				else if (!strncmp(PortName, ALSAPORT_EARC, strlen(ALSAPORT_EARC)))
 					p_info->earc_descrpt = mAudioDeviceDescriptor;
-				else
+				else {
 					free(mAudioDeviceDescriptor);
-
+					ALOGD("\tstream no alsaPORT prefix name, StreamName:%s\n", mStreamName);
+					return;
+				}
 				if (strstr(PortName, ALSAPORT_BUILTINMIC) != NULL)
 					p_info->builtinmic_descrpt = mAudioDeviceDescriptor;
-			} else
+			} else {
 				ALOGD("\tstream no alsaPORT prefix name, StreamName:%s\n", mStreamName);
+				free(mAudioDeviceDescriptor);
+				return;
+			}
+		}else {
+			free(mAudioDeviceDescriptor);
+			ALOGE("%s not find device descriptor\n", __FUNCTION__);
+			return;
 		}
 		ALOGD("%s mCardindex:%d, mPcmindex:%d, PortName:%s\n", __FUNCTION__, mAudioDeviceDescriptor->mCardindex, mAudioDeviceDescriptor->mPcmIndex, PortName);
 		Rch = strtok(NULL, ": ");
diff --git a/utils/aml_alsa_mixer.c b/utils/aml_alsa_mixer.c
index c98fe53..472eeec 100644
--- a/utils/aml_alsa_mixer.c
+++ b/utils/aml_alsa_mixer.c
@@ -27,8 +27,6 @@
 #include <errno.h>
 #include <cutils/log.h>
 #include <fcntl.h>
-#include <pthread.h>
-#include <tinyalsa/asoundlib.h>
 #include <aml_alsa_mixer.h>
 #include "alsa_device_parser.h"
 
@@ -45,6 +43,11 @@ static struct aml_mixer_list gAmlMixerList[] = {
     /* for HDMI ARC status */
     {AML_MIXER_ID_HDMI_ARC_AUDIO_ENABLE, "HDMI ARC Switch"},
     {AML_MIXER_ID_HDMI_EARC_AUDIO_ENABLE, "eARC_RX attended type"},
+    /* eARC RX/TX latency and Capability Data Structure */
+    {AML_MIXER_ID_EARCRX_LATENCY, "eARC_RX Latency"},
+    {AML_MIXER_ID_EARCTX_LATENCY, "eARC_TX Latency"},
+    {AML_MIXER_ID_EARCRX_CDS, "eARC_RX CDS"},
+    {AML_MIXER_ID_EARCTX_CDS, "eARC_TX CDS"},
     {AML_MIXER_ID_AUDIO_IN_SRC,         "Audio In Source"},
     {AML_MIXER_ID_I2SIN_AUDIO_TYPE,     "I2SIN Audio Type"},
     {AML_MIXER_ID_SPDIFIN_AUDIO_TYPE,   "SPDIFIN Audio Type"},
@@ -78,7 +81,10 @@ static struct aml_mixer_list gAmlMixerList[] = {
     {AML_MIXER_ID_AED_MULTI_DRC_ENABLE, "AED Multi-band DRC enable"},
     {AML_MIXER_ID_AED_FULL_DRC_ENABLE,  "AED Full-band DRC enable"},
     {AML_MIXER_ID_SPDIF_IN_SAMPLERATE,  "SPDIFIN audio samplerate"},
+    {AML_MIXER_ID_HW_RESAMPLE_SOURCE,   "Hw resample module"},
+    {AML_MIXER_ID_AUDIO_HAL_FORMAT,     "Audio HAL Format"},
     {AML_MIXER_ID_EARC_AUDIO_TYPE,      "eARC_TX Audio Codec Type"},
+    {AML_MIXER_ID_HDMIIN_AUDIO_EDID,    "HDMIIN AUDIO EDID"},
 };
 
 static char *get_mixer_name_by_id(int mixer_id)
@@ -130,12 +136,11 @@ int close_mixer_handle(struct aml_mixer_handle *mixer_handle)
 
 static struct mixer_ctl *get_mixer_ctl_handle(struct mixer *pmixer, int mixer_id)
 {
+    char *name = get_mixer_name_by_id(mixer_id);
     struct mixer_ctl *pCtrl = NULL;
 
-    if (get_mixer_name_by_id(mixer_id) != NULL) {
-        pCtrl = mixer_get_ctl_by_name(pmixer,
-                                      get_mixer_name_by_id(mixer_id));
-    }
+    if (name)
+        pCtrl = mixer_get_ctl_by_name(pmixer, name);
 
     return pCtrl;
 }
@@ -245,3 +250,67 @@ int aml_mixer_ctrl_set_str(struct aml_mixer_handle *mixer_handle, int mixer_id,
 
     return 0;
 }
+
+int aml_mixer_ctrl_set_array(struct aml_mixer_handle *mixer_handle, int mixer_id, void *array, int count)
+{
+    struct mixer *pMixer = mixer_handle->pMixer;
+    struct mixer_ctl *pCtrl;
+
+    if (pMixer == NULL) {
+        ALOGE("[%s:%d] pMixer is invalid!\n", __FUNCTION__, __LINE__);
+        return -1;
+    }
+
+    pthread_mutex_lock(&mixer_handle->lock);
+    pCtrl = get_mixer_ctl_handle(pMixer, mixer_id);
+    if (pCtrl == NULL) {
+        ALOGE("[%s:%d] Failed to open mixer %s\n", __FUNCTION__, __LINE__,
+              get_mixer_name_by_id(mixer_id));
+        pthread_mutex_unlock(&mixer_handle->lock);
+        return -1;
+    }
+    mixer_ctl_set_array(pCtrl, array, count);
+    pthread_mutex_unlock(&mixer_handle->lock);
+
+    return 0;
+}
+
+int mixer_get_int(struct mixer *pMixer, int mixer_id)
+{
+    struct mixer_ctl *pCtrl = get_mixer_ctl_handle(pMixer, mixer_id);
+
+    if (!pCtrl)
+        return -EINVAL;
+
+    return mixer_ctl_get_value(pCtrl, mixer_id);
+}
+
+int mixer_set_int(struct mixer *pMixer, int mixer_id, int value)
+{
+    struct mixer_ctl *pCtrl = get_mixer_ctl_handle(pMixer, mixer_id);
+
+    if (!pCtrl)
+        return -EINVAL;
+
+    return mixer_ctl_set_value(pCtrl, mixer_id, value);
+}
+
+int mixer_get_array(struct mixer *pMixer, int mixer_id, void *array, int count)
+{
+    struct mixer_ctl *pCtrl = get_mixer_ctl_handle(pMixer, mixer_id);
+
+    if (!pCtrl)
+        return -EINVAL;
+
+    return mixer_ctl_get_array(pCtrl, array, count);
+}
+
+int mixer_set_array(struct mixer *pMixer, int mixer_id, void *array, int count)
+{
+    struct mixer_ctl *pCtrl = get_mixer_ctl_handle(pMixer, mixer_id);
+
+    if (!pCtrl)
+        return -EINVAL;
+
+    return mixer_ctl_set_array(pCtrl, array, count);
+}
diff --git a/utils/aml_android_utils.c b/utils/aml_android_utils.c
index 7b24564..4b280cd 100755
--- a/utils/aml_android_utils.c
+++ b/utils/aml_android_utils.c
@@ -73,12 +73,13 @@ int aml_getprop_int(const char *path)
 */
 int aml_sysfs_get_int (const char *path)
 {
-	int val = 0;
+	int val = 0, nread;
 	int fd = open (path, O_RDONLY);
 	if (fd >= 0) {
 		char bcmd[16];
-		read (fd, bcmd, sizeof (bcmd));
-		val = strtol (bcmd, NULL, 10);
+		nread = read (fd, bcmd, sizeof (bcmd));
+		if (nread > 0)
+			val = strtol (bcmd, NULL, 10);
 		close (fd);
 	} else {
 		ALOGE("%s: open %s node failed! return 0, err: %s\n", __func__, path, strerror(errno));
@@ -89,15 +90,17 @@ int aml_sysfs_get_int (const char *path)
 
 int aml_sysfs_get_int16(const char *path,unsigned *value)
 {
-	int fd;
+	int fd, nread;
 	char valstr[64];
 	unsigned  val = 0;
 
 	fd = open(path, O_RDONLY);
 	if (fd >= 0) {
 		memset(valstr, 0, 64);
-		read(fd, valstr, 64 - 1);
-		valstr[strlen(valstr)] = '\0';
+		nread = read(fd, valstr, 64 - 1);
+		if (nread < 0)
+			nread = 0;
+		valstr[nread] = '\0';
 		close(fd);
 	} else {
 		ALOGE("%s: unable to open file %s, err: %s\n", __func__, path, strerror(errno));
diff --git a/utils/aml_audio_mixer.c b/utils/aml_audio_mixer.c
index cd6ed2a..42af02c 100755
--- a/utils/aml_audio_mixer.c
+++ b/utils/aml_audio_mixer.c
@@ -175,7 +175,7 @@ int aml_start_audio_mixer (struct aml_audio_mixer *audio_mixer)
     struct ring_buf_desc *main_desc = NULL;
     int period_byte = 0;
 
-    if (audio_mixer == NULL && !aml_audio_mixer_check_status (audio_mixer) )
+    if (audio_mixer == NULL || !aml_audio_mixer_check_status (audio_mixer) )
         return -EINVAL;
 
     main_desc = &audio_mixer->main_in_buf;
diff --git a/utils/aml_configs/aml_conf_parser.c b/utils/aml_configs/aml_conf_parser.c
index 3226b08..7417a65 100755
--- a/utils/aml_configs/aml_conf_parser.c
+++ b/utils/aml_configs/aml_conf_parser.c
@@ -205,6 +205,7 @@ int parser_load_from_file(struct parser *pParser, const char *filename)
     SECTION *pCurSection = NULL;
     char             *pM = NULL;
     SECTION        *pSec = NULL;
+    int len;
 
     // open the config file
     ALOGD("%s: name = %s", __func__, filename);
@@ -212,7 +213,8 @@ int parser_load_from_file(struct parser *pParser, const char *filename)
         ALOGE("[%s:%d]\n", __func__, __LINE__);
         return -1;
     }
-    strcpy(pParser->mpFileName, filename);
+    len = sizeof(filename) > (MAX_PASER_NAME_LEN - 1) ? (MAX_PASER_NAME_LEN - 1) : sizeof(filename);
+    strncpy(pParser->mpFileName, filename, len);
     pParser->m_pIniFile = fopen(pParser->mpFileName, "r");
     if (pParser->m_pIniFile == NULL) {
         // open default config file
@@ -251,7 +253,7 @@ int parser_load_from_file(struct parser *pParser, const char *filename)
         /* insert the the link */
         if (pParser->mpFirstLine == NULL) {
             pParser->mpFirstLine = pLINE;
-        } else {
+        } else if (pCurLINE) {
             pCurLINE->pNext = pLINE;
         }
         pCurLINE = pLINE;
@@ -264,7 +266,7 @@ int parser_load_from_file(struct parser *pParser, const char *filename)
             pSec->pNext = NULL;
             if (pParser->mpFirstSection == NULL) { //first section
                 pParser->mpFirstSection = pSec;
-            } else {
+            } else if (pCurSection) {
                 pCurSection->pNext = pSec;
             }
             pCurSection = pSec;
diff --git a/utils/aml_data_utils.c b/utils/aml_data_utils.c
index 75b19d1..0c731bc 100644
--- a/utils/aml_data_utils.c
+++ b/utils/aml_data_utils.c
@@ -47,6 +47,7 @@
 #define AMLOGE ALOGE
 #define AMLOGD ALOGD
 #endif
+#define NAME_LEN 50
 
 static struct aml_audio_channel_name gAudioChName[] = {
 	{AML_CH_IDX_L,   "left"},
@@ -236,7 +237,7 @@ static int _save_conf_to_maps(struct aml_channel_map *maps,
 struct aml_channel_map *data_load_product_config(void)
 {
 	struct parser *gParser = NULL;
-	char   chname[50];
+	char   chname[NAME_LEN];
 	struct aml_channel_map *maps = NULL;
 	int i = 0;
 	int find_idx, invert, ditter;
@@ -259,8 +260,8 @@ struct aml_channel_map *data_load_product_config(void)
 	if (gParser != NULL) {
 		// loop of i2s channel [0, 8]
 		for (i=0; i<AML_CH_IDX_MAX; i++) {
-			strcpy(chname, aml_config_get_str(gParser, AML_SECTION_AUDIO_HAL,
-						_get_ch_conf_name(eAmlConfTypeChMap, i), NULL));
+			strncpy(chname, aml_config_get_str(gParser, AML_SECTION_AUDIO_HAL,
+						_get_ch_conf_name(eAmlConfTypeChMap, i), NULL), NAME_LEN - 1);
 			invert   = aml_config_get_int(gParser, AML_SECTION_AUDIO_HAL,
 						_get_ch_conf_name(eAmlConfTypeChInv, i), 0);
 			ditter   = aml_config_get_int(gParser, AML_SECTION_AUDIO_HAL,
@@ -377,12 +378,6 @@ static int _data_remix_center_to_lr(void *buf, size_t frames, size_t framesz, in
 		return -1;
 	}
 
-	///< TODO:
-	if (framesz != e16BitPerSample) {
-		AMLOGD("%s: only support 16bit now!\n", __func__);
-		return -1;
-	}
-
 	switch (framesz) {
 	case e16BitPerSample:
 		///< 3/0 input L_out/R_out =  = 0.707*(L/R + 0.707*C);
@@ -404,6 +399,12 @@ static int _data_remix_center_to_lr(void *buf, size_t frames, size_t framesz, in
 		break;
 	}
 
+	///< TODO:
+	if (framesz != e16BitPerSample) {
+		AMLOGD("%s: only support 16bit now!\n", __func__);
+		return -1;
+	}
+
 	return 0;
 }
 
@@ -439,12 +440,6 @@ static int _data_remix_all_to_lr(void *buf,	size_t frames, size_t framesz, int c
 		return -1;
 	}
 
-	///< TODO:
-	if (framesz != e16BitPerSample) {
-		AMLOGD("%s: only support 16bit now!\n", __func__);
-		return -1;
-	}
-
 	switch (framesz) {
 	case e16BitPerSample:
 		for (i = 0; i < (int)frames; i++) {
@@ -471,6 +466,12 @@ static int _data_remix_all_to_lr(void *buf,	size_t frames, size_t framesz, int c
 		break;
 	}
 
+	///< TODO:
+	if (framesz != e16BitPerSample) {
+		AMLOGD("%s: only support 16bit now!\n", __func__);
+		return -1;
+	}
+
 	return 0;
 }
 
@@ -609,8 +610,8 @@ int data_replace_lfe_data(
 	int32_t *buf_out32 = (int32_t *)out_buf;
 	int16_t *buf_in16  = (int16_t *)input_lfe_buffer;
 	int32_t *buf_in32  = (int32_t *)input_lfe_buffer;
-	int     lfe_base;
-	int     lfe_cnt;
+	int     lfe_base = 2;
+	int     lfe_cnt = 2;
 
 	//TODO:
 	if (out_channels != 6) {
diff --git a/utils/aml_dump_debug.c b/utils/aml_dump_debug.c
index f2f54b9..950bf81 100644
--- a/utils/aml_dump_debug.c
+++ b/utils/aml_dump_debug.c
@@ -31,7 +31,6 @@
 #undef  LOG_TAG
 #define LOG_TAG "aml_dump_debug"
 
-static int gDumpDataFd = -1;
 
 void DoDumpData(const void *data_buf, int size, int aud_src_type) {
     int tmp_type = -1;
@@ -42,10 +41,6 @@ void DoDumpData(const void *data_buf, int size, int aud_src_type) {
     property_get("media.audiohal.dumpdata.en", prop_value, "null");
     if (strcasecmp(prop_value, "null") == 0
             || strcasecmp(prop_value, "0") == 0) {
-        if (gDumpDataFd >= 0) {
-            close(gDumpDataFd);
-            gDumpDataFd = -1;
-        }
         return;
     }
 
@@ -71,26 +66,15 @@ void DoDumpData(const void *data_buf, int size, int aud_src_type) {
     if (strcasecmp(file_path, "null") == 0) {
         file_path[0] = '\0';
     }
-
-    if (gDumpDataFd < 0 && file_path[0] != '\0') {
-        if (access(file_path, 0) == 0) {
-            gDumpDataFd = open(file_path, O_RDWR | O_SYNC);
-            if (gDumpDataFd < 0) {
-                ALOGE("%s, Open device file \"%s\" error: %s.\n",
-                        __FUNCTION__, file_path, strerror(errno));
-            }
+    FILE *fp1 = fopen(file_path, "a+");
+    if (fp1) {
+        int flen = fwrite((char *)data_buf, 1, size, fp1);
+        if (flen > 0) {
+            ALOGV("%s buffer %p size %d\n", __FUNCTION__, data_buf, size);
         } else {
-            gDumpDataFd = open(file_path, O_WRONLY | O_CREAT | O_EXCL,
-                    S_IRUSR | S_IWUSR);
-            if (gDumpDataFd < 0) {
-                ALOGE("%s, Create device file \"%s\" error: %s.\n",
-                        __FUNCTION__, file_path, strerror(errno));
-            }
+            ALOGV("%s error flen %d\n", __FUNCTION__, flen);
         }
-    }
-
-    if (gDumpDataFd >= 0) {
-        write(gDumpDataFd, data_buf, size);
+        fclose(fp1);
     }
     return;
 }
diff --git a/utils/aml_malloc_debug.c b/utils/aml_malloc_debug.c
new file mode 100644
index 0000000..415e414
--- /dev/null
+++ b/utils/aml_malloc_debug.c
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2019 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "aml_audio_malloc"
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <cutils/list.h>
+#include <cutils/log.h>
+#include <pthread.h>
+#include "aml_malloc_debug.h"
+
+#define MEMINFO_SHOW_FILENAME  "/data/audio_meminfo"
+
+enum {
+    MEMINFO_SHOW_PRINT,
+    MEMINFO_SHOW_FILE
+};
+
+
+struct aml_malloc_node {
+    struct listnode list;
+    char file_name[128];
+    uint32_t line;
+    void * pointer;
+    size_t size;
+};
+
+struct aml_malloc_debug {
+    struct listnode malloc_list;
+    pthread_mutex_t malloc_lock;
+};
+
+static struct aml_malloc_debug *gaudio_malloc_handle = NULL;
+static char aml_malloc_temp_buf[256];
+
+static void add_malloc_node(struct aml_malloc_node * malloc_node)
+{
+    struct aml_malloc_debug *pmalloc_handle = NULL;
+    pmalloc_handle = gaudio_malloc_handle;
+
+    pthread_mutex_lock(&pmalloc_handle->malloc_lock);
+    list_add_tail(&pmalloc_handle->malloc_list, &malloc_node->list);
+    pthread_mutex_unlock(&pmalloc_handle->malloc_lock);
+    return;
+}
+
+static void remove_malloc_item(void* pointer)
+{
+    struct listnode *node = NULL;
+    struct aml_malloc_node * malloc_node = NULL;
+    struct aml_malloc_debug *pmalloc_handle = NULL;
+    pmalloc_handle = gaudio_malloc_handle;
+
+    pthread_mutex_lock(&pmalloc_handle->malloc_lock);
+    list_for_each(node, &pmalloc_handle->malloc_list) {
+        malloc_node = node_to_item(node, struct aml_malloc_node, list);
+        if (malloc_node->pointer == pointer) {
+            list_remove(&malloc_node->list);
+            free(malloc_node);
+            break;
+        }
+    }
+
+    pthread_mutex_unlock(&pmalloc_handle->malloc_lock);
+    return;
+}
+
+
+void aml_audio_debug_malloc_open(void)
+{
+    struct aml_malloc_debug *pmalloc_handle = NULL;
+    pmalloc_handle = (struct aml_malloc_debug *)malloc(sizeof(struct aml_malloc_debug));
+    if (pmalloc_handle == NULL) {
+        ALOGE("%s failed", __FUNCTION__);
+        return;
+    }
+    list_init(&pmalloc_handle->malloc_list);
+    pthread_mutex_init(&pmalloc_handle->malloc_lock, NULL);
+    gaudio_malloc_handle = pmalloc_handle;
+    return;
+}
+
+void aml_audio_debug_malloc_close(void)
+{
+    struct aml_malloc_debug *pmalloc_handle = NULL;
+    struct aml_malloc_node *malloc_node = NULL;
+    struct listnode *node = NULL, *n = NULL;
+    pmalloc_handle = gaudio_malloc_handle;
+    if (pmalloc_handle == NULL) {
+        return;
+    }
+    pthread_mutex_lock(&pmalloc_handle->malloc_lock);
+    list_for_each_safe(node, n, &pmalloc_handle->malloc_list) {
+        malloc_node = node_to_item(node, struct aml_malloc_node, list);
+        list_remove(&malloc_node->list);
+        free(malloc_node);
+    }
+    pthread_mutex_unlock(&pmalloc_handle->malloc_lock);
+    free(pmalloc_handle);
+    gaudio_malloc_handle = NULL;
+    return;
+}
+void* aml_audio_debug_malloc(size_t size, char * file_name, uint32_t line)
+{
+    void * pointer = NULL;
+    struct aml_malloc_node * malloc_node = NULL;
+
+    pointer = malloc(size);
+    if (pointer == NULL) {
+        return NULL;
+    }
+    malloc_node = (struct aml_malloc_node *)malloc(sizeof(struct aml_malloc_node));
+    if (malloc_node == NULL) {
+        free(pointer);
+        return NULL;
+    }
+
+    snprintf(malloc_node->file_name, 128, "malloc=%s", file_name);
+    malloc_node->line    = line;
+    malloc_node->pointer = pointer;
+    malloc_node->size    = size;
+
+    add_malloc_node(malloc_node);
+    return pointer;
+}
+
+void* aml_audio_debug_realloc(void* pointer, size_t bytes, char * file_name, uint32_t line)
+{
+    void * new_pointer = NULL;
+    struct aml_malloc_node * malloc_node = NULL;
+
+    if (pointer) {
+        remove_malloc_item(pointer);
+    }
+
+    new_pointer = realloc(pointer, bytes);
+    if (new_pointer == NULL) {
+        return NULL;
+    }
+    malloc_node = (struct aml_malloc_node *)malloc(sizeof(struct aml_malloc_node));
+    if (malloc_node == NULL) {
+        free(new_pointer);
+        return NULL;
+    }
+
+    snprintf(malloc_node->file_name, 128, "realloc=%s", file_name);
+    malloc_node->line    = line;
+    malloc_node->pointer = new_pointer;
+    malloc_node->size    = bytes;
+
+    add_malloc_node(malloc_node);
+    return new_pointer;
+
+}
+
+void* aml_audio_debug_calloc(size_t nmemb, size_t bytes, char * file_name, uint32_t line)
+{
+    void * pointer = NULL;
+    struct aml_malloc_node * malloc_node = NULL;
+
+    pointer = calloc(nmemb, bytes);
+    if (pointer == NULL) {
+        return NULL;
+    }
+    malloc_node = (struct aml_malloc_node *)malloc(sizeof(struct aml_malloc_node));
+    if (malloc_node == NULL) {
+        free(pointer);
+        return NULL;
+    }
+
+    snprintf(malloc_node->file_name, 128, "calloc:%s", file_name);
+    malloc_node->line    = line;
+    malloc_node->pointer = pointer;
+    malloc_node->size    = nmemb * bytes;
+
+    add_malloc_node(malloc_node);
+    return pointer;
+}
+
+void aml_audio_debug_free(void* pointer)
+{
+    if (pointer) {
+        remove_malloc_item(pointer);
+    }
+    free(pointer);
+    return;
+}
+
+void aml_audio_debug_malloc_showinfo(uint32_t level)
+{
+    struct listnode *node = NULL;
+    struct aml_malloc_node * malloc_node = NULL;
+    struct aml_malloc_debug *pmalloc_handle = NULL;
+    FILE *fp1 = NULL;
+    uint32_t total_mem = 0;
+    pmalloc_handle = gaudio_malloc_handle;
+
+    if (level == MEMINFO_SHOW_FILE) {
+        fp1 = fopen(MEMINFO_SHOW_FILENAME, "w+");
+        if (fp1 == NULL) {
+            return;
+        }
+    }
+
+    pthread_mutex_lock(&pmalloc_handle->malloc_lock);
+    list_for_each(node, &pmalloc_handle->malloc_list) {
+        malloc_node = node_to_item(node, struct aml_malloc_node, list);
+        if (malloc_node) {
+            total_mem += malloc_node->size;
+            if (level == MEMINFO_SHOW_PRINT) {
+                ALOGI("mem info:%s line=%d pointer =%p size=0x%x", malloc_node->file_name, malloc_node->line, malloc_node->pointer, malloc_node->size);
+            } else if (level == MEMINFO_SHOW_FILE) {
+                if (fp1) {
+                    memset(aml_malloc_temp_buf, 0, sizeof(aml_malloc_temp_buf));
+                    sprintf(aml_malloc_temp_buf, "mem info:%s line=%d pointer =%p size=0x%x\n", malloc_node->file_name, malloc_node->line, malloc_node->pointer, malloc_node->size);
+                    fwrite((char *)aml_malloc_temp_buf, 1, sizeof(aml_malloc_temp_buf), fp1);
+                }
+            }
+        }
+    }
+    if (level == MEMINFO_SHOW_PRINT) {
+        ALOGI("HAL Audio total use mem =0x%x\n", total_mem);
+    } else if (level == MEMINFO_SHOW_FILE) {
+        memset(aml_malloc_temp_buf, 0, sizeof(aml_malloc_temp_buf));
+        sprintf(aml_malloc_temp_buf, "HAL Audio total use mem =0x%x\n", total_mem);
+        fwrite((char *)aml_malloc_temp_buf, 1, sizeof(aml_malloc_temp_buf), fp1);
+        fclose(fp1);
+    }
+
+
+    pthread_mutex_unlock(&pmalloc_handle->malloc_lock);
+
+    return;
+}
diff --git a/utils/aml_ringbuffer.c b/utils/aml_ringbuffer.c
index 32b20ac..ea0ab9f 100755
--- a/utils/aml_ringbuffer.c
+++ b/utils/aml_ringbuffer.c
@@ -228,6 +228,50 @@ size_t ring_buffer_read(struct ring_buffer *rbuffer, unsigned char* buffer, size
     return read_bytes;
 }
 
+/*************************************************
+Function: ring_buffer_seek
+Description: seek read or write pointer to add or
+            reduce audio latency
+Input: rbuffer: the source ring buffer
+       bytes: seek space in byte,
+              bytes > 0, reduce audio latency, move read pointer
+              bytes < 0, add audio latency, move write pointer
+Return: 0: do nothing for ringbuffer.
+        bytes: moved space in byte
+*************************************************/
+int ring_buffer_seek(struct ring_buffer *rbuffer, int bytes)
+{
+    struct ring_buffer *buf = rbuffer;
+    int seek_bytes = 0;
+
+    pthread_mutex_lock(&buf->lock);
+
+    if (buf->start_addr == NULL || buf->rd == NULL || buf->wr == NULL
+            || buf->size == 0 || bytes == 0) {
+        pthread_mutex_unlock(&buf->lock);
+        return 0;
+    }
+
+    if (bytes > 0) {
+        seek_bytes = get_read_space(buf->wr, buf->rd, buf->size, buf->last_is_write);
+        if (seek_bytes > bytes) {
+            seek_bytes = bytes;
+        }
+        buf->rd = update_pointer(buf->rd, seek_bytes, buf->start_addr, buf->size);
+    } else {
+        seek_bytes = get_write_space(buf->wr, buf->rd, buf->size, buf->last_is_write);
+        bytes *= -1;
+        if (seek_bytes > bytes) {
+            seek_bytes = bytes;
+        }
+        buf->wr = update_pointer(buf->wr, seek_bytes, buf->start_addr, buf->size);
+        seek_bytes *= -1;
+    }
+
+    pthread_mutex_unlock(&buf->lock);
+    return seek_bytes;
+}
+
 /*************************************************
 Function: ring_buffer_init
 Description: initialize ring buffer
@@ -325,7 +369,7 @@ int ring_buffer_reset_size(struct ring_buffer *rbuffer, int buffer_size)
         ALOGW("resized buffer size exceed largest buffer size, max %d, cur %d\n", \
               rbuffer->size, buffer_size);
         ring_buffer_release(rbuffer);
-        rbuffer->size = buffer_size;
+        //rbuffer->size = buffer_size;
         return ring_buffer_init(rbuffer, buffer_size);
     }
 
diff --git a/utils/earc_utils.c b/utils/earc_utils.c
new file mode 100644
index 0000000..c9e06ba
--- /dev/null
+++ b/utils/earc_utils.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2019 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * DESCRIPTION:
+ *     to get/set eARC RX/TX latency and Capability Data Structure.
+ *
+ */
+#define LOG_TAG "earc_utils"
+//#define LOG_NDEBUG 0
+
+
+#include <earc_utils.h>
+
+#define CDS_VERSION 0x1
+#define CDS_MAX  256
+
+/*
+ * set latency to eARC RX, to tell eARC TX what's the latency
+ */
+int earcrx_config_latency(struct mixer *pMixer, int latency)
+{
+	return mixer_set_int(pMixer, AML_MIXER_ID_EARCRX_LATENCY, latency);
+}
+
+/*
+ * eARC TX get the latency from eARC RX device
+ */
+int earctx_fetch_latency(struct mixer * pMixer)
+{
+	return mixer_get_int(pMixer, AML_MIXER_ID_EARCTX_LATENCY);
+}
+
+static void earc_cds_conf_to_str(char *earc_cds, char *cds_str)
+{
+	char *cds_blocks;
+	char *audio_blocks;
+	char cds_blockid;
+	int blen = 0, dlen = 0, i, j, n = 0, m;
+
+	if (!cds_str || !earc_cds)
+		return;
+
+	cds_str[0] = '\0';
+
+	/* bypass version */
+	cds_blocks = &earc_cds[1];
+	for (i = 0; i < CDS_MAX - 1;) {
+		/* block id */
+		cds_blockid = cds_blocks[i];
+		if (cds_blockid == 1 || cds_blockid == 2) {
+			blen = cds_blocks[1 + i]; /* block length */
+			audio_blocks = &cds_blocks[2 + i];
+			for (j = 0; j < blen;) {
+				/* CTA-861-G Audio Data Block */
+				ALOGV("%s, tagl:%#x\n", __FUNCTION__, audio_blocks[j]);
+				dlen = audio_blocks[j] & 0x1f; /* length of audio data block */
+				ALOGV("%s, dlen:%d\n", __FUNCTION__, dlen);
+
+				for (m = 0; m < dlen; m ++)
+					sprintf(cds_str, "%s%02x", cds_str, audio_blocks[1 + j + m]);
+
+				n += dlen;
+				j += dlen + 1;
+				ALOGV("%s, j:%d, cds_str:%s\n", __FUNCTION__, j, cds_str);
+			}
+
+			i += blen + 2;
+		} else if (cds_blockid == 3) {
+			/* ignore now */
+		}
+			break;
+	}
+
+	ALOGV("%s, bytes:%d, cds_str:%s\n", __FUNCTION__, n, cds_str);
+
+}
+
+/*
+ * CDS Blocks, Now we support only Block Id = 1
+ */
+static void earc_cds_str_to_conf(char *cds_str, char *earc_cds)
+{
+	char *start = cds_str;
+	char *end;
+	long int data;
+	int len = 0;
+
+	if (!cds_str || !earc_cds)
+		return;
+
+	/* data for Block ID=1 */
+	while (start) {
+		data = strtol(start, &end, 16);
+		earc_cds[4 + len] = data;
+		len ++;
+		start = end;
+		if (!(*end))
+			break;
+	}
+	ALOGV("%s, cds:%s len:%d\n", __FUNCTION__, cds_str, len);
+
+	/* CDS version */
+	earc_cds[0] = CDS_VERSION;
+
+	/* Block ID = 0x1 */
+	earc_cds[1] = 0x1;
+	/* Block len */
+	earc_cds[2] = len + 1;
+	/* Tag = 1, lenght of SADs */
+	earc_cds[3] =  (0x1 << 5) | (len & 0x1f);
+
+}
+
+/*
+ * configure CDS from xml to eARC_RX
+ * cds_str: CTA short audio descriptor
+ */
+int earcrx_config_cds(struct mixer *pMixer, char *cds_str)
+{
+	char earc_cds[CDS_MAX] = {0};
+
+	earc_cds_str_to_conf(cds_str, earc_cds);
+
+	return mixer_set_array(pMixer, AML_MIXER_ID_EARCRX_CDS, earc_cds, CDS_MAX);
+}
+
+/*
+ * fetch CDS as eARC_RX
+ * cds_str: CTA short audio descriptor
+ */
+int earcrx_fetch_cds(struct mixer *pMixer, char *cds_str)
+{
+	char earc_cds[CDS_MAX] = {0};
+
+	mixer_get_array(pMixer, AML_MIXER_ID_EARCRX_CDS, earc_cds, CDS_MAX);
+
+	earc_cds_conf_to_str(earc_cds, cds_str);
+
+	return 0;
+}
+
+/*
+ * fetch CDS from eARC_RX, and will update CDS to EDID
+ * cds_str: CTA short audio descriptor
+ */
+int earctx_fetch_cds(struct mixer *pMixer, char *cds_str)
+{
+	char earc_cds[CDS_MAX] = {0};
+
+	mixer_get_array(pMixer, AML_MIXER_ID_EARCTX_CDS, earc_cds, CDS_MAX);
+
+	earc_cds_conf_to_str(earc_cds, cds_str);
+
+	return 0;
+}
diff --git a/utils/ini/IniParser.cpp b/utils/ini/IniParser.cpp
index efcdf46..aba4b13 100644
--- a/utils/ini/IniParser.cpp
+++ b/utils/ini/IniParser.cpp
@@ -260,8 +260,8 @@ INI_LINE* IniParser::newLine(const char* name, const char* value) {
     pLine = new INI_LINE();
     if (pLine != NULL) {
         pLine->pNext = NULL;
-        strcpy(pLine->Name, name);
-        strcpy(pLine->Value, value);
+        strncpy(pLine->Name, name, CC_MAX_INI_LINE_NAME_LEN - 1);
+        strncpy(pLine->Value, value, CC_MAX_INI_FILE_LINE_LEN - 1);
 
 #if CC_MEMORY_NEW_DEL_TRACE == 1
         new_mem(__FUNCTION__, "pLine", pLine);
@@ -278,7 +278,7 @@ INI_SECTION* IniParser::newSection(const char* section, INI_LINE* pLine) {
     if (pSec != NULL) {
         pSec->pLine = pLine;
         pSec->pNext = NULL;
-        strcpy(pSec->Name, section);
+        strncpy(pSec->Name, section, CC_MAX_INI_LINE_NAME_LEN - 1);
 
 #if CC_MEMORY_NEW_DEL_TRACE == 1
         new_mem(__FUNCTION__, "pSec", pSec);
@@ -331,9 +331,13 @@ int IniParser::setKeyValue(void* user, const char* section, const char* key, con
                 pSec->pCurLine = pLine;
             } else {
                 if (set_mode == 1) {
-                    strcpy(pLine->Value, value);
+                    strncpy(pLine->Value, value, CC_MAX_INI_FILE_LINE_LEN - 1);
                 } else {
-                    strcat(pLine->Value, value);
+                    int len = strlen(pLine->Value) + strlen(value);
+                    if (len > CC_MAX_INI_FILE_LINE_LEN - 1)
+                        len = CC_MAX_INI_FILE_LINE_LEN - 1;
+                    strncat(pLine->Value, value, len - strlen(pLine->Value));
+                    pLine->Value[len] = 0;
                 }
             }
         }
@@ -352,10 +356,11 @@ int IniParser::handler(void* user, const char* section, const char* name,
 #if CC_MEMORY_NEW_DEL_TRACE == 1
 
 #define CC_MEM_RECORD_CNT    (1024)
+#define MEMND_MAX_NAME_LENGHT (50)
 
 typedef struct tag_memnd {
-    char fun_name[50];
-    char var_name[50];
+    char fun_name[MEMND_MAX_NAME_LENGHT];
+    char var_name[MEMND_MAX_NAME_LENGHT];
     void *ptr;
 } memnd;
 
@@ -366,16 +371,16 @@ static memnd gMemDelItems[CC_MEM_RECORD_CNT];
 static int gMemDelInd = 0;
 
 static void new_mem(const char *fun_name, const char *var_name, void *ptr) {
-    strcpy(gMemNewItems[gMemNewInd].fun_name, fun_name);
-    strcpy(gMemNewItems[gMemNewInd].var_name, var_name);
+    strncpy(gMemNewItems[gMemNewInd].fun_name, fun_name, MEMND_MAX_NAME_LENGHT - 1);
+    strncpy(gMemNewItems[gMemNewInd].var_name, var_name, MEMND_MAX_NAME_LENGHT - 1);
     gMemNewItems[gMemNewInd].ptr = ptr;
 
     gMemNewInd += 1;
 }
 
 static void del_mem(const char *fun_name, const char *var_name, void *ptr) {
-    strcpy(gMemDelItems[gMemDelInd].fun_name, fun_name);
-    strcpy(gMemDelItems[gMemDelInd].var_name, var_name);
+    strncpy(gMemDelItems[gMemDelInd].fun_name, fun_name, MEMND_MAX_NAME_LENGHT - 1);
+    strncpy(gMemDelItems[gMemDelInd].var_name, var_name, MEMND_MAX_NAME_LENGHT - 1);
     gMemDelItems[gMemDelInd].ptr = ptr;
 
     gMemDelInd += 1;
diff --git a/utils/spdifenc_wrap.cpp b/utils/spdifenc_wrap.cpp
index 8a60a6f..7ac4aa8 100644
--- a/utils/spdifenc_wrap.cpp
+++ b/utils/spdifenc_wrap.cpp
@@ -18,14 +18,27 @@
 
 //#define LOG_NDEBUG 0
 #define LOG_TAG "AudioSPDIF-wrap"
+
 #include <stdint.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sound/asound.h>
 #include <cutils/log.h>
 #include <system/audio.h>
 #include <audio_utils/spdif/SPDIFEncoder.h>
+
 #include <tinyalsa/asoundlib.h>
 #include <cutils/properties.h>
 #include <string.h>
 
+#ifndef PCM_STATE_SETUP
+#define PCM_STATE_SETUP 1
+#endif
+
+#ifndef PCM_STATE_PREPARED
+#define PCM_STATE_PREPARED 2
+#endif
+
 extern "C"
 {
 //#include "audio_hw_utils.h"
@@ -125,6 +138,19 @@ public:
             memset(buf, 0, bytes);
             mFirstFrameMuted = true;
         }
+        /*to avoid ca noise in Sony TV*/
+        {
+            struct snd_pcm_status status;
+            pcm_ioctl(pcm_handle, SNDRV_PCM_IOCTL_STATUS, &status);
+            if (status.state == PCM_STATE_SETUP ||
+                status.state == PCM_STATE_PREPARED ||
+                status.state == PCM_STATE_XRUN) {
+                ALOGI("mute the first raw data");
+                memset(buf, 0, bytes);
+            }
+        }
+
+
         ret = pcm_write(pcm_handle, buffer, bytes);
         if (ret)
             return ret;
@@ -156,6 +182,10 @@ public:
         }
         return 0;
     }
+    audio_format_t getformat()
+    {
+        return mFormat;
+    }
 protected:
     struct pcm *pcm_handle;
 private:
@@ -195,4 +225,13 @@ extern "C" int spdifenc_set_mute(bool mute)
     else
         return -1;
 }
+
+extern "C" audio_format_t  spdifenc_get_format(void)
+{
+    if (myencoder)
+        return myencoder->getformat();
+    else
+        return AUDIO_FORMAT_INVALID;
+}
+
 }
-- 
2.17.1

