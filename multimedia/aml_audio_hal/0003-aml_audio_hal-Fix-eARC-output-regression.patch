From ec0340e3162bffa680a4a09fd3a6adec7bcd78d8 Mon Sep 17 00:00:00 2001
From: Tim Yao <tim.yao@amlogic.com>
Date: Thu, 6 Aug 2020 10:37:26 -0700
Subject: [PATCH 3/7] aml_audio_hal: Fix eARC output regression.

PD#SWPL-27948

Problem:
eARC output has regression because MS12 output callback
will go to new added spdif output routines for non-PCM
format so the original eARC output routine in normal
data_processing and hw_write() path is not used.

Solution:
1. For ARC/eARC output, revert to single output
(sink_format == optical_format).
2. In ms12_output callback, for non-PCM format, still
go to data_processing() and hw_write() path
3. In hw_write(), eARC ALSA driver will be open with
2 channel PCM format instead of configured from I2S pcm
config (which is 8ch). And also need avoid writing both
pcm and non-pcm output to eARC device since both can
go through hw_write().
4. Fixed eARC mixer audio coding type name to set
correct audio format.

Verify:
Tested on AB311 in both PCM and AC3 output mode
with test_arc 1 (build with DD and PCM format).

Change-Id: Ieb4f2a3d2c953284d795bf135f4c6a338838b3b0
---
 audio_hal/alsa_config_parameters.c | 14 +++++-----
 audio_hal/alsa_manager.c           | 20 +++++++++++--
 audio_hal/aml_audio_stream.c       |  3 +-
 audio_hal/audio_hw.c               | 14 +++++++++-
 audio_hal/audio_hw_ms12.c          | 11 ++++++--
 audio_hal/audio_hw_utils.c         | 45 +++++++++++++++++++++++++++++-
 utils/aml_alsa_mixer.c             |  2 +-
 7 files changed, 93 insertions(+), 16 deletions(-)

diff --git a/audio_hal/alsa_config_parameters.c b/audio_hal/alsa_config_parameters.c
index dfd2c99..1bb5e3d 100644
--- a/audio_hal/alsa_config_parameters.c
+++ b/audio_hal/alsa_config_parameters.c
@@ -89,10 +89,10 @@ static void get_ddp_hardware_config_parameters(
     hardware_config->rate = rate /* * 4 */;
     hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
     if (continuous_mode) {
-        hardware_config->period_count = PLAYBACK_PERIOD_COUNT * 2 *4;
-        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 4;
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT * 4;
+        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
     } else {
-        hardware_config->period_count = PLAYBACK_PERIOD_COUNT *4;
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT * 4;
         hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
     }
 #ifndef TINYALSA_VERSION
@@ -116,8 +116,8 @@ static void get_dd_hardware_config_parameters(
     hardware_config->rate = rate;
     hardware_config->period_size = PERIOD_SIZE;
     if (continuous_mode) {
-        hardware_config->period_count = PLAYBACK_PERIOD_COUNT * 2;
-        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 4;
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
+        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
     } else {
         hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
         hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
@@ -156,8 +156,8 @@ static void get_pcm_hardware_config_parameters(
     hardware_config->rate = rate;//defualt sample rate = 48KHz
     hardware_config->period_size = PERIOD_SIZE;
     if (continuous_mode) {
-        hardware_config->period_count = PLAYBACK_PERIOD_COUNT * 2;
-        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 4;
+        hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
+        hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
     } else {
         hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
         hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
diff --git a/audio_hal/alsa_manager.c b/audio_hal/alsa_manager.c
index d4a73d4..341d49c 100644
--- a/audio_hal/alsa_manager.c
+++ b/audio_hal/alsa_manager.c
@@ -195,6 +195,18 @@ int aml_alsa_output_open(struct audio_stream_out *stream)
         if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && (!aml_out->earc_pcm)) {
             int earc_port = alsa_device_update_pcm_index(PORT_EARC, PLAYBACK);
             struct pcm_config earc_config = update_earc_out_config(config);
+            if (!audio_is_linear_pcm(adev->optical_format)) {
+                earc_config.format = PCM_FORMAT_S16_LE;
+                if ((adev->optical_format == AUDIO_FORMAT_E_AC3) ||
+                    (adev->optical_format == AUDIO_FORMAT_MAT)) {
+                    earc_config.period_size *= 4;
+                }
+                if (adev->optical_format == AUDIO_FORMAT_MAT) {
+                    earc_config.rate *= 4;
+                }
+            }
+            ALOGI("%s, audio open eARC device, channels %d, format %d period_count %d period_size %d rate %d",
+                  __func__, earc_config.channels, earc_config.format, earc_config.period_count, earc_config.period_size, earc_config.rate);
             earc_pcm = pcm_open(card, earc_port, PCM_OUT, &earc_config);
             if (!earc_pcm || !pcm_is_ready(earc_pcm)) {
                 ALOGE("%s, earc_pcm %p open [ready %d] failed", __func__,
@@ -436,7 +448,7 @@ size_t aml_alsa_output_write(struct audio_stream_out *stream,
             return bytes;
         } else {
             //emset(audio_data, 0, need_drop_inject);
-            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm) {
+            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm && (adev->optical_format == out_format)) {
                 ret = pcm_write(aml_out->earc_pcm, audio_data + need_drop_inject, bytes - need_drop_inject);
             } else {
                 ret = pcm_write(aml_out->pcm, audio_data + need_drop_inject, bytes - need_drop_inject);
@@ -535,7 +547,7 @@ write:
         }
     }
 
-    if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm) {
+    if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm && (adev->optical_format == out_format)) {
         ret = pcm_write(aml_out->earc_pcm, buffer, bytes);
         if (ret < 0) {
             ALOGE("%s write failed,aml_out->earc_pcm handle:%p, ret:%#x, err info:%s",
@@ -555,6 +567,9 @@ write:
         }
     }
 
+// LINUX Change, the rate control is to solve Android
+// audioflinger underrun issue and not needed for Linux
+#if 0
     if ((adev->continuous_audio_mode == 1) && (eDolbyMS12Lib == adev->dolby_lib_type) && (bytes != 0)  && \
         (adev->ms12.main_input_fmt != AUDIO_FORMAT_AC4)) {
         uint64_t input_ns = 0;
@@ -600,6 +615,7 @@ write:
             pthread_mutex_lock(&adev->alsa_pcm_lock);
         }
     }
+#endif
 
     return ret;
 }
diff --git a/audio_hal/aml_audio_stream.c b/audio_hal/aml_audio_stream.c
index 37c4fa2..fc802e0 100644
--- a/audio_hal/aml_audio_stream.c
+++ b/audio_hal/aml_audio_stream.c
@@ -204,7 +204,6 @@ void get_sink_format (struct audio_stream_out *stream)
         break;
     case DD:
         optical_audio_format = (source_format != AUDIO_FORMAT_DTS && source_format != AUDIO_FORMAT_DTS_HD) ? AUDIO_FORMAT_AC3 : AUDIO_FORMAT_DTS;
-        sink_audio_format = optical_audio_format;
         break;
     case BYPASS:
         sink_audio_format = min(sink_capability,source_format);
@@ -225,7 +224,7 @@ void get_sink_format (struct audio_stream_out *stream)
     adev->sink_format = sink_audio_format;
     adev->optical_format = optical_audio_format;
 
-#if 0
+#if 1
     /* use single output for HDMI_ARC */
     if ((adev->active_outport == OUTPORT_HDMI_ARC) &&
         adev->bHDMIConnected)
diff --git a/audio_hal/audio_hw.c b/audio_hal/audio_hw.c
index 029494a..63c24e4 100644
--- a/audio_hal/audio_hw.c
+++ b/audio_hal/audio_hw.c
@@ -8134,7 +8134,7 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
                 }
             }
 
-            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm/* && adev->bHDMIARCon */) {
+            if (SUPPORT_EARC_OUT_HW && adev->bHDMIConnected && aml_out->earc_pcm /* && adev->bHDMIARCon */ && audio_is_linear_pcm(adev->optical_format)) {
                 apply_volume_16to32(1.0, tmp_buffer, spk_tmp_buf, bytes);
                 *output_buffer = (void *) spk_tmp_buf;
                 *output_buffer_bytes = bytes * 2;
@@ -8320,6 +8320,8 @@ ssize_t hw_write (struct audio_stream_out *stream
         ALOGI("%s, aml_out %p alsa open output_format %#x\n", __func__, aml_out, output_format);
         if (eDolbyDcvLib == adev->dolby_lib_type) {
             aml_tinymix_set_spdif_format(output_format,aml_out);
+        } else {
+            aml_tinymix_set_spdif_format(adev->optical_format, aml_out);
         }
         if (adev->useSubMix) {
             if (aml_out->usecase == STREAM_PCM_DIRECT && adev->audio_patching) {
@@ -9118,13 +9120,23 @@ ssize_t mixer_main_buffer_write (struct audio_stream_out *stream, const void *bu
         need_reset_decoder =digital_input_src ? true: false;
         adev->arc_hdmi_updated = 0;
     }
+
     /* here to check if the hdmi audio output format dynamic changed. */
     if (pre_hdmi_out_format != adev->hdmi_format/* &&
         aml_out->hal_internal_format != AUDIO_FORMAT_PCM_16_BIT &&
         aml_out->hal_internal_format != AUDIO_FORMAT_PCM_32_BIT*/) {
         pre_hdmi_out_format = adev->hdmi_format;
         need_reconfig_output = true;
+#if 0
         need_reset_decoder =digital_input_src ? true: false;
+#else
+        // LINUX change
+        // on Linux, MS12 is configured to have a single digital output only to avoid
+        // high CPU loading. When hdmi_format changes, adev->sink_format and adev->
+        // optical format may change too which requires a relaunch of MS12 pipeline
+        // to configure MS12's output format.
+        need_reset_decoder = true;
+#endif
         ALOGI ("%s(), check if the hdmi audio output format dynamic changed!\n", __func__);
     }
 
diff --git a/audio_hal/audio_hw_ms12.c b/audio_hal/audio_hw_ms12.c
index 693f323..b5f3ef7 100644
--- a/audio_hal/audio_hw_ms12.c
+++ b/audio_hal/audio_hw_ms12.c
@@ -363,7 +363,8 @@ int get_the_dolby_ms12_prepared(
         output_config = get_ms12_output_mask(adev->sink_format, adev->optical_format,adev->active_outport == OUTPORT_HDMI_ARC);
     }
 #else
-    // Currently we only enable max one PCM and one bitstream (DD/DDP/MAT) output
+    // LINUX Change
+    // Currently we only enable max one PCM and one bitstream (DD/DDP/MAT) output to save on CPU loading
     int output_config = get_ms12_output_mask(adev->sink_format, adev->optical_format,adev->active_outport == OUTPORT_HDMI_ARC);
 #endif
 
@@ -1196,7 +1197,13 @@ int ms12_output(void *buffer, void *priv_data, size_t size, aml_dec_info_t *ms12
                 ALOGI("hdmi format=%d bypass =%d size=%d",adev->hdmi_format, ms12->is_bypass_ms12, out_size);
             }
             if (out_size != 0) {
-                ret = aml_audio_spdif_output(stream_out, output_buf, out_size,output_format);
+                if (adev->active_outport == OUTPORT_HDMI_ARC) {
+                    if (audio_hal_data_processing((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+                        ret = hw_write((struct audio_stream_out *)aml_out, output_buffer, output_buffer_bytes, output_format);
+                    }
+                } else {
+                    ret = aml_audio_spdif_output(stream_out, output_buf, out_size,output_format);
+                }
                 dump_ms12_output_data(buffer, size, MS12_OUTPUT_BITSTREAM_FILE);
             }
 
diff --git a/audio_hal/audio_hw_utils.c b/audio_hal/audio_hw_utils.c
index 45a65a6..04f0665 100644
--- a/audio_hal/audio_hw_utils.c
+++ b/audio_hal/audio_hw_utils.c
@@ -1180,6 +1180,49 @@ int aml_audio_get_dolby_drc_mode(int *drc_mode, int *drc_cut, int *drc_boost)
     return 0;
 }
 
+static int _earc_coding_type_mapping(int spdif_format)
+{
+    int r;
+    enum {
+        AUDIO_CODING_TYPE_UNDEFINED         = 0,
+        AUDIO_CODING_TYPE_STEREO_LPCM       = 1,
+        AUDIO_CODING_TYPE_MULTICH_2CH_LPCM  = 2,
+        AUDIO_CODING_TYPE_MULTICH_8CH_LPCM  = 3,
+        AUDIO_CODING_TYPE_MULTICH_16CH_LPCM = 4,
+        AUDIO_CODING_TYPE_MULTICH_32CH_LPCM = 5,
+        AUDIO_CODING_TYPE_HBR_LPCM          = 6,
+        AUDIO_CODING_TYPE_AC3               = 7,
+        AUDIO_CODING_TYPE_AC3_LAYOUT_B      = 8,
+        AUDIO_CODING_TYPE_EAC3              = 9,
+        AUDIO_CODING_TYPE_MLP               = 10,
+        AUDIO_CODING_TYPE_DTS               = 11,
+        AUDIO_CODING_TYPE_DTS_HD            = 12,
+        AUDIO_CODING_TYPE_DTS_HD_MA         = 13,
+        AUDIO_CODING_TYPE_SACD_6CH          = 14,
+        AUDIO_CODING_TYPE_SACD_12CH         = 15,
+        AUDIO_CODING_TYPE_PAUSE             = 16,
+    };
+
+    switch (spdif_format) {
+        case AML_DOLBY_DIGITAL:
+           r = AUDIO_CODING_TYPE_AC3;
+           break;
+        case AML_DOLBY_DIGITAL_PLUS:
+           r = AUDIO_CODING_TYPE_EAC3;
+           break;
+        case AML_TRUE_HD:
+           r = AUDIO_CODING_TYPE_MLP;
+           break;
+        case AML_DTS:
+           r = AUDIO_CODING_TYPE_DTS;
+           break;
+        default:
+           r = AUDIO_CODING_TYPE_STEREO_LPCM;
+           break;
+    }
+
+    return r;
+}
 
 void aml_tinymix_set_spdif_format(audio_format_t output_format,struct aml_stream_out *stream)
 {
@@ -1225,7 +1268,7 @@ void aml_tinymix_set_spdif_format(audio_format_t output_format,struct aml_stream
 #endif
     }
     aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_FORMAT, aml_spdif_format);
-    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_EARC_AUDIO_TYPE,aml_spdif_format);
+    aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_EARC_AUDIO_TYPE, _earc_coding_type_mapping(aml_spdif_format));
     aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_MUTE, spdif_mute);
     ALOGI("%s tinymix AML_MIXER_ID_SPDIF_FORMAT %d,spdif mute %d",
           __FUNCTION__, aml_spdif_format, spdif_mute);
diff --git a/utils/aml_alsa_mixer.c b/utils/aml_alsa_mixer.c
index 472eeec..0988717 100644
--- a/utils/aml_alsa_mixer.c
+++ b/utils/aml_alsa_mixer.c
@@ -83,7 +83,7 @@ static struct aml_mixer_list gAmlMixerList[] = {
     {AML_MIXER_ID_SPDIF_IN_SAMPLERATE,  "SPDIFIN audio samplerate"},
     {AML_MIXER_ID_HW_RESAMPLE_SOURCE,   "Hw resample module"},
     {AML_MIXER_ID_AUDIO_HAL_FORMAT,     "Audio HAL Format"},
-    {AML_MIXER_ID_EARC_AUDIO_TYPE,      "eARC_TX Audio Codec Type"},
+    {AML_MIXER_ID_EARC_AUDIO_TYPE,      "eARC_TX Audio Coding Type"},
     {AML_MIXER_ID_HDMIIN_AUDIO_EDID,    "HDMIIN AUDIO EDID"},
 };
 
-- 
2.17.1

