From 55327ddb6a62a117b9cf52a3514ee08bdf614fbe Mon Sep 17 00:00:00 2001
From: "yi.zhang1" <yi.zhang1@amlogic.com>
Date: Tue, 14 Nov 2023 10:49:22 +0800
Subject: [PATCH 3/9] transcoding: support video transcoding [1/1]

PD#SWPL-144371

Problem:
support video transcoding.

Solution:
add new videotranscoding library.
add new videotranscoding demo.

Verify:
local

Signed-off-by: yi.zhang1 <yi.zhang1@amlogic.com>
Change-Id: I98b5304f9037f732a17e08ffa7cc48c039ec192b
---
 gst-aml-videotranscoding/Makefile             |  31 ++
 .../inc/video_transcoding.h                   | 105 +++++
 gst-aml-videotranscoding/video_transcoding.c  | 425 ++++++++++++++++++
 videotranscoding-demo/Makefile                |  27 ++
 videotranscoding-demo/videotranscoding_demo.c | 393 ++++++++++++++++
 5 files changed, 981 insertions(+)
 create mode 100644 gst-aml-videotranscoding/Makefile
 create mode 100644 gst-aml-videotranscoding/inc/video_transcoding.h
 create mode 100644 gst-aml-videotranscoding/video_transcoding.c
 create mode 100644 videotranscoding-demo/Makefile
 create mode 100644 videotranscoding-demo/videotranscoding_demo.c

diff --git a/gst-aml-videotranscoding/Makefile b/gst-aml-videotranscoding/Makefile
new file mode 100644
index 0000000..ae624e6
--- /dev/null
+++ b/gst-aml-videotranscoding/Makefile
@@ -0,0 +1,31 @@
+OBJ = *.c
+
+TARGET = libvideotranscoding.so
+
+all: $(TARGET)
+
+CFLAGS = $(GST_CFLAGS) -Wall -Wextra -fPIC -Os
+CFLAGS += $(shell $(PKG_CONFIG) --cflags gstreamer-1.0 gstreamer-base-1.0 gstreamer-app-1.0 gstreamer-video-1.0 glib-2.0)
+CFLAGS += $(EXT_CFLAGS)
+CFLAGS += \
+	-I inc/ \
+	-I$(STAGING_DIR)/usr/include/
+
+LDFLAGS = $(GST_PLUGIN_LDFLAGS) $(shell $(PKG_CONFIG) --libs gstreamer-1.0 gstreamer-base-1.0 gstreamer-app-1.0 gstreamer-video-1.0)
+#LDFLAGS += -lgstreamer-1.0 -lgstbase-1.0 -lgstapp-1.0 -lgstvideo-1.0 -lgobject-2.0 -lglib-2.0
+LDFLAGS += -lpthread
+
+
+$(TARGET): $(OBJ)
+	$(CC) $(TARGET_CFLAGS) $(CFLAGS) -D_FILE_OFFSET_BITS=64 -Wall -I$(STAGING_DIR)/usr/include/ -L$(STAGING_DIR)/usr/lib $(LDFLAGS) $(OBJ) -shared -fPIC -o $@
+
+.PHONY: clean
+
+clean:
+	rm -f *.o $(TARGET) $(TEST)
+
+install:
+	cp inc/*.h $(STAGING_DIR)/usr/include/
+	cp $(TARGET) $(TARGET_DIR)/usr/lib/
+	rm $(TARGET)
+
diff --git a/gst-aml-videotranscoding/inc/video_transcoding.h b/gst-aml-videotranscoding/inc/video_transcoding.h
new file mode 100644
index 0000000..01177ce
--- /dev/null
+++ b/gst-aml-videotranscoding/inc/video_transcoding.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014-2019 Amlogic, Inc. All rights reserved.
+ *
+ * All information contained herein is Amlogic confidential.
+ *
+ * This software is provided to you pursuant to Software License Agreement
+ * (SLA) with Amlogic Inc ("Amlogic"). This software may be used
+ * only in accordance with the terms of this agreement.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification is strictly prohibited without prior written permission from
+ * Amlogic.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _VIDEO_TRANSCODING_H_
+#define _VIDEO_TRANSCODING_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+#include <pthread.h>
+
+typedef enum {
+    AV1, //0
+    AVS2,
+    AVS3,
+    AVS,
+    H264, //video/x-h264
+    H265, //video/x-h265
+    JPEG, //image/jpeg
+    MPEG4, //video/mpeg
+    VC1,
+    VP9,
+    INVALID_CODEC
+}CodecType;
+
+//use gstreamer enum
+typedef void* HANDLE;
+typedef int (*video_transcoding_callback)(HANDLE *handle, void *buffer, gint size);
+
+typedef struct _CustomData {
+  GstElement *pipeline, *app_source, *v4l2_dec, *app_sink;
+  GstElement *video_convert, *video_sink, *video_enc, *video_rate;
+
+  guint sourceid;        /* To control the GSource */
+  gboolean playing;      /* media player playing flag */
+  gboolean init;        /* media player init flag */
+
+  HANDLE handle;
+  pthread_t tid;
+
+  GMainLoop *main_loop;  /* GLib's Main Loop */
+  video_transcoding_callback cus_pull_data_callback;
+} CustomData;
+
+
+// typedef struct _transcoding_pip {
+//     HANDLE handle;
+//     pthread_t tid;
+// }transcoding_pip;
+
+typedef struct _video_size
+{
+  gint width;
+  gint height;
+  //gint size;
+}video_size;
+
+typedef struct _video_transcoding_param
+{
+video_size src_size;
+CodecType src_codec;
+int src_framerate;
+
+video_size dst_size;
+CodecType dst_codec;
+int dst_framerate;
+int bitrate_kb;
+int gop_size;
+}video_transcoding_param;
+
+
+//typedef GstFlowReturn (*video_transcoding_callback)(GstElement *sink, CustomData *data);
+HANDLE video_transcoding_init(video_transcoding_param *param, int argc, char **argv);
+void video_transcoding_deinit(HANDLE *handle);
+//int video_transcoding_writeData(HANDLE handle, void *pData);
+// void *video_transcoding_workloop(HANDLE *handle);
+int video_transcoding_start(HANDLE *handle);
+int video_transcoding_stop(HANDLE *handle);
+int video_transcoding_writeData(HANDLE handle, void* buffer, gint buff_size);
+int video_transcoding_setSinkCallback(HANDLE *handle, video_transcoding_callback cb);
+
+#endif
diff --git a/gst-aml-videotranscoding/video_transcoding.c b/gst-aml-videotranscoding/video_transcoding.c
new file mode 100644
index 0000000..04927e5
--- /dev/null
+++ b/gst-aml-videotranscoding/video_transcoding.c
@@ -0,0 +1,425 @@
+/*
+ * Copyright (C) 2014-2019 Amlogic, Inc. All rights reserved.
+ *
+ * All information contained herein is Amlogic confidential.
+ *
+ * This software is provided to you pursuant to Software License Agreement
+ * (SLA) with Amlogic Inc ("Amlogic"). This software may be used
+ * only in accordance with the terms of this agreement.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification is strictly prohibited without prior written permission from
+ * Amlogic.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <gst/gst.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <gst/app/gstappsrc.h>
+#include <gst/app/gstappsink.h>
+#include "video_transcoding.h"
+
+GST_DEBUG_CATEGORY_STATIC(video_transcoding);
+#define GST_CAT_DEFAULT video_transcoding
+
+
+
+//GstFlowReturn video_transcoding_pulldata_callback(GstElement *sink, CustomData *data);
+static void *video_transcoding_workloop(HANDLE *handle);
+
+static GstFlowReturn appsink_pull_data_callback(GstElement *sink, CustomData *data );
+
+HANDLE video_transcoding_init( video_transcoding_param *param, int argc, char **argv){
+    GstCaps* src_caps = NULL;
+    GstCaps* sink_caps = NULL;
+
+
+    CustomData *data = (CustomData *)malloc(sizeof(CustomData));
+    if (NULL == data)
+    {
+        GST_ERROR("%s malloc CustomData error\n", __func__);
+        return NULL;
+    }
+
+    /* init the logsystem  */
+    GST_DEBUG_CATEGORY_EXTERN(video_transcoding);
+    GST_DEBUG_CATEGORY_INIT(video_transcoding, "video_transcoding", 0, "libtranscoding log");
+
+    GST_DEBUG("%s src_width=%d src_height=%d  src_codec=%d src_framerate=%d/1\n \
+                  dst_width=%d dst_height=%d  dst_codec=%d dst_framerate=%d/1\n \
+                  bitrate_kb=%d gop_size=%d\n",
+                  __func__, param->src_size.width, param->src_size.height, param->src_codec, param->src_framerate,
+                  param->dst_size.width, param->dst_size.height, param->dst_codec, param->dst_framerate,
+                  param->bitrate_kb, param->gop_size);
+
+    printf("%s src_width=%d src_height=%d  src_codec=%d src_framerate=%d/1\n \
+                dst_width=%d dst_height=%d dst_codec=%d dst_framerate=%d/1\n \
+                bitrate_kb=%d gop_size=%d\n",
+                __func__, param->src_size.width, param->src_size.height, param->src_codec, param->src_framerate,
+                param->dst_size.width, param->dst_size.height, param->dst_codec, param->dst_framerate,
+                param->bitrate_kb, param->gop_size);
+
+    /* Initialize cumstom data structure */
+    memset (data, 0, sizeof (CustomData));
+
+    /* Initialize GStreamer */
+    gst_init (&argc, &argv);
+
+    /* switch the decoder codec */
+    switch (param->src_codec)
+    {
+    case AV1:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2av1dec", "v4l2_av1_dec");
+        break;
+    case AVS2:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2avs2dec", "v4l2_avs2_dec");
+        break;
+    case AVS3:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2avs3dec", "v4l2_avs3_dec");
+        break;
+    case AVS:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2avsdec", "v4l2_avs_dec");
+        break;
+    case H264:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2h264dec", "v4l2_h264_dec");
+        src_caps = gst_caps_new_simple("video/x-h264",
+                                        "width", G_TYPE_INT, param->src_size.width,
+                                        "height", G_TYPE_INT, param->src_size.height,
+                                        "framerate", GST_TYPE_FRACTION, param->src_framerate,
+                                        NULL);
+        break;
+    case H265:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2h265dec", "v4l2_h265_dec");
+        src_caps = gst_caps_new_simple("video/x-h265",
+                                        "width", G_TYPE_INT, param->src_size.width,
+                                        "height", G_TYPE_INT, param->src_size.height,
+                                        "framerate", GST_TYPE_FRACTION, param->src_framerate,
+                                        NULL);
+        break;
+    case JPEG:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2jpegdec", "v4l2_jpeg_dec");
+        break;
+    case MPEG4:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2mpeg4dec", "v4l2_mpeg4_dec");
+        src_caps = gst_caps_new_simple("video/mpeg",
+                                        "mpegversion", G_TYPE_INT, 2,
+                                        "systemstream", G_TYPE_BOOLEAN, FALSE,
+                                        // "width", G_TYPE_INT, param->src_size.width,
+                                        // "height", G_TYPE_INT, param->src_size.height,
+                                        // "framerate", GST_TYPE_FRACTION, param->src_framerate,
+                                        NULL);
+
+        //src_caps = gst_caps_new_simple("video/mpeg",NULL);
+        //src_caps = gst_caps_new_any();
+        break;
+    case VC1:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2vc1dec", "v4l2_vc1_dec");
+        break;
+    case VP9:
+        data->v4l2_dec = gst_element_factory_make ("amlv4l2vp9dec", "v4l2_vp9_dec");
+        break;
+    default:
+        GST_ERROR("%s No match dec codec : %d\n", __func__, param->src_codec);
+        break;
+    }
+
+    //const gchar *dec_name = gst_element_get_name(data->v4l2_dec);
+    GST_DEBUG("%s dec plugin name : %s\n", __func__, gst_element_get_name(data->v4l2_dec));
+
+    /* switch the encoder codec */
+    switch (param->dst_codec)
+    {
+    case JPEG:
+        data->video_enc = gst_element_factory_make ("amljpegenc", "video_jpeg_enc");
+        break;
+    case H264:
+        data->video_enc = gst_element_factory_make ("amlvenc", "video_h264_enc");
+                    //sink_caps = gst_caps_new_simple("video/x-raw",
+        sink_caps = gst_caps_new_simple("video/x-h264",
+                                        "width", G_TYPE_INT, param->dst_size.width,
+                                        "height", G_TYPE_INT, param->dst_size.height,
+                                        "framerate", GST_TYPE_FRACTION, param->dst_framerate,
+                                        NULL);
+        break;
+    case H265:
+        data->video_enc = gst_element_factory_make ("amlvenc", "video_h265_enc");
+        sink_caps = gst_caps_new_simple("video/x-h265",
+                                        "width", G_TYPE_INT, param->dst_size.width,
+                                        "height", G_TYPE_INT, param->dst_size.height,
+                                        "framerate", GST_TYPE_FRACTION, param->dst_framerate,1,
+                                        NULL);
+        break;
+    default:
+        GST_ERROR("No match enc codec : %d\n", param->dst_codec);
+        break;
+    }
+
+    //const gchar *enc_name = gst_element_get_name(data->video_enc);
+    GST_DEBUG("%s encoder plugin name : %s\n", __func__, gst_element_get_name(data->video_enc));
+
+    /* Create the elements */
+    // data->app_queue = gst_element_factory_make ("queue", "app_queue");
+    data->app_sink = gst_element_factory_make ("appsink", "app_sink");
+    data->app_source = gst_element_factory_make ("appsrc", "app_source");
+    // data->ts_demux = gst_element_factory_make ("tsdemux", "ts_demux");
+    data->video_convert = gst_element_factory_make ("amlvconv", "video_convert");
+    // data->src_parse = gst_element_factory_make ("mpegvideoparse", "src_parse");
+    // data->video_queue = gst_element_factory_make ("queue", "video_queue");
+    //data->video_rate = gst_element_factory_make ("videorate", "video_rate");
+
+    /* Create the empty pipeline */
+    data->pipeline = gst_pipeline_new ("transcoding-pipeline");
+
+    if (!data->pipeline || !data->app_sink || !data->app_source || !data->v4l2_dec || !data->video_convert || !data->video_enc) {
+        GST_ERROR("%s Not all elements could be created.\n", __func__);
+        return NULL;
+    }
+
+    /* configure the appsrc */
+    g_object_set(data->app_source, "caps", src_caps, NULL);
+    GST_DEBUG("%s sink_caps we set : %s\n",__func__, gst_caps_to_string(src_caps));
+    gst_caps_unref(src_caps);
+
+    //g_signal_connect (data->app_source, "need-data", G_CALLBACK (start_feed), &data);
+    //g_signal_connect (data->app_source, "enough-data", G_CALLBACK (stop_feed), &data);
+
+    /* configure the amlvenc */
+    g_object_set(data->video_enc,"bitrate", param->bitrate_kb, "gop", param->gop_size, NULL);
+
+    /*configure the app sink */
+    g_object_set (data->app_sink, "emit-signals", TRUE, "caps", sink_caps, NULL);
+    //"async", FALSE,
+    GST_DEBUG("%s sink_caps we set : %s\n",__func__, gst_caps_to_string(sink_caps));
+    gst_caps_unref(sink_caps);
+    //g_signal_connect (data->app_sink, "new-sample", G_CALLBACK (appsink_pull_data_callback), data);
+
+    /* Add all plugins to the pipeline */
+    gst_bin_add_many (GST_BIN (data->pipeline), data->app_source, data->v4l2_dec, data->video_convert, data->video_enc,data->app_sink ,NULL);
+    if (gst_element_link_many (data->app_source, data->v4l2_dec, data->video_convert, data->video_enc, data->app_sink, NULL) != TRUE ) {
+        GST_ERROR("%s Elements could not be linked.\n", __func__);
+        gst_object_unref (data->pipeline);
+        return NULL;
+    }
+
+    /* Create a GLib Main Loop and set it to run */
+    data->main_loop = g_main_loop_new (NULL, FALSE);
+    data->init = TRUE;
+    data->playing = FALSE;
+    data->cus_pull_data_callback = NULL;
+
+    // start thread
+    pthread_create(&data->tid, NULL, video_transcoding_workloop, (HANDLE)data);
+
+    return (HANDLE)data;
+
+}
+
+void video_transcoding_deinit(HANDLE *handle){
+    /* chech input param */
+    if (NULL == handle) {
+        GST_ERROR("%s invalid param!\n", __func__);
+        return;
+    }
+    CustomData *data = (CustomData *)handle;
+    /* free resources */
+    data->init = FALSE;
+    data->playing = FALSE;
+    g_main_loop_quit(data->main_loop);
+    g_main_loop_unref(data->main_loop);
+    gst_object_unref(data->pipeline);
+    free(data);
+
+    return;
+}
+
+/* This function is called when an error message is posted on the bus */
+static gboolean handle_message (GstBus *bus, GstMessage *msg, CustomData *data)
+{
+    GError *err;
+    gchar *debug_info;
+
+    switch (GST_MESSAGE_TYPE(msg))
+    {
+    case GST_MESSAGE_ERROR:
+        gst_message_parse_error(msg, &err, &debug_info);
+        GST_ERROR("%s Error received from element %s: %s\n",__func__, GST_OBJECT_NAME(msg->src), err->message);
+        GST_ERROR("Debugging information: %s\n", debug_info ? debug_info : "none");
+        g_clear_error(&err);
+        g_free(debug_info);
+        g_main_loop_quit(data->main_loop);
+        break;
+    case GST_MESSAGE_EOS:
+        GST_DEBUG("%s End-Of-Stream reached.\n", __func__);
+        g_main_loop_quit(data->main_loop);
+        break;
+    case GST_MESSAGE_STATE_CHANGED:
+    {
+        GstState old_state, new_state, pending_state;
+        gst_message_parse_state_changed(msg, &old_state, &new_state, &pending_state);
+        GST_DEBUG("%s: state changed from %s to %s\n", GST_MESSAGE_SRC_NAME(msg), gst_element_state_get_name(old_state),
+                gst_element_state_get_name(new_state));
+        if (GST_MESSAGE_SRC(msg) == GST_OBJECT(data->pipeline))
+        {
+            GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS(GST_BIN(data->pipeline), GST_DEBUG_GRAPH_SHOW_ALL, \
+            g_strdup_printf("libtranscoding_dot.%s_%s", gst_element_state_get_name(old_state), gst_element_state_get_name(new_state)));
+            data->playing = FALSE;
+        }
+        break;
+    }
+    default:
+        break;
+    }
+
+    /* We want to keep receiving messages */
+    return TRUE;
+}
+
+
+static void *video_transcoding_workloop(HANDLE *handle) {
+    /* chech input param */
+    if (NULL == handle) {
+        GST_ERROR("%s invalid param!\n", __func__);
+        return NULL;
+    }
+
+    CustomData *data = (CustomData *)handle;
+    /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
+    // GstBus *bus = gst_element_get_bus (data->pipeline);
+    // gst_bus_add_signal_watch (bus);
+    // g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)error_callback, &data);
+
+    GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(data->pipeline));
+    gst_bus_add_watch(bus, (GstBusFunc)handle_message, data);
+    gst_object_unref(bus);
+    g_main_loop_run(data->main_loop);
+
+    GST_DEBUG("%s work loop start work\n", __func__);
+    return NULL;
+}
+
+
+int video_transcoding_writeData(HANDLE handle, void* buffer, gint buff_size){
+    GstFlowReturn ret;
+
+    /* chech input param */
+    if (NULL == handle) {
+        GST_ERROR("%s invalid param!\n", __func__);
+        return -1;
+    }
+    CustomData *data = (CustomData *)handle;
+    /* push sample to appsrc */
+    //g_signal_emit_by_name(data->app_source, "push-sample", &sample);
+    /* for not size set */
+    //gst_buffer = gst_buffer_new_wrapped_full(GST_MEMORY_FLAG_READONLY, buffer, buff_size, 0 ,buff_size, NULL, NULL);
+    GstBuffer *gst_buffer = gst_buffer_copy((GstBuffer *)buffer);
+    ret = gst_app_src_push_buffer(data->app_source, gst_buffer);
+    if (ret != GST_FLOW_OK) {
+        /* We got some error, stop sending data */
+        GST_ERROR("%s write data error\n", __func__);
+        return -1;
+    }
+    GST_DEBUG("%s write data addr: %p  wirite data size: %d\n", __func__, buffer, buff_size);
+    return 0;
+}
+
+static GstFlowReturn appsink_pull_data_callback(GstElement *sink, CustomData *data ){
+    GstSample *sample;
+    GstBuffer *out_buffer;
+    gint out_size;
+    //HANDLE *handle = (HANDLE *)data;
+    /* chech input param */
+    if (NULL == data) {
+        GST_ERROR("%s invalid param!\n", __func__);
+        return GST_FLOW_ERROR;
+    }
+    /* Retrieve the buffer */
+    g_signal_emit_by_name (sink, "pull-sample", &sample);
+    if (NULL != sample) {
+        out_buffer = gst_sample_get_buffer(sample);
+        out_size = gst_buffer_get_size(out_buffer);
+        /* The only thing we do in this example is print a * to indicate a received buffer */
+        GST_DEBUG ("%s out_buffer addr: %p  out_buffer size: %d\n", __func__, out_buffer, out_size);
+        //video_transcoding_pulldata_callback(handle, buffer, out_size);
+
+        /* app pull data callback */
+        data->cus_pull_data_callback((HANDLE *)data, out_buffer, out_size);
+        gst_sample_unref (sample);
+        return GST_FLOW_OK;
+    }
+
+  return GST_FLOW_ERROR;
+}
+
+int video_transcoding_setSinkCallback(HANDLE *handle, video_transcoding_callback video_transcoding_pulldata_callback) {
+    //GstSample* sample = NULL;
+    /* chech input param */
+    if (NULL == handle) {
+        GST_ERROR("%s invalid param!\n", __func__);
+        return -1;
+    }
+    CustomData *data = (CustomData *)handle;
+    /* get sample from appsink */
+    //g_signal_emit_by_name (data->app_sink, "pull-sample", &sample);
+    data->cus_pull_data_callback = video_transcoding_pulldata_callback;
+    //printf("video_transcoding_pulldata_callback address : %p\n", data->cus_pull_data_callback)
+    g_signal_connect (data->app_sink, "new-sample", G_CALLBACK (appsink_pull_data_callback), data);
+    GST_DEBUG("%s get data done\n", __func__);
+    return 0;
+}
+
+int video_transcoding_start(HANDLE *handle) {
+    GstStateChangeReturn ret;
+    /* check input param */
+    if (NULL == handle)
+    {
+        GST_ERROR("%s input param error\n", __func__ );
+        return -1;
+    }
+    CustomData *data = (CustomData *)handle;
+    /* start playing  */
+    ret = gst_element_set_state(data->pipeline, GST_STATE_PLAYING);
+    if (ret == GST_STATE_CHANGE_FAILURE) {
+        GST_ERROR("%s Unable to set the pipeline to the PLAYING state.\n", __func__);
+        gst_object_unref(data->pipeline);
+        return -1;
+    }
+    return 0;
+}
+
+int video_transcoding_stop(HANDLE *handle) {
+    GstStateChangeReturn ret;
+    /* check input param */
+    if (NULL == handle)
+    {
+        GST_ERROR("%s input param error\n", __func__ );
+        return -1;
+    }
+    CustomData *data = (CustomData *)handle;
+
+    ret = gst_element_set_state(data->pipeline, GST_STATE_NULL);
+    if (ret == GST_STATE_CHANGE_FAILURE) {
+        GST_ERROR("%s Unable to set the pipeline to the NULL state.\n", __func__);
+        gst_object_unref(data->pipeline);
+        return -1;
+    }
+    return 0;
+}
+
+
+
+
diff --git a/videotranscoding-demo/Makefile b/videotranscoding-demo/Makefile
new file mode 100644
index 0000000..1fb61f0
--- /dev/null
+++ b/videotranscoding-demo/Makefile
@@ -0,0 +1,27 @@
+TARGET =videotranscoding_demo
+OBJ = videotranscoding_demo.c
+
+all: $(TARGET)
+
+CFLAGS = $(GST_CFLAGS) -Wall -Wextra -fPIC -Os
+CFLAGS += $(shell $(PKG_CONFIG) --cflags gstreamer-1.0 gstreamer-base-1.0 gstreamer-app-1.0 gstreamer-video-1.0 glib-2.0)
+CFLAGS += \
+	-I$(STAGING_DIR)/usr/include/
+
+LDFLAGS = $(GST_PLUGIN_LDFLAGS) $(shell $(PKG_CONFIG) --libs gstreamer-1.0 gstreamer-base-1.0 gstreamer-app-1.0 gstreamer-video-1.0)
+#LDFLAGS += -lgstreamer-1.0 -lgstbase-1.0 -lgstapp-1.0 -lgstvideo-1.0 -lgobject-2.0 -lglib-2.0
+LDFLAGS += -L$(STAGING_DIR)/usr/lib/ -lvideotranscoding
+
+# rules
+
+$(TARGET): $(OBJ)
+	$(CC) $(CFLAGS) $(OBJ) $(LDFLAGS) -o $@
+
+.PHONY: clean
+
+clean:
+	rm -f *.o $(TARGET)
+
+install:
+	cp $(TARGET) $(TARGET_DIR)/usr/bin
+	rm $(TARGET)
diff --git a/videotranscoding-demo/videotranscoding_demo.c b/videotranscoding-demo/videotranscoding_demo.c
new file mode 100644
index 0000000..7122543
--- /dev/null
+++ b/videotranscoding-demo/videotranscoding_demo.c
@@ -0,0 +1,393 @@
+/*
+ * Copyright (C) 2014-2019 Amlogic, Inc. All rights reserved.
+ *
+ * All information contained herein is Amlogic confidential.
+ *
+ * This software is provided to you pursuant to Software License Agreement
+ * (SLA) with Amlogic Inc ("Amlogic"). This software may be used
+ * only in accordance with the terms of this agreement.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification is strictly prohibited without prior written permission from
+ * Amlogic.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <gst/gst.h>
+#include <string.h>
+#include <gst/app/gstappsrc.h>
+#include <gst/app/gstappsink.h>
+#include <gst/gstbuffer.h>
+#include "video_transcoding.h"
+
+
+CodecType tset_code = MPEG4;
+
+/* Structure to contain all our information, so we can pass it to callbacks */
+typedef struct _CustomData_App {
+    GstElement *pipeline;
+    GstElement *source;
+    GstElement *demuxer;
+    GstElement *video_queue;
+    GstElement *video_queue1;
+    GstElement *audio_queue;
+    GstElement *videoparser;
+    GstElement *videoparser1;
+    GstElement *sink;
+    GstElement *audioparser;
+    GstElement *muxer;
+    GstElement *filesink;
+    GstElement *app_source;
+
+} CustomData_App;
+
+// init the global parmam
+video_transcoding_param global_video_transcoding_param;
+
+/* library handle */
+HANDLE *handle = NULL;
+/* app handle */
+HANDLE *handle_app = NULL;
+
+
+CodecType mapStringToCodec(const char *codec) {
+    if (strcmp(codec, "AV1") == 0) {
+        return AV1;
+    } else if (strcmp(codec, "AVS2") == 0) {
+        return AVS2;
+    } else if (strcmp(codec, "AVS3") == 0) {
+        return AVS3;
+    } else if (strcmp(codec, "AVS") == 0) {
+        return AVS;
+    } else if (strcmp(codec, "H264") == 0) {
+        return H264;
+    } else if (strcmp(codec, "H265") == 0) {
+        return H265;
+    } else if (strcmp(codec, "JPEG") == 0) {
+        return JPEG;
+    } else if (strcmp(codec, "MPEG4") == 0) {
+        return MPEG4;
+    } else if (strcmp(codec, "VC1") == 0) {
+        return VC1;
+    } else if (strcmp(codec, "VP9") == 0) {
+        return VP9;
+    }
+
+    g_printerr("%s no match input codec %s\n", __func__, codec);
+    return INVALID_CODEC;
+}
+
+
+void parseConfigFile(const char *filename, video_transcoding_param *param){
+    //char codecStr[20];
+    char src_codec_value[20];
+    char dst_codec_value[20];
+    FILE *file = fopen(filename,"r");
+    if (file == NULL) {
+        g_printerr("Error opening config file %s\n", filename);
+        param->dst_size.width = 640;
+        param->dst_size.height = 480;
+        param->dst_codec = H264;
+        param->dst_framerate = 30;
+        param->bitrate_kb = 3000;
+        param->gop_size = 60;
+        g_print("%s set the default value\n dst_width=%d dst_height=%d dst_codec=%d dst_framerate=%d/1\n \
+                bitrate_kb=%d gop_size=%d\n", __func__, param->dst_size.width,param->dst_size.height,param->dst_codec,
+                param->dst_framerate,param->bitrate_kb,param->gop_size);
+        return;
+    }
+    /* parse the config file */
+    fscanf(file, "src_size={%d, %d}\n", &param->src_size.width, &param->src_size.height);
+    //fscanf(file, "src_codec=%d\n", &param->src_codec);
+    fscanf(file, "src_codec=%s\n", src_codec_value);
+    param->src_codec = mapStringToCodec(src_codec_value);
+    fscanf(file, "src_framerate=%d/1\n,", &param->src_framerate);
+    fscanf(file, "dst_size={%d, %d}\n", &param->dst_size.width, &param->dst_size.height);
+    fscanf(file, "dst_codec=%s\n", dst_codec_value);
+    param->dst_codec = mapStringToCodec(dst_codec_value);
+    fscanf(file, "dst_framerate=%d/1\n", &param->dst_framerate);
+    fscanf(file, "bitrate_kb=%d\n", &param->bitrate_kb);
+    fscanf(file, "gop_size=%d\n", &param->gop_size);
+
+    fclose(file);
+}
+
+static void SignalHandler(int signum){
+    if ( NULL == handle ) {
+        return;
+    }
+    video_transcoding_stop(handle);
+    video_transcoding_deinit(handle);
+    exit(1);
+}
+
+static GstFlowReturn new_sample(GstElement *appsink, gpointer data) {
+    GstSample *sample = gst_app_sink_pull_sample(GST_APP_SINK(appsink));
+    if (sample) {
+        GstBuffer *buffer = gst_sample_get_buffer(sample);
+        // GstCaps *caps = gst_sample_get_caps(sample);
+        // gchar *caps_str = gst_caps_to_string(caps);
+        // g_print("Caps: %s\n", caps_str);
+        //g_free(caps_str);
+
+        if (buffer) {
+            gsize size = gst_buffer_get_size(buffer);
+            g_print("Received ES data: %d, %s\n", (int)size, (const gchar *)data);
+            // save the out data
+            video_transcoding_writeData(handle, buffer, size);
+            gst_sample_unref(sample);
+            return GST_FLOW_OK;
+        }
+
+    }
+
+    return GST_FLOW_ERROR;
+}
+
+/* This function will be called by the pad-added signal */
+static void pad_added_handler (GstElement *src, GstPad *new_pad, CustomData_App *data) {
+  GstPad *sink_pad = NULL;
+  GstPadLinkReturn ret;
+  GstCaps *new_pad_caps = NULL;
+  GstStructure *new_pad_struct = NULL;
+  const gchar *new_pad_type = NULL;
+
+  g_print ("Received new pad '%s' from '%s':\n", GST_PAD_NAME (new_pad), GST_ELEMENT_NAME (src));
+
+  // chech the pad is the source pad
+  if (GST_PAD_DIRECTION(new_pad) != GST_PAD_SRC)
+      return;
+
+  /* Check the new pad's type */
+  new_pad_caps = gst_pad_get_current_caps (new_pad);
+  new_pad_struct = gst_caps_get_structure (new_pad_caps, 0);
+  new_pad_type = gst_structure_get_name (new_pad_struct);
+
+
+  // determine audio or video based on caps
+  if (g_strrstr(new_pad_type, "video")) {
+      g_print("New pad is a video pad.\n");
+      sink_pad = gst_element_get_static_pad (data->video_queue, "sink");
+      // connect to video processing flow
+  } else if (g_strrstr(new_pad_type, "audio")) {
+      sink_pad = gst_element_get_static_pad (data->audio_queue, "sink");
+      // connect to audio processing flow
+  } else {
+      g_print("%s New pad is of unknown type.\n",new_pad_type);
+      return;
+  }
+
+  /* If our converter is already linked, we have nothing to do here */
+  if (gst_pad_is_linked (sink_pad)) {
+    g_print ("We are already linked. Ignoring.\n");
+    goto exit;
+  }
+
+  /* Attempt the link */
+  ret = gst_pad_link (new_pad, sink_pad);
+  if (GST_PAD_LINK_FAILED (ret)) {
+    g_print ("Type is '%s' but link failed.\n", new_pad_type);
+  } else {
+    g_print ("Link succeeded (type '%s').\n", new_pad_type);
+  }
+
+exit:
+  /* Unreference the new pad's caps, if we got them */
+  if (new_pad_caps != NULL)
+    gst_caps_unref (new_pad_caps);
+
+  /* Unreference the sink pad */
+  gst_object_unref (sink_pad);
+}
+
+int video_transcoding_pulldata_callback(HANDLE *handle, void *buffer, gint size){
+  CustomData_App *data = (CustomData_App *)handle_app;
+  GstStateChangeReturn ret=GST_FLOW_OK;;
+  /* create a GstBuffer containing data */
+  //GstBuffer *mybuffer = gst_buffer_new_allocate(NULL, size, NULL);
+  //GstMapInfo map;
+  //gst_buffer_map(mybuffer, &map, GST_MAP_WRITE);
+
+  /* fill data into GstBuffer */
+  //memcpy(map.data, buffer, size);
+  //gst_buffer_unmap(mybuffer, &map);
+
+  if (NULL != buffer) {
+    /* The only thing we do in this example is print a * to indicate a received buffer */
+    g_print ("%s : ****** \n", __func__);
+    GstBuffer *gst_buffer = gst_buffer_copy((GstBuffer *)buffer);
+    ret = gst_app_src_push_buffer(data->app_source, gst_buffer);
+    if (ret != GST_FLOW_OK) {
+        /* We got some error, stop sending data */
+        printf("write data error\n");
+        return -1;
+    }
+    printf("%s : write data func done\n", __func__);
+    return 0;
+  }
+  return 0;
+}
+
+
+int main(int argc, char *argv[]) {
+    CustomData_App *data = (CustomData_App *)malloc(sizeof(CustomData_App));
+    GstBus *bus;
+    GstMessage *msg;
+    GstStateChangeReturn ret;
+    GstCaps* src_caps = NULL;
+    const char *mediaFile = argv[1];
+    const char *configFile = argv[2];
+
+    /* check input param */
+    if (argc !=3 ) {
+        g_printerr("Usage: %s <media_file> <config_file>\n", argv[0]);
+        return -1;
+    }
+
+    signal(SIGINT,SignalHandler);
+
+    /* read param from config file */
+    parseConfigFile(configFile, &global_video_transcoding_param);
+
+    /* init the gstreamer library */
+    gst_init(&argc, &argv);
+
+    data->pipeline = gst_pipeline_new("my-pipeline");
+
+    data->source = gst_element_factory_make("filesrc", "file-source");
+    g_object_set(G_OBJECT(data->source), "location", argv[1], NULL);
+
+    data->demuxer = gst_element_factory_make("tsdemux", "ts-demuxer");
+
+    data->videoparser = gst_element_factory_make("mpegvideoparse", "mpegvideo-parser");
+
+    //data->videoparser1 = gst_element_factory_make("h264parse", "h264parse-parser");
+
+    data->video_queue = gst_element_factory_make ("queue", "video_queue");
+
+    data->audio_queue = gst_element_factory_make ("queue", "audio_queue");
+
+    data->sink = gst_element_factory_make("appsink", "my-sink");
+
+    data->audioparser = gst_element_factory_make("ac3parse", "ac3audio-parser");
+
+    data->muxer = gst_element_factory_make("mpegtsmux", "ts-muxer");
+
+    data->filesink = gst_element_factory_make("filesink", "my-filesink");
+    g_object_set(G_OBJECT(data->filesink), "location", "/data/test.ts", NULL);
+    data->app_source = gst_element_factory_make ("appsrc", "app_source_test");
+
+    switch (global_video_transcoding_param.dst_codec)
+    {
+    case H264:
+        data->videoparser1 = gst_element_factory_make("h264parse", "h264parse-parser");
+        src_caps = gst_caps_new_simple("video/x-h264",
+                                    "stream-format", G_TYPE_STRING, "byte-stream",
+                                        "alignment",G_TYPE_STRING,"au",
+                                        //"width", G_TYPE_INT, 720,
+                                        //"height", G_TYPE_INT, 420,
+                                        // "framerate", GST_TYPE_FRACTION, param->src_framerate,
+                                        NULL);
+        break;
+
+    case H265:
+        data->videoparser1 = gst_element_factory_make("h265parse", "h265parse-parser");
+        src_caps = gst_caps_new_simple("video/x-h265",
+                                        "stream-format", G_TYPE_STRING, "byte-stream",
+                                        "alignment",G_TYPE_STRING,"au",
+                                        //"width", G_TYPE_INT, 720,
+                                        //"height", G_TYPE_INT, 420,
+                                        // "framerate", GST_TYPE_FRACTION, param->src_framerate,
+                                        NULL);
+        break;
+    default:
+        break;
+    }
+
+        /* configure the appsrc */
+     g_object_set (data->app_source, "caps", src_caps, NULL);
+
+    /* Check if all elements were successfully created */
+    if (!data->pipeline || !data->source || !data->demuxer || !data->videoparser || !data->videoparser1
+        || !data->sink || !data->audioparser || !data->muxer || !data->video_queue || !data->audio_queue || !data->app_source) {
+        g_print("One or more elements could not be created. Exiting.\n");
+        return -1;
+    }
+
+    /* Add elements to the pipeline */
+    gst_bin_add(GST_BIN(data->pipeline), data->source);
+    gst_bin_add(GST_BIN(data->pipeline), data->demuxer);
+    gst_bin_add(GST_BIN(data->pipeline), data->video_queue);
+    gst_bin_add(GST_BIN(data->pipeline), data->audio_queue);
+    gst_bin_add(GST_BIN(data->pipeline), data->videoparser);
+    gst_bin_add(GST_BIN(data->pipeline), data->sink);
+    gst_bin_add(GST_BIN(data->pipeline), data->audioparser);
+    gst_bin_add(GST_BIN(data->pipeline), data->app_source);
+    gst_bin_add(GST_BIN(data->pipeline), data->videoparser1);
+    gst_bin_add(GST_BIN(data->pipeline), data->muxer);
+    gst_bin_add(GST_BIN(data->pipeline), data->filesink);
+
+    //|| !gst_element_link_many(data->app_source, data->muxer, data->filesink, NULL)
+    // || !gst_element_link(data->muxer, data->filesink)
+
+    /* Link elements */
+    if (!gst_element_link(data->source, data->demuxer) || !gst_element_link_many(data->video_queue, data->videoparser, data->sink, NULL)
+        || !gst_element_link_many(data->app_source, data->videoparser1, data->muxer, data->filesink, NULL)
+        || !gst_element_link_many(data->audio_queue, data->audioparser, data->muxer, NULL)) {
+        g_print("Elements could not be linked. Exiting.\n");
+        return -1;
+    }
+
+    /* Set appsink */
+    g_object_set(G_OBJECT(data->sink), "emit-signals", TRUE, NULL);
+    g_signal_connect(G_OBJECT(data->sink), "new-sample", G_CALLBACK(new_sample), NULL);
+
+    /* Connect the "pad-added" signal handler */
+    g_signal_connect(data->demuxer, "pad-added", G_CALLBACK(pad_added_handler), data);
+
+    handle_app=(HANDLE)data;
+    handle = video_transcoding_init(&global_video_transcoding_param, argc, NULL);
+    int ret_lib=video_transcoding_start(handle);
+    if (ret_lib == -1) {
+        g_printerr("lib pip: Unable to set the pipeline to the playing state.\n");
+        gst_object_unref(data->pipeline);
+        return -1;
+    }
+
+    /* Set pipeline status to playing */
+    ret = gst_element_set_state(data->pipeline, GST_STATE_PLAYING);
+    if (ret == GST_STATE_CHANGE_FAILURE) {
+        g_printerr("Unable to set the pipeline to the playing state.\n");
+        gst_object_unref(data->pipeline);
+        return -1;
+    }
+
+    video_transcoding_callback pull_data_callback = video_transcoding_pulldata_callback;
+    video_transcoding_setSinkCallback(handle, pull_data_callback);
+
+    /* main loop */
+    bus = gst_element_get_bus(data->pipeline);
+    msg = gst_bus_poll(bus, GST_MESSAGE_EOS, GST_CLOCK_TIME_NONE);
+    gst_message_unref(msg);
+
+    /* release source */
+    gst_element_set_state(data->pipeline, GST_STATE_NULL);
+    gst_object_unref(data->pipeline);
+
+    video_transcoding_stop(handle);
+    video_transcoding_deinit(handle);
+
+    return 0;
+}
+
-- 
2.25.1

