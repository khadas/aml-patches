From 1e5328e7d536f79d38ee0bc92cb95f302ae3dbf4 Mon Sep 17 00:00:00 2001
From: "hanghang.luo" <hanghang.luo@amlogic.com>
Date: Fri, 14 Jul 2023 07:36:07 +0000
Subject: [PATCH 2/4] gst-plugin-aml-v4l2dec: CB2 change interlace to
 progressive  [1/1]

PD#SWPL-130419

Problem:
it will spend much time that interlace stream pass the deinterlace element,
and will lost frames, if the vsink only support progressive

Solution:
change interlace to progressive

Verify:
AM301

Change-Id: I3a5928510354106fd1b3ac8538245dc658f7f213
Signed-off-by: hanghang.luo <hanghang.luo@amlogic.com>
---
 src/gstamlv4l2videodec.c | 18 +++++++++++-------
 src/gstamlv4l2videodec.h |  1 +
 2 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/src/gstamlv4l2videodec.c b/src/gstamlv4l2videodec.c
index 99c36f6..a1b02da 100644
--- a/src/gstamlv4l2videodec.c
+++ b/src/gstamlv4l2videodec.c
@@ -818,14 +818,13 @@ gst_v4l2_drop_event (GstAmlV4l2Object * v4l2object)
 }
 
 static void
-gst_aml_v4l2_video_dec_set_fence(GstVideoDecoder *decoder,GstVideoInfo *info)
+gst_aml_v4l2_video_dec_set_fence(GstVideoDecoder *decoder)
 {
     GstAmlV4l2VideoDec *self = GST_AML_V4L2_VIDEO_DEC(decoder);
     GstStructure *s;
     GstEvent *event;
 
-    guint fence_num = (info->interlace_mode == GST_VIDEO_INTERLACE_MODE_INTERLEAVED) ?
-        GST_AML_V4L2_DEFAULT_CAP_BUF_MARGIN : self->v4l2capture->min_buffers-2;
+    guint fence_num = self->v4l2capture->min_buffers-2;
     s = gst_structure_new ("video_fence","fence_num",G_TYPE_UINT,fence_num,NULL);
     if (s)
     {
@@ -905,7 +904,12 @@ gst_aml_v4l2_video_dec_loop(GstVideoDecoder *decoder)
 
         if (!gst_aml_v4l2_object_acquire_format(self->v4l2capture, &info))
             goto not_negotiated;
-
+        if (info.interlace_mode == GST_VIDEO_INTERLACE_MODE_INTERLEAVED)
+        {
+            GST_DEBUG_OBJECT(self,"change interlace to progressive");
+            info.interlace_mode = GST_VIDEO_INTERLACE_MODE_PROGRESSIVE;
+            self->is_interlace = TRUE;
+        }
         /* Create caps from the acquired format, remove the format field */
         acquired_caps = gst_video_info_to_caps(&info);
         GST_DEBUG_OBJECT(self, "Acquired caps: %" GST_PTR_FORMAT, acquired_caps);
@@ -949,7 +953,7 @@ gst_aml_v4l2_video_dec_loop(GstVideoDecoder *decoder)
         else
             gst_aml_v4l2_clear_error(&error);
         gst_caps_unref(caps);
-        gst_aml_v4l2_video_dec_set_fence(decoder,&info);
+        gst_aml_v4l2_video_dec_set_fence(decoder);
         output_state = gst_video_decoder_set_output_state(decoder,
                                                           info.finfo->format, info.width, info.height, self->input_state);
 
@@ -1000,8 +1004,7 @@ gst_aml_v4l2_video_dec_loop(GstVideoDecoder *decoder)
 
         ret = gst_buffer_pool_acquire_buffer(pool, &buffer, NULL);
         //calculate a new pts for interlace stream
-        if (ret == GST_FLOW_OK &&
-             self->v4l2capture->info.interlace_mode == GST_VIDEO_INTERLACE_MODE_INTERLEAVED)
+        if (ret == GST_FLOW_OK && self->is_interlace)
         {
             //if buffer pts is valid, reduce 1/2 duration
             if (GST_BUFFER_DURATION_IS_VALID(buffer))
@@ -1519,6 +1522,7 @@ gst_aml_v4l2_video_dec_init(GstAmlV4l2VideoDec *self)
     self->last_out_pts = GST_CLOCK_TIME_NONE;
     self->is_secure_path = FALSE;
     self->is_res_chg = FALSE;
+    self->is_interlace = FALSE;
     g_mutex_init(&self->res_chg_lock);
     g_cond_init(&self->res_chg_cond);
 #if GST_IMPORT_LGE_PROP
diff --git a/src/gstamlv4l2videodec.h b/src/gstamlv4l2videodec.h
index 5909fe1..5109121 100644
--- a/src/gstamlv4l2videodec.h
+++ b/src/gstamlv4l2videodec.h
@@ -69,6 +69,7 @@ struct _GstAmlV4l2VideoDec
     /* flags */
     gboolean is_secure_path;
     gboolean is_res_chg;
+    gboolean is_interlace;
 
     /* resolution change lock */
     GMutex res_chg_lock;
-- 
2.25.1

