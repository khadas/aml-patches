From aea9fa3c8c5f057c01fc0499a0337854b9f78d3a Mon Sep 17 00:00:00 2001
From: "dongyang.zhang" <dongyang.zhang@amlogic.com>
Date: Mon, 27 May 2024 15:58:51 +0800
Subject: [PATCH 1/2] audio: t7c mat bypass function. [2/2]

PD#SWPL-170436

Problem:
sync the cl:
https://scgit.amlogic.com/373107

Solution:
sync the cl:
https://scgit.amlogic.com/373107

Verify:
t7c-trunk

Change-Id: I4c0ee75f55660abca557d7874593316043b25405
Signed-off-by: dongyang.zhang <dongyang.zhang@amlogic.com>
---
 audio_hal/alsa_manager.c             |  11 +
 audio_hal/aml_audio_nonms12_render.c | 576 +++++++++++++++------------
 audio_hal/aml_audio_spdifout.c       |   4 +-
 audio_hal/aml_audio_stream.c         |   4 +-
 audio_hal/aml_audio_stream.h         |  28 ++
 audio_hal/audio_hw.c                 |   9 +-
 audio_hal/audio_hw.h                 |   1 +
 input/tv_patch.c                     |   1 -
 input/tv_patch_format_parser.c       |  15 +-
 utils/alsa_device_parser.c           |  60 +++
 utils/include/alsa_device_parser.h   |   2 +
 11 files changed, 435 insertions(+), 276 deletions(-)

diff --git a/audio_hal/alsa_manager.c b/audio_hal/alsa_manager.c
index 37a0736b..e733683b 100644
--- a/audio_hal/alsa_manager.c
+++ b/audio_hal/alsa_manager.c
@@ -33,6 +33,7 @@
 #include "alsa_config_parameters.h"
 #include "dtv_patch.h"
 #include "aml_audio_timer.h"
+#include "aml_config_data.h"
 
 
 #define AML_ZERO_ADD_MIN_SIZE 1024
@@ -842,7 +843,17 @@ int aml_alsa_output_open_new(void **handle, aml_stream_config_t * stream_config,
         ALOGE("Wrong alsa_device ID\n");
         return -1;
     }
+
     pcm_index = alsa_device_update_pcm_index(alsa_port, PLAYBACK);
+    if (pcm_index < 0) {
+        int config_pcm_index;
+        config_pcm_index = aml_get_jason_int_value("HDMITX_HBR_PCM_INDEX", -1);
+        if (config_pcm_index == 2) {
+            pcm_index = config_pcm_index;
+            config->period_size = 2048;
+            config->start_threshold = 0;
+        }
+    }
 
     ALOGI("In pcm open ch=%d rate=%d\n", config->channels, config->rate);
     ALOGI("%s, audio open card(%d), device(%d) \n", __func__, card, pcm_index);
diff --git a/audio_hal/aml_audio_nonms12_render.c b/audio_hal/aml_audio_nonms12_render.c
index 5cf2e032..97e4622a 100644
--- a/audio_hal/aml_audio_nonms12_render.c
+++ b/audio_hal/aml_audio_nonms12_render.c
@@ -121,6 +121,46 @@ ssize_t aml_audio_spdif_output(struct audio_stream_out *stream, void **spdifout_
     return ret;
 }
 
+int nonms12_mat_bypass_process(struct audio_stream_out *stream, const void *buffer, size_t bytes) {
+    int ret = 0;
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+    spdif_config_t spdif_config = { 0 };
+
+    if (!buffer) {
+        ALOGE("%s buffer is NULL\n", __func__);
+        return -1;
+    }
+
+    if (bytes != 0 && buffer != NULL) {
+        /*
+         * if the alsa(use the spdif sound card) out handle is invalid, initialize it immediately.
+         */
+        if (aml_out->spdifout_handle == NULL) {
+            spdif_config.audio_format = AUDIO_FORMAT_IEC61937;
+            spdif_config.sub_format = aml_out->hal_internal_format;
+            /*
+             * FIXME:
+             *      here use the 4*48000(192k)Hz as the spdif config rate.
+             *      if input is 44.1kHz truehd, maybe there is abnormal sound.
+             *      If it is not suitable, please report it.
+             */
+            spdif_config.rate = MAT_OUTPUT_SAMPLE_RATE;
+            spdif_config.channel_mask = AUDIO_CHANNEL_OUT_7POINT1;
+            spdif_config.data_ch = 8;
+            ret = aml_audio_spdifout_open(&aml_out->spdifout_handle, &spdif_config);
+            if (ret != 0) {
+                ALOGE("%s open spdif out failed\n", __func__);
+                return ret;
+            }
+        }
+    }
+
+    /* send these IEC61937 data to alsa */
+    ret = aml_audio_spdifout_process(aml_out->spdifout_handle, buffer, bytes);
+
+    return 0;
+}
+
 int aml_audio_nonms12_render(struct audio_stream_out *stream, struct audio_buffer *abuffer)
 {
     int ret = -1;
@@ -159,324 +199,330 @@ int aml_audio_nonms12_render(struct audio_stream_out *stream, struct audio_buffe
         msync_get_policy(stream, cur_pts);
     }
 
-    //aml_dec
-    if (NULL == aml_out->aml_dec) {
-        ret = config_output(stream, true);
-        if (0 > ret) {
-            return return_bytes;
+    if (is_aml_dec_support(aml_out->hal_internal_format)) {
+        //aml_dec
+        if (NULL == aml_out->aml_dec) {
+            ret = config_output(stream, true);
+            if (0 > ret) {
+                return return_bytes;
+            }
         }
-    }
-
-    aml_dec_t *aml_dec = aml_out->aml_dec;
-    struct audio_buffer ainput;
-    ainput.buffer = abuffer->buffer;
-    ainput.size   = abuffer->size;
-    ainput.pts    = abuffer->pts;
-    ainput.b_pts_valid = true;
-
-    /* check the input apts and set valid flag */
-    if ((NULL_INT64 == ainput.pts) || (ainput.pts == aml_dec->last_in_frame_pts)) {
-        AM_LOGI_IF(adev->debug_flag, "ainput.pts(0x%"PRIx64")->out_frame_pts(0x%"PRIx64")", ainput.pts, aml_dec->out_frame_pts);
 
-        /* if input apts invalid use the out_frame_pts instead */
-        ainput.pts            = aml_dec->out_frame_pts;
-        ainput.b_pts_valid    = false;
-    }
-    aml_dec->last_in_frame_pts = ainput.pts;
+        aml_dec_t *aml_dec = aml_out->aml_dec;
+        struct audio_buffer ainput;
+        ainput.buffer = abuffer->buffer;
+        ainput.size   = abuffer->size;
+        ainput.pts    = abuffer->pts;
+        ainput.b_pts_valid = true;
 
-    dec_data_info_t * dec_pcm_data = &aml_dec->dec_pcm_data;
-    dec_data_info_t * dec_raw_data = &aml_dec->dec_raw_data;
-    dec_data_info_t * raw_in_data  = &aml_dec->raw_in_data;
+        /* check the input apts and set valid flag */
+        if ((NULL_INT64 == ainput.pts) || (ainput.pts == aml_dec->last_in_frame_pts)) {
+            AM_LOGI_IF(adev->debug_flag, "ainput.pts(0x%"PRIx64")->out_frame_pts(0x%"PRIx64")", ainput.pts, aml_dec->out_frame_pts);
 
-    int used_size     = 0;
-    int out_frames    = 0;
-    int dec_used_size = 0;
-    int left_bytes    = ainput.size;
-
-    do {
-        ALOGV("%s() in raw len=%d", __func__, left_bytes);
-        ainput.buffer += used_size;
-        ainput.size = left_bytes;
-
-        AM_LOGI_IF(adev->debug_flag, "in pts:0x%"PRIx64" (%"PRIu64" ms) size: %"PRId32"", ainput.pts, ainput.pts/90, ainput.size);
-        int decoder_ret = -1;
-        decoder_ret = aml_decoder_process(aml_dec, &ainput, &used_size);
-        if (decoder_ret == AML_DEC_RETURN_TYPE_CACHE_DATA) {
-            AM_LOGI_IF(adev->debug_flag, " cache the data to decode");
-            return abuffer->size;
-        } else if (decoder_ret == AML_DEC_RETURN_TYPE_FAIL) {
-            AM_LOGI_IF(adev->debug_flag, "aml_decoder_process error, ret:%d", decoder_ret);
-            break;
+            /* if input apts invalid use the out_frame_pts instead */
+            ainput.pts            = aml_dec->out_frame_pts;
+            ainput.b_pts_valid    = false;
         }
+        aml_dec->last_in_frame_pts = ainput.pts;
 
-        left_bytes    -= used_size;
-        dec_used_size += used_size;
-        aml_out->consumedsize += used_size;
-
-        /* cleanup the pts valid flag to false for next round, the aml dec will accumulate the output apts by decode frame,
-           and when pts valid is true, the aml dec will aligned output apts with input pts add cached frames for the input pts may not continue */
-        ainput.b_pts_valid     = false;
-        aml_dec->out_frame_pts = ainput.pts;
-        AM_LOGI_IF(adev->debug_flag, "out pts:0x%"PRIx64" (%"PRIu64" ms) pcm len =%d raw len=%d used_size %d total used size %d left_bytes =%d",
-            dec_pcm_data->pts, dec_pcm_data->pts/90, dec_pcm_data->data_len,dec_raw_data->data_len,
-            used_size, dec_used_size, left_bytes);
-
-        // write pcm data
-        if (0 >= dec_pcm_data->data_len) {
-            continue;
-        }
-
-        AM_LOGI_IF(adev->debug_flag, "used_size %d total used size %d left_bytes =%d pcm len =%d raw len=%d, bytes:%"PRId32"",
-            used_size, dec_used_size, left_bytes, dec_pcm_data->data_len, dec_raw_data->data_len, abuffer->size);
+        dec_data_info_t * dec_pcm_data = &aml_dec->dec_pcm_data;
+        dec_data_info_t * dec_raw_data = &aml_dec->dec_raw_data;
+        dec_data_info_t * raw_in_data  = &aml_dec->raw_in_data;
 
-        if (aml_dec->format == AUDIO_FORMAT_PCM_32_BIT)
-            aml_out->config.format = PCM_FORMAT_S16_LE;
-        // aml_audio_dump_audio_bitstreams("/data/dec_data.raw", dec_pcm_data->buf, dec_pcm_data->data_len);
-        out_frames = dec_pcm_data->data_len /( 2 * dec_pcm_data->data_ch);
-        aml_dec->out_frame_pts = dec_pcm_data->pts;
+        int used_size     = 0;
+        int out_frames    = 0;
+        int dec_used_size = 0;
+        int left_bytes    = ainput.size;
 
-        audio_format_t output_format = AUDIO_FORMAT_PCM_16_BIT;
-        void  *dec_data = (void *)dec_pcm_data->buf;
-        int pcm_len = dec_pcm_data->data_len;
-        int clip_flag = false;
+        do {
+            ALOGV("%s() in raw len=%d", __func__, left_bytes);
+            ainput.buffer += used_size;
+            ainput.size = left_bytes;
 
-        if (is_dolby_format(aml_out->hal_internal_format))
-        {
-            int remain_samples = 0;
-            if (0 == aml_out->dec_cachedsize)
-            {
-                aml_out->dec_cachedsize = aml_out->consumedsize;
+            AM_LOGI_IF(adev->debug_flag, "in pts:0x%"PRIx64" (%"PRIu64" ms) size: %"PRId32"", ainput.pts, ainput.pts/90, ainput.size);
+            int decoder_ret = -1;
+            decoder_ret = aml_decoder_process(aml_dec, &ainput, &used_size);
+            if (decoder_ret == AML_DEC_RETURN_TYPE_CACHE_DATA) {
+                AM_LOGI_IF(adev->debug_flag, " cache the data to decode");
+                return abuffer->size;
+            } else if (decoder_ret == AML_DEC_RETURN_TYPE_FAIL) {
+                AM_LOGI_IF(adev->debug_flag, "aml_decoder_process error, ret:%d", decoder_ret);
+                break;
             }
-            int offset = aml_out->consumedsize - aml_out->dec_cachedsize;
-            int bpf = sizeof(int16_t) * dec_pcm_data->data_ch;
-            int ret = 0;
-            clip_tbl_t clip_tbl_out;
-            memset(&clip_tbl_out, 0, sizeof(clip_tbl_t));
-            ret = hal_get_clip_tbl_by_offset(aml_out->clip_meta, offset, &clip_tbl_out);
-            if (0 == ret)
-            {
-                uint32_t discarded_samples_from_front = clip_tbl_out.clip_front * dec_pcm_data->data_sr / 1000000000;   //clip_front (ns)
-                uint32_t discarded_samples_from_end   = clip_tbl_out.clip_back * dec_pcm_data->data_sr / 1000000000;
-                remain_samples = hal_clip_data_by_samples(dec_data, pcm_len, bpf, discarded_samples_from_front, discarded_samples_from_end);
-                pcm_len = remain_samples * bpf;
-                clip_flag = true;
+
+            left_bytes    -= used_size;
+            dec_used_size += used_size;
+            aml_out->consumedsize += used_size;
+
+            /* cleanup the pts valid flag to false for next round, the aml dec will accumulate the output apts by decode frame,
+               and when pts valid is true, the aml dec will aligned output apts with input pts add cached frames for the input pts may not continue */
+            ainput.b_pts_valid     = false;
+            aml_dec->out_frame_pts = ainput.pts;
+            AM_LOGI_IF(adev->debug_flag, "out pts:0x%"PRIx64" (%"PRIu64" ms) pcm len =%d raw len=%d used_size %d total used size %d left_bytes =%d",
+                dec_pcm_data->pts, dec_pcm_data->pts/90, dec_pcm_data->data_len,dec_raw_data->data_len,
+                used_size, dec_used_size, left_bytes);
+
+            // write pcm data
+            if (0 >= dec_pcm_data->data_len) {
+                continue;
             }
 
-            AM_LOGI_IF(adev->debug_flag, "input_bytes_size:%"PRIu64", dec_cachedsize:%"PRIu64", offset:%d, consumedsize:%"PRIu64", remain_samples:%d, bpf:%d, ch:%d, sr:%d, data_len:%d, pcm_len:%d",
-                aml_out->input_bytes_size, aml_out->dec_cachedsize, offset, aml_out->consumedsize,
-                remain_samples, bpf, dec_pcm_data->data_ch, dec_pcm_data->data_sr, dec_pcm_data->data_len, pcm_len);
-        }
+            AM_LOGI_IF(adev->debug_flag, "used_size %d total used size %d left_bytes =%d pcm len =%d raw len=%d, bytes:%"PRId32"",
+                used_size, dec_used_size, left_bytes, dec_pcm_data->data_len, dec_raw_data->data_len, abuffer->size);
 
-        if (adev->patch_src  == SRC_DTV &&
-            (adev->start_mute_flag == 1 || adev->tv_mute)) {
-            memset(dec_pcm_data->buf, 0, dec_pcm_data->data_len);
-        }
+            if (aml_dec->format == AUDIO_FORMAT_PCM_32_BIT)
+                aml_out->config.format = PCM_FORMAT_S16_LE;
+            // aml_audio_dump_audio_bitstreams("/data/dec_data.raw", dec_pcm_data->buf, dec_pcm_data->data_len);
+            out_frames = dec_pcm_data->data_len /( 2 * dec_pcm_data->data_ch);
+            aml_dec->out_frame_pts = dec_pcm_data->pts;
 
-        /* For dts certification:
-         * DTS 88.2K/96K pcm direct output case.
-         * If the PCM after decoding is 88.2k/96k, then direct output.
-         * Need to check whether HDMI sink supports 88.2k/96k or not.*/
-        if (adev->hdmi_format == PCM
-            && is_dts_format(aml_out->hal_internal_format)
-            && dec_pcm_data->data_sr > 48000
-            && check_sink_pcm_sr_cap(adev, dec_pcm_data->data_sr)) {
-            dts_pcm_direct_output = true;
-        }
+            audio_format_t output_format = AUDIO_FORMAT_PCM_16_BIT;
+            void  *dec_data = (void *)dec_pcm_data->buf;
+            int pcm_len = dec_pcm_data->data_len;
+            int clip_flag = false;
 
-        if (dec_pcm_data->data_sr != OUTPUT_ALSA_SAMPLERATE && dec_pcm_data->data_sr > 0) {
-            ret = aml_audio_resample_process_wrapper(&aml_out->resample_handle, dec_pcm_data->buf,
-            pcm_len, dec_pcm_data->data_sr, dec_pcm_data->data_ch);
-            if (ret != 0) {
-                ALOGE("aml_audio_resample_process_wrapper failed");
-            } else {
-                dec_data = aml_out->resample_handle->resample_buffer;
-                pcm_len = aml_out->resample_handle->resample_size;
+            if (is_dolby_format(aml_out->hal_internal_format))
+            {
+                int remain_samples = 0;
+                if (0 == aml_out->dec_cachedsize)
+                {
+                    aml_out->dec_cachedsize = aml_out->consumedsize;
+                }
+                int offset = aml_out->consumedsize - aml_out->dec_cachedsize;
+                int bpf = sizeof(int16_t) * dec_pcm_data->data_ch;
+                int ret = 0;
+                clip_tbl_t clip_tbl_out;
+                memset(&clip_tbl_out, 0, sizeof(clip_tbl_t));
+                ret = hal_get_clip_tbl_by_offset(aml_out->clip_meta, offset, &clip_tbl_out);
+                if (0 == ret)
+                {
+                    uint32_t discarded_samples_from_front = clip_tbl_out.clip_front * dec_pcm_data->data_sr / 1000000000;   //clip_front (ns)
+                    uint32_t discarded_samples_from_end   = clip_tbl_out.clip_back * dec_pcm_data->data_sr / 1000000000;
+                    remain_samples = hal_clip_data_by_samples(dec_data, pcm_len, bpf, discarded_samples_from_front, discarded_samples_from_end);
+                    pcm_len = remain_samples * bpf;
+                    clip_flag = true;
+                }
+
+                AM_LOGI_IF(adev->debug_flag, "input_bytes_size:%"PRIu64", dec_cachedsize:%"PRIu64", offset:%d, consumedsize:%"PRIu64", remain_samples:%d, bpf:%d, ch:%d, sr:%d, data_len:%d, pcm_len:%d",
+                    aml_out->input_bytes_size, aml_out->dec_cachedsize, offset, aml_out->consumedsize,
+                    remain_samples, bpf, dec_pcm_data->data_ch, dec_pcm_data->data_sr, dec_pcm_data->data_len, pcm_len);
             }
-            aml_out->config.rate = OUTPUT_ALSA_SAMPLERATE;
-        } else {
-            if (dec_pcm_data->data_sr > 0)
-                aml_out->config.rate = dec_pcm_data->data_sr;
-        }
-        if (!adev->is_TV) {
-            aml_out->config.channels = dec_pcm_data->data_ch;
-        }
 
-        /*process the stream volume before mix*/
-        if (aml_audio_property_get_bool("vendor.media.decoder.tone",false)) {
-            if (2 == dec_pcm_data->data_ch) {
-                appply_tone_16bit2ch(dec_pcm_data->buf, dec_pcm_data->data_len);
+            if (adev->patch_src  == SRC_DTV &&
+                (adev->start_mute_flag == 1 || adev->tv_mute)) {
+                memset(dec_pcm_data->buf, 0, dec_pcm_data->data_len);
             }
-        }
-        if (!adev->useSubMix) {
-            aml_audio_stream_volume_process(stream, dec_data, sizeof(int16_t), dec_pcm_data->data_ch, pcm_len);
-        }
 
-        if (dec_pcm_data->data_ch == 6 || dec_pcm_data->data_ch == 8) {
-            if (adev->vx_enable) {
-                ret = audio_VX_post_process(VX_postprocess, (int16_t *)dec_data, pcm_len);
-                if (ret > 0) {
-                    pcm_len = ret; /* VX will downmix 6ch to 2ch, pcm size will be changed */
-                    dec_pcm_data->data_ch = 2;
-                    if (aml_getprop_bool("vendor.media.audiohal.vxdump")) {
-                        aml_audio_dump_audio_bitstreams("/tmp/audio_dump/after_vx1.pcm", dec_data, pcm_len);
-                    }
+            /* For dts certification:
+             * DTS 88.2K/96K pcm direct output case.
+             * If the PCM after decoding is 88.2k/96k, then direct output.
+             * Need to check whether HDMI sink supports 88.2k/96k or not.*/
+            if (adev->hdmi_format == PCM
+                && is_dts_format(aml_out->hal_internal_format)
+                && dec_pcm_data->data_sr > 48000
+                && check_sink_pcm_sr_cap(adev, dec_pcm_data->data_sr)) {
+                dts_pcm_direct_output = true;
+            }
+
+            if (dec_pcm_data->data_sr != OUTPUT_ALSA_SAMPLERATE && dec_pcm_data->data_sr > 0) {
+                ret = aml_audio_resample_process_wrapper(&aml_out->resample_handle, dec_pcm_data->buf,
+                pcm_len, dec_pcm_data->data_sr, dec_pcm_data->data_ch);
+                if (ret != 0) {
+                    ALOGE("aml_audio_resample_process_wrapper failed");
+                } else {
+                    dec_data = aml_out->resample_handle->resample_buffer;
+                    pcm_len = aml_out->resample_handle->resample_size;
                 }
+                aml_out->config.rate = OUTPUT_ALSA_SAMPLERATE;
             } else {
-                AM_LOGE("dtsvx doesn't enable, need to check!");
+                if (dec_pcm_data->data_sr > 0)
+                    aml_out->config.rate = dec_pcm_data->data_sr;
             }
-        }
-
-        if (adev->audio_hal_info.first_decoding_frame == false) {
-            aml_decoder_get_info(aml_dec, AML_DEC_STREMAM_INFO, &adev->dec_stream_info);
-            adev->audio_hal_info.first_decoding_frame = true;
-            adev->audio_hal_info.is_decoding = true;
-            ALOGI("[%s:%d] aml_decoder_stream_info %d %d", __func__, __LINE__, adev->dec_stream_info.dec_info.stream_ch, adev->dec_stream_info.dec_info.stream_sr);
-        }
-
-        /* may move outside the decoder loop, when parser flow completed later. */
-        if ((NULL != aml_out->avsync_ctx) && (aml_out->avsync_ctx->mediasync_ctx) && (AVSYNC_TYPE_MEDIASYNC == aml_out->avsync_type)) {
-            avsync_ctx_t *avsync_ctx = aml_out->avsync_ctx;
-            int tuning_delay = 0;
-            if (NULL != avsync_ctx->get_tuning_latency) {
-                tuning_delay = avsync_ctx->get_tuning_latency(stream);
+            if (!adev->is_TV) {
+                aml_out->config.channels = dec_pcm_data->data_ch;
             }
-            avsync_ctx->mediasync_ctx->out_start_apts = aml_dec->out_frame_pts;
-            avsync_ctx->mediasync_ctx->cur_outapts    = aml_dec->out_frame_pts - tuning_delay;
-            AM_LOGI_IF(adev->debug_flag, "sr:%d, ch:%d, format:0x%x, in_apts:%"PRIu64"(%"PRIx64"), "
-                "out_pts:%"PRId64", out_frames:%d, cur_outapts:%"PRId64"",
-                dec_pcm_data->data_sr, dec_pcm_data->data_ch, dec_pcm_data->data_format,
-                ainput.pts, ainput.pts, aml_dec->out_frame_pts, out_frames, avsync_ctx->mediasync_ctx->cur_outapts);
 
-            if (adev->useSubMix) {
-                struct amlAudioMixer *audio_mixer = adev->audio_mixer;
-                ringbuf_latency = mixer_get_inport_latency_frames(audio_mixer, aml_out->inputPortID) / 48 * 90;
-                AM_LOGI_IF(adev->debug_flag, "AVSYNC_TYPE_MEDIASYNC ringbuf_latency:%d(90k) == %d(ms)", ringbuf_latency, ringbuf_latency / 90);
-                avsync_ctx->mediasync_ctx->cur_outapts -= ringbuf_latency;
+            /*process the stream volume before mix*/
+            if (aml_audio_property_get_bool("vendor.media.decoder.tone",false)) {
+                if (2 == dec_pcm_data->data_ch) {
+                    appply_tone_16bit2ch(dec_pcm_data->buf, dec_pcm_data->data_len);
+                }
+            }
+            if (!adev->useSubMix) {
+                aml_audio_stream_volume_process(stream, dec_data, sizeof(int16_t), dec_pcm_data->data_ch, pcm_len);
             }
 
-            //sync process here
-            sync_process_res sync_ret = mediasync_nonms12_process(stream);
-            if (ESSYNC_AUDIO_EXIT == sync_ret) {
-                break;
+            if (dec_pcm_data->data_ch == 6 || dec_pcm_data->data_ch == 8) {
+                if (adev->vx_enable) {
+                    ret = audio_VX_post_process(VX_postprocess, (int16_t *)dec_data, pcm_len);
+                    if (ret > 0) {
+                        pcm_len = ret; /* VX will downmix 6ch to 2ch, pcm size will be changed */
+                        dec_pcm_data->data_ch = 2;
+                        if (aml_getprop_bool("vendor.media.audiohal.vxdump")) {
+                            aml_audio_dump_audio_bitstreams("/tmp/audio_dump/after_vx1.pcm", dec_data, pcm_len);
+                        }
+                    }
+                } else {
+                    AM_LOGE("dtsvx doesn't enable, need to check!");
+                }
             }
-            if (ESSYNC_AUDIO_DROP == sync_ret) {
-                continue;
+
+            if (adev->audio_hal_info.first_decoding_frame == false) {
+                aml_decoder_get_info(aml_dec, AML_DEC_STREMAM_INFO, &adev->dec_stream_info);
+                adev->audio_hal_info.first_decoding_frame = true;
+                adev->audio_hal_info.is_decoding = true;
+                ALOGI("[%s:%d] aml_decoder_stream_info %d %d", __func__, __LINE__, adev->dec_stream_info.dec_info.stream_ch, adev->dec_stream_info.dec_info.stream_sr);
             }
-        }
 
-        // pcm case, asink do speed before audio_hal.
-        if (fabs(aml_out->output_speed - 1.0f) > 1e-6) {
-                ALOGE("aml_out->output_speed:%f, fabs:%f", aml_out->output_speed, fabs(aml_out->output_speed - 1.0f));
-            ret = aml_audio_speed_process_wrapper(&aml_out->speed_handle, dec_data,
-                                    pcm_len, aml_out->output_speed,
-                                    OUTPUT_ALSA_SAMPLERATE, dec_pcm_data->data_ch);
-            if (ret != 0) {
-                ALOGE("aml_audio_speed_process_wrapper failed");
-            } else {
+            /* may move outside the decoder loop, when parser flow completed later. */
+            if ((NULL != aml_out->avsync_ctx) && (aml_out->avsync_ctx->mediasync_ctx) && (AVSYNC_TYPE_MEDIASYNC == aml_out->avsync_type)) {
+                avsync_ctx_t *avsync_ctx = aml_out->avsync_ctx;
+                int tuning_delay = 0;
+                if (NULL != avsync_ctx->get_tuning_latency) {
+                    tuning_delay = avsync_ctx->get_tuning_latency(stream);
+                }
+                avsync_ctx->mediasync_ctx->out_start_apts = aml_dec->out_frame_pts;
+                avsync_ctx->mediasync_ctx->cur_outapts    = aml_dec->out_frame_pts - tuning_delay;
+                AM_LOGI_IF(adev->debug_flag, "sr:%d, ch:%d, format:0x%x, in_apts:%"PRIu64"(%"PRIx64"), "
+                    "out_pts:%"PRId64", out_frames:%d, cur_outapts:%"PRId64"",
+                    dec_pcm_data->data_sr, dec_pcm_data->data_ch, dec_pcm_data->data_format,
+                    ainput.pts, ainput.pts, aml_dec->out_frame_pts, out_frames, avsync_ctx->mediasync_ctx->cur_outapts);
+
+                if (adev->useSubMix) {
+                    struct amlAudioMixer *audio_mixer = adev->audio_mixer;
+                    ringbuf_latency = mixer_get_inport_latency_frames(audio_mixer, aml_out->inputPortID) / 48 * 90;
+                    AM_LOGI_IF(adev->debug_flag, "AVSYNC_TYPE_MEDIASYNC ringbuf_latency:%d(90k) == %d(ms)", ringbuf_latency, ringbuf_latency / 90);
+                    avsync_ctx->mediasync_ctx->cur_outapts -= ringbuf_latency;
+                }
 
-                ALOGV("data_len=%d, speed_size=%d\n", pcm_len, aml_out->speed_handle->speed_size);
-                dec_data = aml_out->speed_handle->speed_buffer;
-                pcm_len = aml_out->speed_handle->speed_size;
+                //sync process here
+                sync_process_res sync_ret = mediasync_nonms12_process(stream);
+                if (ESSYNC_AUDIO_EXIT == sync_ret) {
+                    break;
+                }
+                if (ESSYNC_AUDIO_DROP == sync_ret) {
+                    continue;
+                }
             }
-        }
 
-        if (adev->patch_src == SRC_HDMIIN ||
-                    adev->patch_src == SRC_SPDIFIN ||
-                    adev->patch_src == SRC_LINEIN ||
-                    adev->patch_src == SRC_ATV) {
+            // pcm case, asink do speed before audio_hal.
+            if (fabs(aml_out->output_speed - 1.0f) > 1e-6) {
+                    ALOGE("aml_out->output_speed:%f, fabs:%f", aml_out->output_speed, fabs(aml_out->output_speed - 1.0f));
+                ret = aml_audio_speed_process_wrapper(&aml_out->speed_handle, dec_data,
+                                        pcm_len, aml_out->output_speed,
+                                        OUTPUT_ALSA_SAMPLERATE, dec_pcm_data->data_ch);
+                if (ret != 0) {
+                    ALOGE("aml_audio_speed_process_wrapper failed");
+                } else {
 
-            if (patch && patch->need_do_avsync) {
-                 memset(dec_data, 0, pcm_len);
-            } else {
-                if (adev->mute_start)  {
-                    /* fade in start */
-                    ALOGI("start fade in");
-                    start_ease_in(adev);
-                    adev->mute_start = false;
+                    ALOGV("data_len=%d, speed_size=%d\n", pcm_len, aml_out->speed_handle->speed_size);
+                    dec_data = aml_out->speed_handle->speed_buffer;
+                    pcm_len = aml_out->speed_handle->speed_size;
                 }
             }
-            if (adev->audio_patching) {
-                /*ease in or ease out*/
-                aml_audio_ease_process(adev->audio_ease, dec_data, pcm_len);
-            }
 
-        }
+            if (adev->patch_src == SRC_HDMIIN ||
+                        adev->patch_src == SRC_SPDIFIN ||
+                        adev->patch_src == SRC_LINEIN ||
+                        adev->patch_src == SRC_ATV) {
 
-        if (adev->useSubMix) {
-            out_write_direct_pcm(stream, dec_data, pcm_len);
-        } else {
-            if (audio_hal_data_processing(stream, dec_data, pcm_len, &output_buffer, &output_buffer_bytes, output_format) == 0) {
-                hw_write(stream, output_buffer, output_buffer_bytes, output_format);
-            }
-        }
+                if (patch && patch->need_do_avsync) {
+                     memset(dec_data, 0, pcm_len);
+                } else {
+                    if (adev->mute_start)  {
+                        /* fade in start */
+                        ALOGI("start fade in");
+                        start_ease_in(adev);
+                        adev->mute_start = false;
+                    }
+                }
+                if (adev->audio_patching) {
+                    /*ease in or ease out*/
+                    aml_audio_ease_process(adev->audio_ease, dec_data, pcm_len);
+                }
 
-        if (aml_out->optical_format != adev->optical_format) {
-            ALOGI("optical format change from 0x%x --> 0x%x", aml_out->optical_format, adev->optical_format);
-            aml_out->optical_format = adev->optical_format;
-            if (aml_out->spdifout_handle != NULL) {
-                aml_audio_spdifout_close(aml_out->spdifout_handle);
-                aml_out->spdifout_handle = NULL;
             }
-            if (aml_out->spdifout2_handle != NULL) {
-                aml_audio_spdifout_close(aml_out->spdifout2_handle);
-                aml_out->spdifout2_handle = NULL;
+
+            if (adev->useSubMix) {
+                out_write_direct_pcm(stream, dec_data, pcm_len);
+            } else {
+                if (audio_hal_data_processing(stream, dec_data, pcm_len, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+                    hw_write(stream, output_buffer, output_buffer_bytes, output_format);
+                }
             }
-        }
 
-        if (clip_flag == true) {
-            continue; //skip raw output for raw not clip and will block
-        }
+            if (aml_out->optical_format != adev->optical_format) {
+                ALOGI("optical format change from 0x%x --> 0x%x", aml_out->optical_format, adev->optical_format);
+                aml_out->optical_format = adev->optical_format;
+                if (aml_out->spdifout_handle != NULL) {
+                    aml_audio_spdifout_close(aml_out->spdifout_handle);
+                    aml_out->spdifout_handle = NULL;
+                }
+                if (aml_out->spdifout2_handle != NULL) {
+                    aml_audio_spdifout_close(aml_out->spdifout2_handle);
+                    aml_out->spdifout2_handle = NULL;
+                }
+            }
 
-        // write raw data
-        /*for pcm case, we check whether it has muti channel pcm or 96k/88.2k pcm */
-        if (!dts_pcm_direct_output && !speed_enabled && audio_is_linear_pcm(aml_dec->format) && raw_in_data->data_ch > 2) {
-            aml_audio_spdif_output(stream, &aml_out->spdifout_handle, raw_in_data);
-        } else if (dts_pcm_direct_output && !speed_enabled) {
-            aml_audio_stream_volume_process(stream, dec_pcm_data->buf, sizeof(int16_t), dec_pcm_data->data_ch, dec_pcm_data->data_len);
-            aml_audio_spdif_output(stream, &aml_out->spdifout_handle, dec_pcm_data);
-        }
+            if (clip_flag == true) {
+                continue; //skip raw output for raw not clip and will block
+            }
 
-        if (!dts_pcm_direct_output && !speed_enabled && aml_out->optical_format != AUDIO_FORMAT_PCM_16_BIT) {
-            if (dec_raw_data->data_sr > 0) {
-                aml_out->config.rate = dec_raw_data->data_sr;
+            // write raw data
+            /*for pcm case, we check whether it has muti channel pcm or 96k/88.2k pcm */
+            if (!dts_pcm_direct_output && !speed_enabled && audio_is_linear_pcm(aml_dec->format) && raw_in_data->data_ch > 2) {
+                aml_audio_spdif_output(stream, &aml_out->spdifout_handle, raw_in_data);
+            } else if (dts_pcm_direct_output && !speed_enabled) {
+                aml_audio_stream_volume_process(stream, dec_pcm_data->buf, sizeof(int16_t), dec_pcm_data->data_ch, dec_pcm_data->data_len);
+                aml_audio_spdif_output(stream, &aml_out->spdifout_handle, dec_pcm_data);
             }
 
-            if (aml_dec->format == AUDIO_FORMAT_E_AC3 || aml_dec->format == AUDIO_FORMAT_AC3) {
-                if (adev->dual_spdif_support) {
-                    /*output raw ddp to hdmi*/
-                    if (aml_dec->format == AUDIO_FORMAT_E_AC3 && aml_out->optical_format == AUDIO_FORMAT_E_AC3) {
-                        if (raw_in_data->data_len)
-                            aml_audio_spdif_output(stream, &aml_out->spdifout_handle, raw_in_data);
-                    }
+            if (!dts_pcm_direct_output && !speed_enabled && aml_out->optical_format != AUDIO_FORMAT_PCM_16_BIT) {
+                if (dec_raw_data->data_sr > 0) {
+                    aml_out->config.rate = dec_raw_data->data_sr;
+                }
 
-                    /*output dd data to spdif*/
-                    if (dec_raw_data->data_len > 0)
-                        aml_audio_spdif_output(stream, &aml_out->spdifout2_handle, dec_raw_data);
-                } else {
-                    if (aml_dec->format == AUDIO_FORMAT_E_AC3 && aml_out->optical_format == AUDIO_FORMAT_E_AC3) {
-                        if (raw_in_data->data_len) {
-                            aml_audio_spdif_output(stream, &aml_out->spdifout_handle, raw_in_data);
+                if (aml_dec->format == AUDIO_FORMAT_E_AC3 || aml_dec->format == AUDIO_FORMAT_AC3) {
+                    if (adev->dual_spdif_support) {
+                        /*output raw ddp to hdmi*/
+                        if (aml_dec->format == AUDIO_FORMAT_E_AC3 && aml_out->optical_format == AUDIO_FORMAT_E_AC3) {
+                            if (raw_in_data->data_len)
+                                aml_audio_spdif_output(stream, &aml_out->spdifout_handle, raw_in_data);
                         }
-                    } else if (aml_out->optical_format == AUDIO_FORMAT_AC3) {
-                        if (dec_raw_data->data_len) {
-                            aml_audio_spdif_output(stream, &aml_out->spdifout_handle, dec_raw_data);
+
+                        /*output dd data to spdif*/
+                        if (dec_raw_data->data_len > 0)
+                            aml_audio_spdif_output(stream, &aml_out->spdifout2_handle, dec_raw_data);
+                    } else {
+                        if (aml_dec->format == AUDIO_FORMAT_E_AC3 && aml_out->optical_format == AUDIO_FORMAT_E_AC3) {
+                            if (raw_in_data->data_len) {
+                                aml_audio_spdif_output(stream, &aml_out->spdifout_handle, raw_in_data);
+                            }
+                        } else if (aml_out->optical_format == AUDIO_FORMAT_AC3) {
+                            if (dec_raw_data->data_len) {
+                                aml_audio_spdif_output(stream, &aml_out->spdifout_handle, dec_raw_data);
+                            }
                         }
                     }
+                } else {
+                    aml_audio_spdif_output(stream, &aml_out->spdifout_handle, dec_raw_data);
                 }
-            } else {
-                aml_audio_spdif_output(stream, &aml_out->spdifout_handle, dec_raw_data);
-            }
 
-        }
+            }
 
-        /*special case  for dts , dts decoder need to follow aml_dec_api.h */
-        if ((aml_out->hal_internal_format == AUDIO_FORMAT_DTS ||
-            aml_out->hal_internal_format == AUDIO_FORMAT_DTS_HD )&&
-            decoder_ret == AML_DEC_RETURN_TYPE_NEED_DEC_AGAIN ) {
-            try_again = true;
+            /*special case  for dts , dts decoder need to follow aml_dec_api.h */
+            if ((aml_out->hal_internal_format == AUDIO_FORMAT_DTS ||
+                aml_out->hal_internal_format == AUDIO_FORMAT_DTS_HD )&&
+                decoder_ret == AML_DEC_RETURN_TYPE_NEED_DEC_AGAIN ) {
+                try_again = true;
+            }
+        } while ((left_bytes > 0) || aml_dec->fragment_left_size || try_again);
+    }
+    else { //FIXME: We should be able to choose whether to bypass or not when aml_dec exists;
+        if (abuffer->iec_data_buf != NULL && aml_out->hal_internal_format == AUDIO_FORMAT_MAT) {
+            nonms12_mat_bypass_process(stream, abuffer->iec_data_buf, abuffer->iec_data_size);
         }
-    } while ((left_bytes > 0) || aml_dec->fragment_left_size || try_again);
-
+    }
 exit:
     return return_bytes;
 }
diff --git a/audio_hal/aml_audio_spdifout.c b/audio_hal/aml_audio_spdifout.c
index 39eaace7..62971b41 100644
--- a/audio_hal/aml_audio_spdifout.c
+++ b/audio_hal/aml_audio_spdifout.c
@@ -83,7 +83,7 @@ static int select_digital_device(struct spdifout_handle *phandle) {
      */
 
     AM_LOGI("dual_spdif_support:%d", aml_dev->dual_spdif_support);
-    if (!aml_dev->is_TV) {
+    if (!aml_dev->is_TV || aml_dev->is_BDS) {
         if (aml_dev->dual_spdif_support) {
             if (phandle->audio_format == AUDIO_FORMAT_AC3 ||
                 phandle->audio_format == AUDIO_FORMAT_DTS) {
@@ -421,7 +421,7 @@ int aml_audio_spdifout_open(void **pphandle, spdif_config_t *spdif_config)
                 goto error;
             }
 
-        } else if (TDM_DEVICE == device_id) {
+        } else if (TDM_DEVICE == device_id && eDolbyMS12Lib == aml_dev->dolby_lib_type) {
             /* MC PCM output from MS12 is hard coded to 8ch */
             if (spdif_config->data_ch == 8 && audio_is_linear_pcm(audio_format)) {
                 phandle->post_process_type = MC_POST_PROCESS_COMPACT_CHANNEL;
diff --git a/audio_hal/aml_audio_stream.c b/audio_hal/aml_audio_stream.c
index d66b473a..a12ae7f7 100644
--- a/audio_hal/aml_audio_stream.c
+++ b/audio_hal/aml_audio_stream.c
@@ -116,7 +116,7 @@ static audio_format_t get_sink_capability (struct aml_audio_device *adev)
     audio_format_t sink_capability = AUDIO_FORMAT_PCM_16_BIT;
 
     //STB case
-    if (!adev->is_TV)
+    if (!adev->is_TV || adev->is_BDS)
     {
         char *cap = NULL;
         /*we should get the real audio cap, so we need it report the correct truehd info*/
@@ -376,7 +376,7 @@ void get_sink_format(struct audio_stream_out *stream)
     // "adev->active_outport" was set when HDMI ARC cable plug in/off
     // condition 1: ARC port, single output.
     // condition 2: for STB case with dolby-ms12 libs
-    if (adev->active_outport == OUTPORT_HDMI_ARC || !adev->is_TV) {
+    if (adev->active_outport == OUTPORT_HDMI_ARC || !adev->is_TV || adev->is_BDS) {
         ALOGI("%s() HDMI ARC or mbox + dvb case", __FUNCTION__);
         switch (adev->hdmi_format) {
         case PCM:
diff --git a/audio_hal/aml_audio_stream.h b/audio_hal/aml_audio_stream.h
index 757876df..561b2c52 100644
--- a/audio_hal/aml_audio_stream.h
+++ b/audio_hal/aml_audio_stream.h
@@ -174,6 +174,34 @@ static inline bool is_dolby_format(audio_format_t format) {
     }
 }
 
+static inline bool is_aml_dec_support(audio_format_t format) {
+    switch (format) {
+    case AUDIO_FORMAT_AC3:
+    case AUDIO_FORMAT_E_AC3:
+    case AUDIO_FORMAT_DTS:
+    case AUDIO_FORMAT_DTS_HD:
+    case AUDIO_FORMAT_PCM_16_BIT:
+    case AUDIO_FORMAT_PCM_32_BIT:
+    case AUDIO_FORMAT_PCM_8_BIT:
+    case AUDIO_FORMAT_PCM_8_24_BIT:
+    case AUDIO_FORMAT_PCM_LPCM_DVD:
+    case AUDIO_FORMAT_PCM_LPCM_1394:
+    case AUDIO_FORMAT_PCM_LPCM_BLURAY:
+    case AUDIO_FORMAT_PCM_ADPCM_IMA_WAV:
+    case AUDIO_FORMAT_MP3:
+    case AUDIO_FORMAT_MP2:
+    case AUDIO_FORMAT_AAC:
+    case AUDIO_FORMAT_AAC_LATM:
+    case AUDIO_FORMAT_HE_AAC_V1:
+    case AUDIO_FORMAT_HE_AAC_V2:
+    case AUDIO_FORMAT_FLAC:
+    case AUDIO_FORMAT_VORBIS:
+        return true;
+    default:
+        return false;
+    }
+}
+
 static inline bool is_dts_format(audio_format_t format) {
     switch (format) {
     case AUDIO_FORMAT_DTS:
diff --git a/audio_hal/audio_hw.c b/audio_hal/audio_hw.c
index f7769643..edc9bd8e 100644
--- a/audio_hal/audio_hw.c
+++ b/audio_hal/audio_hw.c
@@ -2679,8 +2679,9 @@ int start_input_stream(struct aml_stream_in *in)
     /* check to update alsa device by port */
     alsa_device = alsa_device_update_pcm_index(port, CAPTURE);
     in->config.stop_threshold = in->config.period_size * in->config.period_count;
-    AM_LOGD("open alsa_card(%d %d) alsa_device(%d), in_device:0x%x, period_size(%d), period_count(%d), stop_threshold(%d)\n",
-        card, port, alsa_device, adev->in_device, in->config.period_size, in->config.period_count, in->config.stop_threshold);
+    AM_LOGI("ALSA open card(%d) device(%d), in_device:0x%x, rate:%d channel:%d period_count(%d) period_size(%d) start_threshold(%d) stop_threshold(%d) \n",
+        card, alsa_device, adev->in_device, in->config.rate, in->config.channels, in->config.period_count,
+        in->config.period_size,in->config.start_threshold, in->config.stop_threshold);
 
     in->pcm = pcm_open(card, alsa_device, PCM_IN | PCM_MONOTONIC | PCM_NONEBLOCK, &in->config);
     if (!pcm_is_ready(in->pcm)) {
@@ -2689,7 +2690,6 @@ int start_input_stream(struct aml_stream_in *in)
         adev->active_input = NULL;
         return -ENOMEM;
     }
-    AM_LOGD("pcm_open in: card(%d), port(%d)", card, port);
 
     if (in->requested_rate != in->config.rate) {
         ret = add_in_stream_resampler(in);
@@ -10613,6 +10613,9 @@ static int adev_open(const hw_module_t* module, const char* name, hw_device_t**
 #endif
 /*[SEI-zhaopf-2018-10-29] add for HBG remote audio support } */
 #ifdef BUILD_LINUX
+    adev->is_BDS = check_chip_name("t7", 2, &adev->alsa_mixer) ? true : false;
+    if (adev->is_BDS)
+        ALOGI("[%s:%d] BDS platform", __func__, __LINE__);
     adev->is_TV = aml_get_jason_int_value(TV_PLATFORM,0);
     if (adev->is_TV ) {
         adev->default_alsa_ch =  aml_audio_get_default_alsa_output_ch();
diff --git a/audio_hal/audio_hw.h b/audio_hal/audio_hw.h
index ef771d7a..27a23c36 100644
--- a/audio_hal/audio_hw.h
+++ b/audio_hal/audio_hw.h
@@ -575,6 +575,7 @@ struct aml_audio_device {
     struct aml_mixer_handle alsa_mixer;
     struct amlAudioMixer *audio_mixer;
     bool is_TV;
+    bool is_BDS;
     bool is_STB;
     bool is_SBR;
     bool useSubMix;
diff --git a/input/tv_patch.c b/input/tv_patch.c
index cb8e7b94..bfb00a0a 100644
--- a/input/tv_patch.c
+++ b/input/tv_patch.c
@@ -447,7 +447,6 @@ void *audio_patch_output_threadloop(void *data)
         audio_digital_input_format_check(patch);
         if (IS_DIGITAL_IN_HW(patch->input_src) && patch->digital_input_fmt_change) {
             AM_LOGI("HDMI format change from %x to %x", out->hal_internal_format, patch->aformat);
-
             //! close old stream
             if (out != NULL) {
                 aml_dev->hw_device.close_output_stream(patch->dev, &out->stream);
diff --git a/input/tv_patch_format_parser.c b/input/tv_patch_format_parser.c
index 4fbc85be..aa2a8a0f 100644
--- a/input/tv_patch_format_parser.c
+++ b/input/tv_patch_format_parser.c
@@ -33,6 +33,7 @@
 
 #include "alsa_device_parser.h"
 #include "tv_patch_ctrl.h"
+#include "aml_config_data.h"
 
 #define AML_DCA_SW_CORE_16M             0x7ffe8001  ///< dts-cd 16bit 1024 framesize
 #define AML_DCA_SW_CORE_14M             0x1fffe800  ///< dts-cd 14bit 1024 or 512 framesize
@@ -499,7 +500,11 @@ static int get_config_by_params(struct pcm_config *config_in, bool normal_pcm)
         config_in->channels = 8;
     }
 
-    config_in->rate = 48000;
+    if (aml_get_jason_int_value("HDMITX_HBR_PCM_INDEX", -1) == 2) //for t7c use c0d2 both parser and playback mat/trueHD.
+        config_in->rate = 192000;
+    else
+        config_in->rate = 48000;
+
     config_in->format = PCM_FORMAT_S16_LE;
     config_in->period_size = PARSER_DEFAULT_PERIOD_SIZE;
     config_in->period_count = 16;
@@ -541,6 +546,8 @@ static int audio_type_parse_init(audio_type_parse_t *status)
     }
 
     if (audio_type_status->soft_parser) {
+        AM_LOGI("soft_parser open card(%d) device(%d) \n", audio_type_status->card, audio_type_status->device);
+        AM_LOGI("ALSA open configs: rate:%d channels:%d \n", audio_type_status->config_in.rate, audio_type_status->config_in.channels);
         in = pcm_open(audio_type_status->card, audio_type_status->device,
                       PCM_IN| PCM_NONEBLOCK, &audio_type_status->config_in);
         if (!pcm_is_ready(in)) {
@@ -674,8 +681,10 @@ static int reconfig_pcm_by_packet_type(audio_type_parse_t *audio_type_status,
             audio_type_status->in = NULL;
         }
 
-        ALOGI("%s(), reopen channels %d",
-            __func__, audio_type_status->config_in.channels);
+        AM_LOGI("reopen card(%d) device(%d) \n", audio_type_status->card, audio_type_status->device);
+        AM_LOGI("ALSA open configs: rate:%d channels:%d peirod_count:%d peirod_size:%d start_threshold:%d\n",
+            audio_type_status->config_in.rate, audio_type_status->config_in.channels, audio_type_status->config_in.period_count,
+            audio_type_status->config_in.period_size, audio_type_status->config_in.start_threshold);
         in = pcm_open(audio_type_status->card, audio_type_status->device,
                       PCM_IN | PCM_NONEBLOCK, &audio_type_status->config_in);
         if (!pcm_is_ready(in)) {
diff --git a/utils/alsa_device_parser.c b/utils/alsa_device_parser.c
index c5d9b070..f00bc217 100644
--- a/utils/alsa_device_parser.c
+++ b/utils/alsa_device_parser.c
@@ -119,6 +119,66 @@ bool alsa_device_is_auge(void)
 	return false;
 }
 
+int alsa_device_get_card_index_by_name(void *name)
+{
+	FILE *mCardFile = NULL;
+	int mCardIndex = -1;
+	char* mRet = NULL;
+
+	if (!name)
+		return -1;
+
+	mCardFile = fopen(ALSASOUND_CARD_PATH, "r");
+	if (mCardFile) {
+		char tempbuffer[READ_BUFFER_SIZE];
+
+		while (!feof(mCardFile)) {
+			mRet = fgets(tempbuffer, READ_BUFFER_SIZE, mCardFile);
+
+			/* this line contain '[' character */
+			if (strchr(tempbuffer, '[')) {
+				char *Rch = strtok(tempbuffer, "[");
+				int id = atoi(Rch);
+				ALOGD("\tcurrent card id = %d, Rch = %s", id, Rch);
+				Rch = strtok(NULL, " ]");
+				ALOGD("\tcurrent sound card name = %s", Rch);
+				if (strcmp(Rch, name) == 0) {
+					ALOGD("\t sound cardIndex found = %d", id);
+					mCardIndex = id;
+					break;
+				}
+			}
+			memset((void *)tempbuffer, 0, READ_BUFFER_SIZE);
+		}
+		fclose(mCardFile);
+	}
+	return mCardIndex;
+}
+
+int alsa_device_get_pcm_index_by_name(void *name)
+{
+	FILE *mCardFile = NULL;
+	int mPcmIndex = -1;
+	char buf[100];
+	char str[2];
+
+	if (!name)
+		return -1;
+
+	mCardFile = fopen(ALSASOUND_PCM_PATH, "r");
+	while (fgets(buf, 100, mCardFile)) {
+		if (strstr(buf, name) != NULL) {
+			strncpy(str, buf + 3, 2);
+			mPcmIndex = atoi(str);
+			ALOGD("sound PcmIndex found = %d", mPcmIndex);
+			break;
+		}
+	}
+
+	return mPcmIndex;
+}
+
+
 /*
  * cat /proc/asound/cards
  *	 0 [AMLAUGESOUND   ]: AML-AUGESOUND - AML-AUGESOUND
diff --git a/utils/include/alsa_device_parser.h b/utils/include/alsa_device_parser.h
index 6a80614c..fa17e1bc 100644
--- a/utils/include/alsa_device_parser.h
+++ b/utils/include/alsa_device_parser.h
@@ -54,6 +54,8 @@ int alsa_device_update_pcm_index(int alsaPORT, int stream);
 
 int alsa_device_get_card_index_by_name(void *name);
 
+int alsa_device_get_pcm_index_by_name(void *name);
+
 bool is_earc_descrpt(void);
 
 #endif
-- 
2.25.1

