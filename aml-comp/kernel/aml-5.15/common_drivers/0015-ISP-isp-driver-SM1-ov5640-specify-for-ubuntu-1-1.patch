From b36b6a73c5dfbb7d28c0b78c0981fd36240b7917 Mon Sep 17 00:00:00 2001
From: "junwei.ma" <junwei.ma@amlogic.com>
Date: Thu, 3 Aug 2023 13:51:53 +0800
Subject: [PATCH] ISP: [isp][driver] SM1 ov5640 specify for ubuntu [1/1]

PD#SWPL-134178

Problem:
1.1080P can't output RGB
2.can't enum fmt
3.nv21/nv12 bytesperline error

Solution:
1.add 1080P RGB output logic
2.enum one time
3.correct the bytesperline

Verify:
ok

Change-Id: I0d10a862a45d4980b8e57798dddcadc78b3b5abe
Signed-off-by: junwei.ma <junwei.ma@amlogic.com>
---
 drivers/media/camera/ov5640.c | 67 +++++++++++++++++++++++++----------
 1 file changed, 48 insertions(+), 19 deletions(-)

diff --git a/drivers/media/camera/ov5640.c b/drivers/media/camera/ov5640.c
index b4624ce3..46034a49 100644
--- a/drivers/media/camera/ov5640.c
+++ b/drivers/media/camera/ov5640.c
@@ -315,7 +315,16 @@ static struct v4l2_queryctrl ov5640_qctrl[] = {
 		.step          = 1,
 		.default_value = (1000 << 16) | 1000,
 		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}
+	}, {
+		.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Minimum number of cap bufs",
+		.minimum = 2,
+		.maximum = 10,
+		.step = 1,
+		.default_value = 2,
+		.flags         = V4L2_CTRL_FLAG_READ_ONLY,
+	},
 };
 
 struct v4l2_querymenu ov5640_qmenu_autofocus[] = {
@@ -1355,6 +1364,15 @@ static struct aml_camera_i2c_fig_s OV5640_capture_5M_script[] = {
 
 /*mipi lane bps : M*/
 static struct resolution_param  prev_resolution_array[] = {
+	{
+		.frmsize            = {2592, 1944},
+		.active_frmsize     = {2592, 1944},
+		.active_fps         = 15,
+		.lanes              = 2,
+		.bps                = 672,
+		.size_type          = SIZE_2592X1944,
+		.reg_script         = OV5640_capture_5M_script,
+	},
 	{
 		.frmsize            = {1920, 1080},
 		.active_frmsize     = {1920, 1080},
@@ -2519,6 +2537,18 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 	return 0;
 }
 
+static inline u32 get_bytesperline(struct ov5640_fmt *fmt, u32 width)
+{
+	switch (fmt->fourcc) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+		return width;
+	default:
+		return (width * fmt->depth) >> 3;
+	}
+}
+
 static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
 		struct v4l2_format *f)
 {
@@ -2530,10 +2560,9 @@ static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
 	f->fmt.pix.height       = fh->height;
 	f->fmt.pix.field        = fh->vb_vidq.field;
 	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
-	f->fmt.pix.bytesperline =
-		(f->fmt.pix.width * fh->fmt->depth) >> 3;
+	f->fmt.pix.bytesperline = get_bytesperline(fh->fmt, fh->width);
 	f->fmt.pix.sizeimage =
-		f->fmt.pix.height * f->fmt.pix.bytesperline;
+		(f->fmt.pix.height  * f->fmt.pix.width * fh->fmt->depth) >> 3;
 
 	return 0;
 }
@@ -2583,7 +2612,6 @@ static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 		field = V4L2_FIELD_INTERLACED;
 	} else if (field != V4L2_FIELD_INTERLACED) {
 		dprintk(dev, 1, "Field type invalid.\n");
-		return -EINVAL;
 	}
 
 	maxw  = norm_maxw();
@@ -2592,10 +2620,9 @@ static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 	f->fmt.pix.field = field;
 	v4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,
 		&f->fmt.pix.height, 32, maxh, 0, 0);
-	f->fmt.pix.bytesperline =
-		(f->fmt.pix.width * fmt->depth) >> 3;
+	f->fmt.pix.bytesperline = get_bytesperline(fmt, f->fmt.pix.width);
 	f->fmt.pix.sizeimage =
-		f->fmt.pix.height * f->fmt.pix.bytesperline;
+		(f->fmt.pix.height  * f->fmt.pix.width * fmt->depth) >> 3;
 
 	return 0;
 }
@@ -2642,7 +2669,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 		fh->height, fh->width);
 
 	if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {
-		res_param = get_resolution_param(dev, 1, fh->width, fh->height);
+		res_param = get_resolution_param(dev, 0, fh->width, fh->height);
 		if (!res_param) {
 			pr_err("error, resolution param not get\n");
 			goto out;
@@ -2845,22 +2872,16 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,
 	if (fmt->fourcc == V4L2_PIX_FMT_NV21 ||
 			fmt->fourcc == V4L2_PIX_FMT_NV12 ||
 			fmt->fourcc == V4L2_PIX_FMT_YUV420 ||
-			fmt->fourcc == V4L2_PIX_FMT_YVU420) {
+			fmt->fourcc == V4L2_PIX_FMT_YVU420 ||
+			fmt->fourcc == V4L2_PIX_FMT_RGB24) {
 		if (fsize->index >= ARRAY_SIZE(prev_resolution_array))
 			return -EINVAL;
 		frmsize = &prev_resolution_array[fsize->index].frmsize;
 		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
 		fsize->discrete.width = frmsize->width;
 		fsize->discrete.height = frmsize->height;
-	} else if (fmt->fourcc == V4L2_PIX_FMT_RGB24) {
-		if (fsize->index >= ARRAY_SIZE(capture_resolution_array))
-			return -EINVAL;
-		frmsize =
-		&capture_resolution_array[fsize->index].frmsize;
-		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-		fsize->discrete.width = frmsize->width;
-		fsize->discrete.height = frmsize->height;
 	}
+
 	return ret;
 }
 
@@ -2872,9 +2893,14 @@ static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 static int vidioc_enum_input(struct file *file, void *priv,
 		struct v4l2_input *inp)
 {
+	if (inp->index > 1)
+		return -EINVAL;
 	inp->type = V4L2_INPUT_TYPE_CAMERA;
 	inp->std = V4L2_STD_525_60;
-	sprintf(inp->name, "Camera %u", inp->index);
+	if (inp->index)
+		snprintf(inp->name, sizeof(inp->name), "Camera %u", inp->index);
+	else
+		strlcpy(inp->name, "camera", sizeof(inp->name));
 
 	return 0;
 }
@@ -2988,6 +3014,9 @@ static int vidioc_g_ctrl(struct file *file, void *priv,
 						V4L2_AUTO_FOCUS_STATUS_FAILED;
 				}
 				return 0;
+			} else if (ctrl->id == V4L2_CID_MIN_BUFFERS_FOR_CAPTURE) {
+				ctrl->value = ov5640_qctrl[i].default_value;
+				return 0;
 			}
 			ctrl->value = dev->qctl_regs[i];
 			return 0;
-- 
2.25.1

