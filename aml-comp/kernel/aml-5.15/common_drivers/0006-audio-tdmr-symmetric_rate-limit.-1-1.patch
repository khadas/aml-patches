From e9dde6e5891a897a2d29954506f0232fb9e2c3a1 Mon Sep 17 00:00:00 2001
From: "dongyang.zhang" <dongyang.zhang@amlogic.com>
Date: Mon, 13 Nov 2023 06:35:25 +0000
Subject: [PATCH 6/9] audio: tdmr symmetric_rate limit. [1/1]

PD#SH-16531

Problem:
fail to open TDM-C/i2s4parser when TDM-C is playback 192khz stream
driver have symmetric rate limit.

Solution:
add dts control.

Verify:
t7c-an400

Change-Id: Id0f4a9a0a71486812dc22ae2b111ad3ed9a6ab70
Signed-off-by: dongyang.zhang <dongyang.zhang@amlogic.com>
---
 .../dts/amlogic/t7c_a311d2_an400_linux.dts    |  1 +
 sound/soc/amlogic/auge/tdm.c                  | 25 ++++++++++++++++---
 2 files changed, 22 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/boot/dts/amlogic/t7c_a311d2_an400_linux.dts b/arch/arm64/boot/dts/amlogic/t7c_a311d2_an400_linux.dts
index 3d11c377e..c870b6604 100644
--- a/arch/arm64/boot/dts/amlogic/t7c_a311d2_an400_linux.dts
+++ b/arch/arm64/boot/dts/amlogic/t7c_a311d2_an400_linux.dts
@@ -1026,6 +1026,7 @@
 		dai-tdm-lane-slot-mask-in = <1 1 1 1>;
 		dai-tdm-lane-slot-mask-out = <1 1 1 1>;
 		dai-tdm-clk-sel = <2>;
+		symmetric_rate_enable = <1>;
 
 		clocks = <&clkaudio CLKID_AUDIO_MCLK_C
 				&clkc CLKID_MPLL2>;
diff --git a/sound/soc/amlogic/auge/tdm.c b/sound/soc/amlogic/auge/tdm.c
index 4a13fac97..32061501a 100644
--- a/sound/soc/amlogic/auge/tdm.c
+++ b/sound/soc/amlogic/auge/tdm.c
@@ -119,6 +119,7 @@ struct aml_tdm {
 	/* tdmin_lb src sel */
 	int tdmin_lb_src;
 	int start_clk_enable;
+	int symmetric_rate_enable;
 	int clk_tuning_enable;
 	int last_rate;
 
@@ -670,10 +671,16 @@ int aml_tdm_hw_setting_init(struct aml_tdm *p_tdm,
 	dump_pcm_setting(setting);
 
 	/* set pcm dai hw params */
-	p_tdm->setting.standard_sysclk = setting->sysclk;
-	aml_set_tdm_mclk(p_tdm, setting->sysclk, false);
-	aml_tdm_set_clkdiv(p_tdm, setting->sysclk_bclk_ratio);
-	aml_set_bclk_ratio(p_tdm, setting->bclk_lrclk_ratio);
+	if (p_tdm->symmetric_rate_enable && p_tdm->id == TDM_C
+		&& stream == SNDRV_PCM_STREAM_CAPTURE) {
+	    pr_debug("%s(), skip clock setting when TDM-C capture\n", __func__);
+	} else {
+		pr_debug("%s(), clock setting when TDM-%d stream=%d\n",
+				 __func__, p_tdm->id, stream);
+		aml_set_tdm_mclk(p_tdm, setting->sysclk, false);
+		aml_tdm_set_clkdiv(p_tdm, setting->sysclk_bclk_ratio);
+		aml_set_bclk_ratio(p_tdm, setting->bclk_lrclk_ratio);
+	}
 
 	ret = aml_tdm_set_lanes(p_tdm, channels, stream);
 	if (ret)
@@ -2764,6 +2771,16 @@ static int aml_tdm_platform_probe(struct platform_device *pdev)
 		pr_info("TDM id %d output clk enable:%d\n",
 			p_tdm->id, p_tdm->start_clk_enable);
 
+	ret = of_property_read_u32(node, "symmetric_rate_enable", &p_tdm->symmetric_rate_enable);
+	if (ret < 0)
+		p_tdm->symmetric_rate_enable = 0;
+	else {
+		if (p_tdm->symmetric_rate_enable == 1)
+			aml_tdm_dai[p_tdm->id].symmetric_rate = 0;
+		pr_info("TDM id %d symmetric_rate_enable enable:%d\n",
+			p_tdm->id, p_tdm->symmetric_rate_enable);
+	}
+
 	ret = of_property_read_u32(node, "ctrl_gain", &p_tdm->ctrl_gain_enable);
 	if (ret < 0)
 		p_tdm->ctrl_gain_enable = 0;
-- 
2.25.1

