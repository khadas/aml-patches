From b57be6ace58d03d29f0bdafb07d6a54ffff426d5 Mon Sep 17 00:00:00 2001
From: "haitao.liu" <haitao.liu@amlogic.com>
Date: Thu, 9 Nov 2023 17:29:05 +0800
Subject: [PATCH 3/9] vdin: display and encoding may abnormal in v4l2 mode
 [1/1]

PD#SWPL-145731
PD#SH-17095

Problem:
vfame index in tv path and vb2 index in v4l2 do not match,
case abnormal in some cases

Solution:
match the two indexes

Verify:
t7c

Change-Id: I0a5c122f553353a27721f387f6534ca2645679a6
Signed-off-by: haitao.liu <haitao.liu@amlogic.com>
---
 drivers/media/vin/tvin/vdin/vdin_v4l2_if.c | 41 ++++++++++++++++------
 1 file changed, 30 insertions(+), 11 deletions(-)

diff --git a/drivers/media/vin/tvin/vdin/vdin_v4l2_if.c b/drivers/media/vin/tvin/vdin/vdin_v4l2_if.c
index 30f332f37..9414537b5 100644
--- a/drivers/media/vin/tvin/vdin/vdin_v4l2_if.c
+++ b/drivers/media/vin/tvin/vdin/vdin_v4l2_if.c
@@ -137,6 +137,10 @@ static struct v4l2_capability g_vdin_v4l2_cap[VDIN_MAX_DEVS] = {
 
 int vdin_v4l2_if_isr(struct vdin_dev_s *devp, struct vframe_s *vfp)
 {
+	struct vb2_queue *vb_que;
+	struct vb2_buffer *vb2buf;
+	struct vb2_v4l2_buffer *vb = NULL;
+
 	if (!devp->vb_queue.streaming) {
 		dprintk(2, "not streaming\n");
 		return -1;
@@ -147,8 +151,8 @@ int vdin_v4l2_if_isr(struct vdin_dev_s *devp, struct vframe_s *vfp)
 	/* do framerate control */
 	if (devp->vdin_v4l2.divide > 1 && (devp->frame_cnt % devp->vdin_v4l2.divide) != 0) {
 		devp->vdin_v4l2.stats.drop_divide++;
-		dprintk(3, "%s,drop_divide:%u\n", __func__,
-			devp->vdin_v4l2.stats.drop_divide);
+		dprintk(3, "%s,drop_divide:%u,vf_index:%d\n", __func__,
+			devp->vdin_v4l2.stats.drop_divide, vfp->index);
 		return -1;
 	}
 	spin_lock(&devp->list_head_lock);
@@ -158,16 +162,19 @@ int vdin_v4l2_if_isr(struct vdin_dev_s *devp, struct vframe_s *vfp)
 		spin_unlock(&devp->list_head_lock);
 		return -1;
 	}
-	/* pop a buffer */
-	devp->cur_buff = list_first_entry(&devp->buf_list,
-					  struct vdin_vb_buff, list);
+
+	vb_que = &devp->vb_queue;
+	vb2buf = vb_que->bufs[vfp->index];
+
+	vb = to_vb2_v4l2_buffer(vb2buf);
+	devp->cur_buff = to_vdin_vb_buf(vb);
 
 	dprintk(3, "[%s]vf index = %d\n", __func__, vfp->index);
 	devp->cur_buff->v4l2_vframe_s = vfp;
 	list_del(&devp->cur_buff->list);
 	spin_unlock(&devp->list_head_lock);
 	devp->vdin_v4l2.stats.done_cnt++;
-	vb2_buffer_done(&devp->cur_buff->vb.vb2_buf, VB2_BUF_STATE_DONE);
+	vb2_buffer_done(vb2buf, VB2_BUF_STATE_DONE);
 
 	return 0;
 }
@@ -564,10 +571,9 @@ static int vdin_vidioc_qbuf(struct file *file, void *priv,
 		devp->vdin_v4l2.stats.que_cnt++;
 		if (!IS_ERR(vdin_buf->v4l2_vframe_s)) {
 			receiver_vf_put(vdin_buf->v4l2_vframe_s, devp->vfp);
-			dprintk(3, "[%s]vf idx:%d (0x%p) put back to pool,fd=%d,canvas0Addr:%#x\n",
+			dprintk(3, "[%s]vf idx:%d (0x%p) put back to pool,fd=%d\n",
 				__func__,
-				vdin_buf->v4l2_vframe_s->index, devp->vfp, p->m.fd,
-				vdin_buf->v4l2_vframe_s->canvas0Addr);
+				vdin_buf->v4l2_vframe_s->index, devp->vfp, p->m.fd);
 
 			vdin_buf->v4l2_vframe_s = NULL;
 		} else {
@@ -606,8 +612,8 @@ static int vdin_vidioc_dqbuf(struct file *file, void *priv,
 	vb = to_vb2_v4l2_buffer(devp->vb_queue.bufs[p->index]);
 	vdin_buf = to_vdin_vb_buf(vb);
 	devp->vdin_v4l2.stats.dque_cnt++;
-	dprintk(3, "%s index=%d,fd = %d;vf_index:%d,canvas0Addr:%#x\n", __func__, p->index, p->m.fd,
-		vdin_buf->v4l2_vframe_s->index, vdin_buf->v4l2_vframe_s->canvas0Addr);
+	dprintk(3, "%s index=%d,fd = %d;vf_index:%d\n", __func__,
+		p->index, p->m.fd, vdin_buf->v4l2_vframe_s->index);
 
 	return ret;
 }
@@ -884,6 +890,17 @@ static int vdin_vidioc_g_divide_fr(struct vdin_dev_s *devp,
 	return 0;
 }
 
+/* V4L2_CID_MIN_BUFFERS_FOR_CAPTURE */
+static int vdin_vidioc_g_min_buffers(struct vdin_dev_s *devp,
+			 struct v4l2_control *ctrl)
+{
+	ctrl->value = 2;
+	dprintk(2, "%s get min buffers value %d\n",
+		__func__, ctrl->value);
+
+	return 0;
+}
+
 /* V4L2_CID_EXT_CAPTURE_OUTPUT_FRAMERATE */
 static int vdin_vidioc_g_output_fr(struct vdin_dev_s *devp,
 			 struct v4l2_control *ctrl)
@@ -905,6 +922,8 @@ static int vdin_vidioc_g_ctrl(struct file *file, void *priv,
 		ret = vdin_vidioc_g_divide_fr(devp, ctrl);
 	else if (ctrl->id == V4L2_CID_EXT_CAPTURE_OUTPUT_FRAMERATE)
 		ret = vdin_vidioc_g_output_fr(devp, ctrl);
+	else if (ctrl->id == V4L2_CID_MIN_BUFFERS_FOR_CAPTURE)
+		ret = vdin_vidioc_g_min_buffers(devp, ctrl);
 
 	return 0;
 }
-- 
2.25.1

