From 7213f61ae7233cceaa2100d8612fb65e6b59910f Mon Sep 17 00:00:00 2001
From: "guoping.li" <guoping.li@amlogic.com>
Date: Fri, 19 May 2023 17:17:37 +0800
Subject: [PATCH 1/4] Hdmirx: venc ctrl+c failed  [1/1]

PD#SWPL-121629

Problem:
ctrl+c, will cause double StopTv, and never close socketfd,
udp connect failed for next test

Solution:
hdmictrl needn't care signal, avoid force kill.
gstreamer will send disconnect to hdmictrl for normal stop and release

Verify:
local

Signed-off-by: guoping.li <guoping.li@amlogic.com>
Change-Id: I66a793c3a5b3a873338ebe6f21eaa3983c8ec7d2
---
 amlv4l2src/common/common.c   |   5 +-
 amlv4l2src/hdmisrc/hdmisrc.c | 109 +++++++++++++++++--------------
 hdmictrl/hdmictrl.c          | 122 ++++++++++++++++++-----------------
 3 files changed, 128 insertions(+), 108 deletions(-)

diff --git a/amlv4l2src/common/common.c b/amlv4l2src/common/common.c
index 676b3d5..fd66750 100644
--- a/amlv4l2src/common/common.c
+++ b/amlv4l2src/common/common.c
@@ -59,10 +59,11 @@ int udp_sock_create(const char* server_socket_path) {
 
   memset(&server_unix, 0, sizeof(server_unix));
   server_unix.sun_family = AF_UNIX;
-  strcpy(server_unix.sun_path, server_socket_path);
+  strncpy(server_unix.sun_path, server_socket_path, sizeof(server_unix.sun_path)-1);
+
   int len = offsetof(struct sockaddr_un, sun_path) + strlen(server_unix.sun_path);
   if (connect(sockfd, (struct sockaddr *)&server_unix, len) < 0) {
-    log_error("connect ...");
+    log_error("[%s] connect ...", server_unix.sun_path);
     return -1;
   }
 
diff --git a/amlv4l2src/hdmisrc/hdmisrc.c b/amlv4l2src/hdmisrc/hdmisrc.c
index 6bc0d4d..bfce65e 100644
--- a/amlv4l2src/hdmisrc/hdmisrc.c
+++ b/amlv4l2src/hdmisrc/hdmisrc.c
@@ -64,76 +64,89 @@ static int client_sockfd = -1;
 
 static void
 hdmi_src_obtain_devname(const char *filepath) {
+    log_debug("enter");
 
     if (!access(server_socket, F_OK)) {
-    unlink(server_socket);
-  }
-  log_debug("enter hdmi_src_obtain_devname \n");
-  pid_t pid;
-  pid = fork();
-  if (pid < 0) {
-    log_debug("fork error");
-    exit(1);
-  }
-  log_debug("hdmi_src_obtain_devname, pid=%d \n", pid);
-  if (pid == 0) {
-    prctl(PR_SET_PDEATHSIG, SIGKILL);
-    /* call execl to startup hdmienable */
-    log_debug("ready to execl /usr/bin/hdmictrl, pid=%d \n", pid);
-    execl("/usr/bin/hdmictrl", "hdmictrl", NULL);
-    log_debug("execl /usr/bin/hdmictrl ok \n");
-  }
-  log_debug("hdmi_src_obtain_devname end, pid=%d \n", pid);
-
-  while (true) {
-    if (!access(server_socket, F_OK))
-      break;
-    else
-      continue;
-  }
-
-  client_sockfd = udp_sock_create(server_socket);//need add
+        unlink(server_socket);
+    }
+    pid_t pid;
+    pid = fork();
+    if (pid < 0) {
+        log_debug("fork error");
+        exit(1);
+    }
+    log_debug("%s, pid=%d", __FUNCTION__, pid);
+    if (pid == 0) {
+        prctl(PR_SET_PDEATHSIG, SIGKILL);
+        /* call execl to startup hdmienable */
+        log_debug("ready to execl /usr/bin/hdmictrl, pid=%d", pid);
+        execl("/usr/bin/hdmictrl", "hdmictrl", NULL);
+        log_debug("execl /usr/bin/hdmictrl ok");
+    }
+    log_debug("%s end, pid=%d", __FUNCTION__, pid);
+
+    while (true) {
+        if (!access(server_socket, F_OK))
+            break;
+        else
+            continue;
+    }
+
+    client_sockfd = udp_sock_create(server_socket);//need add
+    log_debug("exit");
 }
 
 char *
 hdmi_src_initialize(const char* filepath) {
-  log_debug("enter  hdmi_src_initialize \n");
+    log_debug("enter");
 
-  hdmi_src_obtain_devname(filepath);
-  char send_buffer[32] = {0};
-  strcpy(send_buffer, "connect");
-  udp_sock_send(client_sockfd, send_buffer, sizeof(send_buffer));
-  log_debug("send_buffer: %s", send_buffer);
+    system("ps -aux | grep hdmictrl");
 
-  return NULL;
+    hdmi_src_obtain_devname(filepath);
+    char send_buffer[32] = {0};
+    strcpy(send_buffer, "connect");
+    log_debug("send_buffer:fd:%d buf:%s", client_sockfd, send_buffer);
+    udp_sock_send(client_sockfd, send_buffer, sizeof(send_buffer));
+
+    log_debug("exit");
+    return NULL;
 }
 
 void
 hdmi_src_finalize() {
-  log_debug("finalize\n");
+    log_debug("enter");
+
+    system("netstat -an | grep hdmi-rx");
+
+    char send_buffer[32] = {0};
+    strcpy(send_buffer, "disconnect");
+    log_debug("send_buffer:fd:%d buf:%s", client_sockfd, send_buffer);
+    udp_sock_send(client_sockfd, send_buffer, sizeof(send_buffer));
 
-  char send_buffer[32] = {0};
-  strcpy(send_buffer, "disconnect");
-  udp_sock_send(client_sockfd, send_buffer, sizeof(send_buffer));
-  log_debug("send_buffer: %s", send_buffer);
-  return;
+    close(client_sockfd); // free connection
+    log_debug("close: %d", client_sockfd);
+
+    log_debug("exit");
+    return;
 }
 
 void
 hdmi_src_start() {
-  log_debug("enter  hdmi_src_start \n");
+    log_debug("enter");
+
+    char recv_buffer[32] = {0};
+    udp_sock_recv(client_sockfd, recv_buffer, sizeof(recv_buffer));
+    log_debug("recv_buffer: %s", recv_buffer);
 
-  char recv_buffer[32] = {0};
-  udp_sock_recv(client_sockfd, recv_buffer, sizeof(recv_buffer));
-  log_debug("recv_buffer: %s", recv_buffer);
-  return;
+    log_debug("exit");
+    return;
 }
 
 void
 hdmi_src_stop() {
-  log_debug("enter  hdmi_src_stop \n");
-  log_debug("stop ...\n");
-  return;
+    log_debug("enter");
+    log_debug("exit");
+    return;
 }
 
 
diff --git a/hdmictrl/hdmictrl.c b/hdmictrl/hdmictrl.c
index f46d1ab..0e165f6 100644
--- a/hdmictrl/hdmictrl.c
+++ b/hdmictrl/hdmictrl.c
@@ -69,24 +69,12 @@ tv_source_input_t e_currentsource ;
 static hdmi_rx_svc_t *g_t_svctx =NULL;
 static int client_sockfd = -1;
 
-static int WriteSysfs(const char *path, const char *cmd)
-{
-	int fd;
-	fd = open(path, O_CREAT|O_RDWR | O_TRUNC, 0777);
-	if (fd >= 0) {
-		write(fd, cmd, strlen(cmd));
-		close(fd);
-		return 0;
-	}
-
-	return -1;
-}
 
 static void TvEventCallback(event_type_t eventType, void *eventData)
 {
 	if (eventType == TV_EVENT_TYPE_SIGLE_DETECT) {
 		SignalDetectCallback_t *signalDetectEvent = (SignalDetectCallback_t *)(eventData);
-		log_debug("%s: source: %d, signalFmt: %d, transFmt: %d, status: %d, isDVI: %d, Hdrinfo: %ud.\n", __FUNCTION__,
+		log_debug("source: %d, signalFmt: %d, transFmt: %d, status: %d, isDVI: %d, Hdrinfo: %ud",
 			signalDetectEvent->SourceInput,
 			signalDetectEvent->SignalFmt,
 			signalDetectEvent->TransFmt,
@@ -105,74 +93,78 @@ static void TvEventCallback(event_type_t eventType, void *eventData)
 		}
 	} else if (eventType == TV_EVENT_TYPE_SOURCE_CONNECT) {
 		SourceConnectCallback_t *sourceConnectEvent = (SourceConnectCallback_t *)(eventData);
-		log_debug("%s: source: %d, connectStatus: %d\n", __FUNCTION__,
+		log_debug("source: %d, connectStatus: %d",
 		sourceConnectEvent->SourceInput, sourceConnectEvent->ConnectionState);
 	} else {
-		log_debug("%s: invalid event %d.\n", __FUNCTION__, eventType);
+		log_debug("invalid event %d.", eventType);
 	}
 }
 
 static void *process_socket_thread(void *arg)
 {
-	log_debug("enter process_socket_thread\n");
+	log_debug("enter");
 	int r;
 	char recv_buffer[32] = {0};
 	// tv_source_input_t e_currentsource ;
 	char *hdmirxsrc;
 	hdmirxsrc = getenv("HDMISRC");
-	log_debug("hdmirxsrc is %s\n",hdmirxsrc);
+	log_debug("hdmirxsrc is %s",hdmirxsrc);
 	if (NULL == hdmirxsrc) {
 		e_currentsource = SOURCE_HDMI1;
 		free(hdmirxsrc);
-		log_debug("HDMISRC is hdmi1\n");
+		log_debug("HDMISRC is hdmi1");
 	}
 	else if (0 == memcmp("hdmi1",hdmirxsrc,5)) {
 		e_currentsource = SOURCE_HDMI1;
-		log_debug("HDMISRC is hdmi1\n");
+		log_debug("HDMISRC is hdmi1");
 	}
 	else if (0 == memcmp("hdmi2",hdmirxsrc,5)) {
 		e_currentsource = SOURCE_HDMI2;
-		log_debug("HDMISRC is hdmi2\n");
+		log_debug("HDMISRC is hdmi2");
 	}
 	else if (0 == memcmp("hdmi3",hdmirxsrc,5)) {
 		e_currentsource = SOURCE_HDMI3;
-		log_debug("HDMISRC is hdmi3\n");
+		log_debug("HDMISRC is hdmi3");
 	}
 	else{
-		log_debug("invalid HDMISRC \n");
+		log_debug("invalid HDMISRC");
 	}
-	log_debug("e_currentsource = %d \n",e_currentsource);
+	log_debug("e_currentsource = %d",e_currentsource);
 	hdmi_rx_svc_t *g_t_svctx = (hdmi_rx_svc_t *)(arg);
 
 	while (g_t_svctx->b_svctx_enable) {
+		log_debug("loop wait recv cmd");
 		r = TEMP_FAILURE_RETRY(recv(g_t_svctx->connect_socker_fd, recv_buffer, sizeof(recv_buffer), 0));
-		log_debug("recv_buffer = %s \n",recv_buffer);
-		log_debug("r = %d \n",r);
+		log_debug("recv_buffer = %s ",recv_buffer);
+		log_debug("r = %d ",r);
 		if (r == 0) {
-		  log_debug("connection interrupted\n");
-		  continue;
+			log_debug("connection interrupted");
+			continue;
 		}
 		if (strcmp("connect", recv_buffer) == 0) {
-		  log_debug("prepare enter connect_hdmi\n");
-		  StartTv(g_t_svctx->tv_client_wrapper, e_currentsource);
-		  log_debug("startv is ok\n");
+			log_debug("prepare enter connect_hdmi");
+			StartTv(g_t_svctx->tv_client_wrapper, e_currentsource);
+			log_debug("startv is ok");
 		} else if (strcmp("disconnect", recv_buffer) == 0) {
-		  log_debug("prepare enter disconnect_hdmi\n");
-		  StopTv(g_t_svctx->tv_client_wrapper, e_currentsource);
-		  log_debug("stoptv is ok\n");
-		  ReleaseInstance(&g_t_svctx->tv_client_wrapper);
-		  break;
+			log_debug("prepare enter disconnect_hdmi");
+
+			StopTv(g_t_svctx->tv_client_wrapper, e_currentsource);
+			log_debug("stoptv is ok");
+			ReleaseInstance(&g_t_svctx->tv_client_wrapper);
+			break;
 		} else {
-		  log_debug("[process_socket_thread] not supported message ...\n");
-		  continue;
+			log_debug("[%s] not supported message ...", __FUNCTION__);
+			continue;
 		}
 	}
+
+	log_debug("exit");
 	return NULL;
 }
 
 static void hdmi_rx_svctx_perform_connect(hdmi_rx_svc_t *g_t_svctx)
 {
-	log_debug("enter hdmi_rx_svctx_perform_connect \n");
+	log_debug("enter");
 	struct sockaddr_un server_unix, client_unix;
 	socklen_t client_unix_len;
 	int listen_fd, connfd, size;
@@ -196,7 +188,7 @@ static void hdmi_rx_svctx_perform_connect(hdmi_rx_svc_t *g_t_svctx)
 	  perror("bind error");
 	  exit(1);
 	}
-	log_debug("UNIX domain socket (%s) bound\n", server_unix.sun_path);
+	log_debug("UNIX domain socket (%s) bound", server_unix.sun_path);
 
 	if (listen(listen_fd, 16) < 0) {
 	  perror("listen error");
@@ -204,69 +196,83 @@ static void hdmi_rx_svctx_perform_connect(hdmi_rx_svc_t *g_t_svctx)
 	}
 
 	client_unix_len = sizeof(client_unix);
-	log_debug("Accepting connections,get the client_unix_len: %d\n",client_unix_len);
+	log_debug("Accepting connections,get the client_unix_len: %d",client_unix_len);
 
 	if ((connfd = accept(listen_fd, (struct sockaddr *)&client_unix, &client_unix_len)) < 0) {
 	  perror("accept error");
 	  return;//add
 	}
 
-	log_debug("g_t_svctx prepare get the connect_socker_fd %d\n", connfd);
+	// show network status
+	system("netstat -an | grep hdmi-rx");
+
+	log_debug("g_t_svctx prepare get the connect_socker_fd %d", connfd);
 	g_t_svctx->connect_socker_fd = connfd;
+
+	log_debug("exit");
 }
 
 static hdmi_rx_svc_t *hdmi_rx_svctx_init()
 {
+	log_debug("enter");
 	hdmi_rx_svc_t *g_t_svctx = (hdmi_rx_svc_t*) malloc(sizeof(hdmi_rx_svc_t));
 	if (!g_t_svctx) {
-		log_debug("malloc hdmi svctx failed\n");
+		log_debug("malloc hdmi svctx failed");
 		return NULL;
 	}
 
-	log_debug("prepare get the GetInstance \n");
+	log_debug("prepare get the GetInstance");
 	g_t_svctx->tv_client_wrapper = GetInstance();
 	if (!g_t_svctx->tv_client_wrapper) {
-		log_debug("get tv client wrapper failed\n");
+		log_debug("get tv client wrapper failed");
 		return NULL;
 	}
 
-	log_debug("go hdmi_rx_svctx_perform_connect \n");
+	log_debug("go hdmi_rx_svctx_perform_connect");
 	hdmi_rx_svctx_perform_connect(g_t_svctx);
+
+	log_debug("exit");
 	return g_t_svctx;
 }
 
-static void Signalhandler(int sig){
-	log_debug("enter hdmictrl Signalhandler: %d\n",sig);
-	StopTv(g_t_svctx->tv_client_wrapper, e_currentsource);
-	ReleaseInstance(&g_t_svctx->tv_client_wrapper);
-	unlink(HDMIRX_SERVER_SOCKET);
-	exit(0);
-}
+// static void Signalhandler(int sig){
+// 	log_debug("enter hdmictrl Signalhandler: %d",sig);
+// 	StopTv(g_t_svctx->tv_client_wrapper, e_currentsource);
+// 	ReleaseInstance(&g_t_svctx->tv_client_wrapper);
+// 	unlink(HDMIRX_SERVER_SOCKET);
+// 	exit(0);
+// }
 
 int main(int argc, char **argv)
 {
-	log_debug("enter main,prepare enter hdmi_rx_svctx_init \n");
+	log_debug("enter, prepare enter hdmi_rx_svctx_init");
 	g_t_svctx = hdmi_rx_svctx_init();
-	signal(SIGINT, Signalhandler);
+	//signal(SIGINT, Signalhandler);
+	if (signal(SIGINT, SIG_IGN) == SIG_ERR) {
+		printf("Failed to ignore SIGINT signal");
+	}
 
-	log_debug("prepare enter setTvEventCallback \n");
+	log_debug("prepare enter setTvEventCallback");
 	setTvEventCallback(TvEventCallback);
 
-	log_debug("prepare enter process_socket_thread \n");
+	log_debug("prepare enter process_socket_thread");
 	int err = 0;
 	g_t_svctx->b_svctx_enable = true;
 	err = pthread_create(&g_t_svctx->t_socket_thread, NULL, &process_socket_thread, g_t_svctx);
 	if (err != 0) {
-		log_debug("create process_socket_thread failed %d\n", err);
+		log_debug("create process_socket_thread failed %d", err);
 		exit(1);
 	}
+
 	pthread_join(g_t_svctx->t_socket_thread, NULL);
-	log_debug("out process_socket_thread\n");
+	log_debug("out process_socket_thread");
 
 	close(g_t_svctx->connect_socker_fd);
 	close(g_t_svctx->listen_fd);
 
 	unlink(HDMIRX_SERVER_SOCKET);
+
+	log_debug("exit");
 	return 0;
 }
 
-- 
2.25.1

