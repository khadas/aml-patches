From 1fc83e3ec7b927a21efe370b6eed8ef7887310e6 Mon Sep 17 00:00:00 2001
From: "xiaobo.wang" <xiaobo.wang@amlogic.com>
Date: Wed, 24 May 2023 10:03:01 +0800
Subject: [PATCH 3/4] Hdmirx: Fix the ctrl c hang up issue [1/1]

PD#SWPL-124718

Problem:
ctrl c caused socket hang up

Solution:
Fix the issue

Verify:
local

Change-Id: I4d928bd46f650d7eeb3f6d1bfbe5a2739e35bbbb
Signed-off-by: xiaobo.wang <xiaobo.wang@amlogic.com>
---
 hdmictrl/hdmictrl.c | 445 +++++++++++++++++++++++++-------------------
 1 file changed, 251 insertions(+), 194 deletions(-)

diff --git a/hdmictrl/hdmictrl.c b/hdmictrl/hdmictrl.c
index 493d615..b7a5642 100644
--- a/hdmictrl/hdmictrl.c
+++ b/hdmictrl/hdmictrl.c
@@ -59,225 +59,282 @@
 #define HDMIRX_SERVER_SOCKET "/tmp/hdmi-rx0"
 
 typedef struct {
-	struct TvClientWrapper_t *tv_client_wrapper;
-	int connect_socker_fd;
-	int listen_fd;
-	pthread_t t_socket_thread;
-	bool b_svctx_enable;
+    struct TvClientWrapper_t *tv_client_wrapper;
+    int connect_socker_fd;
+    int listen_fd;
+    pthread_t t_socket_thread;
+    bool b_svctx_enable;
+    bool b_tv_released;
+    pthread_mutex_t tvclient_mutex;
 }hdmi_rx_svc_t;
 
 tv_source_input_t e_currentsource ;
 static hdmi_rx_svc_t *g_t_svctx =NULL;
 static int client_sockfd = -1;
 
+static void _send_signal_stable()
+{
+    char send_buffer[32] = {0};
+    strcpy(send_buffer, "sigstable");
+    log_debug("send_buffer: %s", send_buffer);
+    int ret = TEMP_FAILURE_RETRY(send(g_t_svctx->connect_socker_fd, send_buffer, strlen(send_buffer), 0));
+    if (ret < 0) {
+        log_debug("send sigstable fail");
+    }
+}
 
 static void TvEventCallback(event_type_t eventType, void *eventData)
 {
-	if (eventType == TV_EVENT_TYPE_SIGLE_DETECT) {
-		SignalDetectCallback_t *signalDetectEvent = (SignalDetectCallback_t *)(eventData);
-		log_debug("source: %d, signalFmt: %d, transFmt: %d, status: %d, isDVI: %d, Hdrinfo: %ud",
-			signalDetectEvent->SourceInput,
-			signalDetectEvent->SignalFmt,
-			signalDetectEvent->TransFmt,
-			signalDetectEvent->SignalStatus,
-			signalDetectEvent->isDviSignal,
-			signalDetectEvent->Hdrinfo);
-		if (TVIN_SIG_STATUS_STABLE == signalDetectEvent->SignalStatus) {
-			log_debug("SignalStatus is stable");
-			char send_buffer[32] = {0};
-			strcpy(send_buffer, "sigstable");
-			log_debug("send_buffer: %s", send_buffer);
-			int	ret = TEMP_FAILURE_RETRY(send(g_t_svctx->connect_socker_fd, send_buffer, strlen(send_buffer), 0));
-					if (ret < 0) {
-					log_debug("send sigstable fail");
-					}
-		}
-	} else if (eventType == TV_EVENT_TYPE_SOURCE_CONNECT) {
-		SourceConnectCallback_t *sourceConnectEvent = (SourceConnectCallback_t *)(eventData);
-		log_debug("source: %d, connectStatus: %d",
-		sourceConnectEvent->SourceInput, sourceConnectEvent->ConnectionState);
-	} else {
-		log_debug("invalid event %d.", eventType);
-	}
+    if (eventType == TV_EVENT_TYPE_SIGLE_DETECT) {
+        SignalDetectCallback_t *signalDetectEvent = (SignalDetectCallback_t *)(eventData);
+        log_debug("source: %d, signalFmt: %d, transFmt: %d, status: %d, isDVI: %d, Hdrinfo: %ud",
+            signalDetectEvent->SourceInput,
+            signalDetectEvent->SignalFmt,
+            signalDetectEvent->TransFmt,
+            signalDetectEvent->SignalStatus,
+            signalDetectEvent->isDviSignal,
+            signalDetectEvent->Hdrinfo);
+        if (TVIN_SIG_STATUS_STABLE == signalDetectEvent->SignalStatus) {
+            log_debug("SignalStatus is stable");
+            _send_signal_stable();
+        }
+    } else if (eventType == TV_EVENT_TYPE_SOURCE_CONNECT) {
+        SourceConnectCallback_t *sourceConnectEvent = (SourceConnectCallback_t *)(eventData);
+        log_debug("source: %d, connectStatus: %d",
+        sourceConnectEvent->SourceInput, sourceConnectEvent->ConnectionState);
+    } else {
+        log_debug("invalid event %d.", eventType);
+    }
 }
 
 static void *process_socket_thread(void *arg)
 {
-	log_debug("enter");
-	int r;
-	char recv_buffer[32] = {0};
-	// tv_source_input_t e_currentsource ;
-	char *hdmirxsrc;
-	hdmirxsrc = getenv("HDMISRC");
-	log_debug("hdmirxsrc is %s",hdmirxsrc);
-	if (NULL == hdmirxsrc) {
-		e_currentsource = SOURCE_HDMI1;
-		free(hdmirxsrc);
-		log_debug("HDMISRC is hdmi1");
-	}
-	else if (0 == memcmp("hdmi1",hdmirxsrc,5)) {
-		e_currentsource = SOURCE_HDMI1;
-		log_debug("HDMISRC is hdmi1");
-	}
-	else if (0 == memcmp("hdmi2",hdmirxsrc,5)) {
-		e_currentsource = SOURCE_HDMI2;
-		log_debug("HDMISRC is hdmi2");
-	}
-	else if (0 == memcmp("hdmi3",hdmirxsrc,5)) {
-		e_currentsource = SOURCE_HDMI3;
-		log_debug("HDMISRC is hdmi3");
-	}
-	else{
-		log_debug("invalid HDMISRC");
-	}
-	log_debug("e_currentsource = %d",e_currentsource);
-	hdmi_rx_svc_t *g_t_svctx = (hdmi_rx_svc_t *)(arg);
-
-	while (g_t_svctx->b_svctx_enable) {
-		log_debug("loop wait recv cmd");
-		r = TEMP_FAILURE_RETRY(recv(g_t_svctx->connect_socker_fd, recv_buffer, sizeof(recv_buffer), 0));
-		log_debug("recv_buffer = %s ",recv_buffer);
-		log_debug("r = %d ",r);
-		if (r == 0) {
-			log_debug("connection interrupted");
-			continue;
-		}
-		if (strcmp("connect", recv_buffer) == 0) {
-			log_debug("prepare enter connect_hdmi");
-			StartTv(g_t_svctx->tv_client_wrapper, e_currentsource);
-			log_debug("startv is ok");
-		} else if (strcmp("disconnect", recv_buffer) == 0) {
-			log_debug("prepare enter disconnect_hdmi");
-
-			StopTv(g_t_svctx->tv_client_wrapper, e_currentsource);
-			log_debug("stoptv is ok");
-			ReleaseInstance(&g_t_svctx->tv_client_wrapper);
-			break;
-		} else {
-			log_debug("[%s] not supported message ...", __FUNCTION__);
-			continue;
-		}
-	}
-
-	log_debug("exit");
-	return NULL;
+    log_debug("enter");
+    int r;
+    char recv_buffer[32] = {0};
+    // tv_source_input_t e_currentsource ;
+    char *hdmirxsrc;
+    hdmirxsrc = getenv("HDMISRC");
+    log_debug("hdmirxsrc is %s",hdmirxsrc);
+    if (NULL == hdmirxsrc) {
+        e_currentsource = SOURCE_HDMI1;
+        free(hdmirxsrc);
+        log_debug("HDMISRC is hdmi1");
+    }
+    else if (0 == memcmp("hdmi1",hdmirxsrc,5)) {
+        e_currentsource = SOURCE_HDMI1;
+        log_debug("HDMISRC is hdmi1");
+    }
+    else if (0 == memcmp("hdmi2",hdmirxsrc,5)) {
+        e_currentsource = SOURCE_HDMI2;
+        log_debug("HDMISRC is hdmi2");
+    }
+    else if (0 == memcmp("hdmi3",hdmirxsrc,5)) {
+        e_currentsource = SOURCE_HDMI3;
+        log_debug("HDMISRC is hdmi3");
+    }
+    else{
+        log_debug("invalid HDMISRC");
+    }
+    log_debug("e_currentsource = %d",e_currentsource);
+    hdmi_rx_svc_t *g_t_svctx = (hdmi_rx_svc_t *)(arg);
+
+    while (g_t_svctx->b_svctx_enable) {
+        log_debug("loop wait recv cmd");
+        r = TEMP_FAILURE_RETRY(recv(g_t_svctx->connect_socker_fd, recv_buffer, sizeof(recv_buffer), 0));
+        log_debug("recv_buffer = %s ",recv_buffer);
+        log_debug("r = %d ",r);
+
+        if (!g_t_svctx->b_svctx_enable) {
+            log_debug("exit thread");
+            break;
+        }
+
+        if (r == 0) {
+            log_debug("connection interrupted");
+            continue;
+        }
+        if (strcmp("connect", recv_buffer) == 0) {
+            log_debug("Enter connect_hdmi");
+            pthread_mutex_lock(&g_t_svctx->tvclient_mutex);
+            StartTv(g_t_svctx->tv_client_wrapper, e_currentsource);
+            log_debug("Exit connect_hdmi");
+            g_t_svctx->b_tv_released = false;
+            pthread_mutex_unlock(&g_t_svctx->tvclient_mutex);
+            log_debug("startv is ok");
+        } else if (strcmp("disconnect", recv_buffer) == 0) {
+            log_debug("prepare enter disconnect_hdmi %d",g_t_svctx->b_tv_released);
+            pthread_mutex_lock(&g_t_svctx->tvclient_mutex);
+            log_debug("prepare enter disconnect_hdmi %d",g_t_svctx->b_tv_released);
+            if (g_t_svctx->b_tv_released) {
+                log_debug("TV resource already released");
+                pthread_mutex_unlock(&g_t_svctx->tvclient_mutex);
+                continue;
+            }
+            StopTv(g_t_svctx->tv_client_wrapper, e_currentsource);
+            log_debug("Enter disconnect_hdmi");
+            log_debug("stoptv is ok");
+            ReleaseInstance(&g_t_svctx->tv_client_wrapper);
+            g_t_svctx->b_tv_released = true;
+            pthread_mutex_unlock(&g_t_svctx->tvclient_mutex);
+            log_debug("Exit disconnect_hdmi");
+            break;
+        } else {
+            log_debug("[%s] not supported message ...", __FUNCTION__);
+            continue;
+        }
+    }
+
+    log_debug("exit");
+    return NULL;
 }
 
 static void hdmi_rx_svctx_perform_connect(hdmi_rx_svc_t *g_t_svctx)
 {
-	log_debug("enter");
-	struct sockaddr_un server_unix, client_unix;
-	socklen_t client_unix_len;
-	int listen_fd, connfd, size;
-
-	if (!g_t_svctx) {
-		log_debug("g_t_svctx null");
-		return;
-	}
-	unlink(HDMIRX_SERVER_SOCKET);
-	if ((listen_fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-	  perror("socket error");
-	  exit(1);
-	}
-	g_t_svctx->listen_fd = listen_fd;
-	memset(&server_unix, 0, sizeof(server_unix));
-	server_unix.sun_family = AF_UNIX;
-	strcpy(server_unix.sun_path, HDMIRX_SERVER_SOCKET);
-	size = offsetof(struct sockaddr_un, sun_path) + strlen(server_unix.sun_path);
-
-	if (bind(listen_fd, (struct sockaddr *)&server_unix, size) < 0) {
-	  perror("bind error");
-	  exit(1);
-	}
-	struct timespec currentTime;
-	clock_gettime(CLOCK_REALTIME, &currentTime);
-
-	log_debug("[%ld]UNIX domain socket (%s) bound", currentTime.tv_nsec, server_unix.sun_path);
-
-	if (listen(listen_fd, 16) < 0) {
-	  perror("listen error");
-	  exit(1);
-	}
-
-	client_unix_len = sizeof(client_unix);
-	clock_gettime(CLOCK_REALTIME, &currentTime);
-	log_debug("[%ld]Accepting connections,get the client_unix_len: %d",currentTime.tv_nsec, client_unix_len);
-
-	if ((connfd = accept(listen_fd, (struct sockaddr *)&client_unix, &client_unix_len)) < 0) {
-	  perror("accept error");
-	  return;//add
-	}
-
-	// show network status
-	system("netstat -an | grep hdmi-rx");
-
-	log_debug("g_t_svctx prepare get the connect_socker_fd %d", connfd);
-	g_t_svctx->connect_socker_fd = connfd;
-
-	log_debug("exit");
+    log_debug("enter");
+    struct sockaddr_un server_unix, client_unix;
+    socklen_t client_unix_len;
+    int listen_fd, connfd, size;
+
+    if (!g_t_svctx) {
+        log_debug("g_t_svctx null");
+        return;
+    }
+    unlink(HDMIRX_SERVER_SOCKET);
+    if ((listen_fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
+      perror("socket error");
+      exit(1);
+    }
+    g_t_svctx->listen_fd = listen_fd;
+    memset(&server_unix, 0, sizeof(server_unix));
+    server_unix.sun_family = AF_UNIX;
+    strcpy(server_unix.sun_path, HDMIRX_SERVER_SOCKET);
+    size = offsetof(struct sockaddr_un, sun_path) + strlen(server_unix.sun_path);
+
+    if (bind(listen_fd, (struct sockaddr *)&server_unix, size) < 0) {
+      perror("bind error");
+      exit(1);
+    }
+    struct timespec currentTime;
+    clock_gettime(CLOCK_REALTIME, &currentTime);
+
+    log_debug("[%ld]UNIX domain socket (%s) bound", currentTime.tv_nsec, server_unix.sun_path);
+
+    if (listen(listen_fd, 16) < 0) {
+      perror("listen error");
+      exit(1);
+    }
+
+    client_unix_len = sizeof(client_unix);
+    clock_gettime(CLOCK_REALTIME, &currentTime);
+    log_debug("[%ld]Accepting connections,get the client_unix_len: %d",currentTime.tv_nsec, client_unix_len);
+
+    if ((connfd = accept(listen_fd, (struct sockaddr *)&client_unix, &client_unix_len)) < 0) {
+      perror("accept error");
+      return;//add
+    }
+
+    // show network status
+    system("netstat -an | grep hdmi-rx");
+
+    log_debug("g_t_svctx prepare get the connect_socker_fd %d", connfd);
+    g_t_svctx->connect_socker_fd = connfd;
+
+    log_debug("exit");
 }
 
 static hdmi_rx_svc_t *hdmi_rx_svctx_init()
 {
-	log_debug("enter");
-	hdmi_rx_svc_t *g_t_svctx = (hdmi_rx_svc_t*) malloc(sizeof(hdmi_rx_svc_t));
-	if (!g_t_svctx) {
-		log_debug("malloc hdmi svctx failed");
-		return NULL;
-	}
-
-	log_debug("prepare get the GetInstance");
-	g_t_svctx->tv_client_wrapper = GetInstance();
-	if (!g_t_svctx->tv_client_wrapper) {
-		log_debug("get tv client wrapper failed");
-		return NULL;
-	}
-
-	log_debug("go hdmi_rx_svctx_perform_connect");
-	hdmi_rx_svctx_perform_connect(g_t_svctx);
-
-	log_debug("exit");
-	return g_t_svctx;
+    log_debug("enter");
+    hdmi_rx_svc_t *g_t_svctx = (hdmi_rx_svc_t*) malloc(sizeof(hdmi_rx_svc_t));
+    if (!g_t_svctx) {
+        log_debug("malloc hdmi svctx failed");
+        return NULL;
+    }
+
+    log_debug("prepare get the GetInstance");
+    g_t_svctx->tv_client_wrapper = GetInstance();
+    if (!g_t_svctx->tv_client_wrapper) {
+        log_debug("get tv client wrapper failed");
+        return NULL;
+    }
+
+    log_debug("go hdmi_rx_svctx_perform_connect");
+    hdmi_rx_svctx_perform_connect(g_t_svctx);
+
+    g_t_svctx->b_svctx_enable = true;
+    g_t_svctx->b_tv_released = false;
+    pthread_mutex_init(&g_t_svctx->tvclient_mutex, NULL);
+
+    log_debug("exit");
+    return g_t_svctx;
 }
 
-// static void Signalhandler(int sig){
-// 	log_debug("enter hdmictrl Signalhandler: %d",sig);
-// 	StopTv(g_t_svctx->tv_client_wrapper, e_currentsource);
-// 	ReleaseInstance(&g_t_svctx->tv_client_wrapper);
-// 	unlink(HDMIRX_SERVER_SOCKET);
-// 	exit(0);
-// }
+static  void _hdmi_rc_svctx_release()
+{
+    if (!g_t_svctx) {
+        log_debug("g_t_svctx null");
+        return;
+    }
+
+    if (!g_t_svctx->b_tv_released) {
+        StopTv(g_t_svctx->tv_client_wrapper, e_currentsource);
+        ReleaseInstance(&g_t_svctx->tv_client_wrapper);
+    }
+
+    close(g_t_svctx->connect_socker_fd);
+    close(g_t_svctx->listen_fd);
+    unlink(HDMIRX_SERVER_SOCKET);
+}
+ static void Signalhandler(int sig)
+ {
+    log_debug("enter hdmictrl Signalhandler: %d",sig);
+    pthread_mutex_lock(&g_t_svctx->tvclient_mutex);
+    //Send Fake signal stable to unlock start() wait.
+    _send_signal_stable();
+    _hdmi_rc_svctx_release();
+
+    g_t_svctx->b_tv_released = true;
+    g_t_svctx->b_svctx_enable = false;
+    log_debug("exit hdmictrl Signalhandler: %d",sig);
+    pthread_mutex_unlock(&g_t_svctx->tvclient_mutex);
+
+    exit(0);
+ }
 
 int main(int argc, char **argv)
 {
-	log_debug("enter, prepare enter hdmi_rx_svctx_init");
-	g_t_svctx = hdmi_rx_svctx_init();
-	//signal(SIGINT, Signalhandler);
-	if (signal(SIGINT, SIG_IGN) == SIG_ERR) {
-		printf("Failed to ignore SIGINT signal");
-	}
-
-	log_debug("prepare enter setTvEventCallback");
-	setTvEventCallback(TvEventCallback);
-
-	log_debug("prepare enter process_socket_thread");
-	int err = 0;
-	g_t_svctx->b_svctx_enable = true;
-	err = pthread_create(&g_t_svctx->t_socket_thread, NULL, &process_socket_thread, g_t_svctx);
-	if (err != 0) {
-		log_debug("create process_socket_thread failed %d", err);
-		exit(1);
-	}
-
-	pthread_join(g_t_svctx->t_socket_thread, NULL);
-	log_debug("out process_socket_thread");
-
-	close(g_t_svctx->connect_socker_fd);
-	close(g_t_svctx->listen_fd);
-
-	unlink(HDMIRX_SERVER_SOCKET);
-
-	log_debug("exit");
-	return 0;
+    signal(SIGINT, Signalhandler);
+    signal(SIGTERM, Signalhandler);
+
+    log_debug("enter, prepare enter hdmi_rx_svctx_init");
+    g_t_svctx = hdmi_rx_svctx_init();
+    if (!g_t_svctx) {
+        log_debug("g_t_svctx init fail");
+        return -1;
+    }
+
+    log_debug("prepare enter setTvEventCallback");
+    setTvEventCallback(TvEventCallback);
+
+    log_debug("prepare enter process_socket_thread");
+    int err = 0;
+    err = pthread_create(&g_t_svctx->t_socket_thread, NULL, &process_socket_thread, g_t_svctx);
+    if (err != 0) {
+        log_debug("create process_socket_thread failed %d", err);
+        exit(1);
+    }
+
+    pthread_join(g_t_svctx->t_socket_thread, NULL);
+    log_debug("out process_socket_thread");
+
+    pthread_mutex_lock(&g_t_svctx->tvclient_mutex);
+    _hdmi_rc_svctx_release();
+    pthread_mutex_unlock(&g_t_svctx->tvclient_mutex);
+    if (g_t_svctx) {
+       free(g_t_svctx);
+    }
+    log_debug("exit");
+    return 0;
 }
 
-- 
2.25.1

